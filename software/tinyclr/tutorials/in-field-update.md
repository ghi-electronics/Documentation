# In-Field Update
---
TinyCLR OS allows for secure, encrypted, In-Field Update (IFU) of your application. The updates can be done from application code stored in a buffer or read over file system.

> [!Note]
> The application key is generated by the [**TinyCLR Config**](../tinyclr-config.md) tool when you create your application.

## Update via Buffer
Systems with external memory can use the buffer updater, which first copies the new update from a file, network, or bus, and stores it in a buffer. When the entire firmware file is in memory, the IFU will then check the buffer for authenticity. Only then will it decrypt the data and flash it into the chip's internal memory.

It doesn't matter to IFU if the buffer is in managed heap or unmanaged heap. In most cases, unmanaged memory is the only memory large enough to hold the firmware buffer. However, if the managed heap has been extended to external memory (see the [External Memory](external-memory.md) page), then managed heap must be used as there is no longer any unmanaged heap space.

Update via buffer is the recommended update mode, but it only works on systems with external memory.

> [!Warning]
> Be careful not to interrupt power during application for firmware updates. A power interruption will cause the update to fail making it necessary to manually update your board.

> [!Tip]
> Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Storage, GHIElectronics.TinyCLR.IO, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Update.

```cs
using GHIElectronics.TinyCLR.Devices.Storage;
using GHIElectronics.TinyCLR.IO;
using GHIElectronics.TinyCLR.Native;
using GHIElectronics.TinyCLR.Pins;
using GHIElectronics.TinyCLR.Update;
using System.IO;

class Program {
    private static void Main() {
        const string FSSD_API_CONTROLLER = SC20100.StorageController.SdCard;
        const string FSUSB_API_CONTROLLER = SC20100.StorageController.UsbHostMassStorage;

        var media = StorageController.FromName(FSSD_API_CONTROLLER); //Update from SD card.
        var drive = FileSystem.Mount(media.Hdc);

        FileStream fsFw = new FileStream(@"A:\sc20xxx Firmware.ghi", FileMode.Open);
        FileStream fsApp = new FileStream(@"A:\yourApplication.tca", FileMode.Open);

        InFieldUpdate updater;
        byte[] fwBuf, appBuf;

        try {
            //Try managed heap first.
            fwBuf = new byte[(int)fsFw.Length];
        }
        catch {
            //Not enough room in managed heap. Use unmanaged heap.
            UnmanagedBuffer fwBuffer = new UnmanagedBuffer((int)fsFw.Length);
            fwBuf = fwBuffer.Bytes;
        }

        try {
            //Try managed heap first.
            appBuf = new byte[((int)fsApp.Length)];
        }
        catch {
            //Not enough room in managed heap. Use unmanaged heap.
            UnmanagedBuffer appBuffer = new UnmanagedBuffer((int)fsApp.Length);
            appBuf = appBuffer.Bytes;
        }

        fsFw.Read(fwBuf, 0, fwBuf.Length);
        fsApp.Read(appBuf, 0, appBuf.Length);

        updater = new InFieldUpdate(fwBuf, appBuf);

        updater.ApplicationKey = new byte[] { }; //Add key as byte array here.

        try {
            updater.AuthenticateFirmware(out var versionFw);
        }
        catch {
            //Firmware authentication failed.
        }

        try {
            updater.AuthenticateApplication(out var versionApp);
        }
        catch {
            //Application authentication failed.
        }

        updater.FlashAndReset();
    }
}
```

## Update via File

The file updater reads files from memory, SD card or USB port, and then handles the update directly without the need for external memory. This update works on systems with or without external memory. You cannot update the firmware using this method, only the application.

> [!Warning]
> Be careful not to interrupt power during the update of your board. A power interruption will cause the update to fail making it necessary to manually update your board.

> [!Tip]
> Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Storage, GHIElectronics.TinyCLR.IO, GHIElectronics.TinyCLR.Update.

```cs
using GHIElectronics.TinyCLR.Devices.Storage;
using GHIElectronics.TinyCLR.IO;
using GHIElectronics.TinyCLR.Update;
using System.IO;

class Program {
    private static void Main() {
        const string FSSD_API_CONTROLLER = SC20100.StorageController.SdCard;

        const string FSUSB_API_CONTROLLER = SC20100.StorageController.UsbHostMassStorage;

        var media = StorageController.FromName(FSSD_API_CONTROLLER); //Using SD card.
        var drive = FileSystem.Mount(media.Hdc);

        FileStream fsApp = new FileStream(@"A:\yourApplication.tca", FileMode.Open);

        InFieldUpdate updater;

        updater = new InFieldUpdate(fsApp);

        updater.ApplicationKey = new byte[] { }; //Add key as byte array here.

        try {
            updater.AuthenticateApplication(out var versionApp);
        }
        catch {
            //Application authentication failed.
        }

        updater.FlashAndReset();
    }
}

```

## Firmware and Application Must Match
It is important that the firmware on your chip is the same version expected by your application. To make sure your application and firmware match, it is best to update both simultaneously if possible.
