# In-Field Update
---
TinyCLR OS allows for secure, encrypted, In-Field Update (IFU) of your application. You can use [TinyCLR Config](../tinyclr-config.md) to create an encrypted deployment file that can then be distributed via IFU. The updates can be done from application code stored in a buffer or read over file system.

> [!Note]
> The application key is generated by the TinyCLR Config tool when you create your application deployment file.

## Update via Buffer
Systems with external memory can use the buffer updater, which first copies the new update from a file, network, or bus, and stores it in a buffer. When the entire firmware file is in memory, the IFU will then check the buffer for authenticity. Only then will it decrypt the data and flash it into the chip's internal memory.

This is the recommended update mode; however, this will only work on systems with external memory.

> [!Warning]
> Be careful not to interrupt power during application for firmware updates. A power interruption will cause the update to fail making it necessary to manually update your board.

> [!Note]
> The application key format used by TinyCLR Config is different than the format used in your application. TinyCLR Config uses hexadecimal pairs delimited by hyphens (5C-2A-64-6A-60-. . .), while in code you need a byte array (updater.ApplicationKey = new byte[] { 0x5C, 0x2A, 0x64, 0x6A, 0x60, . . . }).

> [!Tip]
> Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Storage, GHIElectronics.TinyCLR.IO, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Update.

```cs
using GHIElectronics.TinyCLR.Devices.Storage;
using GHIElectronics.TinyCLR.IO;
using GHIElectronics.TinyCLR.Native;
using GHIElectronics.TinyCLR.Update;
using System.IO;

class Program {
    private static void Main() {
        const string FSSD_API_CONTROLLER = SC20100.StorageController.SdCard;

        const string FSUSB_API_CONTROLLER =  SC20100.StorageController.UsbHostMassStorage;

        var media = StorageController.FromName(FSSD_API_CONTROLLER); //Update from SD card.
        var drive = FileSystem.Mount(media.Hdc);

        FileStream fsFw = new FileStream(@"A:\sc20xxx Firmware.ghi", FileMode.Open);
        FileStream fsApp = new FileStream(@"A:\yourApplication.tca", FileMode.Open);

        InFieldUpdate updater;
        
        UnmanagedBuffer fwUnmagedBuf = new UnmanagedBuffer((int)fsFw.Length);
        UnmanagedBuffer fwUnmagedApp = new UnmanagedBuffer((int)fsApp.Length);

        var fwBuf = fwUnmagedBuf.Bytes;
        var appBuf = fwUnmagedApp.Bytes;

        fsFw.Read(fwBuf, 0, fwBuf.Length);
        fsApp.Read(appBuf, 0, appBuf.Length);

        updater = new InFieldUpdate(fwBuf, appBuf);

        updater.ApplicationKey = new byte[] { }; //Add key as byte array here.

        try {
            updater.AuthenticateFirmware(out var versionFw);
        }
        catch {
            //Firmware authentication failed.
        }

        try {
            updater.AuthenticateApplication(out var versionApp);
        }
        catch {
            //Application authentication failed.
        }

        updater.FlashAndReset();
    }
}
```

## Update via File

The file updater reads files from memory, SD card or USB port, and then handles the update directly without the need for external memory. This update works on systems with or without external memory. You cannot update the firmware using this method, only the application.

> [!Warning]
> Be careful not to interrupt power during updating your board. A power interruption will cause the update to fail making it necessary to manually update your board.

> [!Note]
> The application key format used by TinyCLR Config is different than the format used in your application. TinyCLR Config uses hexadecimal pairs delimited by hyphens (5C-2A-64-6A-60-. . .), while in code you need a byte array (updater.ApplicationKey = new byte[] { 0x5C, 0x2A, 0x64, 0x6A, 0x60, . . . }).

> [!Tip]
> Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Storage, GHIElectronics.TinyCLR.IO, GHIElectronics.TinyCLR.Update.

```cs
using GHIElectronics.TinyCLR.Devices.Storage;
using GHIElectronics.TinyCLR.IO;
using GHIElectronics.TinyCLR.Update;
using System.IO;

class Program {
    private static void Main() {
        const string FSSD_API_CONTROLLER = SC20100.StorageController.SdCard;

        const string FSUSB_API_CONTROLLER = SC20100.StorageController.UsbHostMassStorage;

        var media = StorageController.FromName(FSSD_API_CONTROLLER); //Using SD card.
        var drive = FileSystem.Mount(media.Hdc);

        FileStream fsApp = new FileStream(@"A:\yourApplication.tca", FileMode.Open);

        InFieldUpdate updater;

        updater = new InFieldUpdate(fsApp);

        updater.ApplicationKey = new byte[] { }; //Add key as byte array here.

        try {
            updater.AuthenticateApplication(out var versionApp);
        }
        catch {
            //Application authentication failed.
        }

        updater.FlashAndReset();
    }
}

```

## Firmware and Application Must Match
It is important that the firmware on your chip is the same version expected by your application. To make sure your application and firmware match, it is best to update both simultaneously if possible.
