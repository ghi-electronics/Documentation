{
  "hardware/automotive.html": {
    "href": "hardware/automotive.html",
    "title": "CANxtra",
    "keywords": "CANxtra CANxtra is a hand-held programmable OBD-II tool that includes CAN, LIN and other vehicle buses. Resources below are provided for reference only. Please contact us for all of your custom automotive needs. Resources Brochure Schematic"
  },
  "hardware/breakout/fez-cerb40.html": {
    "href": "hardware/breakout/fez-cerb40.html",
    "title": "FEZ Cerb40",
    "keywords": "FEZ Cerb40 DIP40 form factor board. Not really a Gadgeteer board but it is very small! Schematic FEZ Cerb40 II Same as the FEZ Cerb40 with an added regulator chip. Schematic"
  },
  "hardware/breakout/fez-cobra.html": {
    "href": "hardware/breakout/fez-cobra.html",
    "title": "FEZ Cobra",
    "keywords": "FEZ Cobra Resources Schematic Software For information about programming the FEZ Cobra, please visit our EMX page."
  },
  "hardware/breakout/fez-mini.html": {
    "href": "hardware/breakout/fez-mini.html",
    "title": "FEZ Mini",
    "keywords": "FEZ Mini Resources Schematic Software For information on programming the FEZ Mini, please go to the USBizi page."
  },
  "hardware/breakout/fez-rhino.html": {
    "href": "hardware/breakout/fez-rhino.html",
    "title": "FEZ Rhino",
    "keywords": "FEZ Rhino Resources Schematic Software For information about programming the FEZ Rhino, please visit our USBizi page."
  },
  "hardware/breakout/g120-hdr.html": {
    "href": "hardware/breakout/g120-hdr.html",
    "title": "G120HDR Modules",
    "keywords": "G120HDR Modules The G120HDR Module is a through-hole version of the G120 Module G120HDR G120HDR Rev2 Resources Schematic"
  },
  "hardware/breakout/g120-th.html": {
    "href": "hardware/breakout/g120-th.html",
    "title": "G120 TH Module",
    "keywords": "G120 TH Module A through-hole version of the G120. Resources Schematic Software For information on programming the G120 TH Module, please go to the G120 page."
  },
  "hardware/breakout/g30-th.html": {
    "href": "hardware/breakout/g30-th.html",
    "title": "G30 TH Module",
    "keywords": "G30 TH Module A through-hole version of G30. Resources Schematic Software For information on programming the G30 TH Module, please go to the G30 page."
  },
  "hardware/breakout/g400-th.html": {
    "href": "hardware/breakout/g400-th.html",
    "title": "G400 TH Module",
    "keywords": "G400 TH Module A through-hole version of G400. Resources Schematic Software For information on programming the G400 TH Module please refer to the G400D page."
  },
  "hardware/breakout/g80-th.html": {
    "href": "hardware/breakout/g80-th.html",
    "title": "G80 TH Module",
    "keywords": "G80 TH Module A through-hole version of the G80. Resources Schematics Software For information on programming the G80 TH Module, please go to the G80 page."
  },
  "hardware/breakout/intro.html": {
    "href": "hardware/breakout/intro.html",
    "title": "Breakout",
    "keywords": "Breakout We offer breakout boards for all of our SoMs to speed the path to programming and product development. All of these boards offer through hole connections which accept standard 0.10 inch headers. Some boards also offer surface mount edge connections which are ideal for short production runs."
  },
  "hardware/duino/fez-cerbuino-bee.html": {
    "href": "hardware/duino/fez-cerbuino-bee.html",
    "title": "FEZ Cerbuino Bee",
    "keywords": "FEZ Cerbuino Bee An Arduino-pinout compatible single board computer with Gadgeteer sockets. Resources Schematic Software For information on programming the FEZ Cerbuino Bee, please go to the FEZ Cerberus page."
  },
  "hardware/duino/fez-cerbuino-net.html": {
    "href": "hardware/duino/fez-cerbuino-net.html",
    "title": "FEZ Cerbuino Net",
    "keywords": "FEZ Cerbuino Net An Arduino-pinout compatible single board computer with Gadgeteer sockets. Resources Schematic Software For information on programming the FEZ Cerbuino Net, please go to the FEZ Cerberus page."
  },
  "hardware/duino/fez-cobra-iii.html": {
    "href": "hardware/duino/fez-cobra-iii.html",
    "title": "FEZ Cobra III",
    "keywords": "FEZ Cobra III An Arduino-pinout compatible single board computer. Resources Schematic Software For information on programming the FEZ Cerbuino Bee, please go to the G120 page."
  },
  "hardware/duino/fez-domino.html": {
    "href": "hardware/duino/fez-domino.html",
    "title": "FEZ Domino",
    "keywords": "FEZ Domino Resources Schematic Software For information on programming the FEZ Domino, please go to the USBizi page."
  },
  "hardware/duino/fez-lemur.html": {
    "href": "hardware/duino/fez-lemur.html",
    "title": "FEZ Lemur",
    "keywords": "FEZ Lemur A Arduino-pinout compatible single board computer. Resources Schematic Software For information on programming the FEZ Lemur, please go to the G30 page."
  },
  "hardware/duino/fez-panda.html": {
    "href": "hardware/duino/fez-panda.html",
    "title": "FEZ Panda",
    "keywords": "FEZ Panda An Arduino-pinout compatible board. Resources Schematic Software For information on programming the FEZ Panda, please go to the USBizi page."
  },
  "hardware/duino/fez-panda-ii.html": {
    "href": "hardware/duino/fez-panda-ii.html",
    "title": "FEZ Panda II",
    "keywords": "FEZ Panda II An Arduino-pinout compatible single board computer. Resources Schematic Software For information on programming the FEZ Panda II, please go to the USBizi page."
  },
  "hardware/duino/fez-panda-iii.html": {
    "href": "hardware/duino/fez-panda-iii.html",
    "title": "FEZ Panda III",
    "keywords": "FEZ Panda III An Arduino-pinout compatible single board computer. Resources Schematic Software For information on programming the FEZ Panda II, please go to the G80 page."
  },
  "hardware/duino/fez-t18.html": {
    "href": "hardware/duino/fez-t18.html",
    "title": "FEZ T18",
    "keywords": "FEZ T18 Note FEZ T18 only works with TinyCLR OS 1.0 -- it will not run TinyCLR 2.0. An Arduino-pinout compatible single board computer Spec Value Processor STMicroelectronics ST32F401RET6 Speed 84 MHz Internal RAM 96 KByte Internal Flash 512 KByte Dimensions 70.6 x 56.0 x 14.5 mm Resources Schematic Software FEZ T18 is only supported by TinyCLR OS 1.0 and will not run TinyCLR OS 2.0. Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/duino/intro.html": {
    "href": "hardware/duino/intro.html",
    "title": "Duino Intro",
    "keywords": "Duino Intro Our Duino boards offer Arduino pinout compatible sockets that will accept standard Arduino expansion boards or \"shields.\" They run TinyCLR and can be programmed in C# or Visual Basic using the Microsoft Visual Studio development environment."
  },
  "hardware/filesystem/intro.html": {
    "href": "hardware/filesystem/intro.html",
    "title": "File System",
    "keywords": "File System This page has the technical details and manuals for the File System products. The main website's File System page has more info as well. ALFAT Evaluation Kit This kit offers everything needed to evaluate F40 (ALFAT) and the different ALFAT OEM boards. As F40 and F20 share the same command set, this kit can also be used for understanding the F20 commands. The kit includes: ALFAT OEM board ALFAT SDR board ALFAT EVAL carrier board Storage devices and USB cable Part Number AFEVL-FS-524 ALFAT Eval Kit Schematic File System User Manual Software Bundle UART/SPI Command Implementation F40 (ALFAT) Chipset F40, originally called ALFAT, is the flagship file system chipset. Part Number ALF2X-SC-512 Datasheet User Manual Firmware v1.0.8 Firmware v2.0.0 ALFAT OEM Board F40 chipset with SD and dual-USB connectors. The PHY needed for USB 2.0 480 MHz speeds is available on one of the USB ports. Part Number ALFAT-OM-337 ALFAT-OEM Schematic ALFAT SD F40 chipset with SD connector. Part Number ALFAT-SD-338 ALFAT-SD Schematic ALFAT USB F40 chipset with USB connector. Part Number ALFAT-USB-428 ALFAT-USB Schematic ALFAT SDR This board wires the F40 in SD-reader mode. Part Number AFSDR-FS-523 ALFAT-SDR Schematic F20 Chipset This low-cost chipset is compatible with F40 but with a limited feature set. Part Number F20SC-SC-558 Datasheet User Manual Firmware v1.0.3 F20 uSD Board This boards combines F20 with a micro SD card connector on a very tiny circuit. Part Number F20FS-546 F20-uSD Schematic uALFAT Chipset User Manual Firmware v3.13 USBwiz Chipset User Manual Firmware v2.29 Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/gadgeteer/fez-cerberus.html": {
    "href": "hardware/gadgeteer/fez-cerberus.html",
    "title": "FEZ Cerberus",
    "keywords": "FEZ Cerberus FEZ Cerberus is a .NET Gadgeteer product that utilizes .NET Micro Framework (NETMF). The core of the FEZ Cerberus is the G30 System on Chip (SoC). FEZ Cerberus is the mother of the Cerb Family! To use with NETMF/Gadgeteer, follow these setup instructions . Resources Schematic FEZ Game-O A programmable game console based on the FEZ Cerberus that was funded with a successful kickstarter campaign. The FEZ Game-O combine a 320 x 240 color display, 3D accelerometer and audio circuitry within an attractive, ergonomic enclosure. Schematic"
  },
  "hardware/gadgeteer/fez-cerbot.html": {
    "href": "hardware/gadgeteer/fez-cerbot.html",
    "title": "FEZ Cerbot",
    "keywords": "FEZ Cerbot A robot with reflective sensors and tons of LEDs. Gadgeteer sockets are used as an easy way to add features. Resources Schematic Software For information on programming the FEZ Cerbot, please go to the FEZ Cerberus page."
  },
  "hardware/gadgeteer/fez-cobra-ii.html": {
    "href": "hardware/gadgeteer/fez-cobra-ii.html",
    "title": "FEZ Cobra II Eco and WiFi",
    "keywords": "FEZ Cobra II Eco and WiFi FEZ Cobra II is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Cobra II is the G120 System on Module (SoM). Follow the instructions on the G120 page to learn how to use FEZ Cobra with NETMF and TinyCLR OS. Resources Eco and WiFi Schematic Net Schematic Cobra II Extender schematic Tip To activate bootloader v2, press and hold the LDR0 button while resetting the board."
  },
  "hardware/gadgeteer/fez-hydra.html": {
    "href": "hardware/gadgeteer/fez-hydra.html",
    "title": "FEZ Hydra",
    "keywords": "FEZ Hydra FEZ Hydra is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). To use with NETMF/Gadgeteer, follow these setup instructions . Resources Schematic"
  },
  "hardware/gadgeteer/fez-raptor.html": {
    "href": "hardware/gadgeteer/fez-raptor.html",
    "title": "FEZ Raptor",
    "keywords": "FEZ Raptor FEZ Raptor is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Raptor is the G400S System on Module (SoM). Follow the instructions on the G400S page to learn how to use FEZ Raptor with NETMF and TinyCLR OS. Resources Schematic Tip To activate bootloader v2, press and hold the LDR0 button while resetting the board."
  },
  "hardware/gadgeteer/fez-reaper.html": {
    "href": "hardware/gadgeteer/fez-reaper.html",
    "title": "FEZ Reaper",
    "keywords": "FEZ Reaper FEZ Reaper is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Reaper is the G80 System on Chip (SoC). Follow the instructions on the G80 page to learn how to use FEZ Raptor with NETMF and TinyCLR OS. Resources Schematic Tip To activate bootloader v2, press and hold both LDR0 and LDR1 buttons down while resetting the board."
  },
  "hardware/gadgeteer/fez-spider.html": {
    "href": "hardware/gadgeteer/fez-spider.html",
    "title": "FEZ Spider",
    "keywords": "FEZ Spider FEZ Spider is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Spider is the EMX System on Module (SoM). To use with NETMF/Gadgeteer, follow these setup instructions . Resources Schematic"
  },
  "hardware/gadgeteer/fez-spider-ii.html": {
    "href": "hardware/gadgeteer/fez-spider-ii.html",
    "title": "FEZ Spider II",
    "keywords": "FEZ Spider II FEZ Spider II is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Spider II is the G120E System on Module (SoM). To use with NETMF/Gadgeteer, follow these setup instructions . Resources Schematic Using TinyCLR OS Follow the instructions on the G120 page to learn how to use FEZ Spider II TinyCLR OS. The instructions are the same as G120. LDR0 and LDR1 signals are available on switches #1 and #2. The schematic above has all details."
  },
  "hardware/gadgeteer/intro.html": {
    "href": "hardware/gadgeteer/intro.html",
    "title": ".NET Gadgeteer Intro",
    "keywords": ".NET Gadgeteer Intro .NET Gadgeteer is a discontinued technology that was initiated by Microsoft Research and taken to production by GHI Electronics in the year 2011. .NET Gadgeteer had a great few year run, where it was loved for its plug-and-play mainboard and modules. Tip We will refer to .NET Gadgeteer as Gadgeteer throughout the rest of the documentation. The core of .NET Gadgeteer is .NET Micro Framework (NETMF). Like Gadgeteer, NETMF is no longer evolved by Microsoft and left for the community. Learn more about NETMF Sadly, and after 5 years of building modules and mainboards, GHI Electronics had to announce the EOL for Gadgeteer; however, most of the Gadgeteer hardware can still be used with TinyCLR OS . External resources: Microsoft's .NET Gadgeteer website (down) http://www.gadgeteer.com/ Microsoft's NETMF website (outdated) http://www.netmf.com/ Most of the Gadgeteer ecosystem is open-source: Microsoft's .NET Gadgeteer Core GHI Electronics' Software sources and Hardware design files Socket Map The magic of Gadgeteer is in its socket map Socket Pin1 Pin2 Pin3 Pin4 Pin5 Pin6 Pin7 Pin8 Pin9 Pin10 A +3.3V +5V AIN (G!) AIN (G) AIN GPIO [UN] [UN] [UN] GND B +3.3V +5V LCD B0 LCD B1 LCD B2 LCD B3 LCD B4 LCD ENABLE LCD CLK GND C +3.3V +5V GPIO! CAN TD (G) CAN RD (G) GPIO [UN] [UN] [UN] GND D +3.3V +5V GPIO! D- D+ GPIO GPIO [UN] [UN] GND E +3.3V +5V [UN] LED1 (OPT) LED2 (OPT) TX D- TX D+ RX D- RX D+ GND F +3.3V +5V GPIO! DAT0 DAT1 CMD DAT2 DAT3 CLK GND G +3.3V +5V LCD G0 LCD G1 LCD G2 LCD G3 LCD G4 LCD G5 LCD BACKLIGHT GND H +3.3V +5V GPIO! D- D+ [UN] [UN] [UN] [UN] GND I +3.3V +5V GPIO! [UN] [UN] GPIO [UN] SDA SCL GND K +3.3V +5V GPIO! TX (G) RX (G) RTS CTS [UN] [UN] GND O +3.3V +5V GPIO! GPIO AOUT [UN] [UN] [UN] [UN] GND P +3.3V +5V GPIO! [UN] [UN] GPIO PWM (G) PWM (G) PWM GND R +3.3V +5V LCD R0 LCD R1 LCD R2 LCD R3 LCD R4 LCD VSYNC LCD HSYNC GND S +3.3V +5V GPIO! GPIO GPIO CS MOSI MISO SCK GND T +3.3V +5V [UN] YU XL YD XR [UN] [UN] GND U +3.3V +5V GPIO! TX (G) RX (G) GPIO [UN] [UN] [UN] GND X +3.3V +5V GPIO! GPIO GPIO [UN] [UN] [UN] [UN] GND Y +3.3V +5V GPIO! GPIO GPIO GPIO GPIO GPIO GPIO GND Z +3.3V +5V [MS] [MS] [MS] [MS] [MS] [MS] [MS] GND * +3.3V +5V GPIO! GPIO GPIO [MS] [MS] [MS] [MS] GND Symbol Description AIN Analog input pin. GPIO A general-purpose digital input/output pin, operating at 3.3 volts. (G) In addition to another functionality, a pin that is also usable as a GPIO. [UN] Modules must not connect to this pin if using this socket type. Mainboards can support multiple socket types on one socket, as long as individual pin functionalities overlap in a compatible manner, so that a pin from one socket type can overlap with a [UN] pin of another. ! Interrupt-capable and software pull-up capable GPIO (the pull-up is switchable and in the range of 10,000 to 100,000 ohms). +3.3V Connection to the +3.3 V power net. +5V Connection to the +5 V power net. GND Connection the power ground net. Using .NET Gadgeteer To use .NET Gadgeteer's legacy software, install: Visual Studio 20013 (community edition is also supported) Unzip and install netmfvs2013.vsix and MicroFramewrokSDK.msi from here Microsoft's Gadgeteer Core GHI Electronics' NETMF SDK . The latest is recommended. The Gadgeteer for Beginners guide is a good starting point. Tip You can only use Visual Studio 2013, not a newer edition, unless you are using your Gadgeteer hardware with TinyCLR OS . With TinyCLR OS Most of the .NET Gadgeteer devices are still usable today, and with the latest technologies, thanks to efforts by GHI Electronics and the community. It all started in this video! This means you can still use all your beloved .NET Gadgeteer gear with TinyCLR OS . The first step needed to use TinyCLR OS is to load the GHI Electronics Bootloader v2 onto your mainboard, then use that to load the TinyCLR OS firmware. Each mainboard product page includes the needed instructions. Once those are loaded, you can start blinking the debug LED, detailed in the next section. Blinking the LED Tip If you have never used TinyCLR OS before, start here This example will blink the debug LED. You only need to add a power module to your mainboard. using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var led = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.DebugLed); led.SetDriveMode(GpioPinDriveMode.Output); while(true) { led.Write(GpioPinValue.High); Thread.Sleep(200); led.Write(GpioPinValue.Low); Thread.Sleep(200); } } } Tip The complete pin mapping is made available through GHIElectronics.TinyCLR.Pins . You should not need to use any schematics. Replace FEZSpider with your mainboard's name. Adding Gadgeteer Modules You are now ready to start adding modules ."
  },
  "hardware/gadgeteer/modules.html": {
    "href": "hardware/gadgeteer/modules.html",
    "title": ".NET Gadgeteer Modules",
    "keywords": ".NET Gadgeteer Modules This page lists all .NET Gadgeteer modules. All sources are found on the NETMF and Gadgeteer repo Accel G248 The Accel G248 measures acceleration though I2C bus. Schematic Barometer Measures pressure. Schematic Bluetooth Schematic Breadboard X1 An easy breadboard option. Simply access the socket directly to wire whatever your heart desires! Schematic Breakout Simply a breakout of all signals. Schematic Breakout TB10 Simply a breakout of all signals, on a terminal block. Schematic Button The Button module is very simple, with a button connected to pin 3 and an LED connected to pin4. Schematic Button S7 7 buttons on a single module, with LEDs that light up with button presses! Use the same code example provided for the Button Module. Buttons map: Left: Pin Right: Pin 8 Up: Pin 6 Down: Pin 7 Enter: Pin 3 Back: Pin 4 Forward: Pin 9 Schematic CAN DW Schematic Camera Schematic Cellular Radio Gadgteer driver Schematic Character Display This is a standard and very common HD44780 display. Schematic ColorSense A color sensor that uses software I2C, not yet supported in TinyCLR OS. Schematic Compass Schematic Current ACS712 This is a current sensor that uses ACS712, which simply outputs an analog voltage. Schematic Display CP7 The configurations for the display: // these are the wrong values! Width = 800, Height = 480, PixelClockRate = 24 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 16, HorizontalBackPorch = 46, HorizontalSyncPulseWidth = 1, HorizontalSyncPolarity = true, VerticalFrontPorch = 7, VerticalBackPorch = 23, VerticalSyncPulseWidth = 1, VerticalSyncPolarity = true, Schematic Display N18 This is an SPI display that can work on any system with SPI bus, even small ones without TFT display support. Schematic Display N7 The configurations for the display: Width = 800, Height = 480, PixelClockRate = 24 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 16, HorizontalBackPorch = 46, HorizontalSyncPulseWidth = 1, HorizontalSyncPolarity = true, VerticalFrontPorch = 7, VerticalBackPorch = 23, VerticalSyncPulseWidth = 1, VerticalSyncPolarity = true, Schematic Display NHVN This allows the use of several displays offered by http://newhavendisplay.com/ Supported displays: NHD-4.3-480272EF-ATXL# NHD-4.3-480272EF-ATXL#-CTP NHD-4.3-480272EF-ATXL#-T NHD-7.0-800480EF-ATXL# NHD-7.0-800480EF-ATXL#-CTP NHD-7.0-800480EF-ATXV# NHD-7.0-800480EF-ATXV#-CTP The configurations for all 4.3\" display: Width = 480, Height = 272, PixelClockRate = 20 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, The configurations for all 7\" display: Width = 800, Height = 480, PixelClockRate = 20 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 88, HorizontalBackPorch = 40, HorizontalSyncPulseWidth = 48, HorizontalSyncPolarity = false, VerticalFrontPorch = 13, VerticalBackPorch = 32, VerticalSyncPulseWidth = 3, VerticalSyncPolarity = false, As for the capacitive touch controller, use this old NETMF driver code as a reference: public class FT5306Controller { private InterruptPort touchInterrupt; private I2CDevice i2cBus; private I2CDevice.I2CTransaction[] transactions; private byte[] addressBuffer; private byte[] touchDataBuffer; private byte[] touchCountBuffer; public delegate void TouchEventHandler(FT5306Controller sender, TouchEventArgs e); public event TouchEventHandler TouchDown; public event TouchEventHandler TouchUp; public event TouchEventHandler TouchMove; public FT5306Controller(Cpu.Pin interruptPin) { this.transactions = new I2CDevice.I2CTransaction[2]; this.addressBuffer = new byte[1]; this.touchDataBuffer = new byte[4]; this.touchCountBuffer = new byte[1]; this.i2cBus = new I2CDevice(new I2CDevice.Configuration(0x38, 400)); this.touchInterrupt = new InterruptPort(interruptPin, false, Port.ResistorMode.Disabled, Port.InterruptMode.InterruptEdgeBoth); this.touchInterrupt.OnInterrupt += (a, b, c) => this.OnTouchEvent(); } private void OnTouchEvent() { var points = this.ReadData(2, this.touchCountBuffer)[0]; for (var i = 0; i < points; i++) { var data = this.ReadData(i * 6 + 3, this.touchDataBuffer); var flag = (data[0] & 0xC0) >> 6; var x = ((data[0] & 0x0F) << 8) | data[1]; var y = ((data[2] & 0x0F) << 8) | data[3]; var handler = flag == 0 ? this.TouchDown : flag == 1 ? this.TouchUp : flag == 2 ? this.TouchMove : null; if (handler != null) handler(this, new TouchEventArgs { X = x, Y = y }); } } private byte[] ReadData(int address, byte[] resultBuffer) { this.addressBuffer[0] = (byte)address; this.transactions[0] = I2CDevice.CreateWriteTransaction(this.addressBuffer); this.transactions[1] = I2CDevice.CreateReadTransaction(resultBuffer); this.i2cBus.Execute(this.transactions, 500); return resultBuffer; } public class TouchEventArgs : EventArgs { public int X { get; internal set; } public int Y { get; internal set; } } } Schematic Display T35 The configurations for the display: Width = 320, Height = 240, PixelClockRate = 15 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 51, HorizontalBackPorch = 27, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 16, VerticalBackPorch = 8, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Schematic Display T43 The configurations for the display: Width = 480, Height = 272, PixelClockRate = 20 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Schematic Display TE35 The configurations for the display: Width = 320, Height = 240, PixelClockRate = 15 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 51, HorizontalBackPorch = 29, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 16, VerticalBackPorch = 3, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Schematic Distance US3 A very common ultrasonic sensor that works by sending a pulse on the trig Pin4 and measuring the response time on echo Pin3. Schematic Ethernet ENC28 Schematic Ethernet J11D Schematic Extender Schematic FEZtive Schematic Flash Schematic GPS Schematic GasSense This module can host several different air sensors, like Alcohol and CO2. The sensor has an internal heater on pin 4 that needs to be enabled and then it is a simple analog read on pin 3. Schematic Gyro Schematic HD44780 See the Character Display Module Schematic HubAP5 No hub support is currently planned. Schematic IO60P16 Schematic IR Receiver Schematic Joystick The Joystick module has two analog inputs for X (pin 4) and Y (pin 5) position. Pressing the knob also works like a button (pin 3). Schematic Keypad KP16 Schematic LED 7C An LED that can be set to one of 7 colors, 8 if you count off! Schematic LED 7R This is a ring of 6 LEDs and a 7th center LED. Reference the LED 7C module for using pins. Center LED: pin 9 LEDs going clockwise starting from LEDs D1 to D6 on the board D1, D2, D3, D4, D5, D6 are pins 3 to 8 respectively. Schematic LED Strip A strip of 7 LEDs, connected to pins 3 through 9. Reference the LED 7C module for using pins. Schematic Light Sense Simply using analog on pin 3. Use the same code as the potentiometer. Schematic Load Each one of the 7 GPIO pins are connected to a transistor to handle a load, like a motor. Schematic MaxO Shift registers used to take serial SPI data and put on parallel pins, perfect for driving tons of LEDs! Schematic MicroSD Card Schematic Moisture This is a simple analog input measuring the direct resistance (moisture) on pin 3. An enable pin needs to be activated on pin 6. Schematic Motor Driver The Motor Driver Module uses L298 H-bridge that can drive two motors up to 4A. Pin 6: Motor A Direction (GPIO) Pin 7: Motor A Speed (PWM) Pin 8: Motor B Direction (GPIO) Pin 9: Motor B Speed (PWM) Schematic Multicolor LED Schematic Music The Music Module uses the popular VS1053 decoder chip that decodes MP3, WMA, OGG, MIDI and WAV files. Schematic Null Modem No driver is needed. OBD II OneWire X1 A breakout with a terminal block for easily connecting OneWire devices, specifically the common temperature probes. Schematic PIR Motion detection. Simply pin 3 changes its state when it detects motion. Schematic Parallel CNC Schematic Potentiometer The Potentiometer module is simply a variable resistor connected to pin3. Rotating its knob will result in an analog value changing from min to max. Schematic Pulse Count Schematic Pulse InOut Schematic Pulse Oximeter Schematic RFID Reader Schematic RS232 Simply a serial port. Schematic RS485 Simply a serial port. Schematic Radio FM1 Schematic Reflector R3 Schematic Relay ISOx16 An array of 16 relays. Operate similar to the MaxO module. Schematic Relay X1 Simply set pin 3 high to activate the relay. Schematic Rotary H1 Schematic SD Card Schematic S-Plus Schematic Serial Camera Stepper L6470 Schematic TempHumidity Schematic Thermocouple Schematic Touch C8 Schematic Touch L12 Schematic Tunes The Tunes Module is a tiny speaker that is connected to pin 9. Use PWM to generate sounds Schematic UC Battery 4xAA No driver is needed. Schematic USB Client DP No driver is needed. Schematic USB Client SP No driver is needed. Schematic USB Host Schematic USB Serial Simply, a serial port. Schematic USB Serial SP Simply, a serial port. Schematic VideoOut Schematic WiFi RN171 Schematic WiFi RS21 Schematic XBee Adapter Simply, a serial port. From there a driver like https://xbee.codeplex.com/ will help. Schematic"
  },
  "hardware/gadgeteering.html": {
    "href": "hardware/gadgeteering.html",
    "title": "Gadgeteering",
    "keywords": "Gadgeteering Gadgeteering was meant to extend Gadgeteer beyond NETMF. We are making our hardware and software available for reference only. All material is found at this github repository Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/imaging.html": {
    "href": "hardware/imaging.html",
    "title": "Imaging",
    "keywords": "Imaging ALCAM-OEM is a small yet powerful imaging hardware. It could capture stills and videos to SD card and able to fetch images using serial commands. It started in a successful Kickstarter campaign Resources Examples ALCAM Explorer User Manual We have worked on similar custom commercial designs with imaging needs but decided to proceed with a one-size-fits-all. Please contact us to discuss your imaging needs. Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/intro.html": {
    "href": "hardware/intro.html",
    "title": "Hardware",
    "keywords": "Hardware SITCore Secure IoT SoCs, SoMs and Dev Boards that run C# with full debugging over USB. Learn More... NETMF Modules A mature product line that is still in production running Microsoft's .NET Micro Framework. Learn More... Legacy Support for discontinued products. Learn More... Legal License, Disclaimer, Security. More... You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/legacy/intro.html": {
    "href": "hardware/legacy/intro.html",
    "title": "Legacy Products Introduction",
    "keywords": "Legacy Products Introduction This section covers GHI Electronics legacy products. While we take pride in helping our customers maximize the lifetime of their products, these products are not recommended for new designs and are no longer covered by our free support. Check out our Longevity Promise to find out more about GHI Electronics' product life cycle. SoMs Learn more... Universal Modules Learn more... Gadgeteer Learn more... Duino Learn more... Breakout Learn more... File System Learn more... Automotive Learn more... Gadgeteering Learn more... Imaging Learn more... Raspberry PI Hats Learn more... mBuino Learn more... Tip Our community forum is a great place to get help from our engineers and from thousands of community members: https://forums.ghielectronics.com/ Producing Legacy Products GHI Electronic's products are all engineered and manufactured in-house. While some of our older products are deemed legacy and not recommended for new designs, we can still produce them, however a minimum order may be required. Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/legacy/som.html": {
    "href": "hardware/legacy/som.html",
    "title": "Legacy System on Modules",
    "keywords": "Legacy System on Modules With the rapid advance of technology it can be hard to stay current. We take pride in our support of past products while we work hard to provide our customers with the best new technology. Check out our Longevity Promise to find out more about GHI Electronics' product life cycle. Legacy product should not be used for new designs; however, many of our older products can still be produced (minimum order may be required)."
  },
  "hardware/legal.html": {
    "href": "hardware/legal.html",
    "title": "Legal",
    "keywords": "Legal License This product with its accompanying firmware is licensed royalty-free for commercial and noncommercial use. Using the provided firmware on any non-official product requires additional licensing. The provided documentation/schematics/libraries/sources are not to be used in any manner outside of implementing and using this GHI Electronics product in your design. Disclaimer IN NO EVENT SHALL GHI ELECTRONICS, LLC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS PRODUCT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. GHI ELECTRONICS LINE OF PRODUCTS ARE NOT DESIGNED FOR LIFE SUPPORT APPLICATIONS. SPECIFICATIONS, PRICE AND AVAILABILITY ARE SUBJECT TO CHANGE WITHOUT ANY NOTICE. Security WE DO OUR BEST TO PROVIDE SECURE PRODUCTS THAT PROTECT YOUR INTELLECTUAL PROPERTY (CODE) AND ARE DIFFICULT TO EXPLOIT. HOWEVER, NO PRODUCT IS COMPLETELY SECURE. THERE ARE DISHONEST AND POSSIBLY ILLEGAL METHODS THAT CAN BE USED TO CIRCUMVENT OUR CODE PROTECTION AND SECURITY FEATURES. GHI ELECTRONICS, LLC SHALL IN NO EVENT BE HELD LIABLE IN ANY WAY FOR THE EXPLOITATION OF SECURITY VULNERABILITIES OR ANY USE OR MISUSE OF OUR PRODUCTS RESULTING IN THE LOSS OR THEFT OF CODE OR OTHER INTELLECTUAL PROPERTY. Product Longevity GHI ELECTRONICS, LLC IS PRIMARILY INVOLVED IN PROVIDING ELECTRONIC COMPONENTS, MODULES, AND ACCOMPANYING SOFTWARE THAT ARE USED BY OUR CUSTOMERS TO CREATE NEW AND INNOVATIVE PRODUCTS. IN SUPPORT OF OUR CUSTOMERS, WE DO OUR BEST TO DESIGN AND MANUFACTURE PRODUCTS WITH THE LONGEST LIFE CYCLE POSSIBLE. HOWEVER, OUR PRODUCT AVAILABILITY IS DEPENDENT UPON THE AVAILABILITY OF THE ELECTRONIC COMPONENTS FROM WHICH OUR PRODUCTS ARE BUILT. GHI ELECTRONICS, LLC WILL IN NO WAY BE HELD LIABLE FOR LOSSES OF ANY KIND, INCURRED BY OUR CUSTOMERS OR OTHERS, WHETHER MONETARY OR OTHERWISE, AS A RESULT OF GHI ELECTRONICS' PRODUCT SHORTAGES, DELAYS IN AVAILABILITY, OR DISCONTINUATION."
  },
  "hardware/mbuino.html": {
    "href": "hardware/mbuino.html",
    "title": "mBuino",
    "keywords": "mBuino The mBuino is a tiny keychain circuit. It is GHI Electronics contribution to the mbed community. Learn more here Schematic Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/netmf/chipworkx.html": {
    "href": "hardware/netmf/chipworkx.html",
    "title": "ChipworkX",
    "keywords": "ChipworkX ChipworkX is a NETMF (.NET Micro Framework) System on Module. To use with NETMF, follow these setup instructions . Requires the NETMF 4.1 SDK. Resources User Manual"
  },
  "hardware/netmf/embedded-master.html": {
    "href": "hardware/netmf/embedded-master.html",
    "title": "Embedded Master",
    "keywords": "Embedded Master Embedded Master is a NETMF (.NET Micro Framework) System on Module. To use with NETMF, follow these setup instructions . Requires the NETMF 4.1 SDK. Resources User Manual"
  },
  "hardware/netmf/emx.html": {
    "href": "hardware/netmf/emx.html",
    "title": "EMX System on Module",
    "keywords": "EMX System on Module EMX is a NETMF (.NET Micro Framework) System on Module. To use with NETMF, follow the setup instructions . Resources User Manual EMX Dev Sys The development system used for evaluating the EMX SoM. Schematic"
  },
  "hardware/netmf/g120.html": {
    "href": "hardware/netmf/g120.html",
    "title": "G120 / G120E",
    "keywords": "G120 / G120E Overview The G120 and G120E SoMs are powerful, low-cost, System on Modules part of the GHI Electronics Surface Mount Compute Modules (SCM) line. These modules can be programmed in .NET C# and Visual Basic using .NET Micro Framework. Tip Not recommended for new designs, consider SITCore System on Chip . Ordering Part Number G120 SoM: G120B-SM-373 G120E SoM: G120E-SM-532 G120E Dev Board: G120D-SM-533 G120 vs G120E G120 G120E Processor NXP LPC1788FET180 NXP LPC1788FET208 Package 91 pin surface-mount module (SMT) 120 MHz Dimensions 38.1 x 26.7 x 3.5 mm 45.8 x 39.4 x 4.4 mm RTC External 32,768 Hz crystal Included GPIO 72 80 SPI 3 2 Ethernet ENC28J60 over SPI ENC28J60 over SPI and/or Built-in base 100 Ethernet PHY Specifications Spec Value Processor NXP LPC1788FET Speed 120 MHz Internal RAM 96 KByte (SRAM) Internal Flash 512 KByte External RAM 16 MByte (DRAM) External Flash 4 MByte (SPI) Dimensions (G120) 38.1 x 26.7 x 3.5 mm Dimensions (G120E) 45.8 x 39.4 x 4.4 mm Temperature Range -40 C to +85 C Note: Resources are shared between your application and the operating system. Features .NET Micro Framework RoHS Lead Free 120 MHz ARM Cortex-M3 NXP LPC1788 6 MBytes available RAM 2.3 MBytes available flash Embedded LCD controller 72 to 80 GPIO 43 interrupt capable GPIO 2 to 3 SPI 1 I2C 5 UART 2 CAN 12 PWM 8 12-bit analog input 1 10-bit analog output 4-bit SD/MMC memory card interface Low power modes RTC Watchdog Threading USB host USB client SQLite database TCP/IP with SSL Full .NET socket interface Ethernet WiFi PPP Graphics Images Fonts Controls File System Full .NET file interface SD cards USB drives Native extensions Runtime Loadable Procedures Device register access Signal controls Generation Capture Pulse measurement G120 Pinout Many signals on the G120 are multiplexed to offer multiple functions on a single pin. Developers can decide on the pin functionality to be used through the provided libraries. Any pin with no name, function, or note must be left unconnected. G120E Pinout Footprints We recommend no traces or vias under the module. Dimensions are in inches. G120 Recommended Footprint G120E Recommended Footprint Device Startup The G120 is held in reset when the reset pin is low. Releasing it will begin the system startup process. It is pulled high internally on the G120E and left floating on the G120. There are four different components of the device firmware: GHI Electronics Bootloader: initializes the system, updates TinyBooter when needed, and executes TinyBooter. TinyBooter: executes NETMF, updates NETMF when needed, and updates the system configuration. NETMF: loads, debugs, and executes the managed application. Managed application: the program developed by the customer. Which components get executed on startup can be control by manipulating the LDR0 and LDR1 pins. LDR0 and LDR1 are pulled high on startup. LDRO LDR1 Effect Ignored High Execute the managed application High Low Wait in TinyBooter Low Low Wait in GHI Electronics Bootloader Additionally, the communications interface between the host PC and the G120 is selected on startup through the MODE pin, which is pulled high on startup MODE G120 G120E High USB COM1 Low COM1 USB The above discussed functions of LDR0, LDR1, and MODE are only during startup. After startup, they return to the default GPIO state and are available to use as GPIO in the user application. .NET Micro Framework (NETMF) The NETMF software on G120 is mature and complete. For more information on NETMF you can go to the NETMF Introduction page. The NETMF Getting Started page covers NETMF from setup of the host computer to program deployment on both an emulator and target device. Loading the Firmware Activate the bootloader, hold the LDR0 signal low while resetting the board. Open FEZ Config tool and follow the instructions. You can also update the firmware manually. See GHI Electronics Bootloader page. Start Coding Now that you have installed the bootloader and firmware on the G120, you can setup your host computer and start programming. Go to the NETMF Getting Started page for instructions. Datasheet This documentation page replaced the legacy datasheet PDF but it is here for reference. CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a G120 driving the SN65HVD230 CAN driver chip. See the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 33.333K 1 12 2 120 1 False 86.7% 0.33% 2145M 83.333K 1 13 2 45 1 False 87.5% 0.31% 845M 125K 1 13 2 30 1 False 87.5% 0.31% 545M 250K 1 13 2 15 1 False 87.5% 0.31% 245M 500K 1 12 2 8 1 False 86.7% 0.33% 92M 1M 1 12 2 4 1 False 86.7% 0.33% 18M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested t ensure reliability.* Design Considerations Required Pins Exposing the following pins is required in every design to enable device programming, updates, and recovery: LDR0 LDR1 Reset Desired debug interface(s) MODE if required to select a debug interface Power Supply A typical clean power source, suited for digital circuitry, is needed to power the G120. Voltages should be within at least 10% of the needed voltage. Decoupling capacitors of 0.1 μF are needed near every power pin. Additionally, a large capacitor, typically 47 μF, should be near the G120 if the power supply is more than few inches away. Crystals The G120 and G120E include the needed system crystal and its associated circuitry. The G120E additionally includes the RTC crystal and its associated circuitry. However, the G120 does not. It requires an external 32,768 Hz crystal and circuitry for the RTC to function. Please see the processor’s documentation for advanced information. Interrupt Pins Only pins on ports 0 and 2 support interrupts. Reset The G120E includes an internal pull-up resistor on the reset pin. The G120 does not, so an external 15 kΩ pull-up resistor is required for correct operation. SPI Channels SPI2 is shared internally with the flash memory on the G120. Use of a chip select with devices on this channel is required or the G120 will not function properly. The use of another SPI channel is recommended. Ethernet The built in Ethernet available on the G120E includes all needed Ethernet circuitry internally. However, an appropriate magnet and connector, like the J0011D or similar, are required. Oven Reflow The G120 is not sealed for moisture. Baking the module before reflow is recommended and required in a humid environment. The process of reflow can damage the G120 if the temperature is too high or exposure is too long. The lead-free reflow profiles used by GHI Electronics are shown below. The profiles are based on AIM SAC 305 solder (3% silver, 0.5% copper). The thermal mass of the assembled board and the sensitivity of the components on it affect the total dwell time. Differences in the two profiles are where they reach their respective peak temperatures as well as the time above liquids (TAL). The shorter profile applies to smaller assemblies, whereas the longer profile applies to larger assemblies such as back-planes or high-density boards. The process window is described by the shaded area. These profiles are only starting-points and general guidance. The particulars of an oven and the assembly will determine the final process. G120 Development Board The G120E Dev Board is an excellent starting point and reference design for anyone interested in evaluating and developing with the G120/G120E. Schematic You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/netmf/g30.html": {
    "href": "hardware/netmf/g30.html",
    "title": "G30",
    "keywords": "G30 Overview The G30 SoC is a low-cost System on Chip part of the GHI Electronics SurfaceMount Compute Modules (SCM) line. This modules can be programmed in .NET C# and Visual Basic using .NET Micro Framework. Tip Not recommended for new designs, consider SITCore System on Chip . Ordering Part Number G30 SoC: 30SOC-SC-539 G30 Dev Board: G30DB-SM-555 Specifications Spec Value Processor STM ST32F401RET6 Speed 84 MHz Internal RAM 96 KByte (SRAM) Internal Flash 512 KByte Package LQFP64 10 x 10 mm Temperature Range -40C to +85C Note: Resources are shared between your application and the operating system. Features .NET Micro Framework RoHS Lead Free 84 MHz ARM Cortex-M4 STM32F401RET6 68 KBytes available RAM 128 KBytes available flash 49 GPIO 16 interrupt capable GPIO 2 SPI 1 I2C 2 UART 15 PWM 16 12-bit analog input 4-bit SD/MMC memory card interface Low power modes LQFP64 10 x 10 mm RTC Watchdog Threading USB client File System Full .NET file interface SD cards Native extensions Device register access Signal controls Generation Capture Pulse measurement G30 Pinout Many signals on the G30 are multiplexed to offer multiple functions on a single pin. Developers can decide on the pin functionality to be used through the provided libraries. Any pin with no name, function, or note must be left unconnected. Footprint The chip is standard LQFP64 10x10mm. See the ST32F401RET6 datasheet for exact footprint. Device Startup The G30 is held in reset when the reset pin is low. Releasing it will begin the system startup process. There are three different components of the device firmware: GHI Electronics Bootloader: initializes the system, updates NETMF firmware when needed, and executes NETMF. NETMF Firmware: loads, debugs, and executes the managed application. Managed application: the program developed by the customer. Which components get executed on startup can be control by manipulating the LDR0 pin. It is pulled high on startup. When low, the device waits in the GHI Electronics Bootloader. Otherwise, the managed application is executed. LDR1 is reserved for future use. Additionally, the communications interface between the host PC and the G30 is selected on startup through the MODE pin, which is pulled high on startup. The USB interface is selected when MODE is high and COM1 is selected when MODE is low. The above discussed functions of LDR0, LDR1, and MODE are only during startup. After startup, they return to the default GPIO state and are available to use as GPIO in the user application. .NET Micro Framework NETMF provides a way to program the G30 in C# or Visual Basic from the Microsoft Visual Studio integrated development environment. To get started you must first install the NETMFfirmware (instructions below) and then go to the NETMF Getting Started page for instructions. Loading the Firmware Activate the bootloader, hold the LDR0 signal low while resetting the board. Open FEZ Config tool and follow the instructions. You can also update the firmware manually. See GHI Electronics Bootloader page. Start Coding Now that you have installed the firmware on the G30, you can setup your host computer and start programming. Go to the NETMF Getting Started page for instructions. Datasheet This documentation page replaced the legacy datasheet PDF but it is here for reference. Design Considerations Required Pins Exposing the following pins is required in every design to enable device programming, updates, and recovery: LDR0 LDR1 Reset Desired debug interface(s) MODE if required to select a debug interface Power Supply A typical clean power source, suited for digital circuitry, is needed to power the G30. Voltages should be within at least 10% of the needed voltage. Decoupling capacitors of 0.1 μF are needed near every power pin. Additionally, a large capacitor, typically 47 μF, should be near the G30 if the power supply is more than few inches away. Crystals The G30 requires an external 12 MHz crystal and associated circuitry to function. For the RTC to function, a 32,768 Hz crystal and circuitry are required. Please see the processor’s documentation for advanced information. Interrupt Pins Interrupts are only available on 16 pins at any given time. Of those 16 pins, the pin number must be unique. For example: PA1 and PB1 cannot both be used as interrupts at the same time, but PA1 and PB2 can. Reset The reset pin is not pulled in any direction. Designs must be sure to use an appropriate pull-up resistor. G30 Development Board The G30 Dev Board is an excellent starting point and reference design for anyone interested in evaluating and developing with the G30. Schematic You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/netmf/g400d.html": {
    "href": "hardware/netmf/g400d.html",
    "title": "G400D",
    "keywords": "G400D Overview The G400D System on Module (SoM) is a 400 MHz ARM9. It is made just for running .NET Micro Framework. Tip Not recommended for new designs, consider SITCore System on Chip . Ordering Part Number G400D SoM: G400D-SM-400 Specifications Spec Value Processor Atmel AT91SAM9X35 ARM 926 Speed 400 MHz Internal RAM 32 KByte (SRAM) Internal Flash 0 KByte External RAM 128 MByte (DDR2 SDRAM) External Flash 4 MByte (SPI) Dimensions 67.7 x 31.9 x 5.0 mm Note: Resources are shared between your application and the operating system. Peripherals This table lists the available peripherals. The \"overall\" column shows the available pins if the design did not follow the UCM standard. Peripheral UCM Standard Overall UART 1 5 (including HS) UART HS 1 1 I2C 1 1 SPI 1 1 CAN 1 2 SDIO 1 1 ADC 8 8 PWM 4 4 GPIO 12 70 IRQ 4 70 USB Client Supported Supported USB Host 1 2 LCD Supported (16bpp) Supported (16bpp) Ethernet PHY Supported Supported WiFi Not supported Not supported DCMI Not supported Not supported VBAT Supported Supported JTAG Full JTAG Full JTAG Development Options The UCM development options can greatly simplify the process of building a product or prototype using the UC5550. Options include a development board and displays which can get you programming in minutes. .NET Micro Framework (NETMF) The NETMF software on G400 is mature and complete. For more information on NETMF you can go to the NETMF Introduction page. The NETMF Getting Started page covers NETMF from setup of the host computer to program deployment on both an emulator and target device. Bootloader v1 is needed for G400 to work with NETMF. It is available in the NETMF SDK. Loading Bootloader Version 2 Download the G400 bootloader v2 file and load onto the dataflash using the Microchip SAM-BA tool and the following instructions. To set the chip in SAM-BA mode, hold down the dedicated button on your board (SYS A on UCM Dev and Breakout boards) while the system powers up (or during reset). If there is no such button, connect G400D pin SPI1_MISO to ground. Keep the button pressed (pin grounded) for three seconds after power up or reset, then release the pin. The device manager will show a COM port similar to \"Bossa Program Port\" or \"GPS Detect\". If it is not already installed, download and install the SAM-BA tool from Microchip. The latest version we have tested is 2.18 for Windows. (The tool may not show correctly. Try to make the window larger to see all hidden buttons!) Open the SAM-BA program then select the COM port for your device in the connection box and your board type below it (at91sam9x35-ek for G400), then click connect. Near the middle of the window, go to the DataFlash AT45DB/DCB tab. Under Scripts , select Enable Dataflash (SPI0 CS0) then click the Execute button. Under Scripts , select Erase All then click Execute . This will take some time to complete. It seems that if SAM-BA loses focus during the erase procedure it can seem to lock up. We recommend that once you click the Execute button you leave the computer alone until the erase procedure is completed. Under Scripts , select Send Boot File , click execute, then browse to and select the bootloader for the device. Once the transfer finishes, go to File > Quit and then reset the board. Make sure to properly quit the program or connection errors may result on subsequent uses. Now reset the board. Congratulations, your board is now running the loaded program! Loading the Firmware Activate the bootloader, hold the LDR0 signal (SYS B) low while resetting the board. Open the FEZ Config tool and follow the instructions. You can also update the firmware manually. Download the firmware and learn how to use the GHI Electronics Bootloader manually. Start Coding Now that you have installed the bootloader and firmware, you can setup your host computer and start programming. Go to the NETMF Getting Started page for instructions. Datasheet This documentation page replaced the legacy datasheet PDF but it is here for reference. G400D Pinout Many signals on the G400D are multiplexed to offer multiple functions on a single pin. Developers can decide on the pin functionality to be used through the provided libraries. Any pin with no name, function, or note must be left unconnected. UCM Pinout SO-DIMM Pin UCM Standard Function Name 1 AGND GND 2 Ethernet TX- ETH PHY TX- 3 Module Specific 1 4 Ethernet TX+ ETH PHY TX+ 5 Analog VREF- GND 6 Ethernet RX- ETH PHY RX- 7 Reserved 8 Ethernet RX+ ETH PHY RX+ 9 Reserved 10 Indicator A ETH PHY LED SPEED 11 Indicator B ETH PHY LED LINK 12 Reserved 13 GND GND 14 DCMI D0 15 DCMI D1 16 DCMI D2 17 DCMI D3 18 DCMI D4 19 DCMI D5 20 Analog 3.3V 3.3V 21 DCMI D6 22 DCMI D7 23 DCMI VSYNC 24 DCMI HSYNC 25 DCMI PIXCLK 26 DCMI XCLK 27 GND GND 28 PWM E 29 PWM F 30 PWM G 31 PWM H 32 Analog VREF+ 3.3V 33 Reserved 34 5V 35 Module Specific 4 PB3 36 Module Specific 5 PB4 (DNP) 37 Module Specific 6 PB5 38 Module Specific 7 PB6 39 Module Specific 8 PB7 40 GND GND 41 GND GND 42 LCD 24bpp R0 43 LCD 24bpp R1 44 LCD 24bpp R2 45 LCD 24bpp G0 46 3.3V 3.3V 47 LCD 24bpp G1 48 LCD 24bpp B0 49 LCD 24bpp B1 50 LCD 24bpp B2 51 GND GND 52 Module Specific 9 PB1 53 Reserved 54 Reserved 55 Reserved 56 5V 57 IRQ A PD18 58 IRQ B PD17 59 IRQ C PD16 60 3.3V 3.3V 61 IRQ D PD15 62 GPIO A PD14 63 GPIO B PD13 64 GPIO C PD12 65 GND GND 66 GPIO D PD11 67 GPIO E PD10 68 GPIO F PD9 69 GPIO G PD8 70 5V 71 Reserved 72 3.3V 3.3V 73 I2C B SDA 74 I2C B SCL 75 UART C TX 76 UART C RX 77 UART D TX 78 UART D RX 79 GND GND 80 Reserved 81 Reserved 82 Reserved 83 Reserved 84 Reserved 85 Reserved 86 5V 87 USB Device ID 88 3.3V 3.3V 89 UART B TX 90 UART B RX 91 ADC A PB8, ADC9 92 GPIO H PD2 93 SPI B MISO 94 SPI B MOSI 95 GND GND 96 SPI B SCK 97 ADC B PB11, ADC0 98 CAN A TD PA5, UART3 TX, CAN2 TX 99 CAN A RD PA6, UART3 RX, CAN2 RX 100 CAN B TD 101 CAN B RD 102 UART HS A TX PA0, UART2 TX 103 UART HS A RX PA1, UART2 RX 104 ADC C PB12, ADC1 105 PWM A PC18, PWM0 106 3.3V 3.3V 107 SYS A SPI1 MISO 108 Module Specific 2 SPI1 MOSI 109 Module Specific 3 SPI1 SCK 110 ADC D PB17, ADC6 111 SYS C PA4, LDR1 112 PWM B PC19, PWM1 113 GND GND 114 ADC E PB16, ADC5 115 I2C A SDA PA30, I2C SDA 116 I2C A SCL PA31, I2C SCL 117 UART A RX PA9, UART1 RX, CAN1 RX 118 UART A TX PA10, UART1 TX, CAN1 TX 119 GPIO I PC24 120 UART HS A RTS PA2, UART2 RTS 121 UART HS A CTS PA3, UART2 CTS 122 GPIO J PD7 123 SD Card D0 PA15, SD D0 124 3.3V 3.3V 125 SD Card CMD PA16, SD CMD 126 SD Card CLK PA17, SD CLK 127 SD Card D1 PA18, SD D1 128 SD Card D2 PA19, SD D2 129 SD Card D3 PA20, SD D3 130 PWM C PC21, PWM3 131 GND GND 132 GPIO K PC26 133 PWM D PC20, PWM2 134 SYS B PA24, LDR0 135 SYS D PA25, MODE 136 GPIO L PA26 137 Module Specific 10 PA27 138 UART HS B RTS 139 UART HS B CTS 140 UART HS B TX PC16, UART6 TX 141 UART HS B RX PC17, UART6 RX 142 3.3V 3.3V 143 LCD VSYNC PC27, LCD VSYNC 144 LCD HSYNC PC28, LCD HSYNC 145 LCD CLK PC30, LCD CLK 146 LCD DE PC29, LCD DE 147 Module Specific 11 PD3 148 SD Card CD PD4 149 Module Specific 12 PD5 150 Reserved 151 GND GND 152 LCD B3 PC0, LCD B3 153 LCD B4 PC1, LCD B4 154 LCD B5 PC2, LCD B5 155 LCD B6 PC3, LCD B6 156 LCD B7 PC4, LCD B7 157 ADC F PB13, ADC2 158 ADC G PB14, ADC3 159 ADC H PB15, ADC4 160 3.3V 3.3V 161 LCD G2 PC5, LCD G2 162 LCD G3 PC6, LCD G3 163 LCD G4 PC7, LCD G4 164 LCD G5 PC8, LCD G5, UART5 TX 165 LCD G6 PC9, LCD G6, UART5 RX 166 Module Specific 13 PD1 167 Indicator C PA8, UART4 RX 168 LCD R7 PC15, LCD R7 169 GND GND 170 LCD G7 PC10, LCD G7 171 LCD R3 PC11, LCD R3 172 LCD R4 PC12, LCD R4 173 LCD R5 PC13, LCD R5 174 LCD R6 PC14, LCD R6 175 SPI A SCK PA23, SPI2 SCK 176 SPI A MISO PA21, SPI2 MISO 177 Module Specific 14 WKUP 178 SPI A MOSI PA22, SPI2 MOSI 179 Module Specific 15 SHDN 180 3.3V 3.3V 181 Module Specific 16 PWR EN 182 Module Specific 17 USB H2+ 183 VBAT VBAT 184 Module Specific 18 USB H2- 185 GND GND 186 GND GND 187 RESET RESET 188 USB Host D+ USB H1+ 189 JTAG RTCK RTCK 190 USB Host D- USB H1- 191 JTAG TDO TDO 192 3.3V 3.3V 193 JTAG NTRST NTRST 194 USB Device D+ USB D+ 195 JTAG TDI TDI 196 USB Device D- USB D- 197 JTAG TCK (SWCLK) TCK 198 GND GND 199 JTAG TMS (SWDIO) TMS 200 Indicator D PA7, UART4 TX CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a G400 driving the SN65HVD230 CAN driver chip. See the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 83.333K 7 4 1 99 0 False 87.5% 0.31% 845M 125K 7 1 1 81 0 False 84.6% 0.38% 499M 250K 7 1 1 40 0 False 84.6% 0.38% 222M 500K 7 7 1 13 1 False 89.5% 0.41% 92M 1M 7 7 1 6 1 False 89.5% 0.41% 19M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested to ensure reliability. G400 Development Board This is no longer in production, replaced by the Development Options Schematic Want to quickly build your prototype? Check out the UCM Development Options . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/netmf/g400s.html": {
    "href": "hardware/netmf/g400s.html",
    "title": "G400S",
    "keywords": "G400S Overview The G400S System on Module (SoM) is the surface mount version of the G400D. The G400D can be programmed in .NET C# and Visual Basic using .NET Micro Framework. Tip Not recommended for new designs, consider SITCore System on Chip . Ordering Part Number G400S SoM: G400S-SM-480 Specifications Spec Value Processor Atmel AT91SAM9X35 ARM 926 Speed 400 MHz Internal RAM 32 KByte (SRAM) Internal Flash 0 KByte External RAM 128 MByte (DDR2 SDRAM) External Flash 4 MByte (SPI) Dimensions 48.3 x 33.1 x 4.6 mm Temperature Range -40 C to +85 C Note: Not all memory will be available for your application. Peripherals Note: Many peripherals share I/O pins. Not all peripherals will be available to your application. .NET Micro Framework RoHS Lead Free 400 MHz ARM 9 Atmel SAM9X35 64 MBytes available RAM 1.4 MBytes available flash Embedded LCD controller 89 interrupt capable GPIO 2 SPI 1 I2C 6 UART 2 CAN 4 PWM 12 10-bit analog output 4-bit SD/MMC memory card interface Low power modes RTC Watchdog Threading USB host USB client SQLite database TCP/IP with SSL Full .NET socket interface Ethernet PPP Graphics Images Fonts Controls File System Full .NET file interface SD cards USB drives Native extensions Runtime Loadable Procedures Device register access Signal controls Generation Capture Pulse measurement G400S Pinout Many signals on the G400 are multiplexed to offer multiple functions on a single pin. Developers can decide on the pin functionality to be used through the provided libraries. Any pin with no name, function, or note must be left unconnected. Footprint G400S Recommended Footprint Device Startup The G400 is held in reset when the reset pin is low. Releasing it will begin the system startup process. It is pulled high internally There are four different components of the device firmware: GHI Electronics Bootloader: initializes the system, updates TinyBooter when needed, and executes TinyBooter. TinyBooter: executes NETMF, updates NETMF when needed, and updates the system configuration. NETMF: loads, debugs, and executes the managed application. Managed application: the program developed by the customer. Which components get executed on startup can be control by manipulating the LDR0 and LDR1 pins. LDR0 and LDR1 are pulled high on startup. LDRO LDR1 Effect Ignored High Execute the managed application High Low Wait in TinyBooter Low Low Wait in GHI Electronics Bootloader Additionally, the communications interface between the host PC and the G400 is selected on startup through the MODE pin, which is pulled high on startup. The USB interface is selected when MODE is high and COM1 is selected when MODE is low. The above discussed functions of LDR0, LDR1, and MODE are only during startup. After startup, they return to the default GPIO state and are available to use as GPIO in the user application. .NET Micro Framework (NETMF) The NETMF software on G400 is mature and complete. For more information on NETMF you can go to the NETMF Introduction page. The NETMF Getting Started page covers NETMF from setup of the host computer to program deployment on both an emulator and target device. Bootloader v1 is needed for G400 to work with NETMF. It is available in the NETMF SDK. Loading Bootloader Version 2 Download the G400 bootloader v2 file and load onto the dataflash using the Microchip SAM-BA tool and the following instructions. To set the chip in SAM-BA mode, hold down the dedicated button on your board (SYS A on UCM Dev and Breakout boards) while the system powers up (or during reset). If there is no such button, connect G400S pin SPI1_MISO to ground. Keep the button pressed (pin grounded) for three seconds after power up or reset, then release the pin. The device manager will show a COM port similar to \"Bossa Program Port\" or \"GPS Detect\". If it is not already installed, download and install the SAM-BA tool from Microchip. The latest version we have tested is 2.18 for Windows. (The tool may not show correctly. Try to make the window larger to see all hidden buttons!) Open the SAM-BA program then select the COM port for your device in the connection box and your board type below it (at91sam9x35-ek for G400), then click connect. Near the middle of the window, go to the DataFlash AT45DB/DCB tab. Under Scripts , select Enable Dataflash (SPI0 CS0) then click the Execute button. Under Scripts , select Erase All then click Execute . This will take some time to complete. It seems that if SAM-BA loses focus during the erase procedure it can seem to lock up. We recommend that once you click the Execute button you leave the computer alone until the erase procedure is completed. Under Scripts , select Send Boot File , click execute, then browse to and select the bootloader for the device. Once the transfer finishes, go to File > Quit and then reset the board. Make sure to properly quit the program or connection errors may result on subsequent uses. Now reset the board. Congratulations, your board is now running the loaded program! Loading the Firmware Activate the bootloader, hold the LDR0 signal low while resetting the board. Open FEZ Config tool and follow the instructions. You can also update the firmware manually. See GHI Electronics Bootloader page. Start Coding Now that you have installed the bootloader and firmware, you can setup your host computer and start programming. Go to the NETMF Getting Started page for instructions. Datasheet This documentation page replaced the legacy datasheet PDF but it is here for reference. CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a G400 driving the SN65HVD230 CAN driver chip. See the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 83.333K 7 4 1 99 0 False 87.5% 0.31% 845M 125K 7 1 1 81 0 False 84.6% 0.38% 499M 250K 7 1 1 40 0 False 84.6% 0.38% 222M 500K 7 7 1 13 1 False 89.5% 0.41% 92M 1M 7 7 1 6 1 False 89.5% 0.41% 19M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested to ensure reliability. Design Considerations Required Pins Exposing the following pins is required in every design to enable device programming, updates, and recovery: LDR0 LDR1 Reset Desired debug interface(s) MODE if required to select a debug interface SPI1 MISO to update TinyBooter in SDK 2015 R1 and earlier and to install the GHI Electronics Bootloader once for SDK 2016 R1 and later Power Supply A typical clean power source, suited for digital circuitry, is needed to power the G400. Voltages should be within at least 10% of the needed voltage. Decoupling capacitors of 0.1 μF are needed near every power pin. Additionally, a large capacitor, typically 47 μF, should be near the G400 if the power supply is more than few inches away. Additionally, the G400 requires additional voltages beyond the typical 3.3 V to function properly. See the pinout table for details. Crystals The G400 includes the needed system and RTC crystals and their associated circuitry. SPI Channels SPI1 is shared internally with the flash memory on the G400. Use of a chip select with devices on this channel is required or the G400 will not function properly. The use of another SPI channel is recommended. Ethernet The built in Ethernet available on the G400D includes all needed Ethernet circuitry internally. However, an appropriate magnet and connector, like the J0011D or similar, are required. Soldering the G400S The G400S is designed to be easily machine-placed or hand-soldered. Static sensitive precautions should be taken when handling the module. Oven Reflow The G400S is not sealed for moisture. Baking the module before reflow is recommended and required in a humid environment. The process of reflow can damage the G400 if the temperature is too high or exposure is too long. The lead-free reflow profiles used by GHI Electronics are shown below. The profiles are based on AIM SAC 305 solder (3% silver, 0.5% copper). The thermal mass of the assembled board and the sensitivity of the components on it affect the total dwell time. Differences in the two profiles are where they reach their respective peak temperatures as well as the time above liquids (TAL). The shorter profile applies to smaller assemblies, whereas the longer profile applies to larger assemblies such as back-planes or high-density boards. The process window is described by the shaded area. These profiles are only starting-points and general guidance. The particulars of an oven and the assembly will determine the final process. You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/netmf/g80.html": {
    "href": "hardware/netmf/g80.html",
    "title": "G80",
    "keywords": "G80 Overview The G80 SoC is a low-cost System on Chip part of the GHI Electronics SurfaceMount Compute Modules (SCM) line. This modules can be programmed in .NET C# and Visual Basic using .NET Micro Framework. Tip Not recommended for new designs, consider SITCore System on Chip . Ordering Part Number G80 SoC: G80SC-SM-501 G80 Dev Board: G80DB-SM-483 Specifications Spec Value Processor STM32F427VGT6 Speed 180 MHz Internal RAM 256 KByte (SRAM) Internal Flash 1 MByte Package LQFP100 14 x 14 mm Temperature Range -40C to +85C Note: Resources are shared between your application and the operating system. Features .NET Micro Framework RoHS Lead Free 180 MHz ARM Cortex-M4 STM32F427VGT6 156 KBytes available RAM 256 KBytes available flash 78 GPIO 16 interrupt capable GPIO 2 SPI 1 I2C 4 UART 2 CAN 26 PWM 16 12-bit analog input 4-bit SD/MMC memory card interface Low power modes LQFP6100 14 x 14 mm RTC Watchdog Threading USB host USB client TCP/IP with SSL Full .NET socket interface Ethernet PPP Graphics Images Fonts Controls File System Full .NET file interface SD cards USB drives Native extensions Runtime Loadable Procedures Device register access Signal controls Generation Capture Pulse measurement G80 Pinout Many signals on the G80 are multiplexed to offer multiple functions on a single pin. Developers can decide on the pin functionality to be used through the provided libraries. Any pin with no name, function, or note must be left unconnected. Footprint The chip is standard LQFP100 14x14mm. See the STM32F427VGT6 datasheet for exact footprint. Device Startup The G80 is held in reset when the reset pin is low. Releasing it will begin the system startup process. There are three different components of the device firmware: GHI Electronics Bootloader: initializes the system, updates NETMF firmware when needed, and executes NETMF. NETMF Firmware: loads, debugs, and executes the managed application. Managed application: the program developed by the customer. Which components get executed on startup can be control by manipulating the LDR0 pin. It is pulled high on startup. When low, the device waits in the GHI Electronics Bootloader. Otherwise, the managed application is executed. LDR1 is reserved for future use. Additionally, the communications interface between the host PC and the G80 is selected on startup through the MODE pin, which is pulled high on startup. The USB interface is selected when MODE is high and COM1 is selected when MODE is low. The above discussed functions of LDR0, LDR1, and MODE are only during startup. After startup, they return to the default GPIO state and are available to use as GPIO in the user application .NET Micro Framework NETMF provides a way to program the G80 in C# or Visual Basic from the Microsoft Visual Studio integrated development environment. To get started you must first install the firmware on the G80 (instructions below) and then go to the NETMF Getting Started page for instructions. Loading the Firmware Activate the bootloader, hold the LDR0 signal low while resetting the board. Open the FEZ Config tool and follow the instructions. You can also update the firmware manually. See GHI Electronics Bootloader manually. Start Coding Now that you have installed the firmware on the G80, you can setup your host computer and start programming. Go to the NETMF Getting Started page for instructions. Datasheet This documentation page replaced the legacy datasheet PDF but it is here for reference. CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a G80 driving the TJA1050T CAN driver chip. See the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 33.333K 1 12 2 90 1 False 86.7% 0.33% 2145M 83.333K 1 12 2 36 1 False 86.7% 0.33% 825M 125K 1 12 2 24 1 False 86.7% 0.33% 531M 250K 1 12 2 12 1 False 86.7% 0.33% 238M 500K 1 12 2 6 1 False 86.7% 0.33% 91M 1M 1 12 2 3 1 False 86.7% 0.33% 18M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested to ensure reliability. Design Considerations Required Pins Exposing the following pins is required in every design to enable device programming, updates, and recovery: LDR0 LDR1 Reset Desired debug interface(s) MODE if required to select a debug interface Power Supply A typical clean power source, suited for digital circuitry, is needed to power the G80. Voltages should be within at least 10% of the needed voltage. Decoupling capacitors of 0.1 μF are needed near every power pin. Additionally, a large capacitor, typically 47 μF, should be near the G80 if the power supply is more than few inches away. Crystals The G80 requires an external 12 MHz crystal and associated circuitry to function. For the RTC to function, a 32,768 Hz crystal and circuitry are required. Please see the processor’s documentation for advanced information. Interrupt Pins Interrupts are only available on 16 pins at any given time. Of those 16 pins, the pin number must be unique. For example: PA1 and PB1 cannot both be used as interrupts at the same time, but PA1 and PB2 can. Reset The reset pin is not pulled in any direction. Designs must be sure to use an appropriate pull-up resistor. G80 Development Board The G80 Dev Board is an excellent starting point and reference design for anyone interested in evaluating and developing with the G80. Schematics You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/netmf/intro.html": {
    "href": "hardware/netmf/intro.html",
    "title": "NETMF Modules",
    "keywords": "NETMF Modules These products have matured. They are in full production; however, NETMF software has been replaced by TinyCLR OS 2.0 software and SITCore Modules . Please consider switching ASAP. G30 Learn more... G80 Learn more... G120 / G120E Learn more... G400S Learn more... G400D Learn more... Upgrading to SITCore Learn more... You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/netmf/upgrade.html": {
    "href": "hardware/netmf/upgrade.html",
    "title": "Upgrading to SITCore",
    "keywords": "Upgrading to SITCore To complement our ten year Longevity Promise, we provide SITCore products that are drop in replacements for most of our more mature SoMs and chipsets. We strive to keep your product viable as long as possible with no or minimal changes to your hardware. G30 to SITCore While we offer no SITCore in an LQFP64 package, the recommended replacement (the SC20100S) has considerably more horsepower and available resources. As nearly all new designs will require some form of IoT connectivity, the SC20100S provides much greater value for new designs or redesigns of existing products. G80 to SITCore Unfortunately the LQFP100 version of the SITCore processor is unavailable in a version that is pin compatible with the G80, so changes to your circuit board will be needed. However, many of the pins on the SC20100S have the same function as on the G80, and the other pins are close to their previous position. Our experience has shown that upgrading a circuit board design from the G80 to the SC20100S can easily be accomplished in a matter of hours. G120 to SITCore Our SCM20260N is a drop in replacement for the G120 with the following differences that will rarely be an issue. The following pads/pins on the SCM20260N do not support hardware PWM -- use software PWM if needed: Pad 3/pin PK7, pad 23/pin PC10, pad 24/pin PC9, pad 25/pin PC12, pad 26/pin PC8, pad 28/pin PD2, pad 85/pin PI12, and pad 90/pin PI13. SCM20260N pad 80 (PK6/LCD B7) and pad 88 (PJ6/LCD R7) do not have COM TX and RX as found on G120 pads 80 and 88. As this is an LCD pin, this will rarely be an issue. Pad 15 on the SCM20260N (PI2/SPI2 MISO/TIM8 CH4 + PD3/USART2 CTS through 1K resistor) provides USART CTS connected through a 1K resistor to maintain compatibility with Pad 15 on the G120 (P0.17/COM2 CTS/SPI1 MISO). G120E to SITCore Our SCM20260E is a drop in replacement for the G120E except for a few issues that will rarely present any problem. To enable serial deployment and debugging, the MOD pin on the SCM20260E is active low, while on the G120E the MODE pin is active high. A minor change will be needed to correct the MOD level and select the desired debugging interface. Serial mode deploying and debugging defaults to UART5 on the SCM20260E versus UART1 on the G120E. This is only a concern if serial mode deploying/debugging is needed. SCM20260E pad 57 (PD3/USART2 CTS) does not have PWM as on G120E pad 57 (P3.18/COM2 CTS/PWM2). Use software PWM if needed. SCM20260E pad T5 (PJ6/LCD R7) does not have COM RX as on G120E pad T5 (P2.9/LCD R4/COM5 RX). As this is an LCD pin, this will rarely be an issue. SCM20260E pad T16 (PJ6/LCD R7) does not have COM TX as on G120E pad T16 (P1.29/LCD B4/COM5 TX). As this is an LCD pin, this will rarely be an issue. G400S to SITCore Unfortunately, we do not offer a SITCore drop in replacement for the G400S. The recommended replacement is the SCM20260E, which has considerably more horsepower and available resources. As nearly all new designs will require some form of IoT connectivity, the SCM20260E provides much greater value for new designs or redesigns of older products. G400D to SITCore Our SCM20260D is a drop in replacement for the G400D, with just a couple of differences that will rarely be an issue. SCM20260D pins 164 and 165 do not provide UART TX and RX as on the G400D. As these are LCD pins, this will rarely be an issue. There is no second USB host controller on the SITCore SCM20260D pins 182 and 184 as there is on the G400D. UC2550 and UC5500 to SITCore The recommended replacement, the SCM20260D, is close, but not completely compatible with the UC2550 and UC5550. Some PCB changes will be needed."
  },
  "hardware/netmf/usbizi.html": {
    "href": "hardware/netmf/usbizi.html",
    "title": "USBizi",
    "keywords": "USBizi USBizi was the first single chip .NET Micro Framework (NETMF) on the market. It was available in 100pin and 144pin LQFP packages. We are no longer selling this chipset but we are making all bootloader binaries available for free, including for commercial use. To use with NETMF, follow these setup instructions . Requires the NETMF 4.1 SDK. Resources User Manual USBizi DevSys The original development board for USBizi. Schematic"
  },
  "hardware/raspberrypi-hats.html": {
    "href": "hardware/raspberrypi-hats.html",
    "title": "Raspberry Pi Hats",
    "keywords": "Raspberry Pi Hats Several HATs were made for the RPI. The software was focused on the use of Win10. This GitHub repo includes the software for all HATs. FEZ HAT Schematic FEZ ProtoPi Schematic FEZ Utility Schematic FEZ Cream This HAT was part of the Gadgeteering efforts. Schematic Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/sitcore/dev.html": {
    "href": "hardware/sitcore/dev.html",
    "title": "SITCore Dev Boards",
    "keywords": "SITCore Dev Boards We offer two development boards making it possible to start programming your application within minutes without designing or building new hardware. These boards are not only suitable for prototypes, but for short production runs as well. Note All SITCore Dev boards use a USB-C connector for application deployment and debugging. While USB-C has many advantages, we've also noticed some flaws. Every USB-A to USB-C cable tested worked as expected. Testing USB-C to USB-C cables gave interesting and unexpected results. Most USB-C hubs also do not work when using USB-C to USB-C cables. If you are having problems deploying or debugging, try connecting the board directly to your computer with a USB-A to USB-C cable. SITCore SC20100S Dev Board The SC20100S Dev Board includes an SC20100S soldered to the board and a built in 1.8 inch color serial display. It has three 40 pin socket headers for connecting peripherals and a display. Peripheral connectors include external power, Ethernet, CAN, USB host and client, RTC backup battery, DCMI interface and an SD card slot. It also has a buzzer, LEDs, a reset button, and user programmable boot buttons. To start development using the SC20100S Dev Board, just connect the board's USB Client port to a host computer using a USB-C cable. Go to the Getting Started page in the TinyCLR section of the documentation page for further instructions. The board can be powered through either the USB client connectors or the barrel jack. Always use the barrel jack for power when using displays, especially the larger ones. USB does not provide sufficient power needed for displays. SC20100S Dev Board Schematic Note All boards with a barrel power jack accept a 5.5 x 2.1 mm power plug. The pin is positive, the sleeve is negative. While these boards accept a wide voltage range, they use linear voltage regulators that run hotter with higher input voltages. Generally we recommend an input voltage of 6 to 12 volts, but if your project draws a lot of current, use a lower voltage to keep the regulator cooler. A one amp power supply should provide enough current for most needs. SITCore SCM20260D Dev Board The SCM20260D Dev Board is the fastest and easiest way to start developing with the SCM20260D. This board includes an SCM20260D DIMM module and a 4.3 inch capacitive touch display. It provides standard connectors for input/output, and three 40 pin socket headers for connecting peripherals and a display. Peripheral connectors include external power, Ethernet, CAN, USB host and client, RTC backup battery, DCMI interface and an SD card slot. It also has a buzzer, LEDs, a reset button, and user programmable boot buttons. To start development using the SCM20260D Dev Board, just install the module on the board, plug in the display (if needed), and connect the board's USB Client port to a host computer using a USB-C cable. Go to the Getting Started page in the TinyCLR section of the documentation page for further instructions. The board can be powered through either the USB client connectors or the barrel jack. Always use the barrel jack for power when using displays, especially the larger ones. USB does not provide sufficient power needed for displays. SCM20260D Dev Board Schematic Note All boards with a barrel power jack accept a 5.5 x 2.1 mm power plug. The pin is positive, the sleeve is negative. While these boards accept a wide voltage range, they use linear voltage regulators that run hotter with higher input voltages. Generally we recommend an input voltage of 6 to 12 volts, but if your project draws a lot of current, use a lower voltage to keep the regulator cooler. A one amp power supply should provide enough current for most needs. Display Options One of the headers on the SCM20260 Dev board includes all necessary parallel display signals. It also includes I2C and a couple of GPIOs allowing for support of capacitive touch panels. Out-of-the-box, the SCM20260 Dev board includes a 4.3\" display with capacitive touch. Display Module: ER-TFT043-3 Touch Panel: ER-TPC043-2 4.3\" Display Module Schematic This display module has a 4.3\" 480x272 TFT display with a capacitive touch screen. It plugs directly into the SCM20260D Dev Board and uses I2C1 for capacitive touch and PJ14 for the touch interrupt. The backlight is controllable through PA15. The TinyCLR Samples repo has usage examples. You can learn more in the Graphics and Display sections of the TinyCLR tutorials. See below for the display configuration values: Property Value Width 480 Height 272 DataFormat RGB565 Pixel Clock Rate 8 MHz <= x <= 16MHz Pixel Polarity low DataEnable Is Fixed false DataEnable Polarity low Horizontal Back Porch 46 Horizontal Front Porch 16 Horizontal Sync Polarity low Horizontal Sync Pulse Width 1 Vertical Back Porch 23 Vertical Front Porch 7 Vertical Sync Polarity low Vertical Sync Pulse Width 1 Camera Options The SC20260 SoC and its related SoMs include a parallel Digital Camera Interface. The Dev Board exposes the camera signals on a dedicated header. While any compatible display can be connected, the pinout matches the popular OV9655 breakout board, available from many sources around the web and shown below: It is important to note that some of these breakout boards ship with voltage regulators that don't seem to work properly, while others work well. Please understand that these are just our observations -- we cannot guarantee the functionality or quality of any third party products. Here are images of OV9655 modules where one works and the other doesn't. The good modules have regulators labeled \"3DB8N\" and \"3Cb2b:\" . The bad modules have voltage regulators labeled \"2EB2S\" and \"3AB2I:\" Demo Program The SITCore SCM20260D Dev Board ships with a demonstration program that can be found on our TinyCLR-Samples GitHub repository. Tip There are two power LEDs next to the USB connector for 3.3V and 5V. They are useful to check that you have supplied the necessary power. You can visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/sitcore/intro.html": {
    "href": "hardware/sitcore/intro.html",
    "title": "SITCore",
    "keywords": "SITCore Our SITCore line of products provides an easy way to create secure IoT and embedded devices that are programmable in C# using Visual Studio. Designed with security as a top priority, your intellectual property is protected through device code protection, secure encrypted in-field and OTA update, and secure booting. System on Chip Secure IoT chips that run C# and support debugging over USB. Learn More... System on Modules Available as a surface mount module and a 200 pin SO-DIMM module. Learn More... Development Boards Get started quickly with one of our development boards -- you'll be programming in minutes! Learn More... Single Board Computers Our single board computers provide the lowest barrier of entry to the world of TinyCLR OS Learn More... The SITCore product family is empowered by TinyCLR OS, which lets you program your devices in C# or Visual Basic using Microsoft's Visual Studio -- and the development tools are free! Learn more... . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/sitcore/sbc.html": {
    "href": "hardware/sitcore/sbc.html",
    "title": "Single Board Computers",
    "keywords": "Single Board Computers We offer multiple single board computers to provide the lowest possible barrier to entering the world of TinyCLR OS. Most of these boards have WiFi and they all support the complete TinyCLR feature set. These boards are great for trying out TinyCLR OS, building prototypes, or incorporating into products. Note All SITCore single board computers use a USB-C connector for application deployment and debugging. While USB-C has many advantages, we've also noticed some flaws. Every USB-A to USB-C cable tested worked as expected. Testing USB-C to USB-C cables gave interesting and unexpected results. Most USB-C hubs also do not work when using USB-C to USB-C cables. If you are having problems deploying or debugging, try connecting the board directly to your computer with a USB-A to USB-C cable. Specifications and Peripherals FEZ Bit Fez Duino FEZ Feather Fez Portal FEZ Stick Core SC20100S SC20100S SC20100S SC20260N SC20100S External SDRAM X X X 32 MByte X External Flash X 16 MByte X 16 MByte X Display 1.8\" 160x128 X X 4.3\" 480x272 Cap. Touch X Click Connectors X X X 1 2 WiFi Yes Yes Yes Yes X Micro SD Yes Yes X Yes X User LED Yes Yes Yes Yes Yes Buzzer Yes X X Yes X Accelerometer Yes X X X X User Buttons Yes Yes Yes Yes Yes USB Client Yes Yes Yes Yes Yes USB Host Connector X Yes X Yes Yes LiPo Charger X X Yes X X Power Barrel X Yes X X X GPIO 19 38 31 45 33 SPI 1 2 2 3 2 I2C 1 2 1 1 2 UART 3 (0 w/ HS) 5 (2 w/ HS) 5 (1 w/ HS) 6 (1 w/ HS) 3 (1 w/ HS) CAN 1 1 1 2 1 PWM 8 12 8 17 6 ADC 8 11 6 10 3 DAC 1 2 1 2 X SD/SDIP/MMC 1 1 1 1 1 Note: As many pins share peripherals, not all peripherals will be available. FEZ Bit The FEZ Bit , while seemingly more of a \"maker\" board, provides a convenient way to easily use the multitude of inexpensive Micro:bit accessories that have flooded the market. As the number of Micro:bit accessories continues to grow, this board will be valued as a way to use these accessories to quickly assemble prototypes and test new product concepts. FEZ Bit Schematic FEZ Bit Peripheral Pins User LED PE11 Buzzer PB1 Accelerometer I2C = I2C1 SPI Display SPI = SPI4 BL = PA15 CS = PD10 RS = PC4 RST = PE15 WiFi SPI = SPI3 IRQ = PA10 CS = PD15 EN = PA8 RST = PA9 Note All boards with a barrel power jack accept a 5.5 x 2.1 mm power plug. The pin is positive, the sleeve is negative. While these boards accept a wide voltage range, they use linear voltage regulators that run hotter with higher input voltages. Generally we recommend an input voltage of 6 to 12 volts, but if your project draws a lot of current, use a lower voltage to keep the regulator cooler. A one amp power supply should provide enough current for most needs. FEZ Duino The FEZ Duino provides female headers that make use of the popular Arduino pinout. Once again, we are trying to make it as easy and inexpensive as possible to build prototypes and try out new concepts by taking advantage of an existing accessory ecosystem. FEZ Duino Schematic FEZ Duino Peripheral Pins User LED PE11 WiFi SPI = SPI3 IRQ = PA10 CS = PD15 EN = PA8 RST = PA9 FEZ Feather The Adafruit Feather form factor boards are made to be stackable and have built in support for LiPo batteries, including a charging circuit. We've watched this form factor quickly gaining popularity, so we decided to make a Feather board of our own. If your project needs to run off of a battery, this board makes it quick and easy to get started. The FEZ Feather provides both through hole pads and castellated edges making it both breadboard friendly and easy to build into products. Important Be very careful to ensure the correct polarity of LiPo batteries before connecting them to the FEZ Feather. Reverse polarity will damage the charging circuit, and not all batteries are wired correctly. GHI Electronics is not responsible for, and will not warranty, damage caused by incorrectly connected batteries. Make sure the battery polarity is correct as shown below (red wire to plus, black to minus): FEZ Feather Schematic FEZ Feather Peripheral Pins User LED PE11 WiFi SPI = SPI3 IRQ = PA10 CS = PD15 EN = PA8 RST = PA9 FEZ Portal Already one of our most popular SITCore single board computers, The FEZ Portal is a 4.3\" 480x272 display with capacitive touch that is programmable in C#. As the display and controller are one unit, it's even easier to make a product with touch as you only have to mount a single board that's only slightly larger than the display. FEZ Portal Schematic FEZ Portal Peripheral Pins User LED PB0 Buzzer PB1 Display BL = PA15 Touch I2C = I2C1 Touch IRQ = PG9 WiFi SPI = SPI3 IRQ = PF10 CS = PA6 EN = PA8 RST = PF8 FEZ Stick The FEZ Stick is simply the least expensive way to easily get started with TinyCLR OS. While providing an inexpensive way for the uninitiated to try TinyCLR OS, we've provided castellated edges as well as through hole pads to make it breadboard friendly and easy to embed into products. Also, there's actually space for two click modules, making this a very versatile board at a very affordable price! FEZ Stick Schematic FEZ Stick Peripheral Pins User LED PE11"
  },
  "hardware/sitcore/soc.html": {
    "href": "hardware/sitcore/soc.html",
    "title": "SITCore System on Chip",
    "keywords": "SITCore System on Chip Overview The SITCore SoCs provide a low cost way to add .NET computing power to any embedded product. Available as either a 100 pin LQFP or a 265 ball BGA, the SITCore SoCs let you design IoT products that are secure, easily integrated with the cloud, and can be easily managed and updated from the cloud for deployments of one to a million or more. Specifications Spec SC20100S SC20260B Core ARM Cortex-M7 32 bit ARM Cortex-M7 32 bit Speed 480 MHz 480 MHz Internal RAM 1 MByte 1 MByte Internal Flash 2 MByte 2 MByte Instruction Cache 16 KByte 16 KByte Data Cache 16 KByte 16 KByte Package LQFP100 14 x 14 mm 265-TFBGA 14 x 14 mm Temperature Range -40C to +85C -40C to +85C Note: Resources are shared between your application and the operating system. Peripherals Peripheral SC20100S SC20260B GPIO 76 164 SPI 3 3 I2C 2 3 UART 8 (4 with handshaking) 8 (4 with handshaking) CAN 2 2 PWM 16 29 ADC 12 21 DAC 2 2 SD/SDIP/MMC 1 1 USB Host 1 1 USB Client 1 1 Ethernet 1 1 LCD TFT 0 1 Camera 0 1 Note: As many pins share peripherals, not all peripherals will be available. Using Interrupts (IRQs) The microcontrollers we use in our SITCore line of products do not support concurrent interrupts with the same pin number, even if the pins are on different ports (the port is denoted by the second letter of the GPIO pin name -- PA1 is pin 1 on port A). Therefore, interrupts are available on only 16 pins at any given time. For example, pins PA1 and PB1 cannot be used as interrupt pins at the same time, but PA1 and PB2 can. PA1 and PA2 can also be used with interrupts simultaneously. Features Low power modes including three independently controllable power domains RTC Watchdog Threading TCP/IP with SSL Full .NET socket interface Ethernet PPP Graphics Images Fonts Controls File System Full .NET file interface SD cards USB drives Native extensions Runtime Loadable Procedures Device register access Signal controls Generation Capture Pulse measurement Pinouts SC20100S Pinout SC20260B Pinout Device Startup The SITCore is held in reset while the RESET pin is low. Releasing RESET will begin the system startup process. There are three different components of the device firmware: GHI Electronics Bootloader: initializes the system, updates TinyCLR when needed, and executes TinyCLR. TinyCLR: used to load, debug, and execute the managed application. Managed application: the program developed by you or your software developer. Which components get executed on startup is controlled by manipulating the LDR pin. It is pulled high on startup during normal program execution. When low, the device waits in the GHI Electronics Bootloader. Otherwise, the managed application is executed. The APP pin is used to stop the application from running. Additionally, the communications interface between the host PC and the SITCore is selected on startup through the MOD pin, which is pulled high on startup. The USB interface is selected when MOD is high and COM1 is selected when MOD is low. The above discussed functions of the LDR, APP, and MOD pins are only available during startup. After startup, the pins return to the default GPIO state and are available as a GPIO (or peripheral pin) in your application. Check out the Special Pins page for more information. TinyCLR OS TinyCLR OS provides a way to program the SITCore in C# or Visual Basic from the Microsoft Visual Studio integrated development environment. To get started you must first install the firmware on the SITCore (instructions below) and then go to the TinyCLR Getting Started page for instructions. Loading the Firmware Activate the bootloader, hold the LDR signal low while resetting the board. Open TinyCLR Config tool. Click the loader tab. Select the correct COM port. If you are not seeing it then the device is not in the loader mode. Click the Update to Latest button. You can also update the firmware manually. Download the firmware and learn how to use the GHI Electronics Bootloader manually Start Coding Now that you have installed the bootloader and firmware on the SITCore, you can setup your host computer and start programming. Go to the TinyCLR Getting Started page for instructions. Design Considerations Footprints This is the recommended footprint for the SC20100S: This is the recommended footprint and PCB design rules for the SC20260B: Required Pins Exposing the following pins is required in every design to enable device programming, updates, and recovery: RESET LDR APP MOD (if required to select a debug interface) Desired debug interface(s) For information on these and other important pins, please refer to the Special Pins page. Power Supply A clean power source, suitable for digital circuitry, is needed to power SITCore SoCs. Voltages should be regulated to within 10% or better of the specified voltage. Decoupling capacitors of 0.1 uF are needed near every power pin. Additionally, a large capacitor, typically 47 uF, should be placed near the SoC if the power supply is more than few inches away. Analog Considerations It is a good idea to provide a separate filtered supply line for the Vdda , and Vref+ pins. Additionally, on the 260 pin devices, you may want to provide a separate filtered ground connection for the Vssa and Vref- pins. While this is not needed for ADC operation, it does help to ensure more accurate ADC readings by reducing analog supply noise. Crystals SITCore SoCs require an external 8 MHz crystal and two load capacitors to function. For the RTC to function, a 32.768 kHz crystal two load capacitors are required. There is a lot to consider when selecting a crystal -- especially the RTC crystal. This is one reason our SoMs are so popular, as the difficult design choices have already been made for you. For more information on crystal selection for SITCore SoCs, please consult AN2867 from STMicroelectronics. Main Crystal Most 8 MHz quartz crystals and ceramic resonators from various manufacturer will work with SITCore SoCs. The table below will tell you what to look for based on the crystal's maximum equivalent series resistance (ESR), shunt capacitance (C0), and load capacitance (CL). Keeping the total capacitance of C0 + CL well below the recommended maximum will provide more of a safety margin for stable and reliable oscillator operation. Max crystal ESR (ohms) Recommended max total of C0 and CL (pF) 40 49 50 44 60 40 70 37 80 35 100 31 200 22 300 18 RTC Crystal It's more difficult finding crystals that will work reliably with the RTC. This is because the RTC oscillator is an extremely low power oscillator to increase RTC battery life. Start by looking for crystals with low load capacitance. The table below will help. For reliable operation, the total capacitance of C0 (crystal shunt capacitance) and CL (crystal load capacitance) must be less than the recommended max total of C0 and CL. Max crystal ESR (kilohms) Recommended max total of C0 and CL (pF) 30 9.9 40 8.5 50 7.6 60 7.0 70 6.5 80 6.0 90 5.7 100 5.4 When laying out your board, it is best to keep the crystal as close as possible to the SoC so the oscillator traces are as short as possible. The oscillator circuit should also be surrounded by a grounded guard ring or ground plane on the same layer to reduce noise. There should also be a ground plane on a layer underneath the oscillator circuit. The oscillator ground plane should be connected to the closest SoC ground pin. Conformal coating or other protection is recommended in severe environments to reduce leakage current caused by PCB contamination. Do not expose the crystal to higher temperatures than it is rated for as damage may occur. PCB cleaning is recommended to obtain maximum performance by removing flux residuals from the board after assembly (even when using \"no-clean\" products in ultra-low-power applications). Follow the crystal manufacturer's guidelines for load capacitance, otherwise the oscillation frequency may be changed slightly. If the two load capacitors have the same value, one half the value of one load capacitor added to the capacitance of the oscillator traces should be equal to the manufacturer's recommended load capacitance. QuadSPI External Flash We have tested two 16 MByte QuadSPI flash chips with SITCore SoCs. These are the Winbond Electronics W25Q128JVSIM TR and W25Q128JVSIQ TR. If you want to add external flash to your design, sticking with one of these two chips should ensure compatibility with both the SoC and TinyCLR OS. Reset SITCore processors have a permanent internal pull up resistor that is connected to the RESET (NRST) pin. No external pull up resistor is needed. Oven Reflow Profile SITCore SoCs are not sealed for moisture. Baking SoCs before reflow is recommended and required in a humid environment. The process of reflow can damage the SoC if the temperature is too high or exposure is too long. The lead-free reflow profiles used by GHI Electronics are shown below. The profiles are based on AIM SAC 305 solder (3% silver, 0.5% copper). The thermal mass of the assembled board and the sensitivity of the components on it affect the total dwell time. Differences in the two profiles are where they reach their respective peak temperatures as well as the time above liquids (TAL). The shorter profile applies to smaller assemblies, whereas the longer profile applies to larger assemblies such as back-planes or high-density boards. The process window is described by the shaded area. These profiles are only starting-points and general guidance. The particulars of the oven and the assembly will determine the final process. SITCore Dev Boards We offer SITCore development boards to get you started as quickly and easily as possible. These boards allow you to start programming in minutes, and are suitable for both prototypes and production. Click here for details."
  },
  "hardware/sitcore/som.html": {
    "href": "hardware/sitcore/som.html",
    "title": "SITCore System on Modules",
    "keywords": "SITCore System on Modules Overview The SITCore SoMs provide a low cost way to add .NET computing power to any embedded product. They are available in a 200 pin SO-DIMM format or as surface mount modules. The SITCore SoMs let you design IoT products that are secure, easily integrated with the cloud, and can be easily managed and updated from the cloud for deployments of one to a million or more. The surface mount versions are great for harsh or high vibration environments. Specifications Spec All SITCore SoMs Processor Type ARM Cortex-M7 32 Bit Speed 480 MHz Internal RAM 1 MByte Internal Flash 2 MByte Instruction Cache 16 KByte Data Cache 16 KByte Temperature Range -40C to +85C Note: Resources are shared between your application and the operating system. Peripherals Peripheral SCM20100E SCM20260N SCM20260E SCM20260D External SDRAM None 32 MByte 32 MByte 32 MByte External Flash None 16 MByte 16 MByte 16 MByte GPIO 43 79 85 108 SPI 3 3 3 3 I2C 1 1 3 3 UART 5 (2 w/ H.S.) 7 (4 w/ H.S.) 8 (4 w/ H.S.) 8 (4 w/ H.S.) CAN 1 2 2 2 PWM 12 22 23 28 ADC 6 16 15 20 DAC 2 2 1 2 SD/SDIP/MMC 1 1 1 1 USB Host 1 1 1 1 USB Client 1 1 1 1 Ethernet 1 0 1 1 LCD TFT 0 1 1 1 Camera 0 1 1 1 Note: As many pins share peripherals, not all peripherals will be available. Using Interrupts (IRQs) The microcontrollers we use in our SITCore line of products do not support concurrent interrupts with the same pin number, even if the pins are on different ports (the port is denoted by the second letter of the GPIO pin name -- PA1 is pin 1 on port A). Therefore, interrupts are available on only 16 pins at any given time. For example, pins PA1 and PB1 cannot be used as interrupt pins at the same time, but PA1 and PB2 can. PA1 and PA2 can also be used with interrupts simultaneously. Features Low power modes including three independently controllable power domains RTC Watchdog Threading TCP/IP with SSL Full .NET socket interface Ethernet PPP Graphics Images Fonts Controls File System Full .NET file interface SD cards USB drives Signal controls Generation Capture Pulse measurement Module Pinouts SCM20100E Pinout SCM20260N Pinout SCM20260E Pinout SCM20260D Pinout Schematics SCM20100E Schematic SCM20260N Schematic SCM20260E Schematic SCM20260D Schematic Getting Started As the SITCore modules are based on the SITCore chipset, please refer to the SITCore SoC page for information on device startup, loading TinyCLR OS firmware, and writing and deploying your application. Design Considerations Footprints We recommend no traces or vias under the module. Dimensions are in inches. SCM20100E Recommended Footprint SCM20260N Recommended Footprint SCM20260E Recommended Footprint SCM20260D SO-DIMM Socket The SCM20260D uses the same 200 pin SO-DIMM socket that was originally made for DDR2 memory modules. You can make a custom SO-DIMM SITCore circuit board by adding the appropriate SO-DIMM socket to your circuit board. Tip Make sure to expose the required pins in your design. Specific pins are needed for device programming, updates, recovery, and WiFi firmware updates. See the Special Pins page and the device specifications for details. SO-DIMM stands for Small Outline Dual Inline Memory Module. There are two different 200 pin SO-DIMM sockets, those made for DDR memory and those made for DDR2 memory. They are identical except for the orientation notch which is in a slightly different position. These sockets are not interchangeable. There is also a 204 pin SO-DIMM socket for DDR3 memory with the notch positioned closer to the center of the module. Note Our UCMs are only compatible with DDR2 type 200 pin SO-DIMM sockets. Here is a link to the manufacturer's web page for the connector we use on our boards: EMBOSS ASSY DDR2 SODIMM SOCKET 200P 5.2H Required Pins Exposing the following pins is required in every design to enable device programming, updates, and recovery: RESET LDR APP MOD (if required to select a debug interface) Desired debug interface(s) For information on these and other important pins, please refer to the Special Pins page. Power Supply A clean power source, suitable for digital circuitry, is needed to power SITCore SoMs. Voltages should be regulated to within 10% or better of the specified voltage. Additionally, a large capacitor, typically 47 uF, should be placed near the SoM if the power supply is more than few inches away. Analog Considerations Where these pins are provided, using a separate filtered supply for Analog 3.3V and Analog VREF+ may help to improve ADC accuracy by reducing analog supply noise. For the same reason, you may want to provide a separate and clean analog ground for the Analog GND and Analog VREF- , if these pads are provided on the SoM you are using. Oven Reflow Profile SITCore SoMs are not sealed for moisture. Baking modules before reflow is recommended and required in a humid environment. The process of reflow can damage the SoM if the temperature is too high or exposure is too long. The lead-free reflow profiles used by GHI Electronics are shown below. The profiles are based on AIM SAC 305 solder (3% silver, 0.5% copper). The thermal mass of the assembled board and the sensitivity of the components on it affect the total dwell time. Differences in the two profiles are where they reach their respective peak temperatures as well as the time above liquids (TAL). The shorter profile applies to smaller assemblies, whereas the longer profile applies to larger assemblies such as back-planes or high-density boards. The process window is described by the shaded area. These profiles are only starting-points and general guidance. The particulars of the oven and the assembly will determine the final process. SITCore Dev Boards We offer SITCore development boards to get you started as quickly and easily as possible. These boards allow you to start programming in minutes, and are suitable for both prototypes and production. Click here for details."
  },
  "hardware/ucm/development-options.html": {
    "href": "hardware/ucm/development-options.html",
    "title": "UCM Development Options",
    "keywords": "UCM Development Options These options are provided to speed the development of your product and make it possible to start programming your application within minutes without designing or building new hardware. You may also use these products as quick drop-in options into your design as well. Code Samples For some examples of using the development options in TinyCLR, take a look at the TinyCLR Samples repo . You may also find the TinyCLR tutorials useful. UCM Dev Board Ordering Part Number: UCD-DEV-E Schematic The UCM Dev Board is the fastest and easiest way to start using our Universal Compute Modules. This board provides a socket for the UCM, standard connectors for input/output, and three 40 pin socket headers for connecting peripherals and a display. Peripheral connectors include external power, Ethernet, CAN, USB host and client, RTC backup battery, DCMI interface and an SD card slot. It also has a buzzer, LEDs, a reset button, and user programmable boot buttons. To start development using the UCM Dev Board, just plug a UCM into the socket on the board and connect the board's USB Client port to a host computer using a micro USB. Go to the documentation page for the particular UCM you are using for instructions. For power, the board can be powered through either USB connectors or the barrel jack. Always use the barrel jack for power when using displays, especially the larger ones. USB does not provide sufficient power needed for displays. Tip The barrel jack is pin positive, sleeve negative, 2.1mm. It is capable of anywhere 7V to 30V. 1A of power should be enough for most needs. UCM Breakout Board Ordering Part Number: UCD-BKT-C Schematic The UCM Breakout Board provides a socket for UCMs, and both through hole and surface mount edge connections for soldering the Breakout Board to your own circuit board. You can solder pin headers to the Breakout Board and use traditional breadboarding techniques to build your prototype as well. This board makes it easier to use UCMs in prototypes or products without the need to solder the fine pitch 200 pin SO-DIMM socket. For added convenience, it also includes USB Client connector, a reset button, four user programmable boot buttons, and a micro SD card slot. Please note that this is a Breakout Board and it does not have any power supplies. You will need to add 3.3V or 5V as needed to power up your modules. However, the power from USB is available on one of the pins (5V USB) so it is possible to wire a 3.3V regulator. Tip There are 2 LEDs by the USB connector, for 3.3V and 5V. They are useful to check that you have supplied the necessary power. A simple board can be designed and hand soldered to host the Breakout Board. You can turn an idea into a product prototype in days! This example board example (in green) is made to be the exact same size as the 4.3\" universal display board. It can be designed with the display connector conveniently located in the right place. To start using the breakout board, plug one of the UCMs into the socket on the board and wire in 3.3V (you may also need 5V) and plug in USB into your PC. Go to the documentation page for the particular UCM you are using for instructions. Universal Displays Available displays work directly with the options above, just make sure you are using a SoM supporting the needed peripherals. The Universal Displays can be connected directly or wired though a 40-pin IDE extension ribbon cable, similar to the old-style IDE hard drive cable extender, with a Male connector on one end and a Female connector on the other. To connect a display with the Dev Board, simply plug it on top. The display can be larger than the board but it will still use the same connector (HDR C). When using the Breakout Board you need to add a female header. Make sure the header is placed on the back of the Breakout Board. Note how the Breakout Board, and potentially your host board, hide behind the display. This is a good advantage when mounting the display inside a product. Adding a ribbon cable allows for further flexibility on where and how far the display is mounted. The length of the cable is determined by clock frequency used with the display. If the image on the display is not stable, lower the clock or shorten the cable. In our testing, our display have worked perfectly with 10\" cable. UCD-D43-A Ordering Part Number: UCD-D43-A Display Module: ER-TFT043-3 Touch Panel: ER-TPC043-2 Schematic This display module has a 4.3\" 480x272 TFT display with capacitive touch screen. The display needs a UCM with TFT display support and needs I2C for the capacitive touch. The backlight is controllable through GPIO A. The capacitive touch controller is connected I2C A with the interrupt pin on GPIO B. The TinyCLR Samples repo has usage examples. Learn more about the graphics support. See below for the display configuration values: Property Value Width 480 Height 272 DataFormat RGB565 Pixel Clock Rate 8 MHz <= x <= 16MHz Pixel Polarity low DataEnable Is Fixed false DataEnable Polarity low Horizontal Back Porch 46 Horizontal Front Porch 16 Horizontal Sync Polarity low Horizontal Sync Pulse Width 1 Vertical Back Porch 23 Vertical Front Porch 7 Vertical Sync Polarity low Vertical Sync Pulse Width 1 UCD-D70-A Ordering Part Number: UCD-D70-A Display Module: ER-TFT070-4 Touch Panel: ER-TPC070-6 Schematic This display module has a 7\" 800x480 TFT display with capacitive touch screen. The display needs a UCM with TFT display support and needs I2C for the capacitive touch. The backlight is controllable through GPIO A. The capacitive touch controller is connected I2C A with the interrupt pin on GPIO B. The display is exactly the same size as the Dev Board. They can be nicely mounted back to back with stand offs. A ribbon cable will be needed for the display signals. The TinyCLR Samples repo has usage examples. Learn more about the graphics support. See below for the display configuration values: Property Value Width 800 Height 480 DataFormat RGB565 Pixel Clock Rate 23 MHz <= x <= 46MHz Pixel Polarity low Data Enable Is Fixed false Data Enable Polarity low Horizontal Back Porch 46 Horizontal Front Porch 16 Horizontal Sync Polarity low Horizontal Sync Pulse Width 1 Vertical Back Porch 23 Vertical Front Porch 7 Vertical Sync Polarity low Vertical Sync Pulse Width 1 Custom Boards The \"Display Interface\" utilized on development options include TFT parallel 16bit/24bit bus, I2C bus, SPI, bus and 2 GPIOs. It is possible to design a custom display to utilize the UCM mainboards, or design a mainboard to utilize the available displays. Additionally, the designs of the development options can be used as a reference to start a UCMbased design. GHI Electronics' engineering/manufacturing is available for such designs. You can visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/ucm/intro.html": {
    "href": "hardware/ucm/intro.html",
    "title": "Universal Compute Modules",
    "keywords": "Universal Compute Modules Important Continuing with our longevity policy, these modules are available for purchase; however, due to discontinued components by STMicroelectronics, they are no longer recommended. Consider upgrading Universal Compute Modules are based on a 200 pin SO-DIMM form factor. All models follow a standard pin out making it easy to change modules to fit the needs of your product. A variety of tools and software options are available. Check the individual product documentation for details. The UCM Standard Description, peripherals and pinouts of the standard. Learn more... UC2550 ARM Cortex-M4 based UCM with optional Wi-Fi. Learn more... UC5500 ARM Cortex-M7 based UCM with optional Wi-Fi. Learn more... G400D Based on a 400 MHz Atmel ARM 926. Learn more... UCM Development Options Development boards, breakout boards, displays. Learn more... You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/ucm/standard.html": {
    "href": "hardware/ucm/standard.html",
    "title": "The UCM Standard",
    "keywords": "The UCM Standard The UCM Standard defines a consistent hardware and software interface for the most widely used microcontroller peripherals. Universal Compute Modules are based on the 200 pin SO-DIMM form factor. They adhere to a standard pinout across models making it easy to change modules to adapt to the needs of your product. When designing a product, consider following thee UCM standard pinout. This will make your design compatible with any of the UCM modules. Software also becomes more portable with the UCM standard. For example, our TinyCLR OS provides a library to automatically map the UCM standard names to the underlying system so that your program can use the UCM standard names only, making changing to a different module very easy. The SO-DIMM Socket All of our UCMs use the same 200 pin SO-DIMM socket that was originally made for DDR2 memory modules. The fastest way to get started with UCMs is by using the optional boards and displays described on the UCM Development Options page. You can also incorporate any of our UCMs into your own custom design by adding the appropriate SO-DIMM socket to your circuit board. Tip Make sure to expose the required pins in your design. Specific pins are needed for device programming, updates, recovery, and WiFi firmware updates. See device specifications for details. SO-DIMM stands for Small Outline Dual Inline Memory Module. There are two different 200 pin SO-DIMM sockets, those made for DDR memory and those made for DDR2 memory. They are identical except for the orientation notch which is in a slightly different position. These sockets are not interchangeable. There is also a 204 pin SO-DIMM socket for DDR3 memory with the notch positioned closer to the center of the module. Note Our UCMs are only compatible with DDR2 type 200 pin SO-DIMM sockets. Here is a link to the manufacturer's web page for the connector we use on our boards: EMBOSS ASSY DDR2 SODIMM SOCKET 200P 5.2H Peripherals Peripheral Up to Max UART (Universal Asynchronous Receiver/Transmitter) 4 UART HS (Handshaking) 2 I2C (Inter-Integrated Circuit) 2 SPI (Serial Peripheral Interface) 2 CAN (Controller Area Network) 2 SDIO (SD Card) 1 ADC (Analog to Digital Converter) 8 PWM (Pulse Width Modulation) 8 GPIO (General Purpose Input/Output) 12 IRQ (Interrupt Request Capable GPIO) 4 USB Client 1 USB Host 1 LCD (TFT Controller - 16bpp or 24bpp) 1 Ethernet PHY (Ethernet Physical Layer) 1 DCMI (Digital Camera Interface) 1 VBAT (Battery Backup for RTC) 1 JTAG (Debug Serial Port) 1 * Available peripherals vary by model Note that the system defines 12 GPIOs that are free from any other functions but most other peripheral pins also support GPIO, giving the user several more GPIO pin options -- keep in mind the standard does not guarantee this though. Tip The TinyCLR tutorials are a good resource on using these peripherals. UART (Universal Asynchronous Receiver Transmitter) UART is used to implement moderate speed full duplex asynchronous serial communication. It is usually used for peer to peer communication between only two devices. It can transfer data using only one wire for each direction if both devices share a common ground. UART HS (Handshaking) UART with handshaking is a configuration which allows the host and client to negotiate data transfer via Ready to Send (RTS) and Clear to Send (CTS) signals (two additional wires) to prevent missed data. I2C (Inter-Integrated Circuit) I2C is a multi-master, multi-slave, packet switched, half duplex serial communication bus typically used for attaching peripheral ICs to processors and microcontrollers in short-distance, intra-board communication. It uses two wires and has a slower maximum speed than SPI. SPI (Serial Peripheral Interface) SPI is a synchronous serial communication interface used for short distance communication. It uses a master-slave protocol. When using TinyCLR, the processor running TinyCLR is always configured as the master. SPI needs at least three wires and usually needs an additional line (chip select) for each slave. It can communicate much faster than either UART or I2C. CAN (Controller Area Network) A robust bus standard that originated in the automotive field and works very well in high noise environments. It allows microcontrollers and devices to communicate with each other in applications without a host computer. It is a message-based multi-master protocol and generally uses only two wires. Speed is up to one megabit per second but limited by bus length. SDIO (SD Card) SDIO (Secure Digital Input Output) is an interface used for reading from and writing to SD cards. ADC (Analog to Digital Converter) ADCs are used to measure an analog voltage level by converting it to a digital value. PWM (Pulse Width Modulation) PWM is a method of generating a square wave signal of uniform frequency with variable duty cycle. PWM is often used to generate analog voltages, but has many other uses such as generating digital pulses for driving servo motors or driving infrared LEDs for communication. GPIO (General Purpose Input/Output) GPIOs are the digital I/O pins that allow the user to interface with basic devices such as buttons (input) or LEDs (output). GPIOs are very versatile and can also be used to perform more advanced communication and control duties. IRQ (Interrupt Request Capable GPIO) IRQ capable GPIO pins can be programmed to interrupt a program when the input to the pin changes. For example, an IRQ could be used by a WiFi module to tell the processor that the WiFi module is receiving data. The processor would then stop what it is doing to get the data from the WiFi module. USB Client Used to communicate with a USB host. Often used to program and debug embedded devices. USB Host Used to communicate with one or more USB clients. Typically used to communicate with various devices such as a mouse, keyboard, camera, etc. LCD (TFT Controller - 16bpp or 24bpp) An interface providing communication with a TFT LCD (thin-film-transistor liquid-crystal display). The number of data lines connected determines the number of bits per pixel (bpp), which determines the number of colors that can be displayed. Ethernet PHY Ethernet PHY is the Ethernet physical (hardware) layer. It provides the Tx and Rx signals for the Ethernet connector. DCMI (Digital Camera Interface) A standard interface for compatible digital cameras. VBAT (Battery Backup for RTC) VBAT is used to provide battery voltage to a microcontroller's real time clock. It allows the microcontroller to keep the correct time when the main power to the controller is disconnected (the device is turned off). JTAG JTAG is a serial interface which allows communication between the processor and a host computer. It is built into the microcontroller and provides a means of software debugging including the ability to stop program execution, single step through program instructions, and read and write to memory and processor registers. Pin Assignments SO-DIMM Pin Universal Compute Standard 1 AGND 2 Ethernet TX- 3 Module Specific 1 4 Ethernet TX+ 5 Analog VREF- 6 Ethernet RX- 7 Reserved 8 Ethernet RX+ 9 Reserved 10 Indicator A 11 Indicator B 12 Reserved 13 GND 14 DCMI D0 15 DCMI D1 16 DCMI D2 17 DCMI D3 18 DCMI D4 19 DCMI D5 20 Analog 3.3V 21 DCMI D6 22 DCMI D7 23 DCMI VSYNC 24 DCMI HSYNC 25 DCMI PIXCLK 26 DCMI XCLK 27 GND 28 PWM E 29 PWM F 30 PWM G 31 PWM H 32 Analog VREF+ 33 Reserved 34 5V 35 Module Specific 4 36 Module Specific 5 37 Module Specific 6 38 Module Specific 7 39 Module Specific 8 40 GND 41 GND 42 LCD 24bpp R0 43 LCD 24bpp R1 44 LCD 24bpp R2 45 LCD 24bpp G0 46 3.3V 47 LCD 24bpp G1 48 LCD 24bpp B0 49 LCD 24bpp B1 50 LCD 24bpp B2 51 GND 52 Module Specific 9 53 Reserved 54 Reserved 55 Reserved 56 5V 57 IRQ A 58 IRQ B 59 IRQ C 60 3.3V 61 IRQ D 62 GPIO A 63 GPIO B 64 GPIO C 65 GND 66 GPIO D 67 GPIO E 68 GPIO F 69 GPIO G 70 5V 71 Reserved 72 3.3V 73 I2C B SDA 74 I2C B SCL 75 UART C TX 76 UART C RX 77 UART D TX 78 UART D RX 79 GND 80 Reserved 81 Reserved 82 Reserved 83 Reserved 84 Reserved 85 Reserved 86 5V 87 USB Device ID 88 3.3V 89 UART B TX 90 UART B RX 91 ADC A 92 GPIO H 93 SPI B MISO 94 SPI B MOSI 95 GND 96 SPI B SCK 97 ADC B 98 CAN A TD 99 CAN A RD 100 CAN B TD 101 CAN B RD 102 UART HS A TX 103 UART HS A RX 104 ADC C 105 PWM A 106 3.3V 107 SYS A 108 Module Specific 2 109 Module Specific 3 110 ADC D 111 SYS C 112 PWM B 113 GND 114 ADC E 115 I2C A SDA 116 I2C A SCL 117 UART A RX 118 UART A TX 119 GPIO I 120 UART HS A RTS 121 UART HS A CTS 122 GPIO J 123 SD Card D0 124 3.3V 125 SD Card CMD 126 SD Card CLK 127 SD Card D1 128 SD Card D2 129 SD Card D3 130 PWM C 131 GND 132 GPIO K 133 PWM D 134 SYS B 135 SYS D 136 GPIO L 137 Module Specific 10 138 UART HS B RTS 139 UART HS B CTS 140 UART HS B TX 141 UART HS B RX 142 3.3V 143 LCD VSYNC 144 LCD HSYNC 145 LCD CLK 146 LCD DE 147 Module Specific 11 148 SD Card CD 149 Module Specific 12 150 Reserved 151 GND 152 LCD B3 153 LCD B4 154 LCD B5 155 LCD B6 156 LCD B7 157 ADC F 158 ADC G 159 ADC H 160 3.3V 161 LCD G2 162 LCD G3 163 LCD G4 164 LCD G5 165 LCD G6 166 Module Specific 13 167 Indicator C 168 LCD R7 169 GND 170 LCD G7 171 LCD R3 172 LCD R4 173 LCD R5 174 LCD R6 175 SPI A SCK 176 SPI A MISO 177 Module Specific 14 178 SPI A MOSI 179 Module Specific 15 180 3.3V 181 Module Specific 16 182 Module Specific 17 183 VBAT 184 Module Specific 18 185 GND 186 GND 187 RESET 188 USB Host D+ 189 JTAG RTCK 190 USB Host D- 191 JTAG TDO 192 3.3V 193 JTAG NTRST 194 USB Device D+ 195 JTAG TDI 196 USB Device D- 197 JTAG TCK (SWCLK) 198 GND 199 JTAG TMS (SWDIO) 200 Indicator D Want to quickly build your prototype? Check out the UCM Development Options . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/ucm/uc2550.html": {
    "href": "hardware/ucm/uc2550.html",
    "title": "UC2550",
    "keywords": "UC2550 Overview The efficiency of our UC2550 makes it ideal for low power applications. It is also our lowest cost UCM and offers a large complement of peripherals. Ordering Part Number Model Number WiFi External QSPI Flash UC2550-13NNN no optional UC2550-13NNW yes optional Specifications Specs Value Processor STM STM32F413 32-bit ARM Cortex-M4 Speed 100 MHz Internal RAM 320 KByte (SRAM) Internal Flash 1 MByte External RAM 0 KByte External Flash Up to 4 MByte (QSPI) Dimensions 67.7 x 31.7 x 3.2 mm Note: Not all memory will be available for your application. Peripherals This table lists the available peripherals. The \"overall\" column shows the available pins if the design did not follow the UCM standard. Peripheral UCM Standard Overall UART 4 9 (including HS) UART HS 2 2 I2C 2 2 SPI 2 3 CAN 2 2 SDIO 1 1 ADC 8 15 PWM 8 27 GPIO 10 67 IRQ 4 67 USB Client Supported Supported USB Host Not supported Not supported LCD Not supported Not supported Ethernet PHY Not supported Not supported WiFi Supported Supported Camera Not supported Not supported VBAT Supported Supported JTAG SWD SWD Development Options The UCM development options can greatly simplify the process of building a product or prototype using the UC2550. Options include a development board and displays which can get you programming in minutes. Tip We are assuming you are using the UCM Development Board for all instructions provided. .NET Micro Framework NETMF provides a way to program the G30 in C# or Visual Basic from the Microsoft Visual Studio integrated development environment. To get started you must first install the NETMFfirmware (instructions below) and then go to the NETMF Getting Started page for instructions. Loading Bootloader v2 Download the UC2550 bootloader here . Connect your device to the USB client port. Put the board in DFU mode: Hold the SYS A pin low and press/release the reset button. Wait for a second then release SYS A. Windows Device Manager will now show \"STM Device in DFU Mode\" under the 'Universal Serial Bus controller' TAB. This is a DFU file, upload it like you would any other DFU file. See STMicroelectronics documentation for details. Loading the Firmware Activate the bootloader, hold the LDR0 signal low while resetting the board. Open FEZ Config tool and follow the instructions. Start Coding Now that you have installed the bootloader and firmware on the UC2550, you can setup your host computer and start programming. Go to the NETMF Getting Started page for instructions. Schematic The schematic for the UC2550 can be found here . Customization We also offer customized, non-stock versions of our SoMs. Many options are available, such as various sizes of external QSPI flash. Please contact us for details. We will always do our best to provide you with a module to fit your exact needs. Pin Assignments SO-DIMM Pin Universal Compute Standard Function Name 1 AGND AGND 2 Ethernet TX- 3 Module Specific 1 (WiFi PIN14) WiFi Power LED 4 Ethernet TX+ 5 Analog VREF- Analog VREF- 6 Ethernet RX- 7 Reserved 8 Ethernet RX+ 9 Reserved 10 Indicator A (WiFi PIN15) WiFi Link Up LED 11 Indicator B (WiFi PIN5) WiFi Running (Blink) LED 12 Reserved 13 GND GND 14 DCMI D0 15 DCMI D1 16 DCMI D2 17 DCMI D3 18 DCMI D4 19 DCMI D5 20 Analog 3.3V Analog 3.3V 21 DCMI D6 22 DCMI D7 23 DCMI VSYNC 24 DCMI HSYNC 25 DCMI PIXCLK 26 DCMI XCLK 27 GND GND 28 PWM E PE5, TIM9 CH1 29 PWM F PE6, TIM9 CH2 30 PWM G PB14, TIM12 CH1 31 PWM H PB15, TIM12 CH2 32 Analog VREF+ Analog VREF+ 33 Reserved 34 5V 35 Module Specific 4 (WiFi PIN13) 36 Module Specific 5 (WiFi PIN16) 37 Module Specific 6 (WiFi PIN22) 38 Module Specific 7 39 Module Specific 8 40 GND GND 41 GND GND 42 LCD 24bpp R0 43 LCD 24bpp R1 44 LCD 24bpp R2 45 LCD 24bpp G0 46 3.3V 3.3V 47 LCD 24bpp G1 48 LCD 24bpp B0 49 LCD 24bpp B1 50 LCD 24bpp B2 51 GND GND 52 Module Specific 9 53 I2S SCK 54 I2S WD 55 I2S WS 56 5V 57 IRQ A PC0, ADC10 58 IRQ B PC1, ADC11 59 IRQ C PC2, ADC12 60 3.3V 3.3V 61 IRQ D PC3, ADC13 62 GPIO A PC4, ADC14 63 GPIO B PC5, ADC15 64 GPIO C PA15, TIM2 CH1 65 GND GND 66 GPIO D PB0, ADC8, TIM3 CH3 67 GPIO E PB7, TIM4 CH2 68 GPIO F PD7 69 GPIO G PD10 70 5V 71 Reserved 72 3.3V 3.3V 73 I2C B SDA PB8, I2C3 SDA, TIM10 CH1 74 I2C B SCL PA8, I2C3 SCL, MCO1 75 UART C TX PE1, UART8 TX 76 UART C RX PE0, UART8 RX 77 UART D TX PD15, USART9 TX, TIM4 CH4 78 UART D RX PD14, USART9 RX, TIM4 CH3 79 GND GND 80 Reserved 81 Reserved 82 Reserved 83 Reserved 84 Reserved 85 Reserved 86 5V 87 USB Device ID 88 3.3V 3.3V 89 UART B TX PE8, USART7 TX 90 UART B RX PE7, USART7 RX 91 ADC A PA0, ADC0, TIM5 CH1 92 GPIO H PE10 93 SPI B MISO (WiFi PIN6) PE13, SPI5 MISO, TIM1 CH3 94 SPI B MOSI (WiFi PIN8) PE14, SPI5 MOSI, TIM1 CH4 95 GND GND 96 SPI B SCK (WiFi PIN10) PE12, SPI5 SCK 97 ADC B PA1, ADC1, TIM5 CH2 98 CAN A TD PD1, CAN1 TX, UART4 TX 99 CAN A RD PD0, CAN1 RX, UART4 RX 100 CAN B TD PB13, CAN2 TX, UART5 TX 101 CAN B RD PB12, CAN2 RX, UART5 RX 102 UART HS A TX PD5, USART2 TX 103 UART HS A RX PD6, USART2 RX 104 ADC C PA2, ADC2, TIM5 CH3 105 PWM A PE9, TIM1 CH1 106 3.3V 3.3V 107 SYS A BOOT0 108 Module Specific 2 (WiFi PIN2) 109 Module Specific 3 (WiFi PIN4) 110 ADC D PA3, ADC3, TIM5 CH4 111 SYS C PE3, LDR1 112 PWM B PE11, TIM1 CH2 113 GND GND 114 ADC E PA4, ADC4, DAC1 115 I2C A SDA PB9, I2C2 SDA, TIM10 CH1 116 I2C A SCL PB10, I2C2 SCL, TIM2 CH3 117 UART A RX PA10, USART1 RX 118 UART A TX PA9, USART1 TX 119 GPIO I PD14, UART9 RX, TIM4 CH3 120 UART HS A RTS PD4, USART2 RTS 121 UART HS A CTS PD3, USART2 CTS 122 GPIO J PD15, UART9 RX, TIM4 CH4 123 SD Card D0 PC8, SD D0, TIM8 CH3 124 3.3V 3.3V 125 SD Card CMD PD2, SD CMD 126 SD Card CLK PC12, SD CLK, SPI3 MOSI 127 SD Card D1 PC9, SD D1, TIM8 CH4 128 SD Card D2 PC10, SD D2, SPI3 SCK 129 SD Card D3 PC11, SD D3, SPI3 MISO 130 PWM C PC6, TIM3 CH1, USART6 TX 131 GND GND 132 GPIO K 133 PWM D PC7, TIM3 CH2, USART6 RX 134 SYS B PB2, LDR0 135 SYS D PE4, MODE 136 GPIO L 137 Module Specific 10 138 UART HS B RTS PD12, USART3 RTS 139 UART HS B CTS PD11, USART3 CTS 140 UART HS B TX PD8, USART3 TX 141 UART HS B RX PD9, USART3 RX 142 3.3V 3.3V 143 LCD VSYNC 144 LCD HSYNC 145 LCD CLK 146 LCD DE 147 Module Specific 11 148 SD Card CD PC13 149 Module Specific 12 150 Reserved 151 GND GND 152 LCD B3 153 LCD B4 154 LCD B5 155 LCD B6 156 LCD B7 157 ADC F PA5, ADC5, DAC2 158 ADC G PA6, ADC6 159 ADC H PA7, ADC7 160 3.3V 3.3V 161 LCD G2 162 LCD G3 163 LCD G4 164 LCD G5 165 LCD G6 166 Module Specific 13 167 Indicator C 168 LCD R7 169 GND GND 170 LCD G7 171 LCD R3 172 LCD R4 173 LCD R5 174 LCD R6 175 SPI A SCK PB3, SPI1 SCK, TIM2 CH2 176 SPI A MISO PB4, SPI1 MISO 177 Module Specific 14 178 SPI A MOSI PB5, SPI1 MOSI 179 Module Specific 15 180 3.3V 3.3V 181 Module Specific 16 182 Module Specific 17 183 VBAT VBAT 184 Module Specific 18 185 GND GND 186 GND GND 187 RESET RESET 188 USB Host D+ 189 JTAG RTCK 190 USB Host D- 191 JTAG TDO 192 3.3V 3.3V 193 JTAG NTRST 194 USB Device D+ PA12, USB D+ 195 JTAG TDI 196 USB Device D- PA11, USB D- 197 JTAG TCK (SWCLK) PA14, JTCK, SWCLK 198 GND GND 199 JTAG TMS (SWDIO) PA13, JTMS, SWDIO 200 Indicator D CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a UC2550 driving the SN65HVD230 CAN driver chip. See the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 33.333K 1 13 2 90 1 False 87.5% 0.31% 2195M 83.333K 1 13 2 36 1 False 87.5% 0.31% 845M 125K 1 13 2 24 1 False 87.5% 0.31% 545M 250K 1 13 2 12 1 False 87.5% 0.31% 245M 500K 1 13 2 6 1 False 87.5% 0.31% 95M 1M 1 13 2 3 1 False 87.5% 0.31% 20M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested to ensure reliability. Want to quickly build your prototype? Check out the UCM Development Options . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "hardware/ucm/uc5550.html": {
    "href": "hardware/ucm/uc5550.html",
    "title": "UC5550",
    "keywords": "UC5550 Overview The UC5550 System on Module has the processor and memory needed to run the most intense embedded applications, thanks to its 216 MHz Cortex-M7 and 32 MByte of RAM. Its built in native parallel TFT display makes it an ideal option for applications that require professional display support. Ordering Part Number Model Number WiFi Ethernet PHY External SDRAM External QSPI Flash UC5550-67HFN no no 32 MByte 4 MByte UC5550-67HFW yes no 32 MByte 4 MByte UC5550-67HFE no yes 32 MByte 4 MByte Specifications Spec UC5550 Processor ST STM32F767 32-bit ARM Cortex-M7 Speed 216 MHz Internal RAM 512 KByte (SRAM) Internal Flash 2 MByte External RAM 32 MByte (SDRAM) External Flash 4 MByte (QSPI) Dimensions 67.7 x 31.7 x 4.5 mm Note: Resources are shared between your application and the operating system. Peripherals This table lists the available peripherals. The \"overall\" column shows the available pins if the design did not follow the UCM standard. Peripheral UCM Standard Overall UART 4 5 (including HS) UART HS 1 2 I2C 1 2 SPI 2 3 CAN 2 2 SDIO 1 1 ADC 8 9 PWM 8 20 GPIO 12 103 IRQ 4 103 USB Client Supported Supported USB Host Supported Supported LCD Supported (16bpp & 24bpp) Supported (16bpp & 24bpp) Ethernet PHY Supported Supported WiFi Supported Supported Camera Supported Supported VBAT Supported Supported JTAG SWD SWD Tip The NETMF tutorials is a good resource on using these peripherals. Development Options The UCM development options can greatly simplify the process of building a product or prototype using the UC5550. Options include a development board and displays which can get you programming in minutes. Tip We are assuming you are using the UCM Development Board for all instructions provided. Loading Bootloader v2 Download the UC5550 bootloader here . Connect your device to the USB client port. Put the board in DFU mode: Hold the SYS A pin low and press/release the reset button. Wait for a second then release SYS A. Windows Device Manager will now show \"STM Device in DFU Mode\" under the 'Universal Serial Bus controller' TAB. This is a DFU file, upload it like you would any other DFU file. See STMicroelectronics documentation for details. Loading the Firmware Activate the bootloader, hold the LDR0 signal low while resetting the board. Open FEZ Config tool and follow the instructions. Start Coding Now that you have installed the bootloader and firmware on the UC5550, you can setup your host computer and start programming. Go to the NETMF Getting Started page for instructions. Schematic The schematic for the UC5550 can be found here . Customization We also offer customized, non-stock versions of our SoMs. Many options are available, such as various sizes of external QSPI flash. Please contact us for details. We will always do our best to provide you with a module to fit your exact needs. Pin Assignments SO-DIMM Pin Universal Compute Standard Function Name 1 AGND AGND 2 Ethernet TX- ETH PHY TX- 3 Module Specific 1 (WiFi PIN14) WiFi Power LED 4 Ethernet TX+ ETH PHY TX+ 5 Analog VREF- Analog VREF- 6 Ethernet RX- ETH PHY RX- 7 Reserved 8 Ethernet RX+ ETH PHY RX+ 9 Reserved PH7, DCMI GP 10 Indicator A ETH PHY LED SPEED 11 Indicator B ETH PHY LED LINK 12 Reserved 13 GND GND 14 DCMI D0 PH9, DCMI D0 15 DCMI D1 PH10, DCMI D1 16 DCMI D2 PG10, DCMI D2 17 DCMI D3 PH12, DCMI D3 18 DCMI D4 PE4, DCMI D4 19 DCMI D5 PI4, DCMI D5 20 Analog 3.3V Analog 3.3V 21 DCMI D6 PE5, DCMI D6 22 DCMI D7 PE6, DCMI D7 23 DCMI VSYNC PG9, DCMI VSYNC 24 DCMI HSYNC PH8, DCMI HSYNC 25 DCMI PIXCLK PA6, DCMI PIXCLK 26 DCMI XCLK PA8, DCMI XCLK, MCO1 27 GND GND 28 PWM E PI6, TIM8 CH2 29 PWM F PI7, TIM8 CH3 30 PWM G PI2, TIM8 CH4 31 PWM H PA3, TIM9 CH2, ADC3 32 Analog VREF+ Analog VREF+ 33 Reserved 34 5V 35 Module Specific 4 (WiFi PIN13) 36 Module Specific 5 (WiFi PIN16) 37 Module Specific 6 (WiFi PIN22) 38 Module Specific 7 39 Module Specific 8 40 GND GND 41 GND GND 42 LCD 24bpp R0 PI15, LCD R0 43 LCD 24bpp R1 PJ0, LCD R1 44 LCD 24bpp R2 PJ1, LCD R2 45 LCD 24bpp G0 PJ7, LCD G0 46 3.3V 3.3V 47 LCD 24bpp G1 PJ8, LCD G1 48 LCD 24bpp B0 PJ12, LCD B0 49 LCD 24bpp B1 PJ13, LCD B1 50 LCD 24bpp B2 PJ14, LCD B2 51 GND GND 52 Module Specific 9 53 Reserved 54 Reserved 55 Reserved 56 5V 57 IRQ A PI8 58 IRQ B PI11 59 IRQ C PH14 60 3.3V 3.3V 61 IRQ D PH15 62 GPIO A PD7 63 GPIO B PE3 64 GPIO C PG3 65 GND GND 66 GPIO D PG6 67 GPIO E PG7 68 GPIO F PH4 69 GPIO G PI0 70 5V 71 Reserved 72 3.3V 3.3V 73 I2C B SDA 74 I2C B SCL 75 UART C TX PF7, UART7 TX 76 UART C RX PF6, UART7 RX 77 UART D TX (WiFi PIN9) PB10, USART3 TX, TIM2 CH3, I2C2 SCL 78 UART D RX (WiFi PIN7) PB11, USART3 RX, TIM2 CH4, I2C2 SDA 79 GND GND 80 Reserved 81 Reserved 82 Reserved 83 Reserved 84 Reserved 85 Reserved 86 5V 87 USB Device ID 88 3.3V 3.3V 89 UART B TX PC6, USART6 TX, TIM3 CH1 90 UART B RX PC7, USART6 RX, TIM3 CH2 91 ADC A PA0, ADC0, TIM5 CH1 92 GPIO H PA1, ETH RMII REF CLK 93 SPI B MISO (WiFi PIN6) PF8, SPI5 MISO, TIM13 CH1, UART7 RTS 94 SPI B MOSI (WiFi PIN8) PF9, SPI5 MOSI, TIM14 CH1, UART7 CTS 95 GND GND 96 SPI B SCK (WiFi PIN10) PH6, SPI5 SCK, TIM12 CH1 97 ADC B PA4, ADC4, DAC1 98 CAN A TD PH13, CAN1 TX 99 CAN A RD PI9, CAN1 RX 100 CAN B TD PB13, CAN2 TX 101 CAN B RD PB12, CAN2 RX 102 UART HS A TX PD5, USART2 TX 103 UART HS A RX PD6, USART2 RX 104 ADC C PA5, ADC5, DAC2 105 PWM A PA15, TIM2 CH1 106 3.3V 3.3V 107 SYS A BOOT0 108 Module Specific 2 (WiFi PIN2) 109 Module Specific 3 (WiFi PIN4) 110 ADC D PB0, ADC8, TIM3 CH3 111 SYS C PI1, LDR1 112 PWM B PB7, TIM4 CH2 113 GND GND 114 ADC E PB1, ADC9, TIM3 CH4 115 I2C A SDA PB9, I2C1 SDA, TIM4 CH4 116 I2C A SCL PB8, I2C1 SCL, TIM4 CH3 117 UART A RX PA10, USART1 RX 118 UART A TX PA9, USART1 TX 119 GPIO I PA2, ETH MDIO 120 UART HS A RTS PD4, USART2 RTS 121 UART HS A CTS PD3, USART2 CTS 122 GPIO J PA7, ETH RMII CRS DV 123 SD Card D0 PC8, SD D0 124 3.3V 3.3V 125 SD Card CMD PD2, SD CMD 126 SD Card CLK PC12, SD CLK, SPI3 MOSI 127 SD Card D1 PC9, SD D1 128 SD Card D2 PC10, SD D2, SPI3 SCK 129 SD Card D3 PC11, SD D3, SPI3 MISO 130 PWM C PH11, TIM5 CH2 131 GND GND 132 GPIO K PC4, ETH RMII RXD0 133 PWM D PI5, TIM8 CH1 134 SYS B PB2, LDR0 135 SYS D PI3, MODE 136 GPIO L PC5, ETH RMII RXD1 137 Module Specific 10 (ETH PHY OSCILLATOR PIN1) OE OFF# 138 UART HS B RTS 139 UART HS B CTS 140 UART HS B TX 141 UART HS B RX 142 3.3V 3.3V 143 LCD VSYNC PI13, LCD VSYNC 144 LCD HSYNC PI12, LCD HSYNC 145 LCD CLK PI14, LCD CLK 146 LCD DE PK7, LCD DE 147 Module Specific 11 148 SD Card CD PC13 149 Module Specific 12 150 Reserved 151 GND GND 152 LCD B3 PJ15, LCD B3 153 LCD B4 PK3, LCD B4 154 LCD B5 PK4, LCD B5 155 LCD B6 PK5, LCD B6 156 LCD B7 PK6, LCD B7 157 ADC F PC0, ADC10 158 ADC G PC2, ADC12 159 ADC H PC3, ADC13 160 3.3V 3.3V 161 LCD G2 PJ9, LCD G2 162 LCD G3 PJ10, LCD G3 163 LCD G4 PJ11, LCD G4 164 LCD G5 PK0, LCD G5 165 LCD G6 PK1, LCD G6 166 Module Specific 13 167 Indicator C (WiFi PIN15) WiFi Link Up LED 168 LCD R7 PJ6, LCD R7 169 GND GND 170 LCD G7 PK2, LCD G7 171 LCD R3 PJ2, LCD R3 172 LCD R4 PJ3, LCD R4 173 LCD R5 PJ4, LCD R5 174 LCD R6 PJ5, LCD R6 175 SPI A SCK PB3, SPI1 SCK 176 SPI A MISO PB4, SPI1 MISO 177 Module Specific 14 178 SPI A MOSI PB5, SPI1 MOSI 179 Module Specific 15 180 3.3V 3.3V 181 Module Specific 16 182 Module Specific 17 183 VBAT VBAT 184 Module Specific 18 185 GND GND 186 GND GND 187 RESET RESET 188 USB Host D+ PB15, USBH D+ 189 JTAG RTCK 190 USB Host D- PB14, USBH D- 191 JTAG TDO 192 3.3V 3.3V 193 JTAG NTRST 194 USB Device D+ PA12, USB D+ 195 JTAG TDI 196 USB Device D- PA11, USB D- 197 JTAG TCK (SWCLK) PA14, JTCK, SWCLK 198 GND GND 199 JTAG TMS (SWDIO) PA13, JTMS, SWDIO 200 Indicator D (WiFi PIN5) WiFi Running (Blink) LED CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a UC5550 driving the SN65HVD230 CAN transceiver chip. See the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 33.333K 1 12 2 108 1 False 86.7% 0.33% 2145M 83.333K 1 15 2 36 1 False 88.9% 0.28% 879M 125K 1 13 2 27 1 False 87.5% 0.31% 545M 250K 1 15 2 12 1 False 88.9% 0.28% 257M 500K 1 15 2 6 1 False 88.9% 0.28% 101M 1M 1 15 2 3 1 False 88.9% 0.28% 23M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested to ensure reliability. Want to quickly build your prototype? Check out the UCM Development Options . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "index.html": {
    "href": "index.html",
    "title": "GHI Electronics Documentation",
    "keywords": "GHI Electronics Documentation Here you will find GHI Electronics product documentation. For more information visit the main website at www.ghielectronics.com . You can also visit our community forums at forums.ghielectronics.com . Hardware SITCore Chips, Modules, and Dev Boards are optimized for the development and production of highly secure IoT devices. Learn More... TinyCLR OS TinyCLR lets you run .NET securely on embedded devices, develop software in Microsoft Visual Studio, and debug over USB. Learn More... NETMF Now mature, Microsoft's .NET Micro Framework is the predecessor of TinyCLR OS. NETMF is not recommended for new designs. Learn More..."
  },
  "README.html": {
    "href": "README.html",
    "title": "Documentation",
    "keywords": "Documentation This is the repository for all of our docs. To generate the docs locally: Clone/Fork the repo Open the command prompt in the documents' root folder (\"Run as Administrator\" may be necessary) Execute docfx --serve After executing the above command, a temporary webpage will appear to allow you to view the files in your browser fully rendered in HTML, for example http://localhost:8080 . To install DocFX, please review and download from the following site: https://dotnet.github.io/docfx/ . From there, you can go to the Getting Started page for instructions on how to install and you can go to Download Latest to download the most up to date DocFX files. Please note, you will not need to use the docfx init command as the initial JSON file is already present in our repository. WK<html>TOpdf is required as part of the build process. You will find the needed files at the following address: https://wkhtmltopdf.org/downloads.html . Once downloaded, execute the command to install. Once installed, add the path to the installed binary to the environment variable PATH, for example \"C:\\Program Files\\wkhtmltopdf\\bin\"."
  },
  "software/netmf/bootloader.html": {
    "href": "software/netmf/bootloader.html",
    "title": "Bootloader",
    "keywords": "Bootloader The GHI Electronics Bootloader is used to update the firmware on our devices. It is the first program to run and unless the device specific LDR pins are set (see device documentation for details), it will execute the firmware on the device (if present). The bootloader communicates over a USB virtual serial port and a regular serial port. The interface used is controlled by a MODE pin. See your device specifications for details on interface configuration and selection and which version of the bootloader it runs. Tip If you are running Windows 7 or Windows 8, you must install drivers for the bootloader to appear in Windows. See \"USB Drivers\" in the downloads section below. Bootloader v1 The original loader runs on Embedded Master, EMX, G120, G120E, G400D, G400S and USBizi. All results are terminated with LF (\\n). Commands are executed as soon as they entered without waiting for a new-line. \"BL\" or \"Done.\" will be sent after each command. On startup, a banner is sent that is terminated by \"BL\". Once the banner is received, you are free to enter any of the case-sensitive single-character commands described below. V: returns the current version. E: erases all user sectors of the device (* is sent while erasing). R: runs the firmware if present. B: increases the baud rate in serial mode to 921,600. X: upload a file to the device using 1K XMODEM. Only send *.ghi files meant for your device. The firmware is automatically run after a successful upload. Tip The USB interface on Version 1.0 doesn't work on Windows 7 and newer operating systems. Use the serial interface instead. Bootloader v2 This loader runs on G30, G80, UC25, UC55 and FEZ T18. All commands and results are terminated with CR and LF (\\r\\n). \"OK.\" will be sent after each successful command. On startup, a banner is sent that is terminated by \"OK.\". Once the banner is received, you are free to enter any of the case-insensitive single-character commands described below. Most commands require confirmation. Send Y or y followed by a new-line to proceed or anything else to cancel. V: returns the current version. N: returns the current device type. E: erases all user sectors of the device. R: runs the firmware if present. B: increases the baud rate in serial mode to 921,600. X: upload a ghi file to the device using 1K XMODEM. Only send *.ghi files meant for your device. U: upload a glb file to the device using 1K XMODEM. Only send *.glb files meant for your device. Manually Loading the Firmware TinyCLR Config tool should be used to update the firmware. As a backup, use these instructions: Put your board in bootloader mode. Each product has a specific way to enter the boot loader. Open any terminal software, for example Tera Term . Select serial and pick the COM port associated with your board. (If unsure, check Device Manager) Press V and then enter. You will see back the boot loader version number (v2.x.x) Press U or X and then enter. Use X for firmware file type GHI and U for firmware file type GLB. Press Y to confirm then enter. You will now see CCCC ... Go to File -> Transfer -> XMODEM -> Send . IMPORTANT: Make sure you check the 1K option. Select the firmware file. When the transfer is complete, reset your board. GLB File Format The glb files that are loaded onto devices have some additional metadata that help the bootloader function in addition to the raw data itself. The first 1,024 bytes of a glb file is the upload header. Starting from offset 0 are the below fields. The rest of the header is currently reserved. 32 bit signature number that is unique for each device. 32 bit unsigned address in flash that this image should be copied to. 32 bit unsigned length of the image to flash rounded to the nearest 1,024 bytes. 16 bit CRC-CCITT of the image. After the upload header is the actual image to flash. If its length is not divisible by 1,024 bytes, it is padded until it is. For images that are meant to be bootable, the address in the upload header should be set to the entry point defined for the specific device. Bootable images have an additional 1,024 byte header at the beginning of the image that is used to verify the image before booting it. The boot image is also padded to the nearest 1,024 bytes. Starting from offset 0 are the below fields. The rest of the header is currently reserved. 32 bit signature number that is unique for each device. 32 bit unsigned address in flash that is the entry point the bootloader will invoke. 32 bit unsigned length of the boot image rounded to the nearest 1,024 bytes. 16 bit CRC-CCITT of the boot image bounded by the specified address and length. Upgrading GHI Electronics Bootloader v1 to v2 Warning No longer supported! Some of our devices ship with v1 loader but require v2 loader to work with TinyCLR OS, such as G120. Download the bootloader file from the list below. Put your device in v1 mode (instructions are found on each product's documentation page). The PC will now detect a virtual serial (COM) device. If you need drivers, they are in the NETMF SDK. Open any terminal software, we recommend Tera Term . Select serial and pick the COM port associated with your board. Enter E and you will see back \"Erase all memory! Are you sure?\" now enter Y . (The bootloader is case sensitive) Enter X and you will see CCCC ... showing on the terminal. Now go to File -> Transfer -> XMODEM -> Send . IMPORTANT: Make sure you check the 1K option. Select the bootloader file you have downloaded above. You will see File Transfer Finished Successfully . Change the configuration switches back to the off position and reset the board. You are now running GHI Electronics bootloader v2! Bootloader Downloads Most products already ship with bootloader already installed. But in case the loader needs to be reloaded, the individual product pages include instructions on how to load the bootloader. Here you can find the various bootloaders available for the various products. FEZCLR (used on FEZ and BrainPad Classic) File Date MD5 v2.0.4 2017-08-31 33F7FCAE266D07209C079CEA38AAB583 v2.0.3 2017-07-07 056919694D6A5F06546F9B721AE141CE UC2550 File Date MD5 v2.0.4 2018-04-05 692FA78A161BAA2AEF17E9F85A6AF141 UC5550 File Date MD5 v2.0.5 2018-09-28 9F4DB868E5501773CC52048D8085B8D6 v2.0.4 2018-04-05 594744A52EC07CEFE6212669D33A5FE1 G120 and G120E File Date MD5 v2.0.4 2017-08-31 7052D6FFB1890987DDCC4043895788D3 v2.0.2 2017-03-07 00ECD55A24607336863B1D61B91C3D86 G400S and G400D File Date MD5 v2.0.4 2017-09-13 BD46D86D41DCD42C4FC50D27AF02E5EE v2.0.2 2017-04-06 81D45A8F078AA8E633C824C7BB3279DC v2.0.1 2016-06-27 42CD50E4105939611ABF360475EBF4E5 USBizi File Date MD5 v1.0.7 144 2015-05-05 853557479D8797EAB650B98E3D333DCF v1.0.7 100 2015-05-05 34D17AA5CA4E13D5447C80AB8094D064 USB Drivers Only needed for Windows 7 and 8 since they do not automatically load drivers for the bootloader interface. File Date MD5 v1.0.0 x64 2018-12-27 74D66FC4236126A83CCCFE28D556F339 v1.0.0 x86 2018-12-27 8BDE68132452E22B14597C0972ABA8FD v0.6.0 x64 2017-08-31 AEDD7C00854BBF99AC3FDAB4976E1F33 v0.6.0 x86 2017-08-31 A0F487D32B882199F0A69E6CAA8DE4CB"
  },
  "software/netmf/downloads.html": {
    "href": "software/netmf/downloads.html",
    "title": "NETMF Downloads",
    "keywords": "NETMF Downloads General Resources .NET Micro Framework for Beginners (ebook PDF) Gadgeteer mainboards and moudle driver Source code NETMF Open Source Ports Microsoft Visual Studio The lastest version of Visual Studio that works with NETMF is VS2013. The Community Version can be downloaded from the following link: Microsoft Visual Studio 2013 Community Edition Microsoft .NET Gadgeteer Core Microsoft .NET Gadgeteer Core GHI Electronics Product NETMF SDKs Tip Release notes are found within the SDKs. Date NETMF Core Rev SDK Jun 27, 2016 4.3 QFE2 GHI Electronics NETMF SDK 2016 R1 GHI Electronics NETMF SDK 2016 R1 zip Aug 31, 2015 4.3 QFE2 GHI Electronics NETMF SDK 2015 R1 Oct 29, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R5 Oct 8, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R4 Sep 15, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R3 Jul 31, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R2 Jan 29, 2014 4.3 RTM NETMF and Gadgeteer Package 2014 R1 Oct 23, 2013 4.3 RTM NETMF and Gadgeteer Package 2013 R3 Aug 27, 2013 4.3 RTM NETMF and Gadgeteer Package 2013 R2 Apr 30, 2013 4.3 RTM NETMF and Gadgeteer Package 2013 R1 Update 1 Feb 14, 2013 4.2 QFE2 NETMF and Gadgeteer Package 2013 R1 Feb 17, 2012 4.1 RTM NETMF 4.1 SDK, for Embedded Master, USBizi and ChipworkX (Includes IoT book for FEZ Panda)"
  },
  "software/netmf/getting-started.html": {
    "href": "software/netmf/getting-started.html",
    "title": ".NET Micro Framework Getting Started",
    "keywords": ".NET Micro Framework Getting Started Installation Steps Install Visual Studio Community Edition Download and install Microsoft's Visual Studio 2013 Community Edition . Install Microsoft .NET Micro Framework Uninstall any currently installed NETMF SDKs. Download Microsoft .NET Micro Framework 4.3 (QFE2) and unzip the file. Open the file's folder and install MicroFrameworkSDK.MSI and netmfvs2013.vsix . Install Microsoft .NET Gadgeteer Core (for Gadgeteer users only) Download and install Microsoft .NET Gadgeteer Core . For more information on the future of Gadgeteer, please see this news post . Install GHI Electronic's NETMF SDK Download and install GHI Electronics NETMF SDK 2016 R1 from our NETMF Downloads page. When installing newer GHI Electronics NETMF SDKs, click the Advanced button on the opening dialog box and uncheck the boxes to install the FEZ CERB Family and G400/FEZ Hydra loader updaters (the first two options). If needed, these loaders can be installed separately as highlighted in the individual product pages. Older GHI Electronics NETMF SDKs are also available on the NETMF Downloads page. For the latest 2016 R1 SDK, we've also made a zip archive of the sub-installers available so that you can install just the pieces you need in a quicker fashion. Get Started with .NET Micro Framework for Beginners To help you get started we have a free e-book in .pdf format: .NET Micro Framework for Beginners The Emulator The NETMF SDK includes an emulator for running NETMF applications on the PC. For the first part of this project, the emulator will be used to run a very simple application; afterwards the same program is run on NETMF hardware. Create a New Project Open Visual Studio, select File > New Project . There should be a Micro Framework option in the left menu. Click on it and then select Console Application in the center panel. Note The pictures used in this tutorial may vary slightly with different versions of the development platform. Click the OK button to create a new project. The project has only one C# file, called Program.cs . C# source files are listed in the Solution Explorer window. If the Solution Explorer is not open, use the View > Solution Explorer menu to open it. Double click on Program.cs to open the file in the editor. using System; using Microsoft.SPOT; namespace MFConsoleApplication1 { public class Program { public static void Main() { Debug.Print( Resources.GetString(Resources.StringResources.String1)); } } } For simplicity change the code to match the listing below: Tip All example code should be copied directly from this page and pasted into the Visual Studio program editor. using Microsoft.SPOT; public class Program { public static void Main() { Debug.Print(\"Amazing!\"); } } Selecting Transport When compiling a NETMF Console Project, there are options in Video Studio that control where the program is loaded and run. Select the menu item for the project's properties: In the Properties window, on the left side tabs, select .NET Micro Framework and make sure that Transport: is set to Emulator. Console applications have their Debug.Print statements appear in Visual Studio's Output Window. The application in this example uses print statements. If the Output window is not visible, open it by selecting Output in the View menu. Executing Press F5 and Visual Studio will compile the program, load it into the emulator and run it. The emulator displays a hypothetical NETMF device, complete with buttons and a screen. Do not close it. After a few seconds, the program will stop and the Output window will have \"Amazing!\" printed (surrounded by other application information). Introduction to Debugging The following sections are a quick introduction to the power and ease of debugging NETMF applications. Start running the program by pressing F11 (instead of F5 ), this will \"step\" into the application instead of just running it. After deployment, the program starts to run and stops at the very first line of the code. This is indicated by the yellow arrow. Press F11 to step to the \"Debug.Print\" statement. Finally, after pressing F11 one more time, \"Amazing!\" is printed in the Output window. Press F5 to let the program run to completion. Breakpoints Setting breakpoints is simple! -- Click in the bar to the left of the line that prints \"Amazing!\" A red dot appears to mark the breakpoint location. Press F5 to run the software. When the application reaches the breakpoint the debugger will pause: F11 can be used to single step execution line by line. F5 can be used to let the program run. Running on Hardware Deploying and running NETMF applications on hardware is very simple. Just connect the hardware, change an option in Visual Studio, and all loading, running, debugging, etc. are done on the device. The complete procedure is described below. Warning When working with hardware, take care not to expose the hardware to static electricity as it can damage the device. Connect and Power-up Connect the NETMF hardware to the PC using a USB cable. This is done one of two ways. If the processor has an integral USB port and is colored red, plug a USB cable from the computer directly to the board. Processors without an integral USB port will use a Gadgeteer socket to connect the power/USB module to the board. For these boards connect the power module to a \"D\" labeled socket on the board, then connect the power/USB module to the computer. (These circuit boards are black). The first time a processor is connected to the computer, Windows will need to load a driver. Wait until the driver is fully loaded before proceeding. Updating Device Software Before using a NETMF device, the embedded software must match the version of the SDK being used. Instructions for updating the embedded software are found on the Firmware Update page. If necessary, update your firmware, and then return here to continue the tutorial. Skipping the above step is the most common problem faced by beginners . Tip Many USB hubs are poorly implemented in PCs. If Windows failed to recognize the NETMF device or had any connection problems, make sure the device is connected directly to the PC, not through a USB hub. If problems persist, try using a power transformer or powered USB hub to guarantee the device is getting sufficient power. Deploying to Hardware Once the board is connected, Visual Studio has a control to switch back and forth between the emulator and connected hardware. From the project properties, select USB for transport.. Make sure the setup looks similar to the image below: Pressing F5 sends the simple application to the hardware and runs it. Debugging works exactly the same as described above. Next Steps We are currently updating the NETMF documentation found in our NETMF Tutorials ."
  },
  "software/netmf/intro.html": {
    "href": "software/netmf/intro.html",
    "title": ".NET Micro Framework",
    "keywords": ".NET Micro Framework .NET Micro Framework (NETMF) is a subset of the full Microsoft .NET Framework used to make Windows applications. NETMF initially started by Microsoft for use in SPOT watches and then later was open sourced. The latest version of Visual Studio working with our NETMF products is VS2013. Tip NETMF had a great run, but now it's time for something better. TinyCLR OS continues where NETMF left off, but with added features and increased security. Learn more about TinyCLR OS . General Resources .NET Micro Framework for Beginners (ebook PDF) Gadgeteer mainboards and module driver Source code Our .NET Micro Framework Discussion Forum Getting Started Deploy your first NETMF program. Learn more... Tutorials Learn NETMF embedded programming. Learn more... Downloads Visual Studio and device downloads. Learn more..."
  },
  "software/netmf/tutorials/analog-in.html": {
    "href": "software/netmf/tutorials/analog-in.html",
    "title": "Analog Inputs",
    "keywords": "Analog Inputs Unlike digital input pins which can only read high or low, analog pins can read a range of voltage levels. Micro-controllers based on 3.3V can read voltages anywhere between zero and 3.3V. In contrast to digital input pins that are 5V tolerant; the maximum applied voltage for analog input must not exceed 3.3V (for higher voltages a voltage divider or an op-amp circuit can be used). Using a Light Sensor to Demonstrate Analog Input This example uses a light sensor. Its output voltage varies with light intensity -- the darker the light the higher the voltage output. The following code requires the Microsoft.SPOT.Hardware assembly. Consult the Developers' Guide or the product manual for specific channels. using System.Threading; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { AnalogInput lightSensor = new AnalogInput((Cpu.AnalogChannel)Cpu.AnalogChannel.ANALOG_7); double lightSensorReading = 0; while (true) { lightSensorReading = lightSensor.Read(); Debug.Print(lightSensorReading.ToString()); Thread.Sleep(500); } } }"
  },
  "software/netmf/tutorials/analog-out.html": {
    "href": "software/netmf/tutorials/analog-out.html",
    "title": "Analog Outputs",
    "keywords": "Analog Outputs An analog output sets the voltage on its pin anywhere between 0 and the supplied voltage (maximum voltage) which is typically 3.3 volts. The output voltage is only a signal, not meant to drive any loads. An op-amp or similar circuit can be added to drive loads, such as a speaker. The analog out on a micro has \"precision:\" the precision of a particular processor is in its manual or datasheet; consequentially, actual output values on the pin are an approximation. For example, a micro with an 8-bit (256 steps) analog out has a step precision of 3.3V/256. In NETMF, the voltage to be output is specified as a percentage called the \"level.\" So, on a processor with a maximum output of 3.3V, a level of 0.5 (50%) would output around 1.65V. NETMF has two properties for the AnalogOutput class: Scale and Offset. The final voltage on the output pin will be: Final voltage = maximum output * ( (level*Scale) + Offset)) Final voltages are clipped to fit in the range 0V to maximum pin voltage. Example The processor in this example has a maximum output of 3.3 volts. The 50% voltage (level == 0.5) by default would generate 1.65V. Because of Scale, the actual percent will be 10 (0.5 * 0.2), which results in an output voltage of about 0.33V (3.3V * 0.1). The following code requires the Microsoft.SPOT.Hardware assembly. using Microsoft.SPOT.Hardware; public class Program { public static void Main() { //Setup Analog on the first analog output channel AnalogOutput output = new AnalogOutput( Cpu.AnalogOutputChannel.ANALOG_OUTPUT_0); output.Scale = 0.2; output.Write(0.5); //output approx. 0.33V } }"
  },
  "software/netmf/tutorials/can.html": {
    "href": "software/netmf/tutorials/can.html",
    "title": "CAN",
    "keywords": "CAN Controller Area Network (CAN) is a very common interface in industrial and automotive control. CAN is very robust and works very well in noisy environments at high speeds. All error checking and recovery methods are done automatically on the hardware. TD (Transmit Data) and RD (Receive Date) are the only two pins needed. There is no master/slave relationship in CAN. All nodes are equal and can both transmit and receive. CAN includes a protocal which easily allows for a node to claim a slice of time for its use so that collisions do not occur. You must have at least two nodes on the bus, however, or CAN will not work. There are many kinds of physical layers, but the most commonly used is a high-speed-dual wire that uses a twisted pair for noise immunity. This transceiver can run at up to 1 Mbit/s and can transfer data on very long wires if a low bit rate is used. Data can be transferred between nodes on the bus where any node can transfer at any time and all other nodes are required to successfully receive the data. All nodes must have a predefined bit timing criteria. This is much more complicated than calculating a simple baud rate for UART. For this reason, many CAN bit rate calculators are available which you can find using a simple internet search. We provide a few precalculated speeds that you can use but you can create more precise custom timings if you wish. There is an informative CAN guide in our downloads. The above image shows two CAN nodes connected over a bus with the 120 ohm resistors required on these transceivers. Tip Make sure to check the datasheet from the tranceiver. Most CAN controllers will divide the frequency by 2 before actually using it. Getting Started The code below sends a message over the CAN bus and prints out every message it receives to the debug window. It requires the GHI.Hardware assembly be added to the resources in your Visual Studio project. using GHI.IO; using Microsoft.SPOT; using System.Threading; public class Program { public static void Main() { var can = new ControllerAreaNetwork(ControllerAreaNetwork.Channel.One, ControllerAreaNetwork.Speed.Kbps1000); can.ErrorReceived += can_ErrorReceived; can.MessageAvailable += can_MessageAvailable; can.Enabled = true; can.SendMessage(new ControllerAreaNetwork.Message() { Data = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 }, ArbitrationId = 0x12345678, Length = 8, IsRemoteTransmissionRequest = false, IsExtendedId = true }); Thread.Sleep(-1); } private static void can_MessageAvailable(ControllerAreaNetwork sender, ControllerAreaNetwork.MessageAvailableEventArgs e) { var received = sender.ReadMessage(); var data = string.Empty; for (int i = 0; i < received.Length; i++) data += \"0x\" + received.Data[i].ToString(\"x2\") + \" \"; Debug.Print(\" CAN Message \"); Debug.Print(\"-----------------\"); Debug.Print(\" ID: \" + received.ArbitrationId.ToString()); Debug.Print(\" Time: \" + received.TimeStamp.ToString()); Debug.Print(\" RTR: \" + received.IsRemoteTransmissionRequest.ToString()); Debug.Print(\" EID: \" + received.IsExtendedId.ToString()); Debug.Print(\"Length: \" + received.Length.ToString()); Debug.Print(\" Data: \" + data); Debug.Print(\"\"); } private static void can_ErrorReceived(ControllerAreaNetwork sender, ControllerAreaNetwork.ErrorReceivedEventArgs e) { Debug.Print(\"Error on CAN: \" + e.Error.ToString()); } } CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a SITCore driving the SN65HVD230 CAN transceiver chip. See the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 33.333K ? ? ? ? ? False 86.7% 0.33% 2145M 83.333K ? ? ? ? 1 False 88.9% 0.28% 879M 125K ? ? ? ? 1 False 87.5% 0.31% 545M 250K ? ? ? ? 1 False 88.9% 0.28% 257M 500K ? ? ? ? 1 False 88.9% 0.28% 101M 1M ? ? ? ? 1 False 88.9% 0.28% 23M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested to ensure reliability."
  },
  "software/netmf/tutorials/digital-inputs.html": {
    "href": "software/netmf/tutorials/digital-inputs.html",
    "title": "Digital Inputs",
    "keywords": "Digital Inputs Digital inputs sense if the state of its pin is high or low based on the voltage. Every pin has a maximum & minimum supported voltages. For example, the typical minimum voltage on most pins is 0 volts -- a negative voltage may damage the pin or the processor. Also, the maximum that can be supplied to most pins must be less than the processor power source voltage. Since most processors run on 3.3V, the highest voltage a pin should see is 3.3V; however, some processors that are powered by 3.3V are 5V tolerant and are capable of accepting up to 5V on their inputs. Check the product's or the processor's manual for the tolerance level. Warning 5V-tolerant doesn't mean the processor can be powered by 5V. Only the input pins can tolerate 5V. InputPort An InputPort object is used to handle digital input pins. Most pins on the processor can be input or output. Unconnected input pins are \"floating\". When a pin is an input and is not connected, it is open for any surrounding noise, which can make the pin high or low. To take care of this issue, modern processors include internal weak pull-down or pull-up resistors, that are usually controlled by software. Enabling the pull-up resistor will pull the pin high. Note that the pull-up resistor doesn't make a pin high but it pulls it high. If nothing is connected then the pin is high by default. External resistors can be added as well. In this example, a button is connected between ground and the input pin. We will also enable the pull-up resistor. This means that the pin will be high (pull-up) when button is not pressed and low (connected to ground) when the button is pressed. We will read the status of the button and pass its state to the LED. Note that the pin is high when the button is not pressed (pulled-high) and it is low when the button is pressed. This means the LED will turn off when the button is pressed. The following code requires the Microsoft.SPOT.Hardware assembly. Consult the device schematics or manuals for the proper pin numbers. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { OutputPort LED; InputPort Button; LED = new OutputPort(Cpu.Pin.GPIO_Pin1, true); Button = new InputPort(Cpu.Pin.GPIO_Pin2, false, Port.ResistorMode.PullUp); while (true) { LED.Write(Button.Read()); Thread.Sleep(10); } } } Interrupt Port In the previous example, the program just looped, and looped, and looped -- each time checking the status of the pin attached to the button. The pin is checked maybe a million times before/after the button is pressed! Interrupt ports allows us to set a method that will be executed when the button is pressed (when pin is low for example). We can set the interrupt to fire (call the method) on many state changes on the pin: when a pin is low or maybe when it is high. The most common use is the \"on change.\" The change from low to high or high to low creates a signal edge. The rising edge occurs when the signal rises from low to high. The falling edge happen when the signal falls from high to low. For a more in-depth understanding of the difference between the \"change\" interrupt versus a \"level\" interrupt, use wikipedia -- the two articles of relevance are found by searching for \"Interrupt Port\" and \"edge level transition.\" In the example below, we are using the low edge to detect a button press. \"IntButton_OnInterrupt\" will automatically run when button is pressed. The following code requires the Microsoft.SPOT.Hardware assembly. Consult the device schematic or manual for pin numbers. using Microsoft.SPOT; using Microsoft.SPOT.Hardware; using System; using System.Threading; public class Program { public static void Main() { InterruptPort IntButton = new InterruptPort(Cpu.Pin.GPIO_Pin1, false, Port.ResistorMode.PullUp, Port.InterruptMode.InterruptEdgeLow); IntButton.OnInterrupt += new NativeEventHandler(IntButton_OnInterrupt); // Other code can be added here // ... // We are just going to sleep in this example! Thread.Sleep(Timeout.Infinite); } static void IntButton_OnInterrupt(uint port, uint state, DateTime time) { Debug.Print(\"Button Pressed\"); } } When creating the new InterruptPort object, the second argument indicates whether the glitch filter is enabled (true) or disabled (false). This is typically needed when using the interrupt feature to debounce the button. Not enabling this feature may cause the button to trigger more than one event, even though the button is pressed once. Tip In the event handler, like the one above : ...OnInterrupt(uint port, uint state..., the state argument is the state of the Pin after the edge transition. I.e. on a low to high edge, state will be high (true); likewise for high to low transitions. Tristate Port If we want a pin to be an input and output, what can we do? A pin can never be in and out simultaneously but we can make it output to set something and then make it input to read a response back. One way is to \"Dispose\" of the pin. We make an output port, use it and then dispose it; then we can make the pin input and read it. NETMF supports a better option called a Tristate port. Tristate means three states -- input, output low and output high. One minor issue about tristate pins is that if a pin is set to output and then you set it to output again an exception will occur. One common work-around for this is to check the direction of the pin before changing it. The direction of the pin is in its property \"Active\" where false means input and true is output. The code below requires the Microsoft.SPOT.Hardware assembly. Tip Due to internal design, TristatePorts will only work with interrupt capable digital pins. Warning Be careful not to have the pin connected to a switch then set the pin to output. using System.Threading; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; public class Program { static void MakePinOutput(TristatePort port) { if (port.Active == false) port.Active = true; } static void MakePinInput(TristatePort port) { if (port.Active == true) port.Active = false; } public static void Main() { TristatePort TriPin = new TristatePort(Cpu.Pin.GPIO_Pin6, false, false, Port.ResistorMode.PullUp); MakePinOutput(TriPin); TriPin.Write(true); Debug.Print(\"Write to output pin completed.\"); Debug.Print(\"Changing to input pin\"); MakePinInput(TriPin); Debug.Print(\"The input pin state is: \" + TriPin.Read().ToString()); Thread.Sleep(Timeout.Infinite); } }"
  },
  "software/netmf/tutorials/digital-outputs.html": {
    "href": "software/netmf/tutorials/digital-outputs.html",
    "title": "Digital Outputs",
    "keywords": "Digital Outputs A digital output pin can be set to either high or low. There are different ways of describing these two states. High can also be called \"true\" or \"one;\" low can be called \"false\" or \"zero\". If the processor is powered off of 3.3 V, then the state high means that there is 3.3 V on the output pin. It is not going to be exactly 3.3 V but very close. When the pin is set to low then it is voltage is very close to zero volts. Warning Never connect two output pins together. If they are connected and one is high and the other is low, the entire processor can be damaged. The digital pins on micro-controllers are very weak. They can not be used to drive devices that require a lot of power. Tip All the examples shown below require the Microsoft.SPOT.Hardware assembly. Consult the device schematics or manual for specific pin numbers. Light Up an LED This example turns a LED on. The initial state of the pin (true or false) must be specified when creating the OutputPort. This example makes the pin true which will cause the LED to be on by default. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { OutputPort LED; LED = new OutputPort(Cpu.Pin.GPIO_Pin1, true); Thread.Sleep(Timeout.Infinite); } } Blink an LED To blink an LED, the pin is toggled between high and low. Due to the high speed of the microcontroller (it can flash the LED millions of times per second) a delay needs to be added between ON and OFF to see the blinking. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { OutputPort LED; LED = new OutputPort(Cpu.Pin.GPIO_Pin1, true); while (true) { LED.Write(!LED.Read()); Thread.Sleep(200); } } }"
  },
  "software/netmf/tutorials/files.html": {
    "href": "software/netmf/tutorials/files.html",
    "title": "Files",
    "keywords": "Files The file system features in NETMF are very similar to full .NET. There are no limits on file counts or sizes other than the limits of the FAT file system itself. NETMF supports FAT16 and FAT32. With a few minor changes, NETMF file system access can be tested from within the Microsoft NETMF emulator. Changes include removing any of the GHI Electronics library dependencies. Unlike full .NET, NETMF does require mounting of media. NETMF also handles media names differently than full .NET. Media name differences are easily handled by accessing the root directory name at runtime and then using that name. Consequently, most online examples of how to use .NET to access files on PCs can be used with NETMF. In NETMF, other than differences for specific physical characteristics, usage of SD/MMC cards and USB memory devices are identical to .NET. This document splits it's examples into two sets. One for SD/MMC Card file system access and the other for USB Mass Storage. The core file operations (open, read, write, etc.) are identical between the two. Warning The file system does a lot of data buffering internally to speed up file access time and to increase the life of flash media. When you write data to a file, it is often saved somewhere in internal buffers rather than being written immediately to the media. To make sure the data is stored on the media, you need to flush the data. Flushing (or closing) a file is the only way to guarantee that the data you are trying to write is on the actual media. In addition to the file data there is other information, such as directory information, that may not be written to the media when the file is flushed. For example, if you delete a file and remove the card from the system, the file is probably not actually erased because the directory structure was not flushed. Under current versions of .NET Micro Framework, there can be a variable time delay before the buffers are actually written to the media when using the FileStream's Flush method. This delay can reportedly be as long as a minute (see: https://netmf.codeplex.com/workitem/2149 ). To guarantee that the file buffers and the meta-data are written to the media you need to flush the volume: VolumeInfo.GetVolumes()[0].FlushAll() -or- Microsoft.SPOT.IO.VolumeInfo(\"\\SD\").FlushAll() . Ideally, you would unmount the media before it is removed from the system. This may not be always possible -- FlushAll will guarantee your data is saved Tip The SD/MMC Card examples shown below require the GHI.Hardware, Microsoft.SPOT.IO, and System.IO assemblies. Some Microsoft documentation class descriptions, such as for Directory, place the library code in the mscorlib assembly; however, it is found in the System.IO assembly. SD Card: Show Files in Root Directory This example assumes the card is already inserted; it lists all files available in the root directory. Note Some SD card sockets/interfaces have an internal switch that closes when a card is inserted or ejected. Utilizing the switch is shown in the \" SD Card: Media Detection \" example further down on this page. using System.IO; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; using Microsoft.SPOT.IO; using GHI.IO; using GHI.IO.Storage; class Program { public static void Main() { // ... // assume SD card is inserted // Create a new storage device // NETMF only allows one SD card // to be supported at a time. SDCard sd_card = new SDCard(); // this is a non-blocking call // it fires the RemovableMedia.Insert event after // the mount is finished. sd_card.Mount(); // for some cases, a simple sleep might suffice // This example just waits on the event before proceeding // (After first time firing of the event, you may want // to disable the handler or re-assign it bool fs_ready = false; RemovableMedia.Insert += (a, b) => { fs_ready = true; }; while (! fs_ready) { System.Threading.Thread.Sleep(50); } // Assume one storage device is available, access it through // NETMF and display the available files and folders: Debug.Print(\"Getting files and folders:\"); if (VolumeInfo.GetVolumes()[0].IsFormatted) { string rootDirectory = VolumeInfo.GetVolumes()[0].RootDirectory; string[] files = Directory.GetFiles(rootDirectory); string[] folders = Directory.GetDirectories(rootDirectory); Debug.Print(\"Files available on \" + rootDirectory + \":\"); for (int i = 0; i < files.Length; i++) Debug.Print(files[i]); Debug.Print(\"Folders available on \" + rootDirectory + \":\"); for (int i = 0; i < folders.Length; i++) Debug.Print(folders[i]); } else { Debug.Print(\"Storage is not formatted. \" + \"Format on PC with FAT32/FAT16 first!\"); } // Unmount when done sd_card.Unmount(); } } SD Card: Writing Files There is more than one way to open files. I will only cover FileStream objects. This example will open a file and write a string to it. Since FileStream will only take byte arrays, we need to convert our string to a byte array. using System.Threading; using System.Text; using Microsoft.SPOT; using System.IO; using Microsoft.SPOT.IO; using GHI.IO.Storage; public class Program { static void Main() { // if necessary, check that SD is present here... SDCard sd_card = new SDCard(); sd_card.Mount(); bool fs_ready = false; RemovableMedia.Insert += (a, b) => { fs_ready = true; }; while (! fs_ready ) { System.Threading.Thread.Sleep(1); } // Assume only one storage device is available // and that the media is formatted string rootDirectory = VolumeInfo.GetVolumes()[0].RootDirectory; FileStream FileHandle = new FileStream(rootDirectory + @\"\\hello.txt\", FileMode.Create); byte[] data = Encoding.UTF8.GetBytes(\"This string will go in the file!\"); FileHandle.Write(data, 0, data.Length); FileHandle.Close(); sd_card.Unmount(); } } SD Card: Reading a File Take the SD Card used in the last example, put it in a PC and you will see the file. For this example, we use the same SD Card written to by the last example. The file is opened and read to verify its contents. using System.Threading; using System.Text; using Microsoft.SPOT; using System.IO; using Microsoft.SPOT.IO; using GHI.IO.Storage; public class Program { static void Main() { // ... If desired, check if SD is inserted // SD Card is inserted // Create a new storage device SDCard sd_card = new SDCard(); // Mount the file system sd_card.Mount(); bool fs_ready = false; RemovableMedia.Insert += (a, b) => { fs_ready = true; }; while (!fs_ready) { System.Threading.Thread.Sleep(1); } // Assume one storage device is available, // access it through NETMF string rootDirectory = VolumeInfo.GetVolumes()[0].RootDirectory; FileStream FileHandle = new FileStream(rootDirectory + @\"\\hello.txt\", FileMode.Open, FileAccess.Read); byte[] data = new byte[100]; int read_count = FileHandle.Read(data, 0, data.Length); FileHandle.Close(); Debug.Print(\"The size of data read is: \" + read_count.ToString()); Debug.Print(\"Data from file:\"); Debug.Print(new string(Encoding.UTF8.GetChars(data), 0, read_count)); sd_card.Unmount(); } } SD Card: Media Detection The previous examples assumed that the card was already inserted and mostly ignored whether that media was formatted (contained a file system). The following example shows an application without such assumptions; additionally, it demonstrates the Format method. Together, InsertEventHandler , EjectEventHandler , and IsSDCardPresent are used to respond to physical card activities, which in turn are used to control mounting ( Mount , Unmount ) of the card. Once the card is mounted, the file-system can be used. using System; using System.IO; using System.Threading; using Microsoft.SPOT; using Microsoft.SPOT.IO; using GHI.IO.Storage; public class Program { // evt is used to avoid the possibility that accesses to the // mounted file system do not occur until mount() // is fully done. private static AutoResetEvent evt = new AutoResetEvent(false); //Make sure to set the pin to your sd card detect pin. private static InputPort sdCardDetect = new InputPort(Cpu.Pin.GPIO_NONE, false, Port.ResistorMode.Disabled); public static void Main() { RemovableMedia.Insert += new InsertEventHandler(RemovableMedia_Insert); RemovableMedia.Eject += new EjectEventHandler(RemovableMedia_Eject); // Start auto mounting thread new Thread(SDMountThread).Start(); evt.WaitOne(); // yield here until mounting and initializing is finished // Your program goes here // ... } // This event is fired by unmount; not neccesarily by physical ejection of media static void RemovableMedia_Eject(object sender, MediaEventArgs e) { Debug.Print(\"SD card unmounted, eject event fired\"); // as desired signal other thread(s) in application // that unmount occurred } static void RemovableMedia_Insert(object sender, MediaEventArgs e) { Debug.Print(\"Insert event fired; SD card mount is finished.\"); // insert code here for anything the program wants to do immediately // after mounting occurs... if (e.Volume.IsFormatted) { Debug.Print(\"Available folders:\"); string[] strs = Directory.GetDirectories(e.Volume.RootDirectory); for (int i = 0; i < strs.Length; i++) Debug.Print(strs[i]); Debug.Print(\"Available files:\"); strs = Directory.GetFiles(e.Volume.RootDirectory); for (int i = 0; i < strs.Length; i++) Debug.Print(strs[i]); } else { Debug.Print(\"SD card is not formatted. Formatting...\"); // VolumeInfo is the class that contains volume information for a specific // media. // .GetVolumes()[0] aquires the first volume on the device. Change the // index for different volumes. // .Format(\"FAT\", 0); Selects the \"FAT\" file system as the format type. VolumeInfo.GetVolumes()[0].Format(\"FAT\", 0); } evt.Set(); // proceed with other processing } public static void SDMountThread() { SDCard SD = null; const int POLL_TIME = 500; // check every 500 millisecond bool sdExists; while (true) { try { // If SD card was removed while mounting, it may throw exceptions. sdExists = sdCardDetect.Read(); // make sure it is fully inserted and stable if (sdExists) { Thread.Sleep(50); sdExists = sdCardDetect.Read(); } if (sdExists && SD == null) { SD = new SDCard(); SD.Mount(); } else if (!sdExists && SD != null) { SD.Unmount(); SD.Dispose(); SD = null; } } catch { if (SD != null) { SD.Dispose(); SD = null; } } Thread.Sleep(POLL_TIME); } } } USB Mass Storage Devices USB mass storage devices, such as memory sticks and card readers are supported by GHI's NETMF devices. If you compare the following example with those above for SD Cards, you will see how easy it is to program for one, the other, or both with virtually identical code. using System; using System.Threading; using System.IO; using Microsoft.SPOT; using System.Text; using Microsoft.SPOT.IO; using GHI.Usb; using GHI.Usb.Host; using GHI.IO.Storage; public class Program { // evt is used to avoid the possibility that accesses to the // mounted file system do not occur until mount() // is fully done. private static AutoResetEvent evt = new AutoResetEvent(false); private static MassStorage usb_storage; private static string rootDirectory; public static void Main() { RemovableMedia.Insert += new InsertEventHandler(RemovableMedia_Insert); RemovableMedia.Eject += new EjectEventHandler(RemovableMedia_Eject); // Unlike SD Card detection, the USB Host Controller sends an // event when a Mass Storage device is plugged-in. Controller.MassStorageConnected += (sender, massStorage) => { usb_storage = massStorage; usb_storage.Mount(); // fires the insert event when finished }; Controller.Start(); evt.WaitOne(); // yield here until mounting and initializing is finished byte[] data; // write using (var FileHandle = new FileStream(rootDirectory + @\"\\hello.txt\", FileMode.Create)) { data = Encoding.UTF8.GetBytes(\"This string will go in the file!\"); FileHandle.Write(data, 0, data.Length); } // read int read_count; using (var FileHandle = new FileStream(rootDirectory + @\"\\hello.txt\", FileMode.Open, FileAccess.Read)) { data = new byte[100]; read_count = FileHandle.Read(data, 0, data.Length); } Debug.Print(\"The size of data we read is: \" + read_count.ToString()); Debug.Print(\"Data from file:\"); Debug.Print(new string(Encoding.UTF8.GetChars(data), 0, read_count)); usb_storage.Unmount(); } // This event is fired by unmount static void RemovableMedia_Eject(object sender, MediaEventArgs e) { Debug.Print(\"USB unmounted, eject event fired\"); } static void RemovableMedia_Insert(object sender, MediaEventArgs e) { Debug.Print(\"Insert event fired; USB Storage mount is finished.\"); if (e.Volume.IsFormatted) { rootDirectory = e.Volume.RootDirectory; Debug.Print(\"Available folders:\"); string[] strs = Directory.GetDirectories(e.Volume.RootDirectory); for (int i = 0; i < strs.Length; i++) Debug.Print(strs[i]); Debug.Print(\"Available files:\"); strs = Directory.GetFiles(e.Volume.RootDirectory); for (int i = 0; i < strs.Length; i++) Debug.Print(strs[i]); } else { Debug.Print(\"Media is not formatted. Formatting...\"); e.Volume.Format(\"FAT\", 0); rootDirectory = e.Volume.RootDirectory; } evt.Set(); // proceed with other processing } } Warning Media formatted as FAT12 will not work. This shouldn't be an issue since FAT12 is no longer in use."
  },
  "software/netmf/tutorials/firmware-update.html": {
    "href": "software/netmf/tutorials/firmware-update.html",
    "title": "Firmware Update",
    "keywords": "Firmware Update Note If you need to update the loader, it should always be done before updating the firmware. See your device's developers' guide or manual for more detail on updating the loader. Connect your device to your PC. Launch FEZ Config and click on Check device for update button. This will show the version numbers on the PC and what is loaded on the device. Note Fez Config is installed when you install the NETMF SDK . To proceed with updating TinyCLR, click on the Firmware Updater button on the left and follow the instructions. After FEZ Config selects the firmware and the default configuration files, click Next . Click OK to proceed when the dialog appears asking if you are having issues. As the update occurs, the steps and progress are shown. When it is finished, the module is ready to be flashed with NETMF applications."
  },
  "software/netmf/tutorials/graphics.html": {
    "href": "software/netmf/tutorials/graphics.html",
    "title": "Graphics",
    "keywords": "Graphics Introduction NETMF provides excellent support for graphics through the Bitmap class (that we also supplement with our Glide library). It can draw various shapes, text, and images from BMPs, JPGs, and GIFs -- which can be obtained from the file system, network, or resources. When drawing on a bitmap, everything is rendered on an in-memory object that can be quite large depending on your screen size. To transfer a bitmap object from memory to the screen, we need to call Flush on the bitmap object. Flush will only work if the size of the bitmap is exactly the size of the screen. If it is any other size, no image will be displayed. Non-Native Support Some smaller devices do not have a built in LCD controller. As a result, they can only use displays through a different type of bus, often SPI. Depending on your exact display, you may need to call a display specific function in its driver to draw on the scree. However, some SPI displays do support the Flush method on bitmaps, so be sure to consult your display documentation. Display Configuration In order to use a display, you must configure it. You can select the display type from FEZ Config on the LCD Configuration tab or you can execute the below code (make sure to select your actual display). After you set the configuration, the device must reboot for it to take effect. The Save method returns whether or not a reboot is needed. If you are using a display that is not present under GHIDisplay, you will need to configure the properties on the Display object instead of calling the Populate method. using GHI.Processor; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { Display.Populate(Display.GHIDisplay.DisplayCP7); if (Display.Save()) PowerState.RebootDevice(false); //Display is now configured. } } Drawing The following example draws a line and an ellipse on the screen. The assemblies Microsoft.SPOT.Graphics and Microsoft.SPOT.TinyCore are required. using Microsoft.SPOT; using Microsoft.SPOT.Presentation; using Microsoft.SPOT.Presentation.Media; public class Program { public static void Main() { Bitmap lcd = new Bitmap(SystemMetrics.ScreenWidth, SystemMetrics.ScreenHeight); lcd.DrawLine(Colors.Green, 1, 20, 20, 40, 40); lcd.DrawEllipse(Colors.Blue, 5, 5, 5, 5); lcd.Flush(); } } Text The following code shows how to display text using NETMF. Since resources depend on your project's default namespace, make sure that you change the namespace in this example to match your namespace. If you do not currently have a font resource in your project, NETMF ships with two default fonts that you can add as a resource found in C:\\Program Files (x86)\\Microsoft .NET Micro Framework\\v4.3\\Fonts. You can find the NinaB font that we use below in that folder. using Microsoft.SPOT; using Microsoft.SPOT.Presentation; using Microsoft.SPOT.Presentation.Media; namespace your_namespace { public class Program { public static void Main() { Font font = Resources.GetFont(Resources.FontResources.NinaB); Bitmap lcd = new Bitmap(SystemMetrics.ScreenWidth, SystemMetrics.ScreenHeight); lcd.DrawText(\"Hello, World!\", font, Colors.White, 0, 0); lcd.Flush(); } } } Adding new fonts to your application is very easy. TTL fonts can be converted to the simple font format used in NETMF using the TinyFont tool SPI Displays If you are using a G80 or Cerb based device and a SPI display, you can configure the device so that when you call Flush on a bitmap, it is automatically sent to the display. If the ControlPin is provided, the draw window will automatically be set, the data byte will be sent, and the ControlPin will be set high for you when you call Flush. The display will also be initialized on the first call to Flush. Additionally, the backlight pin will automatically be set high if provided on the first call to Flush. Lastly, if ResetPin is provided, it will be toggled before initialization. If your device does not have enough memory to create a bitmap for the entire screen, you can create a smaller one and only draw to a subset of the display. You can set the draw window on the display to match that new size and pick which position it is drawn at. Doing this multiple times allows you to draw the entire screen by moving the draw window around and redrawing the bitmap. The below example shows how to do this on the FEZ Cerberus and requires the GHI.Hardware, Microsoft.SPOT.Graphics, and Microsoft.SPOT.Hardware assemblies. Make sure you properly set any pins other configuration below for your actual device bearing in mind the above considerations. If you are not using the DisplayN18, you must configure the display before first use and set the draw window before you call Flush every time. using GHI.Pins; using GHI.Processor; using GHI.Utilities; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; using Microsoft.SPOT.Presentation.Media; public class Program { public static void Main() { Display.Width = 128; Display.Height = 160; Display.Type = Display.DisplayType.Spi; Display.CurrentRotation = Display.Rotation.Normal; Display.BitmapFormat = Bitmaps.Format.Bpp16BgrLe; Display.SpiModule = FEZCerberus.Socket5.SpiModule; Display.ChipSelectPin = FEZCerberus.Socket5.Pin6; Display.ResetPin = FEZCerberus.Socket5.Pin3; Display.BacklightPin = FEZCerberus.Socket5.Pin4; Display.ControlPin = FEZCerberus.Socket5.Pin5; Display.Save(); var bmp = new Bitmap(Display.Width, Display.Height); bmp.DrawEllipse(Colors.Red, 5, 5, 5, 5); bmp.DrawEllipse(Colors.Green, 15, 5, 5, 5); bmp.DrawEllipse(Colors.Blue, 25, 5, 5, 5); } } Gadgeteer When using Gadgeteer display modules, the SimpleGraphics interface is provided for you. It provides an API that is a bit easier to use than regular NETMF bitmaps. It is available as the SimpleGraphics property on every display. The below example shows how to display an ellipse, line, and some text. Make sure that you change the namespace to match yours. Gadgeteer programs automatically add the NinaB font to your project so you do not need to worry about adding it yourself. using GT = Gadgeteer; namespace your_namespace { public partial class Program { void ProgramStarted() { this.displayCP7.SimpleGraphics.DisplayEllipse(GT.Color.Red, 1, GT.Color.Red, 5, 5, 5, 5); this.displayCP7.SimpleGraphics.DisplayLine(GT.Color.Blue, 1, 20, 20, 40, 40); this.displayCP7.SimpleGraphics.DisplayText(\"Hello, World!\", Resources.GetFont(Resources.FontResources.NinaB), GT.Color.Green, 60, 60); } } }"
  },
  "software/netmf/tutorials/i2c.html": {
    "href": "software/netmf/tutorials/i2c.html",
    "title": "I2C",
    "keywords": "I2C I2C (pronounced eye-squared-sea, or eye-two-sea) was originally developed by Phillips to allow multiple chipsets to communicate on a 2-wire bus in home consumer devices. It has a master and one or more slaves sharing the same data bus. Instead of selecting the slaves using a digital pin like SPI (consuming an additional I/O pin), I2C uses an addressing mechanism to communicate to the selected device. Before data is transferred, the master sends out a 7-bit address address of the slave device it wants to communicate with. It also sends one bit indicating whether it wants to send data to the device or receive data from the device. When a slave sees its address on the bus, it will acknowledge its presence. At this point, the master can send or receive data. The master will start data transfers with a \"start\" condition before it sends any address or data and then end it with \"stop\" condition. The I2C uses two wires to communicate between the I2C Master and the I2C device. These two wires are known as the SDA and SCL lines. SDA stands for Serial Data, and SCL is Serial Clock. The I2C NETMF driver is based on transactions. If we want to read from a register on a sensor, we would first need to send it the register number we wish to read from, and then we need to read the register. Those are two transactions; a write followed by a read. Addressing One very important point about I2C is that I2C devices have a 7-bit address, but 8-bits are sent on the wire in the \"control byte\" when communicating with the I2C bus. The 8th bit tells the device whether the operation will be a read operation (the 8th bit is a 1) or a write operation (the 8th bit is a 0). When discussing I2C you should always make sure you are clear about the 7-bit address that your device uses, rather than stating your 8-bit read or write address. Software I2C When using I2C, it is highly recommended that you use the built-in hardware support for I2C. In some cases though it may be necessary to have another I2C bus or it is necessary to use specific pins that are not I2C pins. In this case, I2C can be handled completely in software, though performance will be lower. The GHI Electronics libraries include a software I2C implementation in the GHI.Hardware assembly (GHI.IO.SoftwareI2CBus). An I2C Example This example will read the value of the register on an I2C device with the 7-bit address of 0x38. As discussed above, you first have to write the register number you want to read, two in this case, and then read the value back. using Microsoft.SPOT; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { //create I2C object //note that the netmf i2cdevice configuration requires a 7-bit address! It set the 8th R/W bit automatically. I2CDevice.Configuration con = new I2CDevice.Configuration(0x38, 400); I2CDevice MyI2C = new I2CDevice(con); // Create transactions // We need 2 in this example, we are reading from the device // First transaction is writing the \"read command\" // Second transaction is reading the data I2CDevice.I2CTransaction[] xActions = new I2CDevice.I2CTransaction[2]; // create write buffer (we need one byte) byte[] RegisterNum = new byte[1] { 2 }; xActions[0] = I2CDevice.CreateWriteTransaction(RegisterNum); // create read buffer to read the register byte[] RegisterValue = new byte[1]; xActions[1] = I2CDevice.CreateReadTransaction(RegisterValue); // Now we access the I2C bus using a timeout of one second // if the execute command returns zero, the transaction failed (this // is a good check to make sure that you are communicating with the device correctly // and don�t have a wiring issue or other problem with the I2C device) if (MyI2C.Execute(xActions, 1000) == 0) { Debug.Print(\"Failed to perform I2C transaction\"); } else { Debug.Print(\"Register value: \" + RegisterValue[0].ToString()); } } } Multiple Devices The I2C object on NETMF is a representation of the \"bus\" and not the \"device\" so you can't construct multiple I2C objects. To access multiple I2C devices you need to have multiple configurations and then when accessing device \"A\" we need to use configuration \"A\" and when accessing device \"B\" we need to use configuration \"B\". using Microsoft.SPOT; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { //create I2C Device object representing both devices on our bus I2CDevice.Configuration conDeviceA = new I2CDevice.Configuration(0x38, 400); I2CDevice.Configuration conDeviceB = new I2CDevice.Configuration(0x48, 400); //create I2C Bus object using one of the devices on the bus I2CDevice MyI2C = new I2CDevice(conDeviceA); // Note you could have chosen to create the bus using the conDeviceB parameter, which ever you choose it will be the \"selected\" device on the bus to start with. Here's how you would do that: // I2CDevice MyI2C = new I2CDevice(conDeviceB); //create transactions (we need 2 in this example) I2CDevice.I2CTransaction[] xActions = new I2CDevice.I2CTransaction[2]; // create write buffer (we need one byte) byte[] RegisterNum = new byte[1] { 2 }; xActions[0] = I2CDevice.CreateWriteTransaction(RegisterNum); // create read buffer to read the register byte[] RegisterValue = new byte[1]; xActions[1] = I2CDevice.CreateReadTransaction(RegisterValue); // Explicitly set the I2C bus to access device A by setting the I2C Config to the Device A's config. MyI2C.Config = conDeviceA; if (MyI2C.Execute(xActions, 1000) == 0) { Debug.Print(\"Failed to perform I2C transaction\"); } else { Debug.Print(\"Register value: \" + RegisterValue[0].ToString()); } // Explicitly set the I2C bus to access device B by setting the I2C Config to the Device B's config. MyI2C.Config = conDeviceB; if (MyI2C.Execute(xActions, 1000) == 0) { Debug.Print(\"Failed to perform I2C transaction\"); } else { Debug.Print(\"Register value: \" + RegisterValue[0].ToString()); } } }"
  },
  "software/netmf/tutorials/in-field-update.html": {
    "href": "software/netmf/tutorials/in-field-update.html",
    "title": "In-Field Update",
    "keywords": "In-Field Update One of GHI Electronics's additions to NETMF includes the In-Field Update (IFU) class allowing devices to be updated in the field. Updates can be obtained over the network or via USB memory, an SD card, or even through a serial port. File encryption and integrity checking can be implemented if desired. Once the data is available, it is passed on to IFU and then stored internally in RAM. Once all of the data is received and loaded by the developer, a single call will wipe the flash and write the new files. Only the regions that are being updated are erased. Warning The final stage will erase the flash and write the new data. This can take some time depending on the board. Losing power during this process will cause the update to fail and require the device to be updated manually. Extracting an Existing Application Creating a hex file to flash to your deployed board is easy. For example, if you have a board in the field (mall kiosk, traffic signal, etc) that is difficult to access, just deploy the new version of your program to another board of the same type. Then open MFDeploy, select USB, and select Target > Application Deployment > Create Application Deployment as shown below. Tip If you would like the next version of your application to have the same update ability, be sure to include the update code in it as well. Now select the name of the file that you would like to use and where to save it. Once this is done, you can place this file on an SD card and insert it into your device, or you can send it to you device over a network. The next section will demonstrate how to load the files and perform the update. Getting Started The following example shows you how to load data into IFU and then flash the device. It requires the GHI.Hardware assembly and assumes that you have already mounted an SD card. Since firmware files can large and often cannot be held in entirely in memory we only load portions of the file at a time. using GHI.Processor; using System.IO; public class Program { public const int BLOCK_SIZE = 65536; public static void FlashFirmware() { // Reserve the memory needed to buffer the update. // A lot of RAM is needed so it is recommended to do this at the program start. InFieldUpdate.Initialize(InFieldUpdate.Types.Firmware | InFieldUpdate.Types.Configuration); // Start loading the new firmware on the RAM reserved in last step. // Nothing is written to FLASH in this stage. Power loss and failures are okay. // Simply abort this stage any way you like! // Files can come from storage, from network, from serial bus or any other way. LoadFile(\"\\\\SD\\\\Config.hex\", InFieldUpdate.Types.Configuration); LoadFile(\"\\\\SD\\\\Firmware.hex\", InFieldUpdate.Types.Firmware); LoadFile(\"\\\\SD\\\\Firmware2.hex\", InFieldUpdate.Types.Firmware); //Only if your device has two firmware files. // This method will copy The new firmware from RAM to FLASH. // This function will not return but will reset the system when done. // Power loss before this function resets the system will result in corrupted firmware. // A manual update will be needed if this method fails (due to power loss for example). InFieldUpdate.FlashAndReset(); } public static void LoadFile(string filename, InFieldUpdate.Types type) { using (var stream = new FileStream(filename, FileMode.Open)) { var data = new byte[BLOCK_SIZE]; for (int i = 0; i < stream.Length / BLOCK_SIZE; i++) { stream.Read(data, 0, BLOCK_SIZE); InFieldUpdate.Load(type, data, BLOCK_SIZE); } stream.Read(data, 0, (int)stream.Length % BLOCK_SIZE); InFieldUpdate.Load(type, data, (int)stream.Length % BLOCK_SIZE); } } }"
  },
  "software/netmf/tutorials/intro.html": {
    "href": "software/netmf/tutorials/intro.html",
    "title": ".NET Micro Framework Tutorials",
    "keywords": ".NET Micro Framework Tutorials Topics Analog Inputs Analog Outputs CAN Digital Inputs Digital Outputs Files Firmware Update Graphics I2C In-Field Update Networking PWM Pulse Feedback Real Time Clock (RTC) Register Access RLP Signal Capture Signal Generator SPI SQLite Timers Touch UART USB Client USB Host Watchdog XML XTEA What is .NET Micro Framework? If you are new to NETMF you might want to take a look at our free e-book .NET Micro Framework for Beginners"
  },
  "software/netmf/tutorials/networking.html": {
    "href": "software/netmf/tutorials/networking.html",
    "title": "Networking",
    "keywords": "Networking Introduction Networks are an essential part of our everyday lives. Almost every home is connected to a network (the Internet) and most businesses can't function without an internal network (LAN or WiFi) that is connected to an external network (the Internet). All these networks have a standard for communication: TCP/IP. There are actually a few protocols that handle different tasks in the network: DNS, DHCP, IP, ICMP, TCP, UDP, PPP, and others. In code, you create what is called a socket. A socket allows communication between your computer and one or more other endpoints (usually remote computers). Sockets can be TCP, UDP, and others. Socket support in NETMF is very similar to the full .NET Framework. Tip When working with networking, you may sometimes receive socket exceptions that look like \"10054\". NETMF uses the same error codes as WinSock on the desktop, so a quick search can tell you what that code means. For example,10054 means connection reset. Getting started with WiFi Since GHI Electronics's devices can provide multiple network interfaces (only one can be used at a time, however), you must initialize the interface you wish to use. To do so, you must create the interface object, open it, configure any network settings, and, in the case of WiFi, join a network. In the below example, you can see that we are using DHCP and dynamic DNS. This allows a lot of the configuration to be done automatically, depending on your network setup. (Static IP and static DNS also work.) Once you join a network and have been issued a valid IP Address, the network is ready to use. Make sure you enter your network key in the proper format. WPA/WPA2 keys are the literal string value while WEP keys are the hex digits without the leading 0x. The following code requires the GHI.Networking, Microsoft.SPOT.Hardware, and Microsoft.SPOT.Net assemblies. Make sure that you update the pins in the constructor to match your hardware setup. using GHI.Networking; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; using Microsoft.SPOT.Net.NetworkInformation; using System; using System.Net; using System.Threading; public class Program { private static WiFiRS9110 netif; public static void Main() { NetworkChange.NetworkAvailabilityChanged += NetworkChange_NetworkAvailabilityChanged; NetworkChange.NetworkAddressChanged += NetworkChange_NetworkAddressChanged; netif = new WiFiRS9110(SPI.SPI_module.SPI1, Cpu.Pin.GPIO_Pin1, Cpu.Pin.GPIO_Pin2, Cpu.Pin.GPIO_Pin3); netif.Open(); netif.EnableDhcp(); netif.EnableDynamicDns(); netif.Join(\"SSID\", \"Password\"); while (netif.IPAddress == \"0.0.0.0\") { Debug.Print(\"Waiting for DHCP\"); Thread.Sleep(250); } //The network is now ready to use. } private static void NetworkChange_NetworkAddressChanged(object sender, Microsoft.SPOT.EventArgs e) { Debug.Print(\"Network address changed\"); } private static void NetworkChange_NetworkAvailabilityChanged(object sender, NetworkAvailabilityEventArgs e) { Debug.Print(\"Network availability: \" + e.IsAvailable.ToString()); } } Wired Ethernet If you want to use a physical Ethernet connection, you can use our SPI based ENC28 or the built in Ethernet adapter. Initializing the network is similar to WiFi in either case, except you do not join a network as seen below. netif = new EthernetENC28J60(SPI.SPI_module.SPI1, Cpu.Pin.GPIO_Pin1, Cpu.Pin.GPIO_Pin2, Cpu.Pin.GPIO_Pin3); netif.Open(); netif.EnableDhcp(); netif.EnableDynamicDns(); while (netif.IPAddress == \"0.0.0.0\") { Debug.Print(\"Waiting for DHCP\"); Thread.Sleep(250); } //The network is now ready to use. netif = new EthernetBuiltIn(); netif.Open(); netif.EnableDhcp(); netif.EnableDynamicDns(); while (netif.IPAddress == \"0.0.0.0\") { Debug.Print(\"Waiting for DHCP\"); Thread.Sleep(250); } //The network is now ready to use. HTTP communication Once you configure a network interface, you probably want to start communicating over the network. One of the easiest ways to do this is through HTTP. After you have received an IP Address (as shown above), you can create an HTTP request to a URL and then receive its response. What you do with that data is up to you. Make sure the result buffer is larger enough to hold the response or process the data as you read it. byte[] result = new byte[65536]; int read = 0; using (var req = HttpWebRequest.Create(\"url to query\") as HttpWebRequest) { using (var res = req.GetResponse() as HttpWebResponse) { using (var stream = res.GetResponseStream()) { do { read = stream.Read(result, 0, result.Length); Thread.Sleep(20); } while (read != 0); } } } //The result array now contains the data received from the remote server. mIP For those who want greater control over the networking stack, there is the mIP C# library available at http://mip.codeplex.com/ It is a full networking stack allowing you to modify it to suit your needs, something not easily done with the built in stack. PPP You can use the provided PPP class to communicate with serial PPP devices such as cellular or regular modems that provide access to the internet. After you configure your device over a serial port (potentially using AT commands that differ for every device), you pass that port and any authentication parameters to our PPP class and then, once the PPP connection is established with the device, you can use the regular NETMF networking functionality to access the internet or your network. The below example shows the basic initialization, AT commands, and PPP commands needed to access the network using a SIM908 cellular modem. You must provide your own SIM card and correctly set the APN and COM port based on your setup. The code requires the GHI.Networking, Microsoft.SPOT.SerialPort, and Microsoft.SPOT.Net assemblies. Different AT commands will be needed for different modems. using GHI.Networking; using Microsoft.SPOT.Net.NetworkInformation; using System.IO.Ports; using System.Text; using System.Threading; public class Program { private static AutoResetEvent evt; private static void Main() { evt = new AutoResetEvent(false); NetworkChange.NetworkAvailabilityChanged += NetworkChange_NetworkAvailabilityChanged; using (var port = new SerialPort(\"YOUR COM PORT\", 115200, Parity.None, 8, StopBits.One)) { port.Open(); port.DiscardInBuffer(); port.DiscardOutBuffer(); SendATCommand(port, \"AT+CGDCONT=2,\\\"IP\\\",\\\"YOUR APN\\\"\"); SendATCommand(port, \"ATDT*99***2#\"); using (var netif = new PPPSerialModem(port)) { netif.Open(); netif.Connect(PPPSerialModem.AuthenticationType.Pap, \"\", \"\"); evt.WaitOne(); //The network is now ready to use. } } } private static void NetworkChange_NetworkAvailabilityChanged(object sender, NetworkAvailabilityEventArgs e) { if (e.IsAvailable) evt.Set(); } private static void SendATCommand(SerialPort port, string command) { var sendBuffer = Encoding.UTF8.GetBytes(command + \"\\r\"); var readBuffer = new byte[256]; var read = 0; port.Write(sendBuffer, 0, sendBuffer.Length); while (true) { read += port.Read(readBuffer, read, readBuffer.Length - read); var response = new string(Encoding.UTF8.GetChars(readBuffer, 0, read)); if (response.IndexOf(\"OK\") != -1 || response.IndexOf(\"CONNECT\") != -1) break; } } } SSL SSL allows you to secure the communications between your device and a remote server. Currently only SSL2, SSL3, and TLS1.0 are supported. Your NETMF device must have the proper time set for SSL to function. Unlike your PC, NETMF devices do not maintain a database of root certificates which are used to verify a remote server is who it says it is. As a result, you must manually include the root certificate for the site you are connecting to in your project. One easy way to accomplish this is to go to the site in your browser, click the padlock icon near the address bar, view the certificate, and then go to the Certification Path tab, click the top most (the root) certificate entry, view it, then under Details, copy it to a file, making sure to use base 64 encoding. Add that file as a resource to your project. Unfortunately, this will not always work. Some sites present different certificates based on who it detects it asking for them. Additionally, some certificates may be cross signed where there is another root you must use. You can try to search online for the actual root certificate or use Wireshark or a similar program. To use Wireshark, capture the traffic from the device when you try to connect to the desired site. It should fail since you do not have the correct certificate. Early in the conversation, after the \"Server Hello\" packet, find a \"Certificate\" packet. Under the SSL > Handshake Protocol > Certificates, find the very last entry. Make sure it is its own issuer. If not, you must use the issuer as the root certificate. For example, when connecting to https://www.google.com/ , the very last certificate is GeoTrust Global CA. In the browser, it is issued by itself. In Wireshark from our device however, it is actually issued by Equifax Secure Certificate Authority. Once you have added it to your project, you can use the below code to communicate with that site: just pass in the URL you want to download and the root certificate. It requires the Microsoft.SPOT.Native and System.Http assemblies. When connecting to different sites, make sure to repeat the same process and get their root certificate as well. You are also required to update the SSL seed using MFDeploy or FEZ Config any time you update the firmware. void DownloadOverSsl(string url, byte[] certificate) { using (var request = HttpWebRequest.Create(url) as HttpWebRequest) { request.HttpsAuthentCerts = new X509Certificate[] { new X509Certificate(certificate) }; request.KeepAlive = false; using (var response = request.GetResponse()) { using (var stream = response.GetResponseStream()) { var result = string.Empty; var buffer = new byte[4096]; var read = 0; stream.ReadTimeout = 5000; for (var left = response.ContentLength; left > 0; ) { Thread.Sleep(1000); try { read = stream.Read(buffer, 0, buffer.Length); } catch { continue; } left -= read; result += new string(Encoding.UTF8.GetChars(buffer, 0, read)); } Debug.Print(result); } } } } If you do not want to use the HTTP classes, you can use a raw socket. After you have called Connect on the desired socket, pass it to the constructor of SslStream found in System.Net.Security. You then have to call AuthenticateAsClient on it. The first parameter is the common name. Often that is the host portion of the URL, such as \"www.ghielectronics.com\", but it is not always. To find the common name of the site, look at the \"Issued To\" field on the certificate details window. The next parameter is null, followed by an X509Certificate array containing the root certificate. The last two parameters need to be SslVerification.CertificateRequired and SslProtocols.Default. Once that call completes, you can read and write to that stream. Calls to Read will not always succeed, especially if called in rapid succession. You should wait a bit between calls. Waits up to 1 second can be expected depending on your exact network characteristics. We recommend testing different lengths and calibrating the wait for your needs."
  },
  "software/netmf/tutorials/pulse-feedback.html": {
    "href": "software/netmf/tutorials/pulse-feedback.html",
    "title": "Pulse Feedback",
    "keywords": "Pulse Feedback Introduction The PulseFeedback class can be found in the GHI.Hardware assembly and can be used in three different modes. The first mode is EchoDuration. This mode sends a pulse of a given length and state over the provided pin. It then waits for an echo on the other specified pin and measures how long in microseconds that echo pulse was. The echo and pulse pin can be the same if required. The next mode is DurationUntilEcho. It is very similar to EchoDuration, though instead of sending a pulse and measuring the length of the resulting echo, it measures how long it takes until that echo is received. The below example illustrates sending a pulse of 10us and reading an echo on the same pin where both the pulse and echo are high. A constructor overload is available that allows you to specify a different echo pin and state. using GHI.IO; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; using System.Threading; public class Program { public static void Main() { var pulse = new PulseFeedback(PulseFeedback.Mode.EchoDuration, true, 10, Cpu.Pin.GPIO_NONE); while (true) { Debug.Print(pulse.Read().ToString()); Thread.Sleep(250); } } } Measuring Capacitance The final mode is DrainDuration. This mode is often used in capacitive touch. When calling Read, the pulse line will be held in the specified state for the specified length and then is set to an input. When a resistor and capacitor are connected to this pin and ground, the pin will fall to ground after a short period of time dependent on the capacitance on the pin. The below image shows a sample circuit. Do note that this mode can only be used with a single pin. The exact values of the capacitor and resistor will depend on your setup. Generally a resistor in the megaohm range and a capacitor in the low picofarads in acceptable. Pin Example This image shows an example pin capture for each of the modes. It is not drawn to scale. The area marked by the arrows is the time measured for each mode. Remember that the pulse and echo may be on separate pins. Timeouts A call to Read will block until the expected pin state has occurred or the timeout has expired. In the latter case, -1 will be returned. The ReadTimeout property controls this."
  },
  "software/netmf/tutorials/pwm.html": {
    "href": "software/netmf/tutorials/pwm.html",
    "title": "PWM",
    "keywords": "PWM PWM is used to control of the ratio of a pin's high and low state, the \"duty cycle.\" This can be done using software or using built-in PWM pins on the processor. PWM pins have the advantage over Software PWM because the toggling is independent of the CPU. Software PWM is performed using the SignalGenerator class. PWM objects are constructed with the period and duration of the pulse. The duration is how long the pin is high or active while the period is the time between one duration and the next. \"Duty Cycle\" is the ratio of the duration and the period -- as a convenience, a scale can be set. The scale is applied to the numbers assigned to the PWM's properties. A pin with duty cycle 0.5 will be high half the time and low the other half. Some common uses of PWM: control the intensity of lights and the speed of motors by changing the duty-cycle. generate audio tones by keeping the duty-cycle at 50% and changing the frequency. positioning of a servo by using a pulse with a specific duration or width. .NET Micro Framework PWM Channels In NETMF, the PWM pins are defined in the \"Cpu.PWMChannel\" enumeration. As the enumeration has a limited number of members, the number of PWM pins may exceed the members. Casting can be used for those extra PWMs. // Using the enumeration PWM MyServo = new PWM(Cpu.PWMChannel.PWM_3, 2175, 175, PWM.ScaleFactor.Microseconds, false); // Lots of PWMs on processor, use a cast to access an extra PWM PWM LED = new PWM((Cpu.PWMChannel)9, 10000, 0.10, false); > [!Tip] > The examples shown below require the Microsoft.SPOT.Hardware.PWM assembly; > [!Warning] > Some or all PWM pins share the same timers internally. This means the changing frequency on one pin will also effect the others. However, the duty cycle can be different on all pins. Users needing to determine which pins share the same timer have two options. Either use trial and error on all PWM pins or check the processor manual. ## Controlling LEDs Brightness This example starts the LED at 0% intensity then slowly steps up to full intensity, after which it reverts to 0% and starts over. ```cs using System.Threading; using Microsoft.SPOT.Hardware; public class Program { static PWM MyFader = new PWM(Cpu.PWMChannel.PWM_0, 10000, 0.1, false); public static void Main() { double i = 0.0; while (true) { MyFader.DutyCycle = i; /* DutyCycle is not dynamic so make a call to * Start() to refresh the object */ MyFader.Start(); if ((i += 0.1) >= 1.0) { i = 0.0; } Thread.Sleep(10); } } } Musical Tones Music notes have specific frequencies, for example C is about 261Hz. Plugging these numbers into an array and knowing the length of each tone is all that is needed to play some simple music. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { const int NOTE_C = 261; const int NOTE_D = 294; const int NOTE_E = 330; const int NOTE_F = 349; const int NOTE_G = 392; const int WHOLE_DURATION = 1000; const int EIGHTH = WHOLE_DURATION / 8; const int QUARTER = WHOLE_DURATION / 4; const int QUARTERDOT = WHOLE_DURATION / 3; const int HALF = WHOLE_DURATION / 2; const int WHOLE = WHOLE_DURATION; //make sure the two below arrays match in length. each duration element corresponds to //one note element. static int[] note = { NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_E, NOTE_D, NOTE_D, NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_D, NOTE_C, NOTE_C}; static int[] duration = { QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, HALF, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, WHOLE}; public static void Main() { PWM MyPWM = new PWM(Cpu.PWMChannel.PWM_3, 261, 0.50, false); while (true) { for (int i = 0; i < note.Length; i++) { MyPWM.Stop(); MyPWM.Frequency = note[i]; MyPWM.Start(); Thread.Sleep(duration[i]); } Thread.Sleep(100); } } } Servos For the servo in this example, if the pulse width is about 1.25ms then the servo is at 0 degrees. Increasing the pulse width to 1.50ms will move the servo to 90 degrees (neutral). A wider pulse of 1.75ms will move the servo to 180 degrees. Servos expect a pulse every 20ms to 30ms. It is important for the high pulse to be between 1.25ms and 1.75ms so that the servo's position is set properly. The code below will move the position of the servo to 180 degrees (using a pulse of 1.75ms). It uses a pause time between pulses of 20ms. So the period is 21.75ms and a duration of 1.75ms. Note the use of \"scale\". using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { PWM MyServo = new PWM(Cpu.PWMChannel.PWM_3, 2175, 1750, PWM.ScaleFactor.Microseconds, false); while (true) { // 0 degrees. 20ms period and 1.25ms high pulse MyServo.Duration = 1250; MyServo.Period = 20000; MyServo.Start(); Thread.Sleep(1000); // 90 degrees. 20ms period and 1.50ms high pulse MyServo.Duration = 1500; MyServo.Period = 20000; MyServo.Start(); Thread.Sleep(1000); // 180 degrees. 20ms period and 1.75ms high pulse MyServo.Duration = 1750; MyServo.Period = 20000; MyServo.Start(); Thread.Sleep(1000); } } }"
  },
  "software/netmf/tutorials/register-access.html": {
    "href": "software/netmf/tutorials/register-access.html",
    "title": "Register Access",
    "keywords": "Register Access Introduction To make the processor registers directly available to developers, We added the Register class. Register PCONP = new Register(0xE01FC0C4); // Enable timer2 and timer3 PCONP.SetBits((1 << 22) | (1 << 23)); Do you understand why 1 << 22 was used? It's easy to get the first bit (0x01), second bit (0x02) and so on but what about the higher bits such as 0x00400000? Which bit is this one? Instead of complicating things, let the compiler do the work for you. Simply use 1 << 22 for the 22nd bit. Pulse Counter NETMF doesn't have a way to count pulses. What if the processor supports it? Here is an example that sets timer 3 and P0.4 on the LPC2478 processor to count pulses. While this code will compile on any platform, it will only work on LPC2478. Other processors have different registers and different features. Tip You will need the LPC2478 datasheet and manuall to fully understand the example. using System; using System.Threading; using Microsoft.SPOT; using GHI.Processor; namespace MFConsoleApplication1 { public class Program { public static void Main() { Register PCONP = new Register(0xE01FC0C4); PCONP.SetBits(1 << 22);//enable timer2 // Select IO0 on EMX CAP2.0 Register PINSEL0 = new Register(0xE002C000); PINSEL0.SetBits((3 << 8));//set bits 8 and 9 // To enable timer/counter Register T2TCR = new Register(0xE0070004); T2TCR.Value = 1; // set prescale to 0 Register T2PR = new Register(0xE007000C); T2PR.Value = 0; Register T2CTCR = new Register(0xE0070070); T2CTCR.Value = (2 << 0 | 0 << 2);//count on falling edge and use CAPn.0 // should be 0 for a counter Register T2CCR = new Register(0xE0070028); T2CCR.ClearBits(0x07); // Don't do anything on match Register T2MCR = new Register(0xE0070014); T2MCR.Value = 0; // To reset the counter T2TCR.SetBits((1 << 1)); T2TCR.ClearBits((1 << 1)); // To read Register T2TC = new Register(0xE0070008); while (true) { uint count = T2TC.Value; Debug.Print(\"Total count: \" + count); Thread.Sleep(1000); } } } }"
  },
  "software/netmf/tutorials/rlp.html": {
    "href": "software/netmf/tutorials/rlp.html",
    "title": "Runtime Loadable Procedures",
    "keywords": "Runtime Loadable Procedures Introduction In .NET Micro Framework, C# is complied to an intermediate languages that is interpreted by the Common Language Runtime (CLR). The C# you write is not executed directly by processor. In a typical application, you will not see much difference in speed as many objects used in your application are implemented as native code internally and are not interpreted. When running processor intensive tasks, like cryptography algorithms or even as simple as calculating CRC, however, you will likely notice the interpreter overhead. GHI's Runtime Loadable Procedures (RLP) allow you to write and compile native code that you load onto the device and execute from the interpreted C#. Installing the compiler Since you are writing native code for an ARM device, you cannot easily use Visual Studio. Yagarto provides a helpful toolchain for compiling native code for ARM. Download and then install the following programs in order. Make sure the install paths do not have any spaces in them. Compiling will not function if they do. yagarto-bu-2.23.1_gcc-4.7.2-c-c++_nl-1.20.0_gdb-7.5.1_eabi_20121222.exe yagarto-tools-20121018-setup.exe You can verify the correct installation by running make --version and arm-none-eabi-gcc --version from a command prompt. Getting Started Download and extract the samples found here . The RLP.h file found in the Native directory is a header that defines our extensions and helpers that make it easier to write your native code. You will also see a folder for each supported platform. Within each platform, there are four files. makefile and LinkerScript.lds are basic scripts that we provide to get started with compiling your program. You will not normally need to edit them. Build.bat will actually compile your code for you and produce an elf and map file as output. NativeCode.c is an example file that shows you some basic functions. You can modify it and add your own functions. Every function you write that you want to be called from managed code must have the following signature: int YourFunc(void** args); When you invoke that function from the managed side, any arguments you pass will be found in that void** parameter. If you pass five arguments, then args will be an array of five void pointers. It is your job to then cast each of these pointers to their native equivalent. The following table shows the supported NETMF parameter types and their native equivalent: | C# Parameter | Native Parameter | | byte | unsigned char | | sbyte | char | | short | short | | ushort | unsigned short | | int | int | | uint | unsigned int | | long | long | | ulong | unsigned long | | float | float | | double | double | | bool | unsigned char | | Bitmap | unsigned short[] | Arrays of each of the above parameters (except bitmaps) are also supported. When passing a non-array parameter, it is by value. Any changes to these parameters on the native side are not seen on the managed side. Arrays, however, are passed by reference. Any change to the value of a member of an array is seen on the managed side. Make sure to not read or write past the end of the array. It is up to you to track its length, perhaps through a second parameter you pass. For example, imagine you have passed an integer, a byte array, its length, and a boolean down to the native side. You can retrieve those parameters using the following code: int YourFunc(void** args) { int arg1 = *(int*)(args[0]); //the integer unsigned char* arg2 = (unsigned char*)(args[1]); //the byte array int arg3 = *(int*)(args[2]); //the length of the byte array unsigned char arg4 = *(unsigned char*)(args[3]); //the boolean } When you pass a primitive value, you simple cast the void pointer to a pointer of the corresponding native type and dereference it. When the argument is an array, you again cast the void pointer to a pointer of the corresponding native type but you do not reference it. You can dereference that pointer as if it were an array. Again, make sure to not read beyond its length. Warning Make sure you do not store the pointer to a passed array parameter between function invocations. The array is managed by the CLR and the garbage collector may relocate it between invocations. If you want to pass data outside of the parameters to Invoke for performance reasons, you can allocate a buffer on the native side and return its address to managed code. From there, you can read and write to that buffer using Register and AddressSpace. Compiling Once you have written your code, in the folder that contains makefile, LinkerScript.lds, and NativeCode.c run the file Build.bat. You will see some compiler output and an elf and a map file will appear in the directory. Both files will be called [board name]RLP. The ELF file is the one that you will need to load into RLP from the managed code. To be able to invoke the native function from managed code, you must get the compiled ELF file into a byte array in the managed side. You can save the ELF file as a resource, to an SD card, or to the network and then read or download it. Warning If the native code you execute hangs or crashes, NETMF and the device will become unresponsive. It is recommended that you do not execute any RLP code as soon as the board boots because if it crashes you will have no way to redeploy a program requiring you to completely erase and reflash the board. Invoking Your Function The below code shows you how to load the byte array representing the ELF file into RLP and calling it natively. (It assumes you have added the ELF file as a resource to your C# project.) You pass the name of your native function into the FindFunction function and it will return an object that you can call Invoke() on and pass parameters. We will use the same four parameters as above, an integer, byte array, its length, and a boolean. This code requires the GHI.Hardware assembly. using GHI.Processor; using Microsoft.SPOT; public class Program { public static void Main() { byte[] elfBuffer = Resources.GetBytes(Resources.BinaryResources.ELFFile); //Make sure to load the ELF file you compiled into this array. var elfImage = new RuntimeLoadableProcedures.ElfImage(elfBuffer); var yourFunction = elfImage.FindFunction(\"YourFunc\"); var byteArray = new byte[] { 25, 5, 0 }; int anInteger = 5; var result = yourFunction.Invoke(anInteger, byteArray, byteArray.Length, true); Debug.Print(\"The function returned \" + result.ToString()); //Should be 5 Debug.Print(\"The third element of the byte array is \" + byteArray[2].ToString()); //Should be 30 } } Now imagine we defined the native function like this: int YourFunc(void** args) { int arg1 = *(int*)(args[0]); //the integer unsigned char* arg2 = (unsigned char*)(args[1]); //the byte array int arg3 = *(int*)(args[2]); //the length of the byte array unsigned char arg4 = *(unsigned char*)(args[3]); //the boolean if (arg4 != 0) arg2[2] = arg2[0] + arg2[1]; return arg1; } The first parameter, the integer, is returned from the function. You can access that value as the return value of the Invoke function in the managed side. The above C# example prints out that value. If the fourth parameter, the boolean, is not false (0 is false, otherwise it is true) we will add the first and second elements of the byte array and store the result in the third element. You will see the change to the array in the managed side. Events and Tasks Sometimes you might have a long running function that runs in RLP. Since RLP blocks the managed side, nothing else on the board will run for the duration of the that function call. Using RLP tasks, your native function can register a function to be called at some future point so that you can return to NETMF. As long as this callback function is short lived, the managed side will continue to execute. You can break your work up into smaller chunks that are worked on during each callback invocation. When you are done, you can trigger an event on the managed side. Make sure to re-register the callback so long as there is more work to do. The below example passes the first and only argument passed to RLP into the task and then fires that many events. It schedules itself to fire again in one second until the parameter is zero. RLP_Task task; void TaskCallback(void* arg) { unsigned int* count = (unsigned int*)arg; RLP->PostManagedEvent(*count); if (*count > 0) { *count -= 1; RLP->Task.ScheduleTimeOffset(&task, 1000000); } else { RLP->Task.Abort(&task); } } int StartTask(void** args) { RLP->Task.Initialize(&task, TaskCallback, args[0], RLP_FALSE); RLP->Task.Schedule(&task); return 1; } As before, we create and invoke the RLP function object but we also subscribe to the NativeEvent event and then print out the value received. Every time PostManagedEvent is called from the native side, this event will be fired with the data passed to it. In this example, it should be fired six times, printing out 5, 4, 3, 2, 1, and then 0. using GHI.Processor; using Microsoft.SPOT; using System.Threading; public class Program { public static void Main() { byte[] elfBuffer = Resources.GetBytes(Resources.BinaryResources.ELFFile); //Make sure to add an ELF file as a resource RuntimeLoadableProcedures.NativeEvent += RuntimeLoadableProcedures_NativeEvent; var elfImage = new RuntimeLoadableProcedures.ElfImage(elfBuffer); var startTask = elfImage.FindFunction(\"StartTask\"); startTask.Invoke(5); Thread.Sleep(-1); } private static void RuntimeLoadableProcedures_NativeEvent(object sender, RuntimeLoadableProcedures.NativeEventEventArgs e) { Debug.Print(\"We've received \" + e.Data.ToString() + \" from the native side.\"); //Should be 5 to 0 } } Bitmaps You can also pass bitmaps to RLP. You will receive an unsigned short array in the argument list. Changes made to that array will be reflected in the bitmap back in C#. As with all arrays, make sure not to save it between invocations or read beyond its end. Its length is equal to bitmap.Width x bitmap.Height. Each entry in the array represents one pixel in RGB 565 format. You can access a pixel using the following code: void SetPixel(unsigned short* bmp, int x, int y, int bitmapWidth, unsigned short color) { bmp[y * bitmapWidth + x] = color; } Multiple Files If you load more than one ELF image at a time, you must be sure that all images after the first occupy a unique location in RAM. The header and linker scripts we provide place the ELF image at a certain default location. You must change that for the second file so that you do not overwrite the first file when you load the second. When compiling, you should see a map file created as one of the outputs. This file tells you exactly how big and where each function is located. You can use it to determine where your second image must start."
  },
  "software/netmf/tutorials/rtc.html": {
    "href": "software/netmf/tutorials/rtc.html",
    "title": "Real Time Clock",
    "keywords": "Real Time Clock Introduction Systems typically have a Real Time Clock (RTC) that uses a backup battery (VBAT) and a separate crystal to keep time running even if the system is not powered. Typical crystal value is 32.768Khz. Consult your product's documentation to see if it has a built in RTC. Note: NETMF has time services that you can use to get/set the system time such as DateTime.Now. When power is lost or the system is reset, the time is also reset. Those services do not need RTC. An application can set proper time by reading from the RTC (running from a separate always-on power) or from the internet through a time server. Not having RTC will not limit NETMF's time services beyond resetting the date and time to a preset value. Time measurement is still available. Time via NETMF This example sets the current time to a predefined value that is lost when power is lost. using System; using System.Threading; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { //Set the time to 07/25/2012 at 11:46:11 DateTime time = new DateTime(2012, 07, 25, 11, 46, 11); // lost after power cycle or reset: Utility.SetLocalTime(time); while (true) { Debug.Print(DateTime.Now.ToString()); Thread.Sleep(100); } } } Using GHI's extension for Real Time Clock To use the RTC hardware, we first need to check if the RTC hardware has the valid time or not. If RTC has a valid time then we can read from the RTC and use that to set the NETMF system time. If time is not valid, then you will need to set the RTC to the correct time. You can verify the validilty of the RTS several ways. One way is to use the built in battery ram (if available) to store some \"magic numbers\" that we check later to determine if the battery ram data is still valid. If they are then most likely the RTC is valid. You can also check the RTC against some known time. For example, if your program was written on 1/1/2014, you can check to see if the current RTC date is before that known date. If it is, then the time is incorrect. using System; using GHI.Processor; using Microsoft.SPOT; public class Program { public static void Main() { DateTime DT; try { DT = RealTimeClock.GetDateTime(); Debug.Print(\"Current Real-time Clock \" + DT.ToString()); } catch // If the time is not good due to powerloss or being a new system an exception will be thrown and a new time will need to be set { Debug.Print(\"The date was bad and caused a bad time\"); DT = new DateTime(2014, 1, 1, 1, 1, 1); // This will set a time for the Real-time Clock clock to 1:01:01 on 1/1/2014 RealTimeClock.SetDateTime(DT); //This will set the hardware Real-time Clock to what is in DT } if (DT.Year < 2011) { Debug.Print(\"Time is not resonable\"); } Debug.Print(\"Current Real-time Clock \" + RealTimeClock.GetDateTime().ToString()); DT = new DateTime(2014, 9, 15, 7, 30, 0); // This will set the clock to 9:30:00 on 9/15/2014 RealTimeClock.SetDateTime(DT); //This will set the hardware Real-time Clock to what is in DT Debug.Print(\"New Real-time Clock \" + RealTimeClock.GetDateTime().ToString()); } }"
  },
  "software/netmf/tutorials/signal-capture.html": {
    "href": "software/netmf/tutorials/signal-capture.html",
    "title": "Signal Capture",
    "keywords": "Signal Capture Introduction The SignalCapture class monitors a pin and records any changes (high-low or low-high transitions) of the pin into an array. It is a digital waveform recorder. Each array element is the number of microseconds between each signal change. SignalCapture is a GHI Electronics' extension to NETMF. It requires the GHI.Hardware assembly. using System.Threading; using Microsoft.SPOT.Hardware; using GHI.IO; public class Program { public static void Main() { uint[] signal = new uint[100]; SignalCapture pin = new SignalCapture(Cpu.Pin.GPIO_Pin1, Port.ResistorMode.Disabled); pin.Read(false, signal); // ... // process the \"signal\" } } Timeouts When calling read, it blocks until it has read as much data as the buffer can hold or you specify using the count parameter. If your signal is shorter than that, the call will never return. Make sure to request only what you plan to capture. Alternatively, you can use the ReadTimeout property to signal to the call to return after the number of milliseconds specified by the property regardless of how much data you captured."
  },
  "software/netmf/tutorials/signal-generator.html": {
    "href": "software/netmf/tutorials/signal-generator.html",
    "title": "Signal Generator",
    "keywords": "Signal Generator Introduction SignalGenerator is non-blocking digital waveform generator. SignalGenerator works by comparing an internal counter to an array of time values, one by one; when the value of the argument matches the counter, the output pin is changed. The values are in microseconds. SignalGenerator can also be used to generate PWM; unlike the PWM class, SignalGenerator can be used to generate PWM on any available output pins; however, it uses a processor time, the higher the frequency the more processing it uses. SignalGenerator can operate in two modes: non-blocking: runs in the background using system interrupts, and blocking: which does block (while it is running, it does not yield time to other code). This mode has higher accuracy (used, for example, to generate carrier frequencies for infrared signals). Blinking LED This example uses an array of toggle times to turn the LED on and off. The state of the the pin controlled by SignalGenerator will change after waiting for the durations specified in an array. Onces all the elements have been used; SignalGenerator will, optionally, start over at the beginning of the array. using Microsoft.SPOT.Hardware; using GHI.IO; public class Program { public static void Main() { uint[] time = new uint[] { 500 * 1000, 500 * 1000 }; SignalGenerator LED = new SignalGenerator(Cpu.Pin.GPIO_Pin1, false); // args: initial value, // array of times, // array start offset, // length of array, // repeat -- if true ==> repeat LED.Set(false, time, 0, 2, true);//start the waveform //... do more code here and the LED will continue to work. //... because the default running mode is non-blocking. } }"
  },
  "software/netmf/tutorials/spi.html": {
    "href": "software/netmf/tutorials/spi.html",
    "title": "SPI",
    "keywords": "SPI SPI uses three, sometimes four, wires for transferring data. The bus on SPI consists of one master and one or more slaves. The master will send clock to the salves along with data and will read back using the same clock. This clock is used to determine how fast the data is moved. If you know electronics, this is a shift register. So, the master will transmit a clock on a SCK (serial clock) pin and will simultaneously transmit the data on MOSI (Master Out Slave In) pin. The slave will read the clock on SCK pin and simultaneously read the data from MOSI pin. So far, this is a one way communication. While data is transmitted in one direction using MOSI another set of data is sent back on MISO (Master In Slave Out) pin. Other data sizes are possible but bytes are most common. NETMF supports 8-bit (byte) and 16-bit (short) data transfers. Because of this master/slave scheme, we can add multiple slaves on the same bus where the master selects which slave it will swap the data with. Note I am using the word swap because you can never send or receive but you always send and receive (swap) data. The master selects one of the slaves using SSEL (Slave Select) pin. This pin can be called CS (Chip Select) as well. In theory, the master can have unlimited slaves but it can only select one of them at any given time. The master will only need 3 wires (SCK, MISO, MOSI) to connect to all slaves on the bus but then it needs a separate SSEL pin for each one of the slaves. Some SPI devices (slaves) can have more than one select pin, like VS1053 MP3 decoder chip that uses one pin for data and one pin for commands but both share the 3 data transfer pins (SCK, MOSI, MISO). SPI needs more wires than other similar buses but it can transfer data very fast. A 50Mhz clock is possible on SPI, that is 50 million bits in one second. Note that NETMF devices are always SPI masters, not slaves. Before creating a SPI object, we would need a SPI configuration object. The configuration object is used to set the states of the SPI pins and some timing parameters. In most cases, you need the clock to be idle low (false) with clocking on rising edge (true) and with zero for select setup and hold time. The only thing you would need to set is the clock frequency. Some devices may accept high frequencies but others do not. Setting the clock to 1000Khz (1Mhz) should be okay for a starter Getting Started This example is sending/receiving 10 bytes of data on SPI channel 1. Note: NETMF start numbering SPI channels (module) from 1, but on processors the channels start from 0 typically. So, using SPI1 in code is actually using SPI0 on the processor. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { SPI.Configuration MyConfig = new SPI.Configuration(Cpu.Pin.GPIO_Pin1, false, 0, 0, false, true, 1000, SPI.SPI_module.SPI1); SPI MySPI = new SPI(MyConfig); byte[] tx_data = new byte[10]; byte[] rx_data = new byte[10]; MySPI.WriteRead(tx_data, rx_data); Thread.Sleep(100); } } Accessing Multiple Devices The SPI object on NETMF is a representation of the \"bus\" and not the \"device\", so you can't construct multiple SPI objects, unless it uses a different SPI bus. To access multiple SPI devices you need to have multiple configurations and then when accessing device \"A\" we need to use configuration \"A\" and when accessing device \"B\" we need to use configuration \"B\". using Microsoft.SPOT.Hardware; public class Program { public static void Main() { SPI.Configuration ConfigDeviceA = new SPI.Configuration(Cpu.Pin.GPIO_Pin1, false, 0, 0, false, true, 1000, SPI.SPI_module.SPI1); SPI.Configuration ConfigDeviceB = new SPI.Configuration(Cpu.Pin.GPIO_Pin4, false, 0, 0, false, true, 1000, SPI.SPI_module.SPI1); SPI MySPI = new SPI(ConfigDeviceA); byte[] tx_data = new byte[10]; byte[] rx_data = new byte[10]; // accessing device A MySPI.Config = ConfigDeviceA; MySPI.WriteRead(tx_data, rx_data); // accessing device B MySPI.Config = ConfigDeviceB; MySPI.WriteRead(tx_data, rx_data); } }"
  },
  "software/netmf/tutorials/sqlite.html": {
    "href": "software/netmf/tutorials/sqlite.html",
    "title": "SQLite Database",
    "keywords": "SQLite Database Introduction According to the SQLite homepage, \"SQLite is a software library that implements a self-contained, serverless, zero-configuration, transactional SQL database engine. SQLite is the most widely deployed SQL database engine in the world\". GHI Electronics provides a driver for SQLite so that you can have access to a SQL database that resides entirely in a simple file on a persistant storage device. The below code is a simple example where a database file is created in RAM (using SD cards and USB drives is possible as well). A table is created that is filled with some initial rows and then this data is read from the database. This data is then iterated over and printed out. ColumnOriginNames returns the names of each of the columns. using System; using System.Collections; using Microsoft.SPOT; using GHI.SQLite; public class Program { public static void Main() { // Create a database in memory, // file system is possible however! Database myDatabase = new GHI.SQLite.Database(); myDatabase.ExecuteNonQuery(\"CREATE Table Temperature\" + \" (Room TEXT, Time INTEGER, Value DOUBLE)\"); //add rows to table myDatabase.ExecuteNonQuery(\"INSERT INTO Temperature (Room, Time, Value)\" + \" VALUES ('Kitchen', 010000, 4423)\"); myDatabase.ExecuteNonQuery(\"INSERT INTO Temperature (Room, Time, Value)\" + \" VALUES ('Living Room', 053000, 9300)\"); myDatabase.ExecuteNonQuery(\"INSERT INTO Temperature (Room, Time, Value)\" + \" VALUES ('bed room', 060701, 7200)\"); // Process SQL query and save returned records in SQLiteDataTable ResultSet result = myDatabase.ExecuteQuery(\"SELECT * FROM Temperature\"); // Get a copy of columns orign names example String[] origin_names = result.ColumnNames; // Get a copy of table data example ArrayList tabledata = result.Data; String fields = \"Fields: \"; for (int i = 0; i < result.RowCount; i++) { fields += result.ColumnNames[i] + \" |\"; } Debug.Print(fields); object obj; String row = \"\"; for (int j = 0; j < result.RowCount; j++) { row = j.ToString() + \" \"; for (int i = 0; i < result.ColumnCount; i++) { obj = result[j, i]; if (obj == null) row += \"N/A\"; else row += obj.ToString(); row += \" |\"; } Debug.Print(row); } myDatabase.Dispose(); } } The details on SQLite All details on SQLite are found at the offcial SQLite website http://www.sqlite.org/"
  },
  "software/netmf/tutorials/timers.html": {
    "href": "software/netmf/tutorials/timers.html",
    "title": "Timers",
    "keywords": "Timers Introduction NETMF includes 2 timer classes, Timer and ExtendedTimes. Timer class is the same one included in full framework where ExtendedTimer is specific to NETMF with extra functionality. A timer example This example creates a timer that will run after five seconds and then it will keep firing every second. Note: the time parameters expect times in milliseconds. using System.Threading; using Microsoft.SPOT; public class Program { class OurClass { public int x; } static void RunMe(object o) { OurClass cls = (OurClass)o; Debug.Print(\"From timer!\"); Debug.Print(\"Value: \" + cls.x.ToString()); } public static void Main() { OurClass cls = new OurClass(); cls.x = 5; Timer MyTimer = new Timer(new TimerCallback(RunMe), cls, 5000, 1000); Debug.Print( \"The timer will fire in 5 seconds and then fire priodically every 1 second\"); Thread.Sleep(Timeout.Infinite); } }"
  },
  "software/netmf/tutorials/touch.html": {
    "href": "software/netmf/tutorials/touch.html",
    "title": "Touch",
    "keywords": "Touch Introduction NETMF devices have the ability to receive touch input from a touch screen. Getting Started The below code draws a blue circle wherever you touch on the display. Make sure that you have configured your display properly before running this example. It requires the Microsoft.SPOT.Graphics, Microsoft.SPOT.TinyCore, and Microsoft.SPOT.Touch assemblies. using Microsoft.SPOT; using Microsoft.SPOT.Input; using Microsoft.SPOT.Presentation; using Microsoft.SPOT.Presentation.Media; using Microsoft.SPOT.Touch; public class Program : Application { private Bitmap lcd; public static void Main() { Program app = new Program(); app.Run(); } public Program() { this.lcd = new Bitmap(SystemMetrics.ScreenWidth, SystemMetrics.ScreenHeight); Touch.Initialize(this); this.MainWindow = new Window(); this.MainWindow.TouchDown += MainWindow_TouchDown; this.MainWindow.TouchUp += MainWindow_TouchUp; this.MainWindow.TouchMove += MainWindow_TouchMove; } private void MainWindow_TouchMove(object sender, TouchEventArgs e) { Debug.Print(\"Touch move at (\" + e.Touches[0].X.ToString() + \", \" + e.Touches[0].Y.ToString() + \")\"); this.lcd.DrawEllipse(Colors.Blue, e.Touches[0].X, e.Touches[0].Y, 5, 5); this.lcd.Flush(); } private void MainWindow_TouchUp(object sender, TouchEventArgs e) { Debug.Print(\"Touch up at (\" + e.Touches[0].X.ToString() + \", \" + e.Touches[0].Y.ToString() + \")\"); } private void MainWindow_TouchDown(object sender, TouchEventArgs e) { Debug.Print(\"Touch down at (\" + e.Touches[0].X.ToString() + \", \" + e.Touches[0].Y.ToString() + \")\"); } } Touch In Gadgeteer Since Gadgeteer already creates an application instance, you cannot use the above example in a Gadgeteer program. You must instead use the pre-created application instance available under Application.Current. The below example shows you how to use touch in a Gadgeteer program. Tip In the below example we still use a Bitmap object to draw to the display. Usually in Gadgeteer programs you will want to use the SimpleGraphics interface on a display module. using Microsoft.SPOT; using Microsoft.SPOT.Input; using Microsoft.SPOT.Presentation; using Microsoft.SPOT.Presentation.Media; using Microsoft.SPOT.Touch; public partial class Program { private Bitmap lcd; void ProgramStarted() { this.lcd = new Bitmap(SystemMetrics.ScreenWidth, SystemMetrics.ScreenHeight); Touch.Initialize(Application.Current); this.display.WPFWindow.TouchDown += this.MainWindow_TouchDown; this.display.WPFWindow.TouchUp += this.MainWindow_TouchUp; this.display.WPFWindow.TouchMove += this.MainWindow_TouchMove; } private void MainWindow_TouchMove(object sender, TouchEventArgs e) { Debug.Print(\"Touch move at (\" + e.Touches[0].X.ToString() + \", \" + e.Touches[0].Y.ToString() + \")\"); this.lcd.DrawEllipse(Colors.Blue, e.Touches[0].X, e.Touches[0].Y, 5, 5); this.lcd.Flush(); } private void MainWindow_TouchUp(object sender, TouchEventArgs e) { Debug.Print(\"Touch up at (\" + e.Touches[0].X.ToString() + \", \" + e.Touches[0].Y.ToString() + \")\"); } private void MainWindow_TouchDown(object sender, TouchEventArgs e) { Debug.Print(\"Touch down at (\" + e.Touches[0].X.ToString() + \", \" + e.Touches[0].Y.ToString() + \")\"); } } Calibration If your screen does not report touches close to where they actually were, your screen may need to be calibrated. NETMF provides functionality that can do this for you. It will give you a list of coordinates to touch at based on the configured screen size and then you give it the coordinates returned when you touch that spot on the display. It usually asks for five points: the four corners and the center. The below example takes care of all of this calibration for you. It requires the Microsoft.SPOT.Native, Microsoft.SPOT.Graphics, Microsoft.SPOT.TinyCore, and Microsoft.SPOT.Touch assemblies. You begin calibration by touching the screen once. After that, touch where each of the five circles is displayed in turn. After you do that, it will show you the calibration data and show a circle wherever you touch. using Microsoft.SPOT; using Microsoft.SPOT.Input; using Microsoft.SPOT.Presentation; using Microsoft.SPOT.Presentation.Media; using Microsoft.SPOT.Touch; public class Program : Application { private Bitmap lcd; private bool started; private bool finished; private int currentCalibrationPoint; private int calibrationPoints; private short[] screenX; private short[] screenY; private short[] uncalibratedX; private short[] uncalibratedY; public static void Main() { new Program().Run(); } public Program() { this.lcd = new Bitmap(SystemMetrics.ScreenWidth, SystemMetrics.ScreenHeight); Touch.Initialize(this); this.MainWindow = new Window(); this.MainWindow.TouchUp += this.OnTouchUp; this.currentCalibrationPoint = 0; this.calibrationPoints = 0; this.started = false; this.finished = false; Touch.ActiveTouchPanel.GetCalibrationPointCount(ref this.calibrationPoints); this.screenX = new short[this.calibrationPoints]; this.screenY = new short[this.calibrationPoints]; this.uncalibratedX = new short[this.calibrationPoints]; this.uncalibratedY = new short[this.calibrationPoints]; for (int i = 0, x = 0, y = 0; i < this.calibrationPoints; i++) { Touch.ActiveTouchPanel.GetCalibrationPoint(i, ref x, ref y); this.screenX[i] = (short)x; this.screenY[i] = (short)y; } Touch.ActiveTouchPanel.StartCalibration(); } private void OnTouchUp(object sender, TouchEventArgs e) { if (this.started && !this.finished) { this.uncalibratedX[this.currentCalibrationPoint] = (short)e.Touches[0].X; this.uncalibratedY[this.currentCalibrationPoint] = (short)e.Touches[0].Y; if (++this.currentCalibrationPoint == this.calibrationPoints) { Touch.ActiveTouchPanel.SetCalibration(this.calibrationPoints, this.screenX, this.screenY, this.uncalibratedX, this.uncalibratedY); this.lcd.Clear(); var str = \"Screen X: [\"; for (int i = 0; i < this.calibrationPoints; i++) str += this.screenX[i].ToString() + (i + 1 != this.calibrationPoints ? \", \" : string.Empty); str += \"]\"; this.lcd.DrawText(str, Resources.GetFont(Resources.FontResources.NinaB), Colors.White, 0, 0); str = \"Screen Y: [\"; for (int i = 0; i < this.calibrationPoints; i++) str += this.screenY[i].ToString() + (i + 1 != this.calibrationPoints ? \", \" : string.Empty); str += \"]\"; this.lcd.DrawText(str, Resources.GetFont(Resources.FontResources.NinaB), Colors.White, 0, 15); str = \"Uncalibrated X: [\"; for (int i = 0; i < this.calibrationPoints; i++) str += this.uncalibratedX[i].ToString() + (i + 1 != this.calibrationPoints ? \", \" : string.Empty); str += \"]\"; this.lcd.DrawText(str, Resources.GetFont(Resources.FontResources.NinaB), Colors.White, 0, 30); str = \"Uncalibrated Y: [\"; for (int i = 0; i < this.calibrationPoints; i++) str += this.uncalibratedY[i].ToString() + (i + 1 != this.calibrationPoints ? \", \" : string.Empty); str += \"]\"; this.lcd.DrawText(str, Resources.GetFont(Resources.FontResources.NinaB), Colors.White, 0, 45); this.lcd.Flush(); this.finished = true; } else { this.DrawPoint(this.screenX[this.currentCalibrationPoint], this.screenY[this.currentCalibrationPoint]); } } else if (!this.started) { this.started = true; this.DrawPoint(this.screenX[0], this.screenY[0]); } else if (this.finished) { this.DrawPoint(e.Touches[0].X, e.Touches[0].Y); } } private void DrawPoint(int x, int y) { this.lcd.Clear(); this.lcd.DrawEllipse(Colors.Red, x, y, 6, 6); this.lcd.Flush(); } } After you calibrate your display, you can save the values in the four short arrays in the above program along with the number of calibration points. You can then pass these values at a later point, without running calibration again, to the below function. Touch.ActiveTouchPanel.SetCalibration(calibrationPoints, screenX, screenY, uncalibratedX, uncalibratedY);"
  },
  "software/netmf/tutorials/uart.html": {
    "href": "software/netmf/tutorials/uart.html",
    "title": "UART",
    "keywords": "UART UART transfers data between two pins TXD (transmit) and RXD (receive). Normally, the pins are on different processors. Data is sent from TXD, in a sequence, at a predefined speed. The receiver checks data on RXD. Usually systems want to send and recieve as well, so there will be a TXD and RXD on one end with another set on the other end. The connection in between is rossed so TXD on one end goes to RXD on the other end and vice versa. UART Technical Details The \" baud rate\" is number of bits are transmitted per second; standard baud rates are 9600, 119200, 115200 and others. Direct connection between TXD/RXD pins use their high/low voltages for bits (\"TTL level,\" 0V to 3.3V). NETMF supports serial ports (UART) in the same way as the full .NET framework. Serial ports on PC's and on NETMF are called \"COM ports.\" Their names start with COM1 and go up (there is no COM0). Processors usually start with UART0 not UART1 (so, COM1 is UART0... etc.) Software UART Through GHI's SignalGenerator, a system can simulate a UART data. This is beneficial as any GPIO pin can be used to send the UART data. A good example is a serial character display. These typically do not require speed and not updated frequently. If all UARTs are being used, any GPIO can be used to simulate a UART transmission. RS232 Processor pins can be set at 0 for low or at the power level for high, 3.3V for example. This means connecting outputs on a micro to inputs on another is safe. These levels are called TTL. In our case here a TTL UART levels. To overcome distances, the very old standard RS232 defined the low state to be +12V. Sounds like it is backwards but this is how it is! This port is found on many systems and found on many PCs. It has been disappearing from PCs lately but this can be easily added using a USB to serial cable. We can't connect the RS232 levels to TTL levels directly. This is easily solved by adding a small circuitry that converts the RS232 levels to TTL, like the MAX232 chip. In other words, do not connect a PC's serial port to a micro directly. Use a level converter in between. Example using UART The following program sends a counter value 10 times per second. The data is sent at 115200 baud so make sure that the receiving end is setup the same way. This program sends the data on COM1 of your NETMF device. This COM number has nothing to do with COM number on your PC. For example, you may have a USB serial port on your PC that maps to COM8 and so you need to open COM8 on your PC, not COM1. The NETMF program will still use COM1 because it uses UART0 (COM1). The data sent can be shown on a terminal program, like teraterm. Note how we ended the string with \"\\r\\n\". The \"\\r\" is code to tell the terminal to \"return\" back to the beginning of the line and \"\\n\" is to add \"new\" line. When data is received on UART, it is automatically queued a side so you wouldn't lose any data. Tip Using serial ports require the Microsoft.SPOT.Hardware.SerialPort. If your program uses the enums Parity or StopBits, the Microsoft.SPOT.Hardware assembly is needed. using System.IO.Ports; using System.Text; using System.Threading; public class Program { public static void Main() { SerialPort UART = new SerialPort(\"COM1\", 115200); int counter = 0; UART.Open(); while (true) { // create a string string counter_string = \"Count: \" + counter.ToString() + \"\\r\\n\"; // convert the string to bytes byte[] buffer = Encoding.UTF8.GetBytes(counter_string); // send the bytes on the serial port UART.Write(buffer, 0, buffer.Length); // increment the counter; counter++; //wait... Thread.Sleep(100); } } } Receiving Data This example will wait until a byte is received on the port and then print it telling you what was sent from the other end. using System.Threading; using System.IO.Ports; using System.Text; public class Program { public static void Main() { SerialPort UART = new SerialPort(\"COM1\", 115200); int read_count = 0; byte[] rx_byte = new byte[1]; UART.Open(); while (true) { // read one byte read_count = UART.Read(rx_byte, 0, 1); if (read_count > 0)// do we have data? { // create a string string counter_string = \"You typed: \" + rx_byte[0].ToString() + \"\\r\\n\"; // convert the string to bytes byte[] buffer = Encoding.UTF8.GetBytes(counter_string); // send the bytes on the serial port UART.Write(buffer, 0, buffer.Length); //wait... Thread.Sleep(10); } } } } Sending and Receiving This example is a loop-back. Connect a wire from TX to RX on your board and it will send data and make sure it is receiving it correctly. using System.IO.Ports; using System.Text; using System.Threading; using Microsoft.SPOT; public class Program { public static void Main() { SerialPort UART = new SerialPort(\"COM1\", 115200); int read_count = 0; byte[] tx_data; byte[] rx_data = new byte[10]; tx_data = Encoding.UTF8.GetBytes(\"FEZ\"); UART.ReadTimeout = 0; UART.Open(); while (true) { // flush all data UART.Flush(); // send some data UART.Write(tx_data, 0, tx_data.Length); // wait to make sure data is transmitted Thread.Sleep(100); // read the data read_count = UART.Read(rx_data, 0, rx_data.Length); if (read_count != 3) { // we sent 3 so we should have 3 back Debug.Print(\"Wrong size: \" + read_count.ToString()); } else { // the count is correct so check the values // I am doing this the easy way so the code is more clear if (tx_data[0] == rx_data[0]) { if (tx_data[1] == rx_data[1]) { if (tx_data[2] == rx_data[2]) { Debug.Print(\"Perfect data!\"); } } } } Thread.Sleep(100); } } } Tip For .NET Gadgeteer examples, see the Device to PC communications document."
  },
  "software/netmf/tutorials/usb-client.html": {
    "href": "software/netmf/tutorials/usb-client.html",
    "title": "USB Client",
    "keywords": "USB Client By default, all of GHI's NETMF devices use USB for deploying and debugging. You may optionally use the USB client (not the host) for something other than debugging. This is actually supported by NETMF and GHI Electronics adds more functionality making it even easier to use. Say you are making a device that that reads temperature and humidity and logs all of this data on an SD card. This device can be configured to set the time or give file names and you want this configuration to happen over USB, perhaps in the field. So when your device plugs into a USB port, you want it to show as a virtual serial port. This way, anyone can open a terminal software (like TeraTerm) to connect to your device and configure it. Using the USB client, there is no need to add the extra cost of additional RS232 serial ports or USB<->serial chipsets. The built-in USB client port can be configured to act as a CDC device, a virtual COM port. However, you still need to connect the PC to your device for debugging and deploying applications. Since the USB client port is used by your end application, you need to debug and deploy using a serial connection. You only need the serial interface in the development and deployment stage. Setting Up Debugging and deploying serially is specific to each device so you may want to consult your device's manual or Developers' Guide. Once the device is configured for the serial interface, remember to select the proper transport in Visual Studio. Tip The examples shown below require the Microsoft.SPOT.Hardware.Usb and GHI.Usb assemblies. Mouse The following example tells your device to act as a mouse and send random commands to your computer. You could use this to prank others and send their computer fake mouse commands or to have a second mouse for your own computer. using System; using System.Threading; using GHI.Usb; using GHI.Usb.Client; using Microsoft.SPOT; using Microsoft.SPOT.Hardware.UsbClient; public class Program { public static void Main() { // Start Mouse Mouse mouse = new Mouse(); Controller.ActiveDevice = mouse; // Move pointer in a swirl const int ANGLE_STEP_SIZE = 15; const int MIN_CIRCLE_DIAMETER = 50; const int MAX_CIRCLE_DIAMETER = 200; const int CIRCLE_DIAMETER_STEP_SIZE = 1; int diameter = MIN_CIRCLE_DIAMETER; int diameterIncrease = CIRCLE_DIAMETER_STEP_SIZE; int angle = 0; int factor; Random rnd = new Random(); int i = 0; while (true) { // we want to do it every sometime randomly i = rnd.Next(5000) + 5000;//between 5 and 10 seconds Debug.Print(\"Delaying for \" + i + \" ms\"); Thread.Sleep(i); i = rnd.Next(200) + 100;//do it for a short time Debug.Print(\"Looping \" + i + \" times!\"); while (i-- > 0) { // Check if connected to PC if (Controller.State == UsbController.PortState.Running) { // Note Mouse X, Y are reported as change in position // (relative position, not absolute) factor = diameter * ANGLE_STEP_SIZE * (int)System.Math.PI / 180 / 2; int dx = (-1 * factor * (int)Microsoft.SPOT.Math.Sin(angle) / 1000); int dy = (factor * (int)Microsoft.SPOT.Math.Cos(angle) / 1000); angle += ANGLE_STEP_SIZE; diameter += diameterIncrease; if (diameter >= MAX_CIRCLE_DIAMETER || diameter <= MIN_CIRCLE_DIAMETER ) diameterIncrease *= -1; // report mouse position mouse.SendRawData(dx, dy, 0,Buttons.None); } Thread.Sleep(10); } } } } Keyboard Emulating a keyboard is as very similar to emulating a mouse. The following example will create a USB Keyboard and send \"Hello world!\" to a computer every second. using System.Threading; using GHI.Usb; using GHI.Usb.Client; using Microsoft.SPOT; using Microsoft.SPOT.Hardware.UsbClient; public class Program { public static void Main() { // Start keyboard Keyboard kb = new Keyboard(); Controller.ActiveDevice = kb; Debug.Print(\"Waiting to connect to PC...\"); // Send \"Hello world!\" every second while (true) { // Check if connected to PC if ( Controller.State == UsbController.PortState.Running) { // We need shift down for capital \"H\" kb.Press(Key.LeftShift); kb.Stroke(Key.H); kb.Release(Key.LeftShift); // Now \"ello world\" kb.Stroke(Key.E); kb.Stroke(Key.L); kb.Stroke(Key.L); kb.Stroke(Key.O); kb.Stroke(Key.Space); kb.Stroke(Key.W); kb.Stroke(Key.O); kb.Stroke(Key.R); kb.Stroke(Key.L); kb.Stroke(Key.D); // The \"!\" kb.Press(Key.LeftShift); kb.Stroke(Key.D1); kb.Release(Key.LeftShift); // Send an enter key kb.Stroke(Key.Enter); } Thread.Sleep(1000); } } } CDC - Virtual Serial Port Serial ports are the most common interface, especially in the embedded system world. It is an ideal solution for devices to transfer data between computers and embedded devices NETMF products. To combine the popularity and usefulness of USB with the ease of serial, we have virtual USB devices. To Windows' applications or devices, a virtual serial port works just like a serial port but it is actually a USB port. To use CDC, you need the USB Drivers that come with the GHI Electronics NETMF and Gadgeteer SDK (2016 R1 and later). This will only work if you use the default constructor of the Cdc class. If you do not and you provide different Vendor and Product Ids, this driver will not work and you will need to create your own. You can use the one we provide in the SDK as a model, though it will not be signed. Note: CDC drivers usually handle one transaction in every frame. The max EP size on USB is 64 bytes and there 1000 frames per second on full-speed USB. This means that the maximum transfer rate in ideal conditions for CDC is 64KB/sec. The buffer size is limited so you must be make sure to read all data quickly because there is no overflow event. The following example will create a USB CDC and send \"Hello world!\" to computer every second. using System.Threading; using GHI.Usb; using GHI.Usb.Client; using Microsoft.SPOT; using Microsoft.SPOT.Hardware.UsbClient; public class Program { public static void Main() { // Start Cdc Cdc vsp = new Cdc(); Controller.ActiveDevice = vsp; // Send \"Hello world!\" to PC every second. (Append a new line too) byte[] bytes = System.Text.Encoding.UTF8.GetBytes(\"Hello world!\\r\\n\"); while (true) { // Check if connected to PC if (Controller.State != UsbController.PortState.Running) { Debug.Print(\"Waiting to connect to PC...\"); } else { vsp.Stream.Write(bytes, 0, bytes.Length); } Thread.Sleep(1000); } } } Mass Storage GHI's USB client supports Mass Storage Class (MSC). This allows access to connected media right from USB. For example, a data logger application that needs to save data to an SD card or USB memory. When the user is done collecting data, they can plug the USB data logger into the PC and now the PC can detect the device as a mass storage device. The user can then transfer the files using standard operating system controls. It may be helpful to think of the device as a memory card reader. We can even enhance our logger where the USB client interface can be CDC to configure the device and later dynamically switch to MSC to transfer files. Once very common question on GHI Electronics support is \"Why can't I access the media from my application while the media is also accessed externally (from windows)?\" Due to caching of file system data and/or the possibility of a write from one interface while the other is doing a read and/or a write, data on the media and/or data used by the interface will likely (and quickly) be corrupted. Note: you can easily switch back and forth between internal file system and USB MSC. This example code assumes an SD card is always plugged in. It enables MSC showing the device as a card reader. This code assumes that the USB port is NOT being used for debugging. In addition to the assemblies mentioned above in the Note, the following code requires the GHI.Hardware assembly. using System; using System.Threading; using GHI.Usb.Client; using GHI.Usb; using GHI.IO.Storage; public class Program { public static void Main() { // Start MS MassStorage ms = new MassStorage(); Controller.ActiveDevice = ms; // Assume SD card is connected SDCard sd; try { sd = new SDCard(); } catch { throw new Exception(\"SD card not detected\"); } ms.AttachLogicalUnit(sd,0, \" \", \" \"); // enable host access ms.EnableLogicalUnit(0); Thread.Sleep(Timeout.Infinite); } } HID and Custom Devices Windows and other operating systems have built in drivers for USB HID (Human Interface Devices). These drivers are ideal as they provide a simple way to transfer data between a computer and a device. HID's are usually mice and keyboards but they can also be simple data transfer devices. Although examples in codeshare may need changes for differences in SDK releases, this project provides a good example: http://www.ghielectronics.com/community/codeshare/entry/420 The GHI Electronics USB Client allows you to control the USB client in anyway you like. This feature requires advanced knowledge of USB. If you do not know what an EndPoint or a Pipe is then do not attempt to create custom devices. It is very important to have the device configured correctly the first time it is plugged into Windows since Windows stores a lot of information in its registry. If you change the configuration of your device after you had it plugged into Windows previously, Windows may not see the changes since it will be using the old configuration from its registry. Do not use USB Client Custom Devices unless you really have good reason to use them and you are knowledgeable in USB and Windows drivers."
  },
  "software/netmf/tutorials/usb-host.html": {
    "href": "software/netmf/tutorials/usb-host.html",
    "title": "USB Host",
    "keywords": "USB Host There is usually a lot of confusion between USB host and USB client. USB host is the system that connects to multiple USB clients. For example, the PC is a USB host and it can connect to multiple USB clients like mice, keyboards, and mass storage devices. Implementing a USB client is rather simple but implementing a host is far more complicated. USB host is an exclusive feature from GHI Electronics. With this feature, you can connect almost any USB device to GHI's NETMF products. This feature opens new possibilities for embedded systems. Your product can now connect to a standard USB keyboard and can also access files on a USB thumb drive. USB is a hot pluggable system which means any device can be connected or disconnected at any time. Events are generated when devices are connected or disconnected. The program that you write should subscribe to these events and handle them accordingly. With USB hub support, devices can be connected directly to the USB host port or the user may connect multiple USB devices through a USB hub. Getting Started When working with USB host, you interact with the Controller. You subscribe to the connected event for various devices and then start the controller. When a device connected, you receive an object representing that device as the event arguments. You can subscribe to the Disconnect event on that device to do any clean up you might need. The below code requires the GHI.Usb and GHI.Hardware assemblies and shows you briefly how to handle device connections and disconnections. using GHI.Usb.Host; using Microsoft.SPOT; using System.Threading; public class Program { public static void Main() { Controller.DeviceConnectFailed += Controller_DeviceConnectFailed; Controller.KeyboardConnected += Controller_KeyboardConnected; Controller.Start(); Thread.Sleep(-1); } private static void Controller_DeviceConnectFailed(object sender, EventArgs e) { Debug.Print(\"Failed.\"); } private static void Controller_KeyboardConnected(object sender, Keyboard keyboard) { Debug.Print(\"Keyboard connected.\"); keyboard.Disconnected += keyboard_Disconnected; } private static void keyboard_Disconnected(BaseDevice sender, EventArgs e) { Debug.Print(\"Keyboard disconnected.\"); } } Mice, keyboards, and joysticks Once you receive a connect event and the associated object for a mouse, keyboard, or joystick, you can subscribe to various events on those objects to receive data from the device. The below code simply prints out when a button or key is pressed. using GHI.Usb.Host; using Microsoft.SPOT; using System.Threading; public class Program { public static void Main() { Controller.KeyboardConnected += Controller_KeyboardConnected; Controller.MouseConnected += Controller_MouseConnected; Controller.JoystickConnected += Controller_JoystickConnected; Controller.Start(); Thread.Sleep(-1); } private static void Controller_KeyboardConnected(object sender, Keyboard keyboard) { Debug.Print(\"Keyboard connected.\"); keyboard.KeyUp += keyboard_KeyUp; keyboard.KeyDown += keyboard_KeyDown; } private static void Controller_MouseConnected(object sender, Mouse mouse) { Debug.Print(\"Mouse connected.\"); mouse.ButtonChanged += mouse_ButtonChanged; mouse.CursorMoved += mouse_CursorMoved; mouse.WheelMoved += mouse_WheelMoved; } private static void Controller_JoystickConnected(object sender, Joystick joystick) { Debug.Print(\"Joystick connected.\"); joystick.ButtonChanged += joystick_ButtonChanged; joystick.CursorMoved += joystick_CursorMoved; joystick.HatSwitchPressed += joystick_HatSwitchPressed; } private static void keyboard_KeyUp(Keyboard sender, Keyboard.KeyboardEventArgs e) { Debug.Print(\"Up: \" + e.Which.ToString()); } private static void keyboard_KeyDown(Keyboard sender, Keyboard.KeyboardEventArgs e) { Debug.Print(\"Down: \" + e.Which.ToString()); } private static void mouse_ButtonChanged(Mouse sender, Mouse.ButtonChangedEventArgs e) { Debug.Print(e.State.ToString() + \" \" + e.Which); } private static void mouse_CursorMoved(Mouse sender, Mouse.CursorMovedEventArgs e) { Debug.Print(e.Delta.ToString() + \" \" + e.NewPosition.ToString()); } private static void mouse_WheelMoved(Mouse sender, Mouse.WheelMovedEventArgs e) { Debug.Print(e.Delta.ToString() + \" \" + e.NewPosition.ToString()); } private static void joystick_ButtonChanged(Joystick sender, Joystick.ButtonChangedEventArgs e) { Debug.Print(e.State.ToString() + \" \" + e.Which); } private static void joystick_CursorMoved(Joystick sender, Joystick.CursorMovedEventArgs e) { Debug.Print(e.Delta.ToString() + \" \" + e.NewPosition.ToString() + \" \" + e.Which.ToString()); } private static void joystick_HatSwitchPressed(Joystick sender, Joystick.HatSwitchPressedEventArgs e) { Debug.Print(e.Direction.ToString()); } } Serial Serial (UART) communication is a very common interface. There are many companies that create chips that convert USB to serial. GHI Electronics currently supports chipsets from FTDI. Their FT232 is known to work, though others may as well. USB chipsets are made to be somewhat customized. A company can use an FTDI chip to make their product run on USB and they will change the strings in USB descriptors so that when you plug in their device to a PC you will see the company name and not FTDI. They can also change the USB VID/PID, vendor ID and product ID. Many of the interface products on the market use the FTDI chipset. A few other USB-Serial manufacturers, like Prolific, are included, but they are deprecated and not supported by us. The below example simply echoes any data received back out to the sender and prints it to the debug output. using GHI.Usb.Host; using Microsoft.SPOT; using System.Threading; public class Program { public static void Main() { Controller.UsbSerialConnected += Controller_UsbSerialConnected; Controller.Start(); Thread.Sleep(-1); } private static void Controller_UsbSerialConnected(object sender, UsbSerial usbSerial) { Debug.Print(\"UsbSerial connected.\"); usbSerial.DataReceived += usbSerial_DataReceived; } private static void usbSerial_DataReceived(UsbSerial sender, UsbSerial.DataReceivedEventArgs e) { for (int i = 0; i < e.Data.Length; i++) Debug.Print(e.Data[i].ToString()); sender.Write(e.Data); } } Mass Storage When you connect a mass storage device, it can be accessed through the regular NETMF filesystem functions with the device root \"USB\". Once you mount the device, you need to wait for NETMF to fire the RemovableMedia.Insert event before you try accessing the filesystem. The below code simply opens or creates a file on the drive, writes \"Hello, World!\" to it, and then unmounts the device. It requires the Microsoft.SPOT.IO and System.IO assembly. using GHI.Usb.Host; using Microsoft.SPOT; using Microsoft.SPOT.IO; using System.IO; using System.Text; using System.Threading; public class Program { private static AutoResetEvent evt = new AutoResetEvent(false); public static void Main() { Controller.MassStorageConnected += Controller_MassStorageConnected; Controller.Start(); Thread.Sleep(-1); } private static void Controller_MassStorageConnected(object sender, MassStorage massStorage) { RemovableMedia.Insert += RemovableMedia_Insert; massStorage.Mount(); evt.WaitOne(); using (var fs = new FileStream(\"\\\\USB\\\\Hello.txt\", FileMode.OpenOrCreate)) fs.Write(Encoding.UTF8.GetBytes(\"Hello, World!\"), 0, 13); massStorage.Unmount(); } private static void RemovableMedia_Insert(object sender, MediaEventArgs e) { Debug.Print(\"Inserted.\"); evt.Set(); } } Warning Under current versions of NETMF, the Flush method of FileStream will eventually write the buffers; unfortunately, there is a delay (sometimes up to a minute) from when Flush is called to when the data is actually flushed. See Files and Folders for more details. Webcams You can also connect a webcam and stream images from it. Webcams only support certain image formats and sizes so you need to query the formats supported and tell the camera to stream images using that format. We support cameras that support the YUV2 color format. The below code requires the Microsoft.SPOT.Graphics and Microsoft.SPOT.TinyCore assemblies. It looks for a format that has a size of 320x240 and starts to stream it. When a new image is available an event is raised and we draw the received image to the bitmap that represents our screen and then flush it. Make sure you have a display properly configured. using GHI.Usb.Host; using Microsoft.SPOT; using Microsoft.SPOT.Presentation; using System.Threading; public class Program { private static Bitmap lcd = new Bitmap(SystemMetrics.ScreenWidth, SystemMetrics.ScreenHeight); public static void Main() { Controller.WebcamConnected += Controller_WebcamConnected; Controller.Start(); Thread.Sleep(-1); } private static void Controller_WebcamConnected(object sender, Webcam webcam) { webcam.ImageAvailable += webcam_ImageAvailable; foreach (Webcam.ImageFormat i in webcam.SupportedFormats) { if (i.Width == 320 && i.Height == 240) { webcam.StartStreaming(i); break; } } } private static void webcam_ImageAvailable(Webcam sender, EventArgs e) { sender.GetImage(lcd); lcd.Flush(); } } Unknown Devices If your device is not recognized by our libraries, the UnknownDeviceConnected event will be triggered. This event will give you the USB parameters of the device that you can use to \"force\" the creation of a specific type. This method is not guaranteed to work with every unknown device, however. The below code illustrates how to do this with a usb to serial device. using GHI.Usb.Host; using Microsoft.SPOT; using System.Threading; public class Program { private static UsbSerial serial; public static void Main() { Controller.UnknownDeviceConnected += Controller_UnknownDeviceConnected; Controller.Start(); Thread.Sleep(-1); } private static void Controller_UnknownDeviceConnected(object sender, Controller.UnknownDeviceConnectedEventArgs e) { Debug.Print(\"Unknown device connected.\"); serial = new UsbSerial(e.Id, e.InterfaceIndex, e.VendorId, e.ProductId, e.PortNumber, BaseDevice.DeviceType.SerialProlific); serial.DataReceived += serial_DataReceived; } private static void serial_DataReceived(UsbSerial sender, UsbSerial.DataReceivedEventArgs e) { for (int i = 0; i < e.Data.Length; i++) Debug.Print(e.Data[i].ToString()); sender.Write(e.Data); } }"
  },
  "software/netmf/tutorials/watchdog.html": {
    "href": "software/netmf/tutorials/watchdog.html",
    "title": "Watchdog",
    "keywords": "Watchdog Introduction In the embedded system world, devices are usually always running and with no user interaction. So if something went wrong, it would be very beneficial if we have an automatic reset button. Watchdog is your reset button! Assume you are making a smart vending machine that reports its inventory over the network. If your code raises an exception that wasn't handled properly then your program will end. Program ended means the vending machine will no longer work. Someone will have to drive to the vending machine to reset it! The alternative is to use the watchdog. When watchdog is enabled, it is given a timeout where it will reset the system if the time reached without resetting the timeout. This is like saying \"reset the system in 5 seconds\" then the program goes on to do something. The program needs to come back and reset the time and say \"reset in 5 seconds\". If the program keeps doing this, the system will never reset. But if the program got stuck somewhere, the 5 seconds will end causing the system to reset. Tip GHI Electronics does not use the NETMF's built in services for watchdog, but uses its own. Use the GHI.Hardware assembly when using watchdog. Warning Do NOT set the Watchdog reset time too short during the debug phase. If it is shorter than the time taken to deploy your code then your device will reboot and the new code never gets loaded. The only way to get out of the problem is to erase the device and reflash the firmware. We advice not to use watchdog during development and debugging. Max Timeouts The following lists shows the max timeout value for watchdog on our various devices in milliseconds. Do note that for G120 and EMX, there is roughly a 30% margin of error around the max value where the device may still reset. G400: 15,995 G120: 134,217 EMX: 4,294,967 Cerberus: 32768 Five Second Watchdog This example shows how to set the watchdog to 5 seconds timeout and create a thread to clear the watchdog every 3 seconds. Should anything go wrong and the thread that clears the watchdog isn't able the run due to another thread using all of the available resources, the device will reset in 5 seconds. Tip Once you enable the Watchdog, it cannot be disabled. So you have to keep resetting the timeout. This is done to assure that no system corruption will disable watchdog accidentally. using System; using System.Threading; using GHI.Processor; public class Program { public static void Main() { // Timeout 5 seconds int timeout = 1000 * 5; // Enable Watchdog Watchdog.Enable(timeout); // Start a time counter reset thread WDTCounterReset = new Thread(WDTCounterResetLoop); WDTCounterReset.Start(); // .... // your program starts here // If we exit the program, // the thread will stop working and the system will reset! Thread.Sleep(Timeout.Infinite); } static Thread WDTCounterReset; static void WDTCounterResetLoop() { while (true) { // reset time counter every 3 seconds Thread.Sleep(3000); Watchdog.ResetCounter(); } } } You may be thinking, if the software locked up then how would the code that handles watchdog ever run? It works because the watchdog is supported in hardware not software. This means that the counter and the reset mechanism are done inside the processor, without the need for any software. Detecting Watchdog In some cases, you need to know if the system did reset because of a watchdog to log this info or run some recovery procedures. This is how it works using System; using System.Threading; using Microsoft.SPOT; using GHI.Processor; public class Program { public static void Main() { // Normally, you can read this flag ***ONLY ONCE*** on power up if (Watchdog.LastResetCause == Watchdog.ResetCause.Watchdog) { Debug.Print(\"Watchdog did Reset\"); } else { Debug.Print(\"Reset switch or system power\"); } } }"
  },
  "software/netmf/tutorials/xml.html": {
    "href": "software/netmf/tutorials/xml.html",
    "title": "XML",
    "keywords": "XML Introduction Extensible Markup Language (XML) is a standard for containing data. When you want to transfer some info between two devices, you can set some rules on how the data is to be packed and sent from device A. On the other side, device B receives the data and knows how to unpack it. Before XML, this created some difficulties. What if you were sending the data to a system implemented by a different designer? You would have to explain how you packed your data so the other designer can unpack it. With XML, the design is transmitted with the data. XML is extensively used. For example, when a website's shopping cart wants to know the shipping cost on a certain package, it will pack the shipment details in XML format and then send to FedEx. The FedEx website will read the info and send the cost info back in XML format as well. The usefulness of XML can also be utilized in other ways. Let's say you are designing a data logger. Let's also assume the end users will need to configure the data logger to fit their needs. When a user configures the device, you need to store the info internally somehow. You can save the data with your own format which requires extra coding and debugging, or better just use XML. All GHI Electronics NETMF devices have a built-in XML reader and writer (packer and un-packer ). Here is an example XML file that will help in our data logger design. <?xml version=\"1.0\" encoding=\"utf-8\" ?> <NETMF_DataLogger> <FileName>Data</FileName> <FileExt>txt</FileExt> <SampleFreq>10</SampleFreq> </NETMF_DataLogger> This XML example includes a root element and three child elements. XML is very flexible, for instance all info in the example could have been defined as root elements. The root element \"NETMF_DataLogger\" contains three pieces of info that are important for our logger. It contains the file name, the file extension and a frequency of our saved data. With this example, the logger will create a file called Data.txt and then will log data into that file 10 times every second. Spaces and layout do not mean anything to XML, we (humans) need them to make things easier to read. The previous example can be stored without the spaces and layout like this. <?xml version=\"1.0\" encoding=\"utf-8\" ?><NETMF_DataLogger><FileName>Data</FileName> <FileExt>txt</FileExt><SampleFreq>10</SampleFreq></NETMF_DataLogger> See why spaces are important to us human being! You can also add comments inside XML files, comments do not mean anything to XML but can help in manual reading of the files <?xml version=\"1.0\" encoding=\"utf-8\"?> <!--This is just a comment--> <NETMF_DataLogger> <FileName>Data</FileName> <FileExt>txt</FileExt> <SampleFreq>10</SampleFreq> </NETMF_DataLogger> Finally, XML support attributes. An attribute is an extra info given to an element. Alternatively, you can add another element to describe the extra information. The choice is yours. Attributes are not explained in this document; there are many excellent tutorials and examples on the internet. GHI Electronics' NETMF devices support reading and writing XML format. Reading and writing XML files work over streams which means any stream you already have or implement can work with XML. For example, we will use the built-in MemoryStream and FileStream. The examples shown below require the following assemblies: System.IO, System.Xml, MFDpwsExtensions. XML in Memory This code shows how to make an XML document in memory, it implements the XML presented above. using System.IO; using System.Xml; using System.Ext.Xml; using Microsoft.SPOT; public class Program { public static void Main() { MemoryStream ms = new MemoryStream(); XmlWriter xmlwrite = XmlWriter.Create(ms); xmlwrite.WriteProcessingInstruction(\"xml\", \"version=\\\"1.0\\\" encoding=\\\"utf-8\\\"\"); xmlwrite.WriteComment(\"This is just a comment\"); xmlwrite.WriteStartElement(\"NETMF_DataLogger\");//root element xmlwrite.WriteStartElement(\"FileName\");//child element xmlwrite.WriteString(\"Data\"); xmlwrite.WriteEndElement(); xmlwrite.WriteStartElement(\"FileExt\"); xmlwrite.WriteString(\"txt\"); xmlwrite.WriteEndElement(); xmlwrite.WriteStartElement(\"SampleFeq\"); xmlwrite.WriteString(\"10\"); xmlwrite.WriteEndElement(); xmlwrite.WriteEndElement();//end the root element xmlwrite.Flush(); xmlwrite.Close(); //////// display the XML data /////////// byte[] byteArray = ms.ToArray(); char[] cc = System.Text.UTF8Encoding.UTF8.GetChars(byteArray); string str = new string(cc); Debug.Print(str); } } When you try to add an assembly you will notice that there are two assemblies for XML, the \"System.Xml\" and \"System.Xml.Legacy\". Do not use the \"legacy\" driver, it is there for older NETMF devices with systems that did not have built-in support for XML. If the \"Unsupported Exception\" is raised on an older device, replace the System.Xml assembly with System.Xml.Legacy Readable Output When running the example above, we will see the output XML data at the end. The data is correct but it is not formatted to be \"human\" friendly. Note that we are reading and writing XML files on a very small system so the less info (spaces/formatting) the better it is. So it is actually better not to have any extra spaces or formatting but for the sake of making things look pretty, we will add new lines as follows using System.IO; using System.Xml; using System.Ext.Xml; using Microsoft.SPOT; public class Program { public static void Main() { MemoryStream ms = new MemoryStream(); XmlWriter xmlwrite = XmlWriter.Create(ms); xmlwrite.WriteProcessingInstruction(\"xml\", \"version=\\\"1.0\\\" encoding=\\\"utf-8\\\"\"); xmlwrite.WriteComment(\"This is just a comment\"); xmlwrite.WriteRaw(\"\\r\\n\"); xmlwrite.WriteStartElement(\"NETMF_DataLogger\");//root element xmlwrite.WriteString(\"\\r\\n\\t\"); xmlwrite.WriteStartElement(\"FileName\");//child element xmlwrite.WriteString(\"Data\"); xmlwrite.WriteEndElement(); xmlwrite.WriteRaw(\"\\r\\n\\t\"); xmlwrite.WriteStartElement(\"FileExt\"); xmlwrite.WriteString(\"txt\"); xmlwrite.WriteEndElement(); xmlwrite.WriteRaw(\"\\r\\n\\t\"); xmlwrite.WriteStartElement(\"SampleFeq\"); xmlwrite.WriteString(\"10\"); xmlwrite.WriteEndElement(); xmlwrite.WriteRaw(\"\\r\\n\"); xmlwrite.WriteEndElement();//end the root element xmlwrite.Flush(); xmlwrite.Close(); //////// display the XML data /////////// byte[] byteArray = ms.ToArray(); char[] cc = System.Text.UTF8Encoding.UTF8.GetChars(byteArray); string str = new string(cc); Debug.Print(str); } } Reading and Parsing Creating XML files is actually easier than parsing (reading) them. There are many ways to read the XML file but basically you can just go through the file and read one piece at the time till you reach the end. This code example creates an XML data and it reads it back. using System.IO; using System.Xml; using System.Ext.Xml; using Microsoft.SPOT; public class Program { public static void Main() { MemoryStream ms = new MemoryStream(); XmlWriter xmlwrite = XmlWriter.Create(ms); xmlwrite.WriteProcessingInstruction(\"xml\", \"version=\\\"1.0\\\" encoding=\\\"utf-8\\\"\"); xmlwrite.WriteComment(\"This is just a comment\"); xmlwrite.WriteRaw(\"\\r\\n\"); xmlwrite.WriteStartElement(\"NETMF_DataLogger\");//root element xmlwrite.WriteString(\"\\r\\n\\t\"); xmlwrite.WriteStartElement(\"FileName\");//child element xmlwrite.WriteString(\"Data\"); xmlwrite.WriteEndElement(); xmlwrite.WriteRaw(\"\\r\\n\\t\"); xmlwrite.WriteStartElement(\"FileExt\"); xmlwrite.WriteString(\"txt\"); xmlwrite.WriteEndElement(); xmlwrite.WriteRaw(\"\\r\\n\\t\"); xmlwrite.WriteStartElement(\"SampleFeq\"); xmlwrite.WriteString(\"10\"); xmlwrite.WriteEndElement(); xmlwrite.WriteRaw(\"\\r\\n\"); xmlwrite.WriteEndElement();//end the root element xmlwrite.Flush(); xmlwrite.Close(); //////// display the XML data /////////// byte[] byteArray = ms.ToArray(); char[] cc = System.Text.UTF8Encoding.UTF8.GetChars(byteArray); string str = new string(cc); Debug.Print(str); ///////////read xml MemoryStream rms = new MemoryStream(byteArray); XmlReaderSettings ss = new XmlReaderSettings(); ss.IgnoreWhitespace = true; ss.IgnoreComments = false; //XmlException.XmlExceptionErrorCode. XmlReader xmlr = XmlReader.Create(rms,ss); while (!xmlr.EOF) { xmlr.Read(); switch (xmlr.NodeType) { case XmlNodeType.Element: Debug.Print(\"element: \" + xmlr.Name); break; case XmlNodeType.Text: Debug.Print(\"text: \" + xmlr.Value); break; case XmlNodeType.XmlDeclaration: Debug.Print(\"decl: \" + xmlr.Name + \", \" + xmlr.Value); break; case XmlNodeType.Comment: Debug.Print(\"comment \" +xmlr.Value); break; case XmlNodeType.EndElement: Debug.Print(\"end element\"); break; case XmlNodeType.Whitespace: Debug.Print(\"white space\"); break; case XmlNodeType.None: Debug.Print(\"none\"); break; default: Debug.Print(xmlr.NodeType.ToString()); break; } } } }"
  },
  "software/netmf/tutorials/xtea.html": {
    "href": "software/netmf/tutorials/xtea.html",
    "title": "XTEA",
    "keywords": "XTEA Introduction XTEA is a secure encryption algorithm, though not as secure as RSA or others, that uses a 128bit key and requires very little processing power. Make sure you only attempt to encrypt arrays with a size divisible by eight. Getting Started The following example shows the basic encryption and decryption of a string. When you use the parameterless constructor of the Xtea object, a key is generated for you that you can find in the Key property. If you pass a key to the constructor, it will be used instead. using GHI.Utilities; using Microsoft.SPOT; using System.Text; public class Program { public static void Main() { var xtea = new Xtea(); var encrypted = xtea.Encrypt(Encoding.UTF8.GetBytes(\"0123456776543210\")); var decrypted = xtea.Decrypt(encrypted); Debug.Print(new string(Encoding.UTF8.GetChars(decrypted))); //should be \"0123456776543210\" var keyStr = \"0x\"; for (int i = 0; i < Xtea.KeyLength; i++) keyStr += xtea.Key[i].ToString(\"x2\"); Debug.Print(\"The key used was \" + keyStr); } }"
  },
  "software/tinyclr/bootloader.html": {
    "href": "software/tinyclr/bootloader.html",
    "title": "GHI Electronics Bootloader",
    "keywords": "GHI Electronics Bootloader The GHI Electronics Bootloader is used to update the firmware on our devices. It is the first program to run and unless the device specific LDR pins are set (see device documentation for details), it will execute the firmware on the device (if present). The bootloader communicates over a USB (virtual serial port) and a regular serial port. The interface used is controlled by a MOD pin as detailed in Special Pins . Loading the Firmware The individual product pages include further instructions on the firmware needed and how to set the board in the loader mode. Once you have downloaded the firmware and set the board in loader mode, use the instructions below to load the firmware. Using TinyCLR Config TinyCLR Config tool includes multiple features developers need to work with TinyCLR OS-enabled devices. It simplifies the firmware update and it includes options for accessing the TinyCLR firmware at runtime. Using this tool is the recommended path; however, manual installation instructions are also included on this page. Read more on the TinyCLR Config page. Manual Update TinyCLR Config tool should be used to update the firmware. As a backup, use these instructions: Put your board in bootloader mode. Each product has a specific way to enter the boot loader. Open any terminal software, for example Tera Term . Select serial and pick the COM port associated with your board. (If unsure, check Device Manager) Press V and then enter. You will see back the boot loader version number (v2.x.x) Press U or X and then enter. Use X for firmware file type GHI and U for firmware file type GLB. Press Y to confirm then enter. You will now see CCCC ... Go to File -> Transfer -> XMODEM -> Send . IMPORTANT: Make sure you check the 1K option. Select the firmware file. When the transfer is complete, reset your board. Commands All commands and results are terminated with CR and LF (\\r\\n). \"OK.\" will be sent after each successful command. On startup, a banner is sent that is terminated by \"OK.\". Once the banner is received, you are free to enter any of the case-insensitive single-character commands described below. Most commands require confirmation. Send Y or y followed by a new-line to proceed or anything else to cancel. V: Returns the current version. N: Returns the current device type. E: Erases all user sectors of the device. R: Runs the firmware if present. B: Increases the baud rate in serial mode to 921,600. X: Upload a ghi file to the device using 1K XMODEM. Only send *.ghi files meant for your device. USB Drivers Tip Only needed for Windows 7 and 8. File Date Status MD5 v1.0.0 x64 2018-12-27 Production 74D66FC4236126A83CCCFE28D556F339 v1.0.0 x86 2018-12-27 Production 8BDE68132452E22B14597C0972ABA8FD"
  },
  "software/tinyclr/configuration.html": {
    "href": "software/tinyclr/configuration.html",
    "title": "Configuration",
    "keywords": "Configuration This section covers some of the configuration needed before you can program your board as well as design considerations for designing custom circuit boards. Special Pins Special pins used by the SITCore product line. Learn more... Bootloader Bootloader information and downloads Learn more... TinyCLR Config Used to load firmware and applications. Learn more..."
  },
  "software/tinyclr/downloads.html": {
    "href": "software/tinyclr/downloads.html",
    "title": "Downloads",
    "keywords": "Downloads This page includes downloads for the SITCore line of products as well as some of our earlier product lines. See individual product pages for details. TinyCLR OS 2.0 The release notes are here . Software status legend: Status Meaning Production Ready to be used commercially. Preview Preview of the next release, not quite ready for production use. Alpha Bleeding edge development that will frequently change. Major changes to come. Visual Studio Project System The extension is what gets loaded on Visual Studio to allow it to communicate with a TinyCLR OS device. It also includes project templates. File Date Status MD5 v2.0.0-preview6 2020-05-20 Preview C48AB3F1E84C5B7C09CFC98D6FD6B67A v2.0.0-preview5 2020-04-21 Preview 9B3271A643D7C9F82BC951796CD6E337 v2.0.0-preview4 2020-03-10 Preview C6D4E1441BEF89806EF60016E1D83299 v2.0.0-preview3 2020-02-20 Preview 306A9AE97F13B1A797D70BC4EE831D0A v2.0.0-preview2 2020-01-22 Preview E0B241CCE0B7C1CBA25D0B41D8B0F75A Libraries Libraries provide prebuilt ways of performing many common tasks. You can find them on NuGet instead of downloading them here. File Date Status MD5 v2.0.0-preview6 2020-05-20 Preview 788E9BDA83DC4DDF7207B779185A4B27 v2.0.0-preview5 2020-04-21 Preview 42D402EABA616FC9518A7FC4BD836867 v2.0.0-preview4 2020-03-10 Preview 73F41AEC3279469B403208B21597B76C v2.0.0-preview3 2020-02-20 Preview F85EC2C83718211181CDB887E189F096 v2.0.0-preview2 2020-01-22 Preview 92291EBDFFAFFBB7D80A71E54F03EE97 TinyCLR Config TinyCLR Config is a tool used to update and configure your TinyCLR device. File Date Status MD5 v2.0.0-preview6 2020-05-20 Preview 5A93788BE4D9083F6DE021CD7EA24FB6 v2.0.0-preview5 2020-04-21 Preview 3D60888ECD7884964DE74D5551FFAFE5 v2.0.0-preview4 2020-03-10 Preview 4E56B1E2810DAC30799290CA3276B202 v2.0.0-preview3 2020-02-20 Preview D58DA9D455EA1EC51BEEAA579E714568 v2.0.0-preview2 2020-01-22 Preview F23B08C69E152590A3D977BFCA4D440C TinyCLR Font Converter The font converter is a tool used to convert desktop TrueType fonts to the format used by TinyCLR OS. File Date Status MD5 v2.0.0-preview2 2020-01-22 Preview 40F6EA89AA8B826956A83220285E471F Firmware The Firmware is the TinyCLR OS that lives on your hardware. The firmware version loaded on the hardware must match the version number of the extension and the libraries. SC20xxxx (works on all SITCore products) File Date Status MD5 v2.0.0.60000 (preview6) 2020-05-20 Preview D3E96058F7931BF7A225D231765DA9F5 v2.0.0.50000 (preview5) 2020-04-21 Preview 1A395143AA14601B97965D21E2EC8E2B v2.0.0.40000 (preview4) 2020-03-10 Preview 5287F47A0A15D4F3967175038AF9A929 v2.0.0.30000 (preview3) 2020-02-20 Preview 1F7B70C43A4FAC67B3480BEA5AEEC0B3 v2.0.0.21000 (preview2) 2020-01-31 Preview F1B03AB44296E7DF98B155D3E1B47359 v2.0.0.20000 (preview2) 2020-01-22 Preview 61148AD3CC4A5E7D79D5F73B7F313C7F TinyCLR OS 1.0 These downloads are provided with no support and are not recommended for commercial designs. File Date MD5 Project System 2018-12-27 2CDD88E2203716781CA0735FEAE2BBE3 Libraries 2018-12-27 4EB8D0C9DBD8AABA8C48716256099924 TinyCLR Config 2018-12-27 FFA158A503EBEA0D9F812007608A1974 TinyCLR Font Converter 2018-12-27 9FBDD44955F51BDBE83BBAB4CAD25616 UC5550 2018-12-27 BE4D80D4F88AA0902F25E8353148D2F8 UC2550 2018-12-27 97F2BA54A92107CBFB5DDA029E58DA42 G400 2018-12-27 DF863A79DE30F5C4C204B2F6EE0ED4FE G120 2018-12-27 482C2ADE1B27675A5457D8894D43BB6F G80 2018-12-27 CE90C3F05C6193A68C42E7D4C3A5AB80 G30 2018-12-27 B3A3BC288A4776506D40198847AFAB85 FEZCLR (FEZ T18) 2018-12-27 C089598B40CC7398DD7BBC3723D25D0E"
  },
  "software/tinyclr/getting-started.html": {
    "href": "software/tinyclr/getting-started.html",
    "title": "Getting Started",
    "keywords": "Getting Started This page explains how to set up the TinyCLR programming environment. It covers device and computer setup and deployment of a \"hello world\" program. Tip If you're an existing user of NETMF and still want to use it in addition to TinyCLR OS, don't worry. TinyCLR is completely independent of NETMF and works side-by-side with no issues. Compatible Hardware TinyCLR OS is made to run on our SITCore line of SoCs, SoMs, dev boards and single board computers. Check out the SITCore page in the hardware section of this documentation to find the device best suited for your project. TinyCLR Device Setup To use TinyCLR with a device you must first install the latest version of the TinyCLR firmware on the device. The TinyCLR firmware includes the Common Language Runtime (CLR) which converts compiled code into machine instructions and manages program execution. The TinyCLR firmware is also responsible for interacting with Microsoft Visual Studio to load and debug your application programs. Use the TinyCLR Config tool to update the firmware on your device. Development Machine Setup If you don't already have Visual Studio 2019, download and install one of the editions, including the free community edition: Visual Studio Community 2019 . You can also use other editions as well. Make sure to select the .NET desktop development workload when installing Visual Studio. Download and install the newest TinyCLR Visual Studio Project System by going to Tools > Extensions and Updates... . In the Extensions and Updates dialog box select Online in the left panel. Type tinyclr into the Search text box in the upper right of the window to search for and install the TinyCLR OS Project System . You'll need to restart Visual Studio to let the extension installer complete the installation. Note Pre-releases of the Project System are not hosted online but found on the Downloads page. Starting a New Project Let's blink an LED on a SITCore board. Open Visual Studio and select Create a new project . In the Create a new project window , select TinyCLROS from the platforms drop down list. Now select the C# TinyCLR Application template and click the Next button. We're going to stick with the default name and location. If you use a different name, make sure the program's namespace statement matches the namespace of your program. Now click on the \"Create\" button. Now cut and paste the following code into the Program.cs window. Make sure to install the GHIElectronics.TinyCLR.Core , GHIElectronics.TinyCLR.Devices.Gpio , GHIElectronics.TinyCLR.Native , and GHIElectronics.TinyCLR.Pins NuGet packages. If not sure how, the following section explains how this can be done. using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; using System.Threading; namespace TinyCLRApplication1 { class Program { static void Main() { //Use \"SC20100.GpioPin.PE11\" on SC20100S Dev Board. //Use \"SC20260.GpioPin.PB0\" on SCM20260D Dev Board. var LED = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PB0); LED.SetDriveMode(GpioPinDriveMode.Output); while (true) { LED.Write(GpioPinValue.High); Thread.Sleep(100); LED.Write(GpioPinValue.Low); Thread.Sleep(100); } } } } You may have to change line 11 depending on which board you are using. Make sure your device is plugged into the computer's USB port. Now hit the start button as shown on the above image (or hit the F5 key). If you've done everything correctly, the program will compile and deploy to your device. The left most LED on the dev board should blink if you've done everything correctly. Congratulations! You're on your way to becoming a TinyCLR embedded developer! The NuGet Packages NuGet packages are typically hosted online on www.NuGet.org. The steps below explain how to add onlione-hosted NuGet libraries to your project. If you are using a pre-release, the libraries must be downloaded and installed as a local feed. Start Visual Studio and create a new TinyCLR Application under C# > TinyCLR . New to Visual Studio or C#? Take a look at the getting started guide from Microsoft . Right click on your Project in the Solution Explorer panel and select Manage NuGet Packages . If the Solution Explorer window is not visible, open it by selecting Solution Explorer in the View menu. You can also select Manage NuGet Packages... in the Project menu of Visual Studio. Make sure the package source is set to \"Package source\" or \"All.\" In the search box type \"tinyclr\" Selecting the Browse tab will show all the TinyCLR NuGet packages. Those installed are noted with a green down arrow in front of the name. To install one of the packages click on the down arrow to the right of the package version. You can also select the package and click on the Install button in the center panel. Click OK to accept the proposed changes. Accept the licensing agreement to install the package. Note Pre-release libraries are not hosted on NuGet.org, use the local feed feature to fetch the needed libraries from your local machine, found on the Downloads page. To find the best hardware for your TinyCLR application, go to the SITCore page in the hardware section of this documentation. To learn more about TinyCLR embedded programming check out our tutorials . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/tinyclr/intro.html": {
    "href": "software/tinyclr/intro.html",
    "title": "TinyCLR OS Introduction",
    "keywords": "TinyCLR OS Introduction TinyCLR OS started with Microsoft's .NET Micro Framework and continues to enable managed .NET development and debugging using Visual Studio on embedded devices. All you need to get started is Visual Studio (free version available), a TinyCLR device, and a USB cable. Getting Started Deploy your first TinyCLR program. Learn more... Configuration Special pins, bootloader, TinyCLR Config Learn more... Tutorials Learn TinyCLR embedded programming. Learn more... Downloads Visual Studio and device downloads. Learn more... Release Notes Find the latest changes to TinyCLR. Learn more... Limitations How TinyCLR OS is different from full .NET. Learn more... To learn more about TinyCLR embedded programming check out our tutorials . You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/tinyclr/limitations.html": {
    "href": "software/tinyclr/limitations.html",
    "title": "Limitations",
    "keywords": "Limitations TinyCLR OS is made to run on small, secure, IoT devices. TinyCLR was built from the ground up with security first and foremost. Performance is also excellent, but we did have to limit some of the less important features to achieve this performance while maximizing application memory. Here is a list of limitations and possible workarounds: There is no support for multidimensional arrays, use jagged arrays instead. Simply use [1][1] instead of [1,1]. Each assembly is limited to 64KB. If you have gigantic code, just split your solution into multiple assemblies. This approach improves code maintainability as well. Resource files are not subject to this limitation, so if you are adding large lookup tables or binary objects, include them as a resource. TinyCLR does not support generics. While this is less of a limitation on an embedded device than on the desktop, we understand that professional .NET developers will miss this feature. However, on small embedded systems implementing generics can reduce performance. The async/await pattern is not supported. All libraries, networking sockets for example, are tweaked to be a subset of the full .NET framework that will perform well on embedded devices. These tweaks have allowed us to support essential IoT features like CAN and USB."
  },
  "software/tinyclr/release-notes.html": {
    "href": "software/tinyclr/release-notes.html",
    "title": "Release Notes",
    "keywords": "Release Notes 2.0.0-preview6 Released 2020-05-20 This preview release implements all remaining functionality, fixes bugs, and improves the API. Visual Studio Project System Changes Added support for secure assemblies. Removed Visual Basic template. Known Issues Debug breakpoint will sometimes hang for 5-6 seconds before resuming normally. There is sometimes a longer than usual delay during deployment at the \"Found debugger\" and \"Waiting for device to initialize\" steps. Libraries Changes MQTT keep alive timeout default has been changed to 60 seconds. \"EnableExternalHeap\" has been renamed to \"ExtendHeap.\" Added OTP support to API. Added external flash support to API. Fixed Double.Compare incorrectly returning zero. Fixed intermittent crashing when using SPI with no chip select. Known Issues String does not implement IEnumerable (GitHub issue #323). JSON cannot deserialize long integers (GitHub issue #540). Network operations on any thread block all other threads (GitHub issue #525). Network stack requires delays in order to work properly (GitHub issue #503). Equals() throws unsupported instruction exceptions (GitHub issue #502). On touch screens, moving off of a button does not release the button (GitHub issue #479). I2C raises timeout exception when using address 0x00 (GitHub issue #554). Several other bugs have been reported which have not yet been verified by GHI Electronics. TinyCLR Config Changes Improved user experience during installation. Added Device Configuration window to enable extension of RAM (Extend heap) and extension of flash (Enable external flash) into external memories. Also added ability to disable the debug interface. Added Deployment Map. Added progress bar while erasing device. Known Issues Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. Firmware Changes Support for deployments in external QSPI flash in addition to internal flash. Deployment size has changed. Secure deployments can now be up to 640 KBytes in size, external deployments can be up to 8 MBytes. Added 64 KByte one time programmable (OTP) region. Improved Ethernet performance. Green Ethernet LED is now activity indicator instead of link indictor. MAC addressing has changed. Ethernet and ENC always require a MAC address, WiFi MAC address is optional, PPP needs no MAC address. Fixed Thread.Sleep() adding 2 ms when not debugging. Fixed USB and SD card not working at the same time. Known Issues User can access QSPI pins even when QSPI is active for deployment. Networking won't work correctly if WiFi scan is called after Network.Enable() . WiFi scan always adds a blank SSID at the end of the list. Drawing on screen may be slower when network that uses SPI is running (WiFi, ENC28). In Visual Studio, the application doesn't start automatically when trying to Start Without Debugging (CTRL+F5). Resetting the board will start the application. The PJ0 interrupt configuration changes when the device is reset with the reset button, but there is no problem when power cycling the board. Drivers Changes Fixed issue of intermittent noise coming from OV9655 camera modules. Known Issues None. 2.0.0-preview5 Released 2020-04-21 This preview release moves us closer to a commercially viable product with new and updated features and some API improvements. Visual Studio Project System Changes Updated to preview5 Known Issues None Libraries Changes Added rotation to display and touch. Added endianness argument to SPI API. Removed data bit length from SPI API. Changed SPI chip select argument type from integer to GpioPin. AssemblySigner has been removed. Updated user interface keyboard resource image. Added support for USB keyboards, mice, and raw device library to USB host class. SignalGenerator now always uses a carrier frequency of 38 kHz. Added missing QSPI pins to GHIElectronics.TinyCLR.Pins. Improved JSON support. Changed GeneratePulse() to Trigger() in SignalGenerator, SignalCapture, and PulseFeedback APIs. Simplified formatting of RFC dates. Fixed TextBox misalignment in UI library. Made CheckBoxes consistent with XAML API in UI library. Fixed problem with building libraries. Added PWM15 pin definition. Known Issues The ToString() method fails on structs, including Guid and enum. Equals() throws an CLR_E_UNSUPPORTED_INSTRUCTION exception. Dropdowns in user interface do not respond to direct touches. In networking, Socket.Connect blocks all threads until it finishes. TinyCLR Config Changes Added a progress bar and result highlighting. Known Issues TinyCLR Config forces device reboot several times when reconnecting to the device. Does not happen during firmware update. TinyCLR Font Converter Changes None. Known Issues None. Firmware Changes Removed GetDefault() from the API of peripherals that have more than one controller or channel. Reworked the SPI API. Added screen rotation. Added USB host keyboard, mouse, and raw device. Fixed PulseFeedback DrainDuration mode. Fixed file information calls returning a Not Implemented exception. Fixed incorrect reporting of static IP addresses when there is no connection. Fixed inability to set socket timeout. Changed serial deploy/debug port from UART5 to UART1 on 100 pin devices. SC20260B still uses UART5. The RTC will run approximately one second slower every 4-6 hours. Drawing on display becomes slower if there is network activity. Known Issues In Visual Studio, the application doesn't start automatically when trying to Start Without Debugging (CTRL+F5). Resetting the board will start the application. The PJ0 interrupt configuration changes when the device is reset with the reset button, but there is no problem when power cycling the board. Drivers Changes Added support for display rotation to the FT5x06 Touch driver Reworked the MSGEQ7 graphic equalizer API. Fixed incorrect color rendition in the WS2812 LED driver. Known Issues When drawing to SSD1351 displays, you may have to add ten to the x coordinate for the screen position to be correct. The OV9655 camera can intermittently have a noisy picture. Resetting the board should fix the problem. 2.0.0-preview4 Released 2020-03-10 This preview release includes many bug fixes, a few new and updated features, and some API improvements. Visual Studio Project System Changes Updated with the latest core libraries. Known Issues None Libraries Changes Fixed missing UART dependency when adding Network NuGet. Fixed ADC that was incorrectly mapped to wrong controller. Added serialization. Reworked power management API. DisplayController is now only used with parallel interface displays. Graphics.Clear() no longer takes an argument. Added NeoPixel WS2812 driver. Added SSD1351 display driver. Changed MJPEG driver to return raw jpeg data instead of internally flushing data to display. Fixed dependency for OV9655 driver and sped up screen refresh rate. Reworked the SSD1306 and ST7735 display drivers so they no longer inherit from DisplayController. Known Issues JSON does not work in some cases. When drawing to SSD1351 displays, you may have to add ten to the x coordinate for the screen position to be correct. The OV9655 camera can intermittently have a noisy picture. Resetting the board should fix the problem. TinyCLR Config Changes Fixed occasional crashes during firmware updates. Known Issues None TinyCLR Font Converter Changes None. Known Issues None. Firmware Changes Signal generator has been improved and can now generate signals of up to 1.25 MHz in frequency. Fixed SPI locking up networking. Fixed bug when sharing SPI bus with multiple devices. Fixed incorrect timestamping of events. Added support for microcontroller temperature sensor. Added support for Vbat voltage monitoring. Added support for ADC internal reference voltage. Fixed I2C bug with messages larger than 255 bytes. Corrected I2C clock bug. Added support for wake up from RTC alarm. Reworked power management with support for stopping processor during Thread.Sleep(). Added pin PC1 as analog input on SC20100S. Fixed crashing when deploying application over UART. Improved Ethernet Fixed networking bug when using static IP Addressing. Known Issues In Visual Studio, the application doesn't start automatically when trying to Start Without Debugging (CTRL+F5). Resetting the board will start the application. The PJ0 interrupt configuration changes when the device is reset with the reset button, but there is no problem when power cycling the board. ToString() does not work if the argument is an Enum. PulseFeedback DrainDuration does not work correctly. Cannot send more than 64 KBytes in one SPI transaction. The workaround is to split the data so the transactions are smaller. When using static IP addressing, after disconnecting the device from an Ethernet network the old IP address will still be assigned instead of 0.0.0.0. Graphics.DrawString() with native displays on the SC20260B may stop WiFi. 2.0.0-preview3 Released 2020-02-20 Our third preview includes bug fixes, added features, and increases performance. Visual Studio Project System Changes None Known Issues None Libraries Changes Added missing USB host controller definition. Added missing UART controller definition. Removed Network Stream timeout. Removed Streams. Removed GHIElectronics.TinyCLR.Devices NuGet package. Fixed HTTP exception that sometimes occurs when parsing data. Added Button, ListBoxHighLightItem, ProgressBar, CheckBox, Radio Button, and Drop-Down List elements to UI. Added ability to get current WiFi MAC Address. Added simple MJPEG driver that supports decoding of MJPEG files. Added simple WAV driver that supports decoding of WAV files. Known Issues JSON doesn't work in some cases. Ov9655 camera can randomly have a noisy picture. Reset the board as a workaround. TinyCLR Config Changes Fixed display of incorrect version number. Fixed crashing when trying to connect to bootloader. Fixed Connect button not returning to Enable after firmware update is done. Known Issues None. TinyCLR Font Converter Changes None. Known Issues None. Firmware Changes Increased Performance by 15%. Added RSA cryptography. Added MD5 hash. Fixed One-Wire exceptions and inconsistent operation. Added Network Suspend/Resume to support changing back and forth between a modem's PPP data frame mode and AT command mode. Added Enable External Memory for heap (heap can be 32 MBytes). Fixed SPI from using PA0 for chip select if no chip select pin is specified. Fixed SPI4 and SPI5 clock errors. Increased default free heap size from 300 KBytes to 364 KBytes (maximum size is still 512 KBytes). Fixed USB client reading only a single byte of each packet. Fixed system crashing when there are missing network configuration settings. Added support for hardware random number generator. Fixed SPI throwing exceptions when drawing on N18 display. Known Issues In Visual Studio the application doesn't start automatically when trying to Start Without Debugging (Ctrl+F5). Pressing the reset button will start the application. The PJ0 interrupt configuration changes when the device is reset with the reset button, but there is no problem when resetting by power cycling the board. ToString() doesn't work if the argument is an Enum. PulseFeedback DrainDuration does not work correctly. 2.0.0-preview2 update Released 2020-01-31 A refresh release of the firmware only with improved performance. Changes Considerably faster execution speed. Known Issues See the 2.0.0-preview2 release notes. This 2.0.0.21000 release activates all accelerators which might cause some bugs. If you have any strange behavior, please load the previous 2.0.0.20000 release and see if that fixes your issue. Both firmware versions are identical otherwise, and both run with same 2.0.0-preview2 NuGet packages. 2.0.0-preview2 Released 2020-01-22 Initial insider release for SITCore hardware. Visual Studio Project System Changes First release to private insiders with major changes. Known Issues Cannot change boards or connect an additional board to your PC while Visual Studio is open, or Visual Studio will get confused and deployment will stop working. Do not switch devices while Visual Studio is open. Not digitally signed. Libraries Changes First release to private insiders with major changes. Known Issues None, still going through final testing. Cryptography and hashing are currently only supported through TLS. We are still planning how to securely expose this functionality. Not digitally signed. TinyCLR Config Changes First release to private insiders with major changes. Known Issues TinyCLR may not work when connecting over UART. Use Tera Term to update firmware when in UART mode. Not digitally signed. TinyCLR Font Converter Changes None. Known Issues None. Not digitally signed. Firmware Changes First release to private insiders with major changes. Known Issues TinyCLR OS is not yet optimized for full performance as this release is focused on stability. Conversion from enum to string (enumObject.ToString()) may fail. PulseFeedback DrainDuration does not work when going from low to high. Not digitally signed. 2.0.0-preview1 Released 2019-12-09 A preview of the new API and available features. Libraries Changes Major changes. Known Issues Still going through complete testing. Firmware Changes Major changes. Known Issues Internal use only. TinyCLR Config Changes None. Known Issues Random crash."
  },
  "software/tinyclr/special-pins.html": {
    "href": "software/tinyclr/special-pins.html",
    "title": "Special Pins",
    "keywords": "Special Pins There are a number of predefined pins that have special functionality on SITCore SoMs and SoCs: RESET (NRST) LDR (PE3) APP (PB7) MOD (PD7) WKUP (PA0) Vbat All special pins except RESET and Vbat can be used as GPIO or peripheral pins, however it is up to you to make sure your use of these pins does not interfere with their use as special pins if needed. We strongly recommend exposing all special pins in your SITCore designs. You will also need to expose the debug interface(s) you plan to use to deploy and debug your application. In addition to exposing these pins, it is important to follow the design considerations on the System on Chip or System on Module page that corresponds to the SITCore product your are using. RESET The SITCore chip is held in reset while the RESET(NRST) pin is held low. Releasing RESET and allowing it to go high will begin the system startup process. All SITCore processors have a permanent internal pull up resistor on the RESET pin. An external pull up resistor is not required on the RESET(NRST) pin when designing your own circuit boards. LDR The LDR pin is used to enter the GHI Electronics bootloader mode. The LDR pin is normally pulled high during startup or reset, allowing the managed application to execute. When the LDR pin is pulled low during startup or reset, the device enters GHI Electronics bootloader mode, which is used to load the SITCore firmware. There is no need for a pull up resistor on the LDR pin as the LDR pin is pulled high through a pull up resistor internal to the processor. APP The APP pin is used to prevent the application from running. The APP pin is checked shortly after startup and reset. When the APP pin is high your application will run normally. If the APP pin is low when the bootloader is finished, the bootloader will not transfer execution to your application. There is no need for an external pull up on the APP pin as it is pulled high by an internal pull up. MOD The MOD pin is used to select the debugging/deployment interface. The MOD pin is pulled high by an internal pull up resistor -- there is no need to add a pull up resistor to the MOD pin when designing a custom circuit board. By default, the MOD pin is pulled high during reset allowing for deployment and debugging over USB. Pulling the MOD pin low during startup or reset allows for deployment and debugging over UART. Note that our SITCore Dev Boards include a FT232R USB to serial converter chip to provide a convenient way to connect a PC to the board's serial debug/deploy port. WKUP The WKUP pin can be used to wake up the processor from special power saving modes. The WKUP pin can be configured to use an internal pull-up or pull-down, so no external pull resistor is needed. When WKUP functionality is not needed, this pin can be used as a GPIO or peripheral pin. See the Power Management page for more information. Vbat The Vbat pin on SITCore SoCs and SoMs is used to provide battery power to the Real Time Clock (RTC). This pin also provides power for battery backed memory (see the Real Time Clock page for details). If you require either RTC or battery backed memory, the Vbat pin must be connected to the positive terminal of a supercap or battery. The negative terminal of the battery or supercap needs a connection to GND. Vbat requires 1.2 to 3.6 volts for correct operation. This is usually provided by either a CR2032 lithium coin cell or a supercap, but other options are available. SITCore Dev boards use a 33 mF 3.3 volt supercap. The best Vbat option depends on your application. If your board needs to keep correct time while being unpowered for more than a few days, a battery may be a better choice than a supercap. The disadvantage to batteries is they eventually discharge and must be replaced. Supercaps are rechargeable and should last for the life of the product. It is important that your application correctly sets the charging status of the Vbat pin. Trying to charge a lithium coin cell may damage it and could possibly cause it to leak. Supercaps need to be charged every few days or so (depending on supercap size) before they lose their charge. Information on setting Vbat charge status is found on the Real Time Clock page. Debug Interface Don't forget to expose either the USB client or UART interface (or both) that you plan on using to deploy and debug your application code. All SITCore products built around a 100 pin chip (SC20100x) use UART1 for the serial debug interface. All SITCore products built around the 260 pin SC20260B chip use UART5 for the serial debug interface. Other Recommended Pin Usage When designing your own board, we recommend that you add the following peripherals using the stated pins to maintain consistency with our dev boards and sample software. Peripheral Recommended SITCore I/O Assignment User LED 100 pin devices: PE11 260 pin devices: PB0 Buzzer PB1"
  },
  "software/tinyclr/tinyclr-config.html": {
    "href": "software/tinyclr/tinyclr-config.html",
    "title": "TinyCLR Config",
    "keywords": "TinyCLR Config TinyCLR Config is a stand-alone tool to help manage TinyCLR OS devices, including firmware installation and creating encrypted application deployments and loading them onto SITCore devices. There is also a Debug panel that shows any debug data coming from the connected device. You can download TinyCLR Config from the Downloads page. Connecting a Device When TinyCLR Config opens, you will notice a Device section near the top of its window. Connect your device to your PC's USB port and click on the Select a device drop down text box. The name of your device should appear. Click on the device and hit the Connect button. Once your device is connected, you can ping the device using the Ping command in the Utilities menu. In the Assemblies menu there is an Assemblies Listing command that will list all the assemblies installed on the connected device along with their version number. There are also options in the Utilities menu to reboot the device, show a deployment map, or update the device configuration. Deployment Map The deployment map can be used to gauge the resources used by your application, but more importantly it allows you to make sure assemblies are stored in secure internal flash memory. See the IP Protection page for more information about secure assemblies. Device Configuration The device configuration options have very important implications for system security. For more information on protecting your application and data, please refer to the IP Protection page of this documentation. Firmware Configuration The Extend heap and Enable external flash firmware configuration options both expand internal memory by allowing the use of external memory chips. Once external heap or flash are enabled, you will need to reflash the firmware or completely erase the device to disable external memory. Extend heap extends internal RAM and only works on devices that include external SDRAM. There is also a method, GHIElectronics.TinyCLR.Native.Memory.ExtendHeap() , that can be used to extend the heap from within your code. See the External Memory page for more information. Enable external flash extends internal flash memory and only works devices that include external flash memory. To extend flash from within an application, use the GHIElectronics.TinyCLR.Native.Flash.EnableExternalFlash() method. See the External Memory page for more information. Data stored in external SDRAM or flash memory is less secure than data stored internally. See the IP Protection page for more information. Deployment Configuration For added security, the debug interface can be disabled. Note that once this is done, you will not be able to update the firmware or debug your application until you completely erase your device. You can update your application code, but only through TinyCLR Config or In-Field-Update . You can also disable the debug interface from within your code. Please refer to the IP Protection page for more information about disabling the debug interface. Managing Firmware TinyCLR Config can be used to install new firmware on a connected device. The firmware is the TinyCLR software installed on your device that runs and manages your application program. To update your firmware, click on the ... button to the left of the Update Firmware button. A dialog box will open so you can select your firmware file. Only .ghi and .glb files will be recognized. After selecting your firmware file, click on the Update Firmware button to copy it to your device. In the Erase menu, the Erase All selection will erase the firmware on the device, but will also erase the application. While it's not necessary to delete the firmware or the application to install new firmware, it can sometimes help if your device stops working properly. Managing Your Application TinyCLR Config lets you create and deploy encrypted application files. A key is needed to install an encrypted application deployment file on your device. This key can be generated by TinyCLR Config or provided by you. Creating a Deployment File To create an encrypted deployment, you must first have the application installed on your device and the device must be connected to TinyCLR Config. A key is needed to encrypt your deployment file. Either enter a key into the key text box (hexadecimal pairs delimited by hyphens) or just press the Generate Key button to generate a random key. If you want to add a version number to your deployment, enter it in the Version of created app: text box. Click on the ... button next to the Create App button and select a directory and enter a filename for your deployment file. Now press the Create App button. The encrypted deployment file and a text file with the key will be saved in the directory you selected. Installing a Deployment File To install an encrypted deployment file on your device, first use TinyCLR Config to connect to your device. Click on the ... button next to the Update App button and select the deployment file (should have a .tca extension). Enter the correct key in the text box next to the Generate Key button. The key is a series of hexadecimal pairs that are separated by hyphens. Now click on the Update App button. If the key matches the deployment file, the application will be deployed to your device. Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com ."
  },
  "software/tinyclr/tutorials/1-wire.html": {
    "href": "software/tinyclr/tutorials/1-wire.html",
    "title": "1-Wire",
    "keywords": "1-Wire 1-Wire is a communication protocol designed by Dallas Semiconductor. 1-Wire is similar to I2C, but with lower data rates, longer range, and the ability to power remote sensors over the two bus lines (data and ground). The following sample code is written for the SC20100S Dev Board with one or more DS18B20 temperature sensors. The temperature sensors are powered directly from the dev board with the data line connected to pin PA1. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Onewire, GHIElectronics.TinyCLR.Native, and GHIElectronics.TinyCLR.Pins. class program { private static void Main() { var oneWireBus = new GHIElectronics.TinyCLR.Devices.Onewire.OneWireController (GHIElectronics.TinyCLR.Pins.SC20100.GpioPin.PA1); oneWireBus.TouchReset(); var oneWireDevices = oneWireBus.FindAllDevices(); System.Diagnostics.Debug.WriteLine(\"Number of sensors found = \" + oneWireDevices.Count.ToString()); foreach (byte[] serialNumber in oneWireDevices) { oneWireBus.TouchReset(); oneWireBus.WriteByte(0x55); //Match ROM command. for (int i = 0; i < serialNumber.Length; i++) { oneWireBus.WriteByte(serialNumber[i]); //Send serial number of device. } oneWireBus.WriteByte(0x44); //Convert temperature. while (oneWireBus.ReadByte() == 0) { // Wait for conversion to finish. } oneWireBus.TouchReset(); oneWireBus.WriteByte(0x55); //Match ROM command. for (int i = 0; i < serialNumber.Length; i++) { oneWireBus.WriteByte(serialNumber[i]); //Send serial number of device. } oneWireBus.WriteByte(0xBE); //Read scratchpad command. System.Diagnostics.Debug.WriteLine(\"Temperature: \" + ((float)(oneWireBus.ReadByte() + (oneWireBus.ReadByte() << 8)) / 16.0).ToString()); System.Diagnostics.Debug.WriteLine(\"Remaining 7 bytes of scratch pad:\"); for (int i = 0; i < 7; i++) { System.Diagnostics.Debug.WriteLine(oneWireBus.ReadByte().ToString()); } System.Diagnostics.Debug.WriteLine(\"--------\"); } System.Threading.Thread.Sleep(-1); } } Sample output: Number of sensors found = 3 Temperature: 21.125 Remaining 7 bytes of scratch pad: 75 70 127 255 14 16 255 -------- Temperature: 21 Remaining 7 bytes of scratch pad: 75 70 127 255 16 16 73 -------- Temperature: 21.1875 Remaining 7 bytes of scratch pad: 75 70 127 255 13 16 233 --------"
  },
  "software/tinyclr/tutorials/adafruit-io.html": {
    "href": "software/tinyclr/tutorials/adafruit-io.html",
    "title": "Adafruit IO",
    "keywords": "Adafruit IO The Adafruit cloud, Adafruit IO, is a cloud service primarily aimed at the maker market. While Adafruit IO is more limited than the major players in cloud services, it is very easy to use and there's a free option making this a great way to test IoT proofs of concept and prototypes. To run the sample code on this page, you will need to create an Adafruit account and setup a dashboard with a gauge named \"Temperature\" and a toggle named \"Digital.\" For the toggle, you will need to change the Button On Text to \"1\" and the Button Off Text to \"0.\" Using HTML Your IoT device can communicate with Adafruit IO using simple HTTP GET and POST commands. However, to respond to input on your Adafruit IO dashboard you must repeatedly execute HTTP GET requests to poll the input. If you would rather use event driven input from Adafruit IO, MQTT is a better choice than HTML. The following code uses an HTTP POST request to send a value to an Adafruit IO feed named \"Temperature\" which is represented by a gauge on an Adafruit IO dashboard. It uses a secure connection, so you must have the Adafruit certificate loaded as a resource . There must be a working Internet connection for this code to work. var url = \"http://io.adafruit.com/api/feeds/temperature/data.json\"; var postData = \"{\\\"value\\\":\\\"20\\\"}\"; //Sending a temperature of 20 degrees. var byteArray = System.Text.Encoding.UTF8.GetBytes(postData); var cert = Resource.GetBytes(Resource.BinaryResources.DigiCertGlobalRootG2); certx509 = new X509Certificate[] { new X509Certificate(cert) }; int read = 0, total = 0; byte[] result = new byte[512]; try { using (var postRequest = HttpWebRequest.Create(url) as HttpWebRequest) { postRequest.KeepAlive = false; postRequest.HttpsAuthentCerts = certx509; postRequest.ReadWriteTimeout = 2000; postRequest.Headers.Add(\"x-aio-key: your_adafruit_io_key_goes_here\"); postRequest.ContentType = \"application/json\"; postRequest.Method = \"POST\"; postRequest.ContentLength = byteArray.Length; System.IO.Stream dataStream = postRequest.GetRequestStream(); dataStream.Write(byteArray, 0, byteArray.Length); dataStream.Close(); using (var res = postRequest.GetResponse() as HttpWebResponse) { using (var stream = res.GetResponseStream()) { do { read = stream.Read(result, 0, result.Length); total += read; System.Diagnostics.Debug.WriteLine(\"read : \" + read); System.Diagnostics.Debug.WriteLine(\"total : \" + total); String page = \"\"; page = new String(System.Text.Encoding.UTF8.GetChars (result, 0, read)); System.Diagnostics.Debug.WriteLine(\"Response : \" + page); } while (read != 0); } } } } catch { } You can use an HTTP GET request to read the status of an Adafruit IO feed. The following code reads that status of a toggle block called \"Digital.\" You will need the rename the toggle's Button On Text to \"1\" and the Button Off Text to \"0\" on the Adafruit IO dashboard. There must be a working Internet connection for this code to work. url = \"https://io.adafruit.com/api/v2/adafruit_io_username/ feeds/digital/data?include=value&limit=1\"; var cert = Resource.GetBytes(Resource.BinaryResources.DigiCertGlobalRootG2); certx509 = new X509Certificate[] { new X509Certificate(cert) }; using (var getRequest = HttpWebRequest.Create(url) as HttpWebRequest) { getRequest.KeepAlive = false; getRequest.HttpsAuthentCerts = certx509; getRequest.ReadWriteTimeout = 2000; getRequest.Headers.Add(\"x-aio-key: your_adafruit_io_key_goes_here\"); getRequest.Method = \"GET\"; using (var response = getRequest.GetResponse() as HttpWebResponse){ using (var stream = response.GetResponseStream()) { do { read = stream.Read(result, 0, result.Length); total += read; System.Diagnostics.Debug.WriteLine(\"read : \" + read); System.Diagnostics.Debug.WriteLine(\"total : \" + total); String page = \"\"; page = new String(System.Text.Encoding.UTF8.GetChars (result, 0, read)); System.Diagnostics.Debug.WriteLine(\"Response : \" + page); } while (read != 0); } } } Using MQTT MQTT is a simple messaging protocol that is widely supported. See our MQTT page for more information. Using MQTT with Adafruit IO allows you to subscribe to an MQTT topic that represents a block on the Adafruit IO dashboard, allowing for event driven response. This sample code connects to Adafruit IO using their MQTT API. It publishes a value to a gauge named \"Temperature\" on an Adafruit IO dashboard. It also subscribes to an Adafruit IO toggle named \"Digital.\" You will need the rename the toggle's Button On Text to \"1\" and the Button Off Text to \"0\" on the Adafruit IO dashboard. It uses a secure connection, so you must have the Adafruit certificate loaded as a resource . You will also need a working Internet connection for this code to work. var certx509 = new X509Certificate(Resource.GetBytes(Resource.BinaryResources.DigiCertGlobalRootG2)); var mqttHost = \"io.adafruit.com\"; var mqttPort = 8883; //Default SSL port is 8883, default insecure port is 1883. var deviceId = \"\"; var username = \"adafruit_io_username\"; var password = \"adafruit_io_key\"; var topic = \"adafruit_io_username/feeds/digital\"; try { var clientSetting = new MqttClientSetting { BrokerName = mqttHost, BrokerPort = mqttPort, ClientCertificate = null, CaCertificate = certx509, SslProtocol = System.Security.Authentication.SslProtocols.Tls12, }; var client = new Mqtt(clientSetting); var connectSetting = new MqttConnectionSetting { ClientId = deviceId, UserName = username, Password = password }; // Connect to host var returnCode = client.Connect(connectSetting); var packetId = 1; // Subscribe to a topic client.Subscribe(new string[] { topic }, new QoSLevel[] { QoSLevel.ExactlyOnce }, (ushort)packetId++); client.PublishReceivedChanged += Client_PublishReceivedChanged; // Publish a topic client.Publish(\"joelriley/feeds/temperature\", Encoding.UTF8.GetBytes(\"0\"), QoSLevel.MostOnce, false, (ushort)packetId); //Sets temperature to zero. } catch (Exception e) { } private static void Client_PublishReceivedChanged(object sender, MqttPacket packet) { if (packet.Data[0] == '1') //Toggle is set to '1' if (packet.Data[0] == '0') //Toggle is set to '0' }"
  },
  "software/tinyclr/tutorials/analog-in.html": {
    "href": "software/tinyclr/tutorials/analog-in.html",
    "title": "Analog In",
    "keywords": "Analog In Unlike digital input pins, which can only read high or low, analog pins can read a range of voltage levels. Microcontrollers based on 3.3V can typically read voltages anywhere between zero and 3.3V. Analog inputs connect internally to an Analog to Digital Converter (ADC) that converts the analog voltage level on the pin to a digital value. Tip Note that the analog channel number is not the pin number. You need to determine the channel number of a specific pin using your system's documentation. The resolution of the ADC determines its accuracy. An 8bit ADC has 256 steps to work with, 3.3V/256=0.013V. This means an increase of 0.013V will increase the ADC value by one. In other words, a voltage change of less than 0.013V has no effect. Tip When multiple ADC are available on a system, you must select the right controller instead of using the default controller through GetDefault() var adc = AdcController.FromName(SC20100.AdcChannel.Controller1.Id); var analog = adc.OpenChannel(SC20100.AdcChannel.Controller1.PA0); while (true) { double d = analog.ReadRatio(); Debug.WriteLine(\"An-> \" + d.ToString(\"N2\")); Thread.Sleep(100); }"
  },
  "software/tinyclr/tutorials/analog-out.html": {
    "href": "software/tinyclr/tutorials/analog-out.html",
    "title": "Analog Out",
    "keywords": "Analog Out DAC A Digital to Analog Converter (DAC) will convert a digital input (number) to an analog output (voltage). The voltage of a DAC usually swings from very close to zero volts up to nearly the voltage of the microcontroller (usually 3.3 volts). This output voltage is only a weak signal and is not meant to drive a load. An op-amp or similar circuit can be added to drive a load, such as a speaker. The analog out on a microcontroller has a given resolution, which in large part determines its precision or accuracy. Check the device documentation for details. For example, an 8-bit DAC has 256 possible output voltage levels and a resolution of 3.3V/256 or 0.013 volts. This example will generate a triangular waveform. var dac = DacController.GetDefault(); var analog = dac.OpenChannel(SC20100.DacChannel.PA4); double d = 0.5; double dd = 0.01; while (true) { analog.WriteValue(d); d += dd; if (d <= 0 || d >= 1) dd *= -1; //Invert Thread.Sleep(10); } Tip Do not use analog outputs to control the power of an LED or a motor. Use PWM for that. PWM PWM can also be used to output an analog voltage. Click here for details. Audio Playback WAV audio playback can be done using an analog output pin. See Audio Playback ."
  },
  "software/tinyclr/tutorials/application-domain.html": {
    "href": "software/tinyclr/tutorials/application-domain.html",
    "title": "Application Domain",
    "keywords": "Application Domain The AppDomain class lets you load assemblies from any file stream at runtime. This feature can be used to reduce the need for program flash memory by loading code only as needed from a USB flash drive or SD card, or when you won't know until runtime which assemblies will be used. The sample code below loads and executes a small assembly from a USB flash drive. To run this sample, start a new project in Visual Studio and copy the first code sample into the Program.cs window. Then add a new TinyCLR class named TestAppDomainAssembly.cs , and copy the second code sample into this window. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Storage, GHIElectronics.TinyCLR.IO, GHIElectronics.TinyCLR.Native, and GHIElectronics.TinyCLR.Pins. Program.cs class: class Program { static void Main() { var storageController = GHIElectronics.TinyCLR.Devices.Storage.StorageController. FromName(GHIElectronics.TinyCLR.Pins.SC20260.StorageController. UsbHostMassStorage); var drive = GHIElectronics.TinyCLR.IO.FileSystem.Mount(storageController.Hdc); var filename = drive.Name + \"\\\\TestAppDomain.pe\"; System.IO.FileStream fsRead = new System.IO.FileStream(filename, System.IO.FileMode.Open); var assemblyInBytes = new byte[fsRead.Length]; fsRead.Read(assemblyInBytes, 0, assemblyInBytes.Length); var assembly = System.Reflection.Assembly.Load(assemblyInBytes); var obj = System.AppDomain.CurrentDomain.CreateInstanceAndUnwrap(\"TestAppDomain\", \"TestAppDomain.TestAssembly\"); var type = assembly.GetType(\"TestAppDomain.TestAssembly\"); System.Reflection.MethodInfo mi = type.GetMethod(\"PrintMessage\"); mi.Invoke(obj, null); } } TestAppDomainAssembly.cs class: namespace TestAppDomain { public class TestAssembly { public void PrintMessage() { System.Diagnostics.Debug.WriteLine(\"Hello from TestAssembly\"); } } } In the TestAppDomain properties window (right click on TestAppDomain in Solution Explorer and select Properties ), click on TinyCLR OS in the left panel and check the Generate native stubs for internal methods and Generate bare native stubs boxes. This tells Visual Studio to create the Portable Executable (PE) file that will be copied to the USB flash drive and then executed by the main program. Now build the project. Inside of the project's directory navigate to the TestAppDomain/bin/Debug/pe directory and copy the file TestAppDomain.pe to a USB flash drive. Now insert the flash drive into your SITCore board and deploy the program. The main program will load and run TestAppDomain.pe from the USB flash drive. If everthing worked, you should see the following in your output window: 'GHIElectronics.TinyCLR.VisualStudio.ProjectSystem.dll' (Managed): Loaded 'TestAppDomain' Assembly: TestAppDomain (1.0.0.0) Hello from TestAssembly"
  },
  "software/tinyclr/tutorials/audio-playback.html": {
    "href": "software/tinyclr/tutorials/audio-playback.html",
    "title": "Audio Playback",
    "keywords": "Audio Playback WAV Files Simple audio playback is accomplished by reading a PCM WAV file and passing the data to the built-in analog out pin. Even easier, parse the WAV file on a PC and include the PCM samples. This code plays an 8 bit mono WAV file with a sample rate of 8 kHz. The WAV file must be saved as a BIN file before adding it as a resource. The audio is output to pin PA4 on the SC20100S Dev Board. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Dac, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.Spi, GHIElectronics.TinyCLR.Drawing, GHIElectronics.TinyCLR.Drivers.Media, GHIElectronics.TinyCLR.IO, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Pins. var dac = GHIElectronics.TinyCLR.Devices.Dac.DacController.GetDefault(); var analogOut = dac.OpenChannel(GHIElectronics.TinyCLR.Pins.SC20100.DacChannel.PA4); var byteFile = Properties.Resources.GetBytes (Properties.Resources.BinaryResources.yourWavFileResource); var wavFile = new GHIElectronics.TinyCLR.Drivers.Media.Wav(byteFile); var dataIndex = wavFile.GetDataIndex(); var size = wavFile.GetDataSize(); var sampleRate = wavFile.GetSampleRate(); if (sampleRate == 8000) { for (int i = dataIndex; i < size; i++) { analogOut.WriteValue(byteFile[i]); for (int timer = 0; timer < 58; timer++) { } } } else { System.Diagnostics.Debug.WriteLine(\"Sorry, file does not have an 8 kHz sample rate.\"); } MP3 Files MP3 file decoding can be accomplished by using one of the many MP3 decoders available from VLSI Solution http://www.vlsi.fi/ . We provide a drivers for VS1053B, which supports MP3, AAC, Ogg Vorbis, WMA and MIDI. The driver is on the TinyCLR-Drivers GitHub repository."
  },
  "software/tinyclr/tutorials/aws.html": {
    "href": "software/tinyclr/tutorials/aws.html",
    "title": "Amazon Web Services",
    "keywords": "Amazon Web Services This example shows how to communicate with AWS. Tip Needed Nugets: GHIElectronics.TinyCLR.Networking.Mqtt static void DoTestAwsMqtt() { var iotArnString = \"Need your ARN string\"; var iotPort = 8883; var deviceId = \"Need your Device ID\"; var topicShadowUpdate = string.Format(\"$aws/things/{0}/shadow/update\", deviceId); var topicShadowGet = string.Format(\"$aws/things/{0}/shadow/get\", deviceId); var message = \"{\\\"state\\\":{\\\"desired\\\":{\\\"My message\\\":\\\"From my test \\\"}}}\"; var caCertSource = UTF8Encoding.UTF8.GetBytes(\"Need AWS root CA certificate\"); var clientCertSource = UTF8Encoding.UTF8.GetBytes(\"Need your AWS client CA certificate\"); var privateKeyData = UTF8Encoding.UTF8.GetBytes(\"Need your AWS private key\"); X509Certificate CaCert = new X509Certificate(caCertSource); X509Certificate ClientCert = new X509Certificate(clientCertSource); ClientCert.PrivateKey = privateKeyData; var clientSetting = new MqttClientSetting { BrokerName = iotArnString, BrokerPort = iotPort, CaCertificate = CaCert, ClientCertificate = ClientCert, SslProtocol = System.Security.Authentication.SslProtocols.Tls12 }; var iotClient = new Mqtt(clientSetting); iotClient.PublishReceivedChanged += (a, b) => { Debug.WriteLine (\"Received message: \" + Encoding.UTF8.GetString(b.Data)); }; iotClient.SubscribedChanged += (a, b) => { Debug.WriteLine(\"Subscribed\"); }; var connectSetting = new MqttConnectionSetting { ClientId = deviceId, UserName = null, Password = null }; var connectCode = iotClient.Connect(connectSetting); ushort packetId = 1; iotClient.Subscribe(new string[] { topicShadowGet }, new QoSLevel[] { QoSLevel.LeastOnce }, packetId++); iotClient.Publish(topicShadowUpdate, Encoding.UTF8.GetBytes(message), QoSLevel.MostOnce, false, packetId++); } This example requires iotArnString, deviceId, CA certificate, client certificates, and a private key, which are available when you register an AWS account. Check out the AWS tutorial at: https://aws.amazon.com/"
  },
  "software/tinyclr/tutorials/azure.html": {
    "href": "software/tinyclr/tutorials/azure.html",
    "title": "Microsoft Azure",
    "keywords": "Microsoft Azure The example below shows how to use MQTT to communicate with the Azure IoT Hub. Tip Needed Nugets: GHIElectronics.TinyCLR.Networking.Mqtt static void DoTestAzureMqtt() { var caCert = new X509Certificate(UTF8Encoding.UTF8.GetBytes(\"Need Azure certificate\")); var iotHubName = \"your IoT Hub name\"; var iotHubPort = 8883; // device/client information const string deviceId = \"your device Id\"; var username = string.Format(\"{0}/{1}\", iotHubName, deviceId); var password = \"your string connection\"; // define topics var topicDeviceToServer = string.Format(\"devices/{0}/messages/events/\", deviceId); var topicService2Device = string.Format(\"devices/{0}/messages/devicebound/#\", deviceId); try { var clientSetting = new MqttClientSetting { BrokerName = iotHubName, BrokerPort = iotHubPort, ClientCertificate = null, CaCertificate = caCert, SslProtocol = System.Security.Authentication.SslProtocols.Tls12 }; var client = new Mqtt(clientSetting); client.PublishReceivedChanged += (a, b) => { Debug.WriteLine (\"Received message: \" + Encoding.UTF8.GetString(b.Data)); }; var connectSetting = new MqttConnectionSetting { ClientId = deviceId, UserName = username, Password = password }; var returnCode = client.Connect(connectSetting); ushort packetId = 1; client.Subscribe(new string[] { topicService2Device }, new QoSLevel[] { QoSLevel.ExactlyOnce }, packetId++); client.Subscribe(new string[] { topicDeviceToServer }, new QoSLevel[] { QoSLevel.ExactlyOnce }, packetId++); client.Publish(topicDeviceToServer, Encoding.UTF8.GetBytes (\"Your message\"), QoSLevel.MostOnce, false, packetId++); } catch (Exception e) { throw; } This example requires iotHubName and deviceId, which are available only when you open an Azure account. Replace \"password\" with a string that starts with \"SharedAccessSignature sr=...\". To generate a password string, visit https://docs.microsoft.com/en-us/azure/storage/common/storage-configure-connection-string More detail about Microsoft Azure, please visit: https://azure.microsoft.com/en-us/"
  },
  "software/tinyclr/tutorials/camera.html": {
    "href": "software/tinyclr/tutorials/camera.html",
    "title": "Camera Interface",
    "keywords": "Camera Interface TinyCLR OS supports digital camera interface, sometimes referred to as DCMI or DCI, on devices using the SITCore SC20260 SoC. Typically, cameras need to be configured using I2C bus . Check the Omnivision/Ov9655 driver under https://github.com/ghi-electronics/TinyCLR-Drivers for an example of how to configure your camera, or refer to the camera's manual to determine the needed configuration. The following function captures camera images: public void Capture(byte[] data, int timeoutMillisecond) => this.cameraController.Capture(data, timeoutMillisecond); This example configures the camera and sends the images to the 4.3 inch display attached to the SCM20260D Dev Board. Tip Needed NuGets: GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.I2c, GHIElectronics.TinyCLR.Drivers.Omnivision.Ov9655, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Pins, GHIElectronics.TinyCLR.Devices.Display, GHIElectronics.TinyCLR.Drawing Needed Namespaces: GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.I2c, GHIElectronics.TinyCLR.Drivers.Omnivision.Ov9655, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Pins, System.Diagnostics, System.Drawing using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Devices.I2c; using GHIElectronics.TinyCLR.Drivers.Omnivision.Ov9655; using GHIElectronics.TinyCLR.Native; using GHIElectronics.TinyCLR.Pins; using System.Diagnostics; using System.Drawing; class Program { static void Test_Dcmi() { GpioPin backlight = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PA15); backlight.SetDriveMode(GpioPinDriveMode.Output); backlight.Write(GpioPinValue.High); var displayController = GHIElectronics.TinyCLR.Devices.Display.DisplayController.GetDefault(); var controllerSetting = new GHIElectronics.TinyCLR.Devices.Display.ParallelDisplayControllerSettings { Width = 480, Height = 272, DataFormat = GHIElectronics.TinyCLR.Devices.Display.DisplayDataFormat.Rgb565, Orientation = DisplayOrientation.Degrees0, //Rotate display. PixelClockRate = 10000000, PixelPolarity = false, DataEnablePolarity = false, DataEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, }; displayController.SetConfiguration(controllerSetting); displayController.Enable(); var screen = Graphics.FromHdc(displayController.Hdc); var controller = I2cController.GetDefault(); // Camera var ov9655 = new Ov9655(controller); var id = ov9655.ReadId(); Debug.WriteLine(\"id = \" + id); var ptr = Memory.UnmanagedMemory.Allocate(640 * 480 * 2); var data = Memory.UnmanagedMemory.ToBytes(ptr, 640 * 480 * 2); ov9655.SetResolution(Ov9655.Resolution.Vga); byte temp = 0; while (true) { try { ov9655.Capture(data, 100); displayController.DrawBuffer(0, 0, 0, 0, 480, 270, 640, data, 0); } catch (System.Exception) { } } } static void Main() { Test_Dcmi(); } }"
  },
  "software/tinyclr/tutorials/can.html": {
    "href": "software/tinyclr/tutorials/can.html",
    "title": "CAN",
    "keywords": "CAN Controller Area Network (CAN) bus is a two wire serial communication protocol which was originally released at the 1986 Society of Automotive Engineers (SAE) congress in Detroit. The first vehicle to use CAN reduced the weight of its wiring by over 100 pounds. While CAN was originally designed for use in cars to reduce the amount of wiring, the use of CAN has expanded and it can now be found in avionics, hospitals, assembly lines, and even some bicycles and prosthetic limbs. Some features that make CAN so popular include: High speed (up to 1 megabit/second) serial communication over inexpensive twisted pair wiring. High noise immunity due to balanced differential signaling. Built in message priority which allows higher priority messages to automatically suppress messages of lower priority without any delay in transmission of the higher priority message. Guaranteed latency time for high priority messages. Automatic synchronization of nodes without a clock signal. Communication from 40 meters at 1 megabit per second up to 5 kilometers at 10 kilobits per second (distances will vary depending on bus characteristics). Automatic bus arbitration and collision detection and correction. Automatic error detection and re-transmission. The ability to work even when different nodes have different ground potentials. Only two required processor pins (Transmit Data (TD) and Receive Data (RD)). Low cost. CAN bus is generally a two wire bus, but sometimes additional power and ground lines are included requiring four wires. High speed CAN is set up as a linear bus of 120 ohm nominal twisted pair wiring with two or more nodes. Termination resistors are used at each end of the bus as shown below. Tip Some CAN devices, including our own development boards, have built in termination resistors. If you are using more than two nodes on a high speed CAN bus, you must disable the termination resistors on all nodes except for the two end nodes. Low speed or fault tolerant CAN uses a linear bus, star bus, or multiple star buses. Fault tolerant CAN buses are terminated differently than linear CAN buses and require a termination resistor at each node. The value of these resistors depends on the network but should equal about 100 ohms per CAN line in total. The TinyCLR CAN Interface The TinyCLR CAN API provides several methods for configuring the CAN bus and sending and receiving CAN messages. Configuring the Bus CAN bit timing is a complex topic that requires considerable knowledge of the CAN protocol. If you can obtain timing parameters for a device you are connecting to, use them. All nodes on a CAN network must use the same baud rate. Sample bit timing settings are given on each product's documentation page to help you get started. Please note that the given maximum oscillator tolerance and maximum cable length are theoretical maximums based only on the bit timing. These values do not take into account the number of nodes on the network, the type of cabling and termination, and the resistance of the cable, all of which may reduce the maximum bus length. It is up to you to test the network to ensure reliability. Before you can communicate over the CAN bus, the processor needs to know the characteristics of the bus so all nodes can communicate properly. SetBitTiming() defines the CAN bus timing using the arguments listed below. Due to the complexity of CAN bus timing, CAN bit rate calculators are available online which you may find helpful. Please refer to the processor datasheet for more information about the following parameters. The propagation argument is used to compensate for the physical delay times of the network and includes the input comparator delay, the output driver delay and the propagation delay of the bus itself (which is affected by the length and type of cable used). Propagation uses time quanta as a unit of measurement. The phase1 argument defines the length in time quanta of the phase one segment. The phase one segment can be automatically lengthened during re-synchronization. The phase2 argument defines the length in time quanta of the phase two segment. The phase two segment can be automatically shortened during re-synchronization. The baudratePrescaler argument determines the speed of the CAN system clock. The synchronizationJumpWidth defines the maximum amount of time quanta a bit period may be lengthened or shortened during each re-synchronization. When true, useMultiBitSampling will cause the bus to be sampled three times for each bit. Its use is recommended for low to medium speed buses to filter noise on the bus line. For high speed buses it is recommended to set this to false . In the sample code at the bottom of this page, the CAN bus is communicating at one Megabit per second over a short bus. CAN Bit Timing Settings The following CAN bit timing parameters were calculated for our SITCore Dev Boards and provide a good starting point for setting CAN timing. These values will work with any SITCore driving a SN65HVD230 CAN driver chip. When using a different CAN driver chip, the maximum cable length may be affected. If you are already familiar with CAN, you might notice that the Propagation and Phase 1 segments have been combined. This is very common for online CAN calculators and also the way CAN is handled by the microcontrollers used in the SITCore line of products. Baud PropagationPhase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 33.333K 13 2 90 1 False 87.5% 0.31% 2200M 83.333K 13 2 36 1 False 87.5% 0.31% 850M 125K 13 2 24 1 False 87.5% 0.31% 550M 250K 13 2 12 1 False 87.5% 0.31% 250M 500K 13 2 6 1 False 87.5% 0.31% 100M 1M 13 2 3 1 False 87.5% 0.31% 40M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested to ensure reliability. Calculating Your Own CAN Bit Timing There are many online CAN calculators that can be used to help you with CAN timing. One of the better ones is here: http://www.bittiming.can-wiki.info/ . This page also has a lot of useful information about CAN including this helpful visualization of the time segments that comprise one bit of CAN data: To use a CAN calculator, you will need to know the microcontroller's CAN clock speed. For the SITCore series of chips and SoMs this is 48 MHz, and can easily be found with the SourceClock property. For example, if your CAN controller is named \"can,\" Debug.WriteLine(can.SourceClock.ToString()); will display the CAN clock frequency in Hertz in the output window. Sending CAN Messages WriteMessage() WriteMessage() writes a single CAN message. Each CAN message is defined by eight data bytes, an arbitration ID, the length (number of bytes to send), and two Boolean arguments which specify if the transmission is a remote transmission request and whether the message uses an extended arbitration ID. Extended arbitration IDs are 29 bits long, standard IDs are 11 bits long. WriteMessages() The WriteMessages() method is used to send an array of CAN messages. The arguments for this function are the array of CAN messages followed by an offset and count integer values. The offset is the array subscript of the first message to send, while count specifies how many messages to send. Receiving CAN Messages ReadMessage() ReadMessage() receives a CAN message and includes the ArbitrationId , IsExtendedId , IsRemoteTransmissionRequest , TimeStamp and Data properties. Filtering Incoming CAN Messages SetGroupFilters() SetGroupFilters() takes two arrays as arguments to set ranges of arbitration IDs that will be accepted. The first array defines the lower bounds of accepted arbitration IDs, while the second array specifies the upper bounds. Both arrays must be the same size. In the sample code below, the group filters will accept messages with arbitration IDs ranging from 0x12 to 0x20 and also between 0x500 and 0x1000 inclusive. SetExplicitFilters() SetExplicitFilter() takes an array argument which specifies individual arbitration IDs that will be accepted regardless of the group filter settings. In the sample code below, CAN messages with arbitration IDs of 0x11 and 0x5678 will be accepted, in addition to the arbitration IDs specified by the group filters. Sample Code The following sample code is written for our SITCore SC20100S Dev Board. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices and GHIElectronics.TinyCLR.Pins using System; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.Can; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { private static void Main() { var LdrButton = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PE3); LdrButton.SetDriveMode(GpioPinDriveMode.InputPullUp); var can = CanController.FromName(SC20100.CanBus.Can1); var propagationPhase1 = 13; var phase2 = 2; var baudratePrescaler = 3; var synchronizationJumpWidth = 1; var useMultiBitSampling = false; can.SetBitTiming(new CanBitTiming(propagationPhase1, phase2, baudratePrescaler, synchronizationJumpWidth, useMultiBitSampling)); can.Enable(); var message = new CanMessage() { Data = new byte[] { 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x2E, 0x20, 0x20 }, ArbitrationId = 0x11, Length = 6, IsRemoteTransmissionRequest = false, IsExtendedId = false }; var lowerBounds = new int[] { 0x12, 0x500 }; var upperBounds = new int[] { 0x20, 0x1000 }; can.SetGroupFilters(lowerBounds, upperBounds); var explicitFilter = new int[] { 0x11, 0x5678 }; can.SetExplicitFilters(explicitFilter); can.MessageReceived += Can_MessageReceived; can.ErrorReceived += Can_ErrorReceived; while (true) { if (LdrButton.Read() == GpioPinValue.Low) can.WriteMessage(message); Thread.Sleep(100); } } private static void Can_MessageReceived(CanController sender, MessageReceivedEventArgs e) { sender.ReadMessage(out var message); Debug.WriteLine(\"Arbitration ID: 0x\" + message.ArbitrationId.ToString(\"X8\")); Debug.WriteLine(\"Is extended ID: \" + message.IsExtendedId.ToString()); Debug.WriteLine(\"Is remote transmission request: \" + message.IsRemoteTransmissionRequest.ToString()); Debug.WriteLine(\"Time stamp: \" + message.Timestamp.ToString()); var data = \"\"; for (var i = 0; i < message.Length; i++) data += Convert.ToChar(message.Data[i]); Debug.WriteLine(\"Data: \" + data); } private static void Can_ErrorReceived(CanController sender, ErrorReceivedEventArgs e) => Debug.WriteLine(\"Error \" + e.ToString()); }"
  },
  "software/tinyclr/tutorials/cellular.html": {
    "href": "software/tinyclr/tutorials/cellular.html",
    "title": "Cellular",
    "keywords": "Cellular Any Cellular modem with PPP support should simply work with TinyCLR OS. Please see our PPP tutorial for more details and sample code. Other networking information and sample code can be found on our WiFi and Ethernet tutorials. Security Clarification Most users of embedded systems that connect to mobile networks assume they are secure, but often they are not. Typically, a serial connection with AT commands is used to communicate with the Internet. While the data over the air is secure, all data transmitted over the serial connection is raw unencrypted data that can be easily scoped. This is not the case with TinyCLR OS. With TinyCLR OS, serial data between the device and the modem is encrypted. All data handling is done internally inside the core processor, which is extremely difficult to hack into."
  },
  "software/tinyclr/tutorials/collections.html": {
    "href": "software/tinyclr/tutorials/collections.html",
    "title": "Collections",
    "keywords": "Collections Similar data can often be handled more efficiently when stored and manipulated as a collection. You can use the System.Array class or the classes in the System.Collections namespace to add, remove, and modify either individual elements or a range of elements in a collection. For more info go to https://docs.microsoft.com/en-us/dotnet/standard/collections/index . TinyCLR OS collections support ArrayLists, Hashtables, Stacks, and Queues. ArrayLists ArrayLists have a significant advantage over arrays in that ArrayLists are automatically resized as needed, whereas arrays are limited to a fixed number of elements. The following code sample creates an ArrayList, adds a couple of records, and then iterates through the ArrayList items and displays each record. class Program { private struct rmaRecord { public System.DateTime date; public string modelNumber; public string fault; } private static void Main() { var rmaList = new System.Collections.ArrayList(); var record = new rmaRecord(); record.date = new System.DateTime(2020, 2, 21); record.modelNumber = \"XY23\"; record.fault = \"No power\"; rmaList.Add(record); record.date = new System.DateTime(2020, 2, 20); record.modelNumber = \"XY42\"; record.fault = \"Blown fuse\"; rmaList.Add(record); PrintValues(rmaList); } private static void PrintValues(System.Collections.ArrayList list) { System.Diagnostics.Debug.WriteLine(\"Count: \" + list.Count); System.Diagnostics.Debug.WriteLine(\"Capacity: \" + list.Capacity); System.Diagnostics.Debug.WriteLine(\" \"); System.Diagnostics.Debug.WriteLine(\"Values:\"); foreach (rmaRecord record in list) { System.Diagnostics.Debug.WriteLine(\" Date: \" + record.date.Year + \"/\" + record.date.Month + \"/\" + record.date.Day); System.Diagnostics.Debug.WriteLine(\" Model#: \" + record.modelNumber); System.Diagnostics.Debug.WriteLine(\" Fault: \" + record.fault); System.Diagnostics.Debug.WriteLine(\"----------\"); } } } The above code outputs the following: Count: 2 Capacity: 4 Values: Date: 2020/2/21 Model#: XY23 Fault: No power ---------- Date: 2020/2/20 Model#: XY42 Fault: Blown fuse ---------- In the above sample, rmaList.Clear() will remove all elements from rmaList , rmaList.RemoveAt(1) will remove only the second element in the list, and rmaList.Remove(record) will remove the first element that is equal to record . Hashtables Hash tables are used to store information in a way that associates each data element, or value, with a key that can be used to look up that value. Hash tables make it easy to quickly retrieve information that would otherwise be difficult to organize in an efficient manner. For example, imagine trying to look up a phone number from a given name. You could make a two dimension array of names and phone numbers and then iterate through the array looking for the correct name, but this would be slow with a large array. Hash tables solve this problem by using a hash function to convert a key, in this case a name, into an array index that points directly to the data element you are looking for. This allows you to quickly retrieve the data directly instead of searching for it. The following code sample creates a hash table, adds elements to the hash table, and then reads back the value for each key. //Create a hash table. System.Collections.Hashtable processorPin = new System.Collections.Hashtable(); //Add some elements to the hash table. There can be no duplicate keys, but duplicate // values are allowed. // Key Value processorPin.Add(\"LDR\", \"PE3\"); processorPin.Add(\"APP\", \"PB7\"); processorPin.Add(\"MOD\", \"PD7\"); processorPin.Add(\"WKUP\", \"PA0\"); processorPin.Add(\"BTN1\", \"PE3\"); processorPin.Add(\"BTN2\", \"PB7\"); processorPin.Add(\"BTN3\", \"PD7\"); //When you use foreach to enumerate hash table elements, the elements are retrieved // as DictionaryEntry objects. foreach (System.Collections.DictionaryEntry de in processorPin) { System.Diagnostics.Debug.WriteLine(\"Key = \" + de.Key + \" Value = \" + de.Value); } The above code outputs the following: Key = MOD Value = PD7 Key = LDR Value = PE3 Key = BTN1 Value = PE3 Key = BTN2 Value = PB7 Key = BTN3 Value = PD7 Key = WKUP Value = PA0 Key = APP Value = PB7 Stacks Stacks are first in, last out (or last in, first out) collections of objects. The Push method is used to add items to a stack, and the Pop method is used to remove items from a stack. There is also a Peek method that returns the item at the top of the stack without removing it from the stack. private static void Main() { var sitCoreDevices = new System.Collections.Stack(); sitCoreDevices.Push(\"SC20100S\"); sitCoreDevices.Push(\"SC20260B\"); sitCoreDevices.Push(\"SCM20260D\"); sitCoreDevices.Push(\"SCM20260E\"); sitCoreDevices.Push(\"SCM20260N\"); PrintValues(sitCoreDevices); System.Diagnostics.Debug.WriteLine(\"Popped: \" + sitCoreDevices.Pop().ToString()); System.Diagnostics.Debug.WriteLine(\" \"); PrintValues(sitCoreDevices); } public static void PrintValues(System.Collections.Stack myQueue) { System.Diagnostics.Debug.WriteLine(\"Count: \" + myQueue.Count); System.Diagnostics.Debug.WriteLine(\"Items in queue:\"); foreach (System.Object obj in myQueue) System.Diagnostics.Debug.WriteLine(\" \" + obj); System.Diagnostics.Debug.WriteLine(\" \"); } The above code outputs the following: The thread '<No Name>' (0x2) has exited with code 0 (0x0). Count: 5 Items in queue: SCM20260N SCM20260E SCM20260D SC20260B SC20100S Popped: SCM20260N Count: 4 Items in queue: SCM20260E SCM20260D SC20260B SC20100S Queues Queues are first in, first out collections of objects. To add items to a queue, the enqueue method is used. To remove items, the dequeue method is used. private static void Main() { var sitCoreDevices = new System.Collections.Queue(); sitCoreDevices.Enqueue(\"SC20100S\"); sitCoreDevices.Enqueue(\"SC20260B\"); sitCoreDevices.Enqueue(\"SCM20260D\"); sitCoreDevices.Enqueue(\"SCM20260E\"); sitCoreDevices.Enqueue(\"SCM20260N\"); PrintValues(sitCoreDevices); System.Diagnostics.Debug.WriteLine(\"Dequeued: \" + sitCoreDevices.Dequeue().ToString()); System.Diagnostics.Debug.WriteLine(\" \"); PrintValues(sitCoreDevices); } public static void PrintValues(System.Collections.Queue myQueue) { System.Diagnostics.Debug.WriteLine(\"Count: \" + myQueue.Count); System.Diagnostics.Debug.WriteLine(\"Items in queue:\"); foreach (System.Object obj in myQueue) System.Diagnostics.Debug.WriteLine(\" \" + obj); System.Diagnostics.Debug.WriteLine(\" \"); } The above code outputs the following: Count: 5 Items in queue: SC20100S SC20260B SCM20260D SCM20260N SCM20260E Dequeued: SC20100S Count: 4 Items in queue: SC20260B SCM20260D SCM20260N SCM20260E"
  },
  "software/tinyclr/tutorials/configuration.html": {
    "href": "software/tinyclr/tutorials/configuration.html",
    "title": "Configuration",
    "keywords": "Configuration"
  },
  "software/tinyclr/tutorials/cryptography.html": {
    "href": "software/tinyclr/tutorials/cryptography.html",
    "title": "Cryptography",
    "keywords": "Cryptography TinyCLR OS supports RSA public key cryptography. Key sizes can be 1024 or 2048 bits and are generated automatically when RSACryptoServiceProvider() is instantiated. Note RSACryptoServiceProvider() implements the IDisposable interface Tip Needed NuGets: GHIElectronics.TinyCLR.Core and GHIElectronics.TinyCLR.Cryptography The following sample code encrypts and decrypts a string of text. byte[] dataToEncrypt = System.Text.Encoding.UTF8.GetBytes(\"Data to Encrypt\"); byte[] encryptedData; byte[] decryptedData; using (GHIElectronics.TinyCLR.Cryptography.RSACryptoServiceProvider RSA = new GHIElectronics.TinyCLR.Cryptography.RSACryptoServiceProvider(2048)) { //Encrypt data. using (GHIElectronics.TinyCLR.Cryptography.RSACryptoServiceProvider encryptRSA = new GHIElectronics.TinyCLR.Cryptography.RSACryptoServiceProvider()) { encryptRSA.ImportParameters(RSA.ExportParameters(false)); encryptedData = encryptRSA.Encrypt(dataToEncrypt); } //Decrypt data. using (GHIElectronics.TinyCLR.Cryptography.RSACryptoServiceProvider decryptRSA = new GHIElectronics.TinyCLR.Cryptography.RSACryptoServiceProvider()) { decryptRSA.ImportParameters(RSA.ExportParameters(true)); decryptedData = decryptRSA.Decrypt(encryptedData); } } System.Diagnostics.Debug.WriteLine(\"Decrypted: \" + System.Text.Encoding.UTF8.GetString(decryptedData)); The above code outputs the following: Decrypted: Data to Encrypt If no key size is provided as an argument to RSACryptoServiceProvider() , a default key size of 1024 bits will be used. The boolean argument for RSA.ExportParameters() determines whether this method returns the private key (true) or public key (false). The public key is used to encrypt messages, while the private key is needed to decrypt messages."
  },
  "software/tinyclr/tutorials/debugging.html": {
    "href": "software/tinyclr/tutorials/debugging.html",
    "title": "Debugging",
    "keywords": "Debugging Debug a tiny IoT device just like you would debug an application on a full PC. You can easily debug your code from within Visual Studio over USB or Serial. Set breakpoints, step through code, and examine variables without the need for specialized hardware or software. On power up, the system checks the MOD pin to determine the debug interface, USB or Serial. Information on using the debugger can be found in Microsoft's documentation here ."
  },
  "software/tinyclr/tutorials/displays.html": {
    "href": "software/tinyclr/tutorials/displays.html",
    "title": "Displays",
    "keywords": "Displays Graphical Displays can be grouped into two distinct interface categories, built-in parallel TFT displays and virtual displays, typically serial (SPI/I2C) displays. There are also non-graphical character displays and those work through a simple driver, not using the graphics . The display drivers are meant to transfer the pixel data from memory to the actual display. The graphics tutorial shows how drawing is done in memory. Built-in TFT Displays These displays connect to special dedicated pins on the processor. Internally, the display controller automatically transfers (refreshes) the display directly from memory without any processor interaction, using DMA. When the system needs to update the display, it simply writes to memory. Neither the operating system nor the application program are burdened with display processing. The down side to this is that the system needs to have enough RAM to handle the display. An 800x600 display with 16bpp needs 960,000 bytes! Virtual Displays The internal graphics services can be mapped to work with virtual display displays. This is done by accessing graphics memory directly, and then writing the graphics memory contents to the desired display. private static void Graphics_OnFlushEvent(IntPtr hdc, byte[] data) { st7735.DrawBuffer(data); } See the Graphics Tutorial for more information and sample code. Character Displays These displays are capable of only showing characters. Most of these displays use the HD44780 controller. They are available in different sizes, but two lines of 16 characters is most common. These displays only require GPIO pins and can be used with TinyCLR. Sample code for HD44780 displays can be found in our GitHub Samples Repo . Low Level Display Access TinyCLR also provides low level display access as part of the GHIElectronics.TinyCLR.Devices.Display library. These methods provide a simple way to write to a display without need for the System.Drawing library or an added font resource file. Tip The low level support should only be used in advanced edge cases only. The following example is written for the SC20260D Dev Board with the 4.3\" display. It will paint the screen as shown in the picture beneath the code. Note that low level display access requires that you use the data format required by your display as configured. The SC20260D Dev Board used in this example expects each pixel to have 16 bits (two bytes per pixel) of color information in RGB565 format. Tip Needed Nugets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Display, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.I2c, GHIElectronics.TinyCLR.Devices.Spi, GHIElectronics.TinyCLR.Native, and GHIElectronics.TinyCLR.Pins. using GHIElectronics.TinyCLR.Devices.Display; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; namespace LowLevelDisplayAccess{ class Program{ private static void Main(){ GpioPin backlight = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PA15); backlight.SetDriveMode(GpioPinDriveMode.Output); backlight.Write(GpioPinValue.High); var displayController = DisplayController.GetDefault(); // Enter the proper display configurations displayController.SetConfiguration(new ParallelDisplayControllerSettings{ Width = 480, Height = 272, DataFormat = GHIElectronics.TinyCLR.Devices.Display.DisplayDataFormat.Rgb565, Orientation = DisplayOrientation.Degrees0, //Rotate display. PixelClockRate = 10000000, PixelPolarity = false, DataEnablePolarity = false, DataEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, }); displayController.Enable(); byte[] myPic = new byte[480 * 272 * 2]; for (var i = 0; i < myPic.Length; i++){ myPic[i] = (byte)(((i % 2) == 0) ? ((i / 4080) & 0b00000111) << 5 : i / 32640); } displayController.DrawString(\"\\f\"); displayController.DrawBuffer(0, 0, 0, 0, 480, 272, 480, myPic, 0); displayController.DrawString(\"GHI Electronics\\n\"); displayController.DrawString(\"Low Level Display Demo.\"); for (var x = 20; x < 459; x++){ displayController.DrawPixel(x, 50, 0xF800); //Color is 31,0,0 (RGB565). displayController.DrawPixel(x, 51, 0xF800); } } } } SCM20260D Dev Board 4.3\" display after running the sample code:"
  },
  "software/tinyclr/tutorials/encoding-decoding.html": {
    "href": "software/tinyclr/tutorials/encoding-decoding.html",
    "title": "Encoding & Decoding",
    "keywords": "Encoding & Decoding TinyCLR OS provides the following methods for converting data and handling strings. Encoding The Encoding class is used to convert between strings, character arrays, and byte arrays. For example, to convert from a byte array to a string: var string = System.Text.Encoding.UTF8.GetString(new byte[] { 65, 66, 67, 68, 69 }); //string = \"ABCDE\" Encoding Overloads Convert From String to Byte Array System.Text.Encoding.UTF8.GetBytes(string s) //The following method returns an integer for the number of bytes converted. //The resulting bytes are returned within the byte[] array. System.Text.Encoding.UTF8.GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex) Convert From Byte Array to Character Array System.Text.Encoding.UTF8.GetChars(byte[] bytes) System.Text.Encoding.UTF8.GetChars(byte[] bytes, int byteIndex, int byteCount) Convert From Byte Array to String System.Text.Encoding.UTF8.GetString(byte[] bytes) System.Text.Encoding.UTF8.GetString(byte[] bytes, int index, int count) BitConverter The BitConverter class is used to convert from one data type to another. For example, to convert an integer into a byte array: var byteArray = System.BitConverter.GetBytes(23); //byteArray[0] = 23, byteArray[1] = 0, byteArray[2] = 0, byteArray[3] = 0 byteArray = System.BitConverter.GetBytes(65536); //byteArray[0] = 0, byteArray[1] = 0, byteArray[2] = 1, byteArray[3] = 0 You can also convert from a byte array to a string, but the results are different than the results from the Encoding class: var string = System.BitConverter.ToString(new byte[] { 65, 66, 67, 68, 69 }); //string = \"41-42-43-44-45\" (hexadecimal values delimited by hyphens). var string = System.Text.Encoding.UTF8.GetString(new byte[] { 65, 66, 67, 68, 69 }); //string = \"ABCDE\" BitConverter Overloads Convert to a Byte Array System.BitConverter.GetBytes(char value) System.BitConverter.GetBytes(double value) System.BitConverter.GetBytes(float value) System.BitConverter.GetBytes(int value) System.BitConverter.GetBytes(long value) System.BitConverter.GetBytes(short value) System.BitConverter.GetBytes(uint value) System.BitConverter.GetBytes(ulong value) System.BitConverter.GetBytes(ushort value) System.BitConverter.GetBytes(bool value) Convert from a Byte Array System.BitConverter.ToBoolean(byte[] bytes, int startIndex) System.BitConverter.ToChar(byte[] bytes, int startIndex) System.BitConverter.ToDouble(byte[] bytes, int startIndex) System.BitConverter.ToInt16(byte[] bytes, int startIndex) System.BitConverter.ToInt32(byte[] bytes, int startIndex) System.BitConverter.ToInt64(byte[] bytes, int startIndex) System.BitConverter.ToSingle(byte[] bytes, int startIndex) System.BitConverter.ToString(byte[] bytes) System.BitConverter.ToString(byte[] bytes, int startIndex) System.BitConverter.ToString(byte[] bytes, int startIndex, int length) System.BitConverter.ToUInt16(byte[] bytes, int startIndex) System.BitConverter.ToUInt32(byte[] bytes, int startIndex) System.BitConverter.ToUInt64(byte[] bytes, int startIndex) Convert Between Double and Long System.BitConverter.DoubleToInt64Bits(double value) System.BitConverter.Int64BitsToDouble(long value) Swap Endianness System.BitConverter.SwapEndianness(byte[] data, int groupSize) String Handling StringBuilder As strings are immutable, manipulating strings, especially in a tight loop, can impact system performance and increase memory usage and fragmentation. Because strings cannot be changed, every time you manipulate a string a new string is created and the original string becomes garbage. The StringBuilder class uses a string buffer to improve the performance of string manipulation, allowing you to manipulate strings instead of creating new strings. The following example changes the content of a string without creating a new string. var sb = new System.Text.StringBuilder(\"PA0 is the pin to use.\"); sb[1] = 'B'; System.Diagnostics.Debug.WriteLine(sb.ToString()); //Will output \"PB0 is the pin to use.\" StringBuilder is also great when you want to build strings by concatenating characters or other strings. Without StringBuilder, each time you add a character to a string, a new string is created and the old string becomes garbage. The following code creates a string one character at a time without creating all the garbage strings. var sb = new System.Text.StringBuilder(); for (int i=48; i<58; i++) { sb.Append((char)i); } System.Diagnostics.Debug.WriteLine(sb.ToString()); //Will output \"0123456789\""
  },
  "software/tinyclr/tutorials/ethernet.html": {
    "href": "software/tinyclr/tutorials/ethernet.html",
    "title": "Ethernet",
    "keywords": "Ethernet Ethernet is supported through the internal MAC, by adding an external PHY (100BASE), and also by using an ENC28J60 over SPI bus (10BASE). Some available modules include the necessary PHY, so the user will only need to add an Ethernet connector with magnets. If you are designing a product that incorporates Ethernet, you will need to ship each device with a valid and unique MAC address. More information about MAC addresses can be found here . Built-in Ethernet Here is a simple example: Tip Needed Nugets: GHIElectronics.TinyCLR.Devices.Network, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Pins static bool linkReady = false; static void EthernetTest() { //Reset external phy. var gpioController = GHIElectronics.TinyCLR.Devices.Gpio.GpioController.GetDefault(); var resetPin = gpioController.OpenPin(GHIElectronics.TinyCLR.Pins.SC20260.GpioPin.PG3); resetPin.SetDriveMode(GHIElectronics.TinyCLR.Devices.Gpio.GpioPinDriveMode.Output); resetPin.Write(GHIElectronics.TinyCLR.Devices.Gpio.GpioPinValue.Low); System.Threading.Thread.Sleep(100); resetPin.Write(GHIElectronics.TinyCLR.Devices.Gpio.GpioPinValue.High); System.Threading.Thread.Sleep(100); var networkController = GHIElectronics.TinyCLR.Devices.Network.NetworkController.FromName (GHIElectronics.TinyCLR.Pins.SC20260.NetworkController.EthernetEmac); var networkInterfaceSetting = new GHIElectronics.TinyCLR.Devices.Network. EthernetNetworkInterfaceSettings(); var networkCommunicationInterfaceSettings = new GHIElectronics.TinyCLR. Devices.Network.BuiltInNetworkCommunicationInterfaceSettings(); networkInterfaceSetting.Address = new System.Net.IPAddress (new byte[] { 192, 168, 1, 122 }); networkInterfaceSetting.SubnetMask = new System.Net.IPAddress (new byte[] { 255, 255, 255, 0 }); networkInterfaceSetting.GatewayAddress = new System.Net.IPAddress (new byte[] { 192, 168, 1, 1 }); networkInterfaceSetting.DnsAddresses = new System.Net.IPAddress[] { new System.Net.IPAddress(new byte[] { 75, 75, 75, 75 }), new System.Net.IPAddress(new byte[] { 75, 75, 75, 76 }) }; networkInterfaceSetting.MacAddress = new byte[] { 0x00, 0x4, 0x00, 0x00, 0x00, 0x00 }; networkInterfaceSetting.IsDhcpEnabled = true; networkInterfaceSetting.IsDynamicDnsEnabled = true; networkInterfaceSetting.TlsEntropy = new byte[] { 0, 1, 2, 3 }; networkController.SetInterfaceSettings(networkInterfaceSetting); networkController.SetCommunicationInterfaceSettings (networkCommunicationInterfaceSettings); networkController.SetAsDefaultController(); networkController.NetworkAddressChanged += NetworkController_NetworkAddressChanged; networkController.NetworkLinkConnectedChanged += NetworkController_NetworkLinkConnectedChanged; networkController.Enable(); while (linkReady == false) ; System.Diagnostics.Debug.WriteLine(\"Network is ready to use\"); System.Threading.Thread.Sleep(-1); } private static void NetworkController_NetworkLinkConnectedChanged (GHIElectronics.TinyCLR.Devices.Network.NetworkController sender, GHIElectronics.TinyCLR.Devices.Network.NetworkLinkConnectedChangedEventArgs e) { //Raise connect/disconnect event. } private static void NetworkController_NetworkAddressChanged (GHIElectronics.TinyCLR.Devices.Network.NetworkController sender, GHIElectronics.TinyCLR.Devices.Network.NetworkAddressChangedEventArgs e) { var ipProperties = sender.GetIPProperties(); var address = ipProperties.Address.GetAddressBytes(); linkReady = address[0] != 0; } ENC28J60 This example uses the ENC28J60 click on our SC20260D Dev Board. Tip Needed Nugets: GHIElectronics.TinyCLR.Devices.Network, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.Spi, GHIElectronics.TinyCLR.Pins static void Enc28Test() { var networkController = NetworkController.FromName (\"GHIElectronics.TinyCLR.NativeApis.ENC28J60.NetworkController\"); var networkInterfaceSetting = new EthernetNetworkInterfaceSettings(); var networkCommunicationInterfaceSettings = new SpiNetworkCommunicationInterfaceSettings(); var cs = GHIElectronics.TinyCLR.Devices.Gpio.GpioController.GetDefault(). OpenPin(GHIElectronics.TinyCLR.Pins.SC20260.GpioPin.PG12); var settings = new GHIElectronics.TinyCLR.Devices.Spi.SpiConnectionSettings() { ChipSelectLine = cs, ClockFrequency = 4000000, Mode = GHIElectronics.TinyCLR.Devices.Spi.SpiMode.Mode0, ChipSelectType = GHIElectronics.TinyCLR.Devices.Spi.SpiChipSelectType.Gpio, ChipSelectHoldTime = TimeSpan.FromTicks(10), ChipSelectSetupTime = TimeSpan.FromTicks(10) }; networkCommunicationInterfaceSettings.SpiApiName = GHIElectronics.TinyCLR.Pins.SC20260.SpiBus.Spi3; networkCommunicationInterfaceSettings.GpioApiName = GHIElectronics.TinyCLR.Pins.SC20260.GpioPin.Id; networkCommunicationInterfaceSettings.SpiSettings = settings; networkCommunicationInterfaceSettings.InterruptPin = GHIElectronics.TinyCLR.Devices. Gpio.GpioController.GetDefault().OpenPin (GHIElectronics.TinyCLR.Pins.SC20260.GpioPin.PG6); networkCommunicationInterfaceSettings.InterruptEdge = GpioPinEdge.FallingEdge; networkCommunicationInterfaceSettings.InterruptDriveMode = GpioPinDriveMode.InputPullUp; networkCommunicationInterfaceSettings.ResetPin = GHIElectronics.TinyCLR.Devices.Gpio. GpioController.GetDefault().OpenPin(GHIElectronics.TinyCLR.Pins.SC20260.GpioPin.PI8); networkCommunicationInterfaceSettings.ResetActiveState = GpioPinValue.Low; networkInterfaceSetting.Address = new IPAddress(new byte[] { 192, 168, 1, 122 }); networkInterfaceSetting.SubnetMask = new IPAddress(new byte[] { 255, 255, 255, 0 }); networkInterfaceSetting.GatewayAddress = new IPAddress(new byte[] { 192, 168, 1, 1 }); networkInterfaceSetting.DnsAddresses = new IPAddress[] { new IPAddress(new byte[] { 75, 75, 75, 75 }), new IPAddress(new byte[] { 75, 75, 75, 76 }) }; networkInterfaceSetting.MacAddress = new byte[] { 0x00, 0x4, 0x00, 0x00, 0x00, 0x00 }; networkInterfaceSetting.IsDhcpEnabled = true; networkInterfaceSetting.IsDynamicDnsEnabled = true; networkInterfaceSetting.TlsEntropy = new byte[] { 0, 1, 2, 3 }; networkController.SetInterfaceSettings(networkInterfaceSetting); networkController.SetCommunicationInterfaceSettings (networkCommunicationInterfaceSettings); networkController.SetAsDefaultController(); networkController.NetworkAddressChanged += NetworkController_NetworkAddressChanged; networkController.NetworkLinkConnectedChanged += NetworkController_NetworkLinkConnectedChanged; networkController.Enable(); while (linkReady == false) ; System.Diagnostics.Debug.WriteLine(\"Network is ready to use\"); Thread.Sleep(-1); } private static void NetworkController_NetworkLinkConnectedChanged (NetworkController sender, NetworkLinkConnectedChangedEventArgs e) { // Raise event connect/disconnect } private static void NetworkController_NetworkAddressChanged (NetworkController sender, NetworkAddressChangedEventArgs e) { var ipProperties = sender.GetIPProperties(); var address = ipProperties.Address.GetAddressBytes(); linkReady = address[0] != 0; } Event Handlers NetworkController provides two events: private static void NetworkController_NetworkLinkConnectedChanged (NetworkController sender, NetworkLinkConnectedChangedEventArgs e) { // Raise event connect/disconnect } private static void NetworkController_NetworkAddressChanged (NetworkController sender, NetworkAddressChangedEventArgs e) { var ipProperties = sender.GetIPProperties(); var address = ipProperties.Address.GetAddressBytes(); var subnet = ipProperties.SubnetMask.GetAddressBytes(); var gw = ipProperties.GatewayAddress.GetAddressBytes(); var interfaceProperties = sender.GetInterfaceProperties(); for (int i = 0; i < dnsCount; i++) { var dns = ipProperties.DnsAddresses[i].GetAddressBytes(); } }"
  },
  "software/tinyclr/tutorials/external-memory.html": {
    "href": "software/tinyclr/tutorials/external-memory.html",
    "title": "External Memory",
    "keywords": "External Memory External memory is typically not secure as it can be probed by hackers. However, external memory provides the large amount of storage required by some applications. External RAM Devices with external RAM have the option of utilizing this memory as Unmanaged Heap . Unmanaged heap is great for storing large amounts of data, but it is not considered secure. Bitmaps and large buffers are automatically stored in unmanaged heap. Developers also have the option of extending core managed heap into unsecure external memory, in which case there is no longer any unmanaged heap space. This feature is a trade off between security and convenience -- it provides a large amount of managed heap space, but data is stored outside of the microcontroller chip where it's less secure. Please see the IP Protection page for more information. TinyCLR Config can be used to extend the heap into external SDRAM, as well as the following method: GHIElectronics.TinyCLR.Native.Memory.ExtendHeap() External Flash Devices with external flash have the option of using up to 8 MBytes of this memory for deployment. This is done by using TinyCLR Config to enable external flash, or by using the following method: GHIElectronics.TinyCLR.Native.Flash.EnableExternalFlash() On SITCore devices that include external flash, there is another 8 MBytes we are reserving for future use. As external memory chips can possibly be probed, enabling external flash has important security implications. See the IP Protection page for more information."
  },
  "software/tinyclr/tutorials/file-system.html": {
    "href": "software/tinyclr/tutorials/file-system.html",
    "title": "File System",
    "keywords": "File System The file system library is subset of the full .NET file system support. Most example should work with without minor changes. The internal drivers fully support FAT16 or FAT32 file systems, with no limitations beyond the FAT file system itself! USB Mass Storage This allows file access on USB devices with MSC class, such as USB memory sticks. See the USB page. SD Card SD and MMC cards are fully supported as detailed on the SD tutorial page. The example below requires the GHIElectronics.TinyCLR.IO and GHIElectronics.TinyCLR.Devices.Storage libraries and a device with an SD card. Note Make sure the namespace statement in the following code is changed to match the namespace of your project. var sd = StorageController.FromName(SC20100.StorageController.SdCard); var drive = FileSystem.Mount(sd.Hdc); //Show a list of files in the root directory var directory = new DirectoryInfo(drive.Name); var files = directory.GetFiles(); foreach (var f in files) { System.Diagnostics.Debug.WriteLine(f.Name); } //Create a text file and save it to the SD card. var file = new FileStream($@\"{drive.Name}Test.txt\", FileMode.OpenOrCreate); var bytes = Encoding.UTF8.GetBytes(DateTime.UtcNow.ToString() + Environment.NewLine); file.Write(bytes, 0, bytes.Length); file.Flush(); FileSystem.Flush(sd.Hdc); Low-level Access You can access the raw underlying data of the storage provider by using the Provider property of the controller. Be careful when using this interface, however, as it bypasses any file system present and writes directly to the device. This is useful for implementing your own or otherwise unsupported file systems. var controller = StorageController.FromName (SC20100.StorageController.SdCard); controller.Provider.Read(address, buffer, 0, buffer.Length, -1);"
  },
  "software/tinyclr/tutorials/font-support.html": {
    "href": "software/tinyclr/tutorials/font-support.html",
    "title": "Font Support",
    "keywords": "Font Support Fonts can be included in your TinyCLR application by adding them as a resource . Any TrueType font can be used after being converted to the .tcfnt format with the FontConverter tool. The Font Converter tool (found under downloads is a command line utility which does just that. Make sure to use this tool for any fonts you need, using old fonts from NETMF will not work. var screen = Graphics.FromHdc(displayController.Hdc); var font = Resource.GetFont(Resource.FontResources.NinaB); var greenPen = new Pen(Color.Green); screen.DrawString(\"Hello World!\", font, greenPen.Brush, 10, 100); screen.Flush(); Built-in fonts When using systems with managed SPI display drivers, the font support is handled though an internal built-in font. This is done to reduce memory requirements. var teal = new SolidBrush(Color.Teal); var font = new Font(\"GHIMono8x5\", 8); screen.DrawString(\"Hello World!\", font, teal, 40, 10); screen.Flush(); Font Conversion To convert a font you must first make a .fntdef file which is a text file describing the font to convert as well as a number of other parameters. This file contains one option on each line. A minimal .fntdef file may look like this to have the standard ASCII characters. SelectFont \"FN:Arial,WE:400,HE:12,IT:0\" ImportRange 32 126 Tip This third-party tool can be handy for generating compatible fonts. Font Definition The .fntdef file options are as follows: Note The order of statements in the .fntdef file matters. For example, properties such as AntiAlias must be specified before the InputRange property. AddFontToProcess path Path is the path to the TrueType font you want to convert. If the path contains spaces, you must enclose it in quotes and escape any backslashes. Example: AddFontToProcess C:\\Windows\\Fonts\\Arial.ttf SelectFont \"selection string\" \"Selection string\" is a quoted string containing comma delimited fields indicating the characteristics of the font to convert. ConvertFont searches the TrueType fonts installed on your computer, as well as any fonts in the AddFontToProcess argument, for a font matching the characteristics in the selection string argument. The first match is converted. Using spaces around the commas or colons in selection string will result in errors. Field types are as follows: HE: Height in logical units. Use zero for default height, a positive number for cell height and a negative number for character height. WI: Width. Average width of characters in logical units. Set to zero for closest match based on aspect ratio. ES: Escapement angle in tenths of a degree. Negative numbers rotate clockwise, positive numbers rotate counterclockwise. WE: Weight of font in range of 0 to 1000. 400 is normal, 700 is bold. Set to zero for default weight. IT: Italic if set to 1 (IT:1). FN: Face name. Name of the typeface. FullName: Full name. The unique name of the font. For example: \"Monotype:Arial Regular (Microsoft).\" For example, SelectFont \"HE:12,WE:400,FN:Arial\" will look for a regular-weight font of height 12 with a face name of \"Arial.\" AdjustAscent adjustment Adjustment is integer number of EM units to adjust ascent. Can be positive or negative. Can only be used once per .fntdef file. If it is used more than once, only the last occurrence will be used. AdjustDescent adjustment Adjustment is integer number of EM units to adjust descent. Can be positive or negative. Can only be used once per .fntdef file. If it is used more than once, only the last occurrence will be used. AdjustExternalLeading adjustment Adjustment is integer number of EM units to adjust the external leading. Can be positive or negative. Can only be used once per .fntdef file. If it is used more than once, only the last occurrence will be used. AdjustInternalLeading adjustment Adjustment is integer number of EM units to adjust the internal leading. Can be positive or negative. Can only be used once per .fntdef file. If it is used more than once, only the last occurrence will be used. AdjustLeftMargin adjustment Adjustment is integer number of device units to add to the left margin. Can be positive or negative. Applies to the characters specified by the ImportRange statement that most closely follows this option. AdjustRightMargin adjustment Adjustment is integer number of EM units to add to the right margin. Can be positive or negative. Applies to the characters specified by the ImportRange statement that most closely follows this statement. AntiAlias level Level can be 1, 2, 4, or 8. Font bitmaps will contain 2, 5, 17, or 65 levels of gray respectively. Must come after the SelectFont statement specifying the font to which this statement applies. May be applied to a range of characters defined by the ImportRange option. ImportRange start end Start and end are Unicode character codes indicating the beginning and end of the range of characters to convert (inclusive). Can be applied multiple times to convert a non-contiguous range of characters. Must come after the SelectFont statement specifying the font to which this statement applies. Both arguments are required. To specify a single character, make start and end the same number. ImportRangeAndMap start end offset Specifies range of characters to convert starting with Unicode character start + offset and ending with character end + offset , inclusive. Can be applied multiple times to convert a non-contiguous range of characters. Must come after the SelectFont statement specifying the font to which this statement applies. NoDefaultCharacter Specifies that no default character will be substituted for characters not converted. Must come after the SelectFont statement specifying the font to which this statement applies. OffsetX adjustment Adjustment is an integer describing the number of EM units to shift character position left or right. Positive numbers shift to the left, and negative numbers shift to the right. Applies to characters specified by any ImportRange, ImportRangeAndMap, or SetAsDefaultCharacter statements that follow it in the .fntdef file. Subsequent OffsetX statements supersede all previous OffxetX statements in the same .fntdef file. OffsetY adjustment Adjustment is an integer describing the number of EM units to shift character position up or down. Positive numbers shift down, and negative numbers shift up. Applies to characters specified by any ImportRange, ImportRangeAndMap, or SetAsDefaultCharacter statements that follow it in the .fntdef file. Subsequent OffsetX statements supersede all previous OffxetX statements in the same .fntdef file. SetAsDefaultcharacter charcode \"Charcode is the Unicode character code for the default character to substitute for characters that weren't converted. SetDefaultcharacter Indicates that the default character of the currently selected TrueType font will be substituted for characters that weren't converted. Verbosity level Note Not currently supported, set to 0. Level can be 0, 1, or 2. Level 0 displays no details, level 1 displays font properties, and level 2 displays font and character properties and a diagram of each character. # Comments You can add comments to your .fntdef file by starting the comment line with the \"#\" character. Syntax for running FontConverter is GHIElectronics.TinyCLR.FontConverter.exe input-font output-font . For example GHIElectronics.TinyCLR.FontConverter.exe Arial.fntdef Arial.tcfnt . Resources Fonts can be added to your application as a resource. Click here for more information."
  },
  "software/tinyclr/tutorials/google-cloud.html": {
    "href": "software/tinyclr/tutorials/google-cloud.html",
    "title": "Google Cloud",
    "keywords": "Google Cloud This example below demonstrates how to communicate with the Google Cloud Platform: Tip Needed Nugets: GHIElectronics.TinyCLR.Networking.Mqtt static void DoTestGoogleCloudMqtt() { string iotHubName = \"mqtt.googleapis.com\"; int iotPort = 8883; var projectId = \"your project id\"; var cloudRegion = \"your region\"; var registryId = \"your register id\"; var deviceId = \"your device id\"; var clientId = $\"projects/{projectId}\" + $\"/locations/{cloudRegion}\" + $\"/registries/{registryId}\" + $\"/devices/{deviceId}\"; var message = \"My message\"; var caCertSource = UTF8Encoding.UTF8.GetBytes(\"Your CA certificate\"); var clientCertSource = UTF8Encoding.UTF8.GetBytes(\"Your Client certificate\"); X509Certificate CaCert = new X509Certificate(caCertSource); X509Certificate ClientCert = new X509Certificate(clientCertSource); var clientSetting = new MqttClientSetting { BrokerName = iotHubName, BrokerPort = iotPort, CaCertificate = CaCert, ClientCertificate = null, SslProtocol = System.Security.Authentication.SslProtocols.Tls12 }; var iotClient = new Mqtt(clientSetting); var jwt = \"your jwt\"; iotClient.PublishReceivedChanged += (a, b) => { Debug.WriteLine(\"Publish Received Changed.\"); }; iotClient.PublishedChanged += (a, b, c) => { Debug.WriteLine(\"Published Changed.\"); }; ; iotClient.SubscribedChanged += (a, b) => { Debug.WriteLine(\"Subscribed Changed.\"); }; iotClient.ConnectedChanged += (a) => { Debug.WriteLine(\"Connected Changed.\"); }; iotClient.UnsubscribedChanged += (a, b) => { Debug.WriteLine(\"Unsubscribed Changed.\"); }; var connectSetting = new MqttConnectionSetting { ClientId = clientId, UserName = \"unused\", Password = jwt }; string topic = $\"/devices/{deviceId}/events\"; var returnCode = iotClient.Connect(connectSetting); if (returnCode == ConnectReturnCode.ConnectionAccepted) { iotClient.Publish(topic , UTF8Encoding.UTF8.GetBytes(message) , QoSLevel.LeastOnce , false, 1); } } This example requires projectId, cloudRegion, registryId, and deviceId, which will be available when you register a Google Cloud account. a client certificate and private key are also provided when you register your account. You may want to visit https://cloud.google.com/iot/docs/quickstart for more detail. JWT When connect to google cloud, you also need a JWT (JSON Web Token) to be used as password if using MQTT. For an easy way to generate a JWT visit https://jwt.io/ . However, if you are concerned about sharing your private key with a third party site, there are a multitude of other options. Warning By using https://jwt.io/ , your private key is shared with a third party. This should be used only for testing purpose.\" There are also two fields iat (issue at), and exp (expire), they contains time in Unix Timestamp format. You can convert them online at https://www.epochconverter.com/ Note The google cloud connection accepts a maximum expire time of 24 hours, meaning the timespan between iat and exp must be less that 24 hours."
  },
  "software/tinyclr/tutorials/gpio.html": {
    "href": "software/tinyclr/tutorials/gpio.html",
    "title": "General Purpose Input Output (GPIO)",
    "keywords": "General Purpose Input Output (GPIO) Microcontrollers include pins that can be controlled through software. They can be inputs or outputs, hence the name \"general purpose input/output,\" or GPIO for short. Tip GPIO is found in the GHIElectronics.TinyCLR.Devices.Gpio NuGet package and pin definitions are found in the GHIElectronics.TinyCLR.Pins package. Digital Outputs A digital output pin can be set to either high or low. There are different ways of describing these two states. High can also be called \"true\" or \"one;\" low can be called \"false\" or \"zero\". If the processor is powered from 3.3V, then the state high means that there is 3.3V on the output pin. It is not going to be exactly 3.3V but very close. When the pin is set to low, it's voltage will be very close to zero. Maximum Output Current Each SITCore GPIO pin can sink and source up to 8 mA of current, and up to 20 mA with relaxed output voltage ratings. For example, the maximum output low voltage is 0.4 volts when the I/O current is +8 mA, but could be as high as 1.3 volts when the I/O current is +20 mA. The minimum output high voltage is Vdd - 0.4 volts (2.9 volts with 3.3 volt supply) when the I/O current is -8 mA, but could be as low as Vdd - 1.3 (2.0 volts with 3.3 volt supply) volts when the I/O current is -20 mA. The total output current sunk or sourced by the sum of all I/Os and control pins must not exceed 140 mA. Warning Never connect two output pins together. If they are connected and one is high and the other is low, the entire processor can be damaged. Warning Digital pins on microcontrollers are weak. They can only be used to control small LEDs or transistors. Those transistors can, in turn, control devices with high power needs like a motor. var led = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PH6); led.SetDriveMode(GpioPinDriveMode.Output); while (true) { led.Write(GpioPinValue.High); Thread.Sleep(100); led.Write(GpioPinValue.Low); Thread.Sleep(100); } Digital Inputs Digital inputs sense the state of an input pin based on its voltage. The pin can be high or low. Every pin has a maximum and minimum supported voltage. For example, the typical minimum voltage on most pins is 0 volts; a negative voltage may damage the pin or the processor. Also, the maximum that can be applied to most pins must be less than or equal to the processor's power supply voltage. Since most processors run on 3.3V, the highest voltage a pin should see is 3.3V. However, some processors that are powered by 3.3V are 5V tolerant -- they can withstand up to 5V on their inputs. The SITCore is 5V tolerant. Warning 5V tolerant doesn't mean the processor can be powered by 5V, only that the input pins can tolerate 5V. Unconnected input pins are called \"floating.\" They are in a high impedance state and are susceptible to surrounding noise which can make the pin read high or low. A resistor can be added to pull the pin high or low. Modern processors include internal pull-up and pull-down resistors that are controlled by software. Note that a pull-up resistor doesn't necessarily make a pin high -- something connected to the pin can still pull it low. In this example, a button is connected between ground and an input pin. We will enable the pull-up resistor making that pin high when the button is not pressed. When the button is pressed, it will overpower the pull-up and make the input low. We will read the status of the button and pass its state to an LED. Tip Never use an infinite loop without giving the system time to think. Add a short sleep to the loop, or use events instead. var gpio = GpioController.GetDefault(); var button = gpio.OpenPin(SC20260.GpioPin.PD7); button.SetDriveMode(GpioPinDriveMode.InputPullUp); while (true) { if (button.Read() == GpioPinValue.Low) { //Button is pressed. } Thread.Sleep(10); //Always give the system time to think! } Digital Input Events In the previous example the program loops forever. The input attached to the button is checked during each iteration of the loop. The pin may be checked millions of times before the button is pressed! This method of checking inputs is called \"polled input.\" Using events to check an input instead of polling the input is often preferred. Once an event is set up it will automatically check the input on its own, freeing up the program to do other things. Also, it is possible to miss a change in input if you don't check (or poll) the input often enough. Events use interrupts to check inputs so you don't have to worry about missing anything. When an event occurs, the program stops what it is doing and control is transferred to an event handler. An event handler is code you write that responds to the event. Let's use event driven programming to respond to a button and turn an LED on and off. We will raise an event when the value on the button's input pin changes because the button is pressed or released. You will see a reference to a \"falling edge\" in the following code. A falling edge occurs when the state of a pin goes from high to low. A rising edge is just the opposite -- it occurs when a pin goes from low to high. The following code demonstrates a GPIO pin event (interrupt) on the SCM20260D Dev board. This example works exactly the same as the example above, but uses events instead of polling. private static void Main() { var gpio = GpioController.GetDefault(); var button = gpio.OpenPin(SC20260.GpioPin.PD7); button.SetDriveMode(GpioPinDriveMode.InputPullUp); button.ValueChanged += Button_ValueChanged; //Do other tasks here ... Thread.Sleep(-1); } private static void Button_ValueChanged(GpioPin sender, GpioPinValueChangedEventArgs e) { if (e.Edge == GpioPinEdge.FallingEdge) { // Pin went low } else { // Pin went high } } Tip Once you type += after the event, hit the tab key and Visual Studio will automatically create the event for you. Pin Interrupts Input events use interrupts (IRQs). Interrupts are only available on 16 pins at any given time. Of those 16 pins, the pin number must be unique. For example: PA1 and PB1 cannot both be used as interrupts at the same time. However, PA1 and PB2, or even PA1 and PA2, can be used simultaneously with interrupts. It is also important to consider what interrupt pins are used by the system's internal functions, such as WiFi and touch screen interrupt pins. These interrupts invalidate interrupts with the same pin number on any GPIO port. If your product design relies on interrupts, be very careful when allocating GPIO pins to make sure interrupts are available on all needed pins."
  },
  "software/tinyclr/tutorials/graphics.html": {
    "href": "software/tinyclr/tutorials/graphics.html",
    "title": "Graphics",
    "keywords": "Graphics The GHIElectronics.TinyCLR.Drawing NuGet package includes the backbone for all graphics needs. It has support for shapes, fonts and bitmaps. Shape examples are Graphics.FillEllipse , Graphics.DrawLine and Graphics.DrawRectangle . These methods need Pen and Brush that are also part of Graphics . Native Displays Native display support in TinyCLR OS is handled automatically using the microcontroller's DMA to transfer data to the display without slowing down your application. Because of this, native displays can be much larger in size and resolution while using less processor time than non-native displays. Additionally, native displays usually transfer data in parallel as opposed to the serial transfer usually used with non-native displays, so the data is transferred much more quickly. SCM20260D Dev Board Code Sample The following example runs on the SCM20260D Dev Board with either the 4.3\" or 7\" display. You will need to add a font and a small JPG image as resources to run the code as is. With 4.3\" Display Tip Needed Nugets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Display, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.I2c, GHIElectronics.TinyCLR.Devices.Spi, GHIElectronics.TinyCLR.Drawing, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Pins. Tip Make sure you change the namespace to match your project! using GHIElectronics.TinyCLR.Devices.Display; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; using System.Drawing; using System.Threading; namespace GraphicsSample { class Program { private static void Main() { GpioPin backlight = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PA15); backlight.SetDriveMode(GpioPinDriveMode.Output); backlight.Write(GpioPinValue.High); var displayController = DisplayController.GetDefault(); // Enter the proper display configurations displayController.SetConfiguration(new ParallelDisplayControllerSettings { Width = 480, Height = 272, DataFormat = DisplayDataFormat.Rgb565, Orientation = DisplayOrientation.Degrees0, //Rotate display. PixelClockRate = 10000000, PixelPolarity = false, DataEnablePolarity = false, DataEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, }); displayController.Enable(); //This line turns on the display I/O and starts // refreshing the display. Native displays are // continually refreshed automatically after this // command is executed. var screen = Graphics.FromHdc(displayController.Hdc); var image = Resource1.GetBitmap(Resource1.BitmapResources.smallJpegBackground); var font = Resource1.GetFont(Resource1.FontResources.small); screen.Clear(); screen.FillEllipse(new SolidBrush(System.Drawing.Color.FromArgb (255, 255, 0, 0)), 0, 0, 240, 136); screen.FillEllipse(new SolidBrush(System.Drawing.Color.FromArgb (255, 0, 0, 255)), 240, 0, 240, 136); screen.FillEllipse(new SolidBrush(System.Drawing.Color.FromArgb (128, 0, 255, 0)), 120, 0, 240, 136); screen.DrawImage(image, 216, 122); screen.DrawRectangle(new Pen(Color.Yellow), 10, 150, 140, 100); screen.DrawEllipse(new Pen(Color.Purple), 170, 150, 140, 100); screen.FillRectangle(new SolidBrush(Color.Teal), 330, 150, 140, 100); screen.DrawLine(new Pen(Color.White), 10, 271, 470, 271); screen.SetPixel(240, 200, 0xFF0000); screen.DrawString(\"Hello world!\", font, new SolidBrush(Color.Blue), 210, 255); screen.Flush(); Thread.Sleep(-1); } } } With 7\" Display If you are using the UD700 7 inch display, replace the display configuration code with the following code: displayController.SetConfiguration(new ParallelDisplayControllerSettings { Width = 800, Height = 480, DataFormat = DisplayDataFormat.Rgb565, Orientation = DisplayOrientation.Degrees0, //Rotate display. PixelClockRate = 24000000, PixelPolarity = false, DataEnablePolarity = false, DataEnableIsFixed = false, HorizontalFrontPorch = 16, HorizontalBackPorch = 46, HorizontalSyncPulseWidth = 1, HorizontalSyncPolarity = false, VerticalFrontPorch = 7, VerticalBackPorch = 23, VerticalSyncPulseWidth = 1, VerticalSyncPolarity = false, }); Non-Native Displays Our SC20100S Dev Board has a non-native SPI display installed on it. There are special considerations for non-native displays -- instead of the data being automatically written to the display using the microcontroller's DMA, you must format and then transfer the data to the display yourself. Only the SC20260B SITCore chip has the resources to support native displays. Any device the uses the SC20100S chip can only support non-native displays. At the bottom of the next code sample, you will notice a Graphics_OnFlushEvent() event handler. This method gets called when the display is flushed. In this case, there is a DrawBuffer method that is part of the ST7735 display driver that writes to the display over SPI. Because this method is available, you need only call it within the Graphics_OnFlushEvent() event handler to write the buffer to the display. If you are using a display without a driver, you will have to correctly format the display data and send it to the display yourself inside this event handler. SC20100S Dev Board Code Sample The following sample code runs on our SC20100S Dev Board with its built in display. You will need to add a font and a small JPG image as resources to run the code as is. Tip Needed Nugets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Display, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.I2c, GHIElectronics.TinyCLR.Devices.Spi, GHIElectronics.TinyCLR.Drawing, GHIElectronics.TinyCLR.Drivers.Sitronix.ST7735, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Pins. Tip Make sure you change the namespace to match your project! using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Devices.Spi; using GHIElectronics.TinyCLR.Drivers.Sitronix.ST7735; using GHIElectronics.TinyCLR.Pins; using System; using System.Drawing; using System.Threading; namespace GraphicsSample { class Program { private static ST7735Controller st7735; private const int SCREEN_WIDTH = 160; private const int SCREEN_HEIGHT = 128; private static void Main() { var spi = SpiController.FromName(SC20100.SpiBus.Spi3); var gpio = GpioController.GetDefault(); st7735 = new ST7735Controller( spi.GetDevice(ST7735Controller.GetConnectionSettings (SpiChipSelectType.Gpio, SC20100.GpioPin.PD10)), //CS pin. gpio.OpenPin(SC20100.GpioPin.PC4), //RS pin. gpio.OpenPin(SC20100.GpioPin.PE15) //RESET pin. ); var backlight = gpio.OpenPin(SC20100.GpioPin.PE5); backlight.SetDriveMode(GpioPinDriveMode.Output); backlight.Write(GpioPinValue.High); st7735.SetDataAccessControl(true, true, false, false); //Rotate the screen. st7735.SetDrawWindow(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT); st7735.Enable(); // Create flush event Graphics.OnFlushEvent += Graphics_OnFlushEvent; // Create bitmap buffer var screen = Graphics.FromImage(new Bitmap(SCREEN_WIDTH, SCREEN_HEIGHT)); var image = Properties.Resources.GetBitmap(Properties.Resources.BitmapResources. smallJpegBackground); var font = Properties.Resources.GetFont(Properties.Resources.FontResources.small); screen.Clear(); screen.FillEllipse(new SolidBrush(System.Drawing.Color.FromArgb (255, 255, 0, 0)), 0, 0, 80, 64); screen.FillEllipse(new SolidBrush(System.Drawing.Color.FromArgb (255, 0, 0, 255)), 80, 0, 80, 64); screen.FillEllipse(new SolidBrush(System.Drawing.Color.FromArgb (128, 0, 255, 0)), 40, 0, 80, 64); screen.DrawImage(image, 56, 50); screen.DrawRectangle(new Pen(Color.Yellow), 10, 80, 40, 25); screen.DrawEllipse(new Pen(Color.Purple), 60, 80, 40, 25); screen.FillRectangle(new SolidBrush(Color.Teal), 110, 80, 40, 25); screen.DrawLine(new Pen(Color.White), 10, 127, 150, 127); screen.SetPixel(80, 92, 0xFF0000); screen.DrawString(\"Hello world!\", font, new SolidBrush(Color.Blue), 50, 110); screen.Flush(); Thread.Sleep(-1); } private static void Graphics_OnFlushEvent(IntPtr hdc, byte[] data) { st7735.DrawBuffer(data); } } } Helper Methods With parallel displays, (also called native displays), the DisplayController.ActiveConfiguration can be used to read the configuration at any time. The Width and Height can be used to write code that automatically scales to the display's resolution. The following line of code draws a line from corner to corner, no matter the display resolution. screen.DrawLine(new Pen(Color.Red), 0, 0, displayController.ActiveConfiguration.Width - 1, displayController.ActiveConfiguration.Height - 1); It is important to note that drawing functions process graphics in RAM independently from the display. The display driver then transfers the pixels from internal memory to the display when Graphics.Flush is called. Learn more about display support. Images TinyCLR OS supports the BMP, GIF, and JPG. See the Image Decoders page. Fonts Fonts are well supported. They are covered here ."
  },
  "software/tinyclr/tutorials/hashing.html": {
    "href": "software/tinyclr/tutorials/hashing.html",
    "title": "Hashing",
    "keywords": "Hashing TinyCLR OS currently supports the very popular MD5 hash function. While MD5 is no longer used as a cryptographic hash function, it is still used as a checksum to guard against unintentional corruption of data. For example, our Downloads page lists the MD5 hash value of each TinyCLR OS file. When you download one of these files, you can calculate the MD5 hash value of the downloaded file to make sure it matches the MD5 hash value we provide. This ensures the file was downloaded correctly and matches the original. The following commands will calculate the MD5 hash value of a byte array: Tip Needed NuGets: GHIElectronics.TinyCLR.Core and GHIElectronics.TinyCLR.Cryptography var md5 = GHIElectronics.TinyCLR.Cryptography.MD5.Create(); var hashValue = md5.ComputeHash(data); //data is a byte array. There is also an overload of the ComputeHash method that takes an offset into the byte array and a count of how many bytes to process."
  },
  "software/tinyclr/tutorials/http-https.html": {
    "href": "software/tinyclr/tutorials/http-https.html",
    "title": "HTTP/HTTPS",
    "keywords": "HTTP/HTTPS Hyper Text Transport Protocol (HTTP) builds on top of the Core Networking Protocols to provide a standard way to work with web servers. HTTP Client The following code connects to bing.com and reads the robots.txt file. This code needs an active network connection to work properly. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Network and GHIElectronics.TinyCLR.Networking.Http. static void TestHttp() { var url = \"http://www.bing.com/robots.txt\"; int read = 0, total = 0; byte[] result = new byte[512]; try { using (var req = HttpWebRequest.Create(url) as HttpWebRequest) { req.KeepAlive = false; req.ReadWriteTimeout = 2000; using (var res = req.GetResponse() as HttpWebResponse) { using (var stream = res.GetResponseStream()) { do { read = stream.Read(result, 0, result.Length); total += read; System.Diagnostics.Debug.WriteLine(\"read : \" + read); System.Diagnostics.Debug.WriteLine(\"total : \" + total); String page = \"\"; page = new String(System.Text.Encoding.UTF8.GetChars (result, 0, read)); System.Diagnostics.Debug.WriteLine(\"Response : \" + page); } while (read != 0); } } } } catch { } } HTTP Server TinyCLR OS provides an HttpListener class which can be used to make an HTTP Server. This code needs an active network connection on the same local network as your client application to work properly. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Network and GHIElectronics.TinyCLR.Networking.Http. Note To run this example the client and server devices must both connect to the same local network. static void TestHttpServer() { //Create a listener. HttpListener listener = new HttpListener(\"http\", 80); listener.Start(); System.Diagnostics.Debug.WriteLine(\"Listening...\"); var clientRequestCount = 0; while (true) { //Note: The GetContext method blocks while waiting for a request. HttpListenerContext context = listener.GetContext(); //Obtain a response object. HttpListenerResponse response = context.Response; //Construct a response. var responseString = string.Format(\"<HTML><BODY> I am TinyCLR OS Server. \" + \"Client request count: {0}</BODY></HTML>\", ++clientRequestCount); byte[] buffer = System.Text.Encoding.UTF8.GetBytes(responseString); //Get a response stream and write the response to it. response.ContentLength64 = buffer.Length; var output = response.OutputStream; output.Write(buffer, 0, buffer.Length); //You must close the output stream. output.Close(); } listener.Stop(); } From your client device (smartphone, PC...), enter the server ip address into your web browser. In our case it's 192.168.1.6. The response is shown as below: HTTPS Secure connections work in a similar way through built in TLS support. HTTPS can also be used to send data to cloud computing services such as Azure ."
  },
  "software/tinyclr/tutorials/i2c.html": {
    "href": "software/tinyclr/tutorials/i2c.html",
    "title": "I2C",
    "keywords": "I2C I2C (pronounced eye-squared-sea, or eye-two-sea) was originally developed by Phillips as a protocol for synchronous serial communication between integrated circuits. It has a master and one or more slaves sharing the same data bus. Instead of selecting the slaves by using a dedicated chip select signal like SPI, I2C uses an addressing mechanism to communicate with the selected device. This addressing method saves one I/O pin per slave. Before data is transferred, the master transmits the 7-bit address of the slave device it wants to communicate with. It also sends one bit indicating whether it wants to send data to the slave or receive data from the slave. When a slave sees its address on the bus, it will acknowledge its presence. At this point, the master can send or receive data. The master will start data transfers with a \"start condition\" before sending an address or data. The master ends the data transfer with a \"stop condition.\" The two wires for I2C communication are called the SDA and SCL lines. SDA stands for Serial Data, and SCL is Serial Clock. Note I2C bus speed can be either 100,000 bits/second (standard mode) or 400,000 bits/second (fast mode). This is a partial demo showing the use of I2C. var settings = new I2cConnectionSettings(0x1C, 100_000); //The slave's address and the bus speed. var controller = I2cController.FromName(SC20100.I2cBus.I2c1); var device = controller.GetDevice(settings); device.Write(new byte[] { 1, 2 }); //Write something device.WriteRead(...); //This is good for reading register Software I2C The I2C bus is relatively simple and can be \"bit banged\" using software. The advantage of bit banging is that any two GPIO pins can be used, not just the pins that support hardware I2C. However, software I2C requires more system resources and runs slower. This example initializes a software I2C driver. Once initialized, it's used the same as hardware I2C. var provider = new I2cControllerSoftwareProvider (SC20260.GpioPin.PA0, SC20260.GpioPin.PA1, false); var controller = I2cController.FromProvider(provider); var device = controller.GetDevice(new I2cConnectionSettings(0x1C, 100_000) { AddressFormat = I2cAddressFormat.SevenBit });"
  },
  "software/tinyclr/tutorials/ifttt.html": {
    "href": "software/tinyclr/tutorials/ifttt.html",
    "title": "IFTTT",
    "keywords": "IFTTT If This Then That IOT Example. If This Then That (IFTTT) is a free service allowing users to automate tasks by using simple conditional statements to create scripts or Applets (previously called \"recipes\"). Some similar platforms you might want to check out include Twilio , ThingSpeak , Yonomi , and Home Assistant . IFTTT can be used to respond to both events on websites and events from devices. Some uses include: Turn on the lights when you come home. Send a text message if rain is forecast. Turn on your lights if your Ring doorbell senses motion. Turn off your WiFi when you aren't home. Send you an e-mail when the New York Times publishes a new article in its science section. Automatically back up your smart phone photos to the cloud. Automate GitHub tasks. Get a text message whenever a Craigslist post matches your search. Notify you when the International Space Station passes overhead. Track when your company is mentioned on Twitter or Reddit. The possibilities are almost endless. Here we will take you step by step through the process using IFTTT to send an email notification of a button being pressed on a SITCore Dev Board. First we will set up an IFTTT account, then create and test the needed applets, and finally program the SITCore to trigger the IFTTT applet. Create an IFTTT Account Signing up for IFTTT is easy and free -- just go to IFTTT.com and click on the Sign up button in the upper right hand corner of the screen. You can sign up using your Google or Facebook account, or use an e-mail address and password to sign in. IFTTT will usually offer to set up a sample connection right after you sign up -- just hit the \"X\" in the upper right corner to skip this step. Click on the Get more button under the message Start connecting your world to get started. Create the IFTTT Applets Two IFTTT applets will be needed for this project. An Email Applet will be send and email when a button is pushed. A Webhooks Applet will be used to receive an HTTP GET request from the FEZ when the temperature goes below ten degrees. Finally, an If This Then That Applet will call the Email Applet when triggered by the Webhooks Applet. Create the Webhooks Applet After signing up and getting to the Explore page, scroll down the page until you find the Create your own button and click on it. You will then be presented with a screen that may seem to provide no option forward. Click on +This to get to the next step. Search for webhooks and click on that option. On the next screen click on the Connect button, then click on the Receive a web request box on the following screen. You will be prompted for an event name. Enter button_press and press the Create trigger button. Now click on +That . This will take us to the next step of choosing an action service -- in this case we will send an email. Create the Email Applet You should now be on the Choose action service screen. Search for email and then click on the email icon. Click on the Connect button on the next screen. You will be prompted for an email address to send notifications to. Type in the email address you would like to use and press the Send PIN button. Once you receive the email with your PIN, enter the PIN and hit the Connect button. Now click on the Send me an email box. You should now be on the Complete action fields screen. Click on the Create action button without making any changes. This will tell IFTTT to use the default method of constructing the subject line and body of the notification email. This should take you to the Review and finish screen. Click on the Finish button. Get Your Key Now we just have to get the key that is sent from the SITCore to trigger the event. You should now be at a screen with the text \"If Maker Event \"button_press\", then Send me an email at. . . Click on the Webhooks icon as shown below: Then click on the Documentation button near the upper right of the next screen. This will bring up a page with your unique key. Including this key in an HTTP GET or POST request to the IFTTT website will trigger your event. To test the IFTTT event, you can enter the following line into the address bar of your web brower (replace Your_Key_Here with your key) : https://maker.ifttt.com/trigger/button_press/with/key/Your_Key_Here Setup the SITCore To setup the FEZ we will have to connect a temperature sensor and then program the FEZ to send the proper HTTP GET request when the temperature drops below 10 degrees. Connect the Temperature Sensor For this demo we programmed the FEZ to act as a temperature alarm, but the same principles can be applied to any sensor that can be connected to the FEZ. You can also test the program without any sensor at all - just call SendSmsAlert() to simulate an alarm condition. For our temperature sensor we used an NPN transistor (2N2222A) and an 8.2K resistor as they were sitting conveniently on my desk. They were wired as shown below. Power for the temperature sensor is controlled by GPIO pin A1. 3V3 could have been used, but by using a GPIO pin the sensor can be turned off between readings to reduce the effects of self heating. The transistor is wired with its base and collector connected together so it is acting as a diode. When a constant current passes through this diode the voltage drop is a linear function with a temperature coefficient of about two millivolts per degree celsius. While a series resistor does not provide a true constant current source, it will be plenty accurate for this demo. Programming the FEZ Start a new C# project. You will need to add the following NuGet packages: GHIElectronics.TinyCLR.Core GHIElectronics.TinyCLR.Devices.Adc GHIElectronics.TinyCLR.Devices.Gpio GHIElectronics.TinyCLR.Devices.Spi GHIElectronics.TinyCLR.Native GHIElectronics.TinyCLR.Networking GHIElectronics.TinyCLR.Networking.Http GHIElectronics.TinyCLR.Pins Cut and paste the following code into the Program.cs window. You will have to change the WiFi SSID and password (line 50) and cut and paste your IFTTT key into line 53 near the end of the program (replace Paste_IFTTT_Key_Here ). To copy your key, click on My Applets on the IFTTT website, then click on Services , click on the Webhooks box, and click on the Documentation button. using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Devices.Spi; using GHIElectronics.TinyCLR.Drivers.STMicroelectronics.SPWF04Sx; using GHIElectronics.TinyCLR.Pins; using System; using System.Threading; class Program { private static void Main() { var gpioCont = GpioController.GetDefault(); var reset = gpioCont.OpenPin(FEZ.GpioPin.WiFiReset); var irq = gpioCont.OpenPin(FEZ.GpioPin.WiFiInterrupt); var wifiGpio8 = gpioCont.OpenPin(FEZCLR.GpioPin.PA0); var tempSensePower = gpioCont.OpenPin(FEZ.GpioPin.A1); var spiCont = SpiController.FromName(FEZ.SpiBus.WiFi); var spi = spiCont.GetDevice(SPWF04SxInterface.GetConnectionSettings(SpiChipSelectType.Gpio, FEZ.GpioPin.WiFiChipSelect)); var adcController = AdcController.GetDefault(); var tempSense = adcController.OpenChannel(FEZ.AdcChannel.A0); tempSensePower.SetDriveMode(GpioPinDriveMode.Output); tempSensePower.Write(GpioPinValue.Low); wifiGpio8.SetDriveMode(GpioPinDriveMode.InputPullDown); while (true) { tempSensePower.Write(GpioPinValue.High); var tempSenseValue = tempSense.ReadRatio(); tempSensePower.Write(GpioPinValue.Low); // ADC value was 0.589 volts at 21 degrees celsius. // Temperature coefficient is approx. 2mv/deg C. var temperature = 21 - (tempSenseValue * 3.3 - 0.589) / 0.002; temperature = Math.Round(temperature * 10) / 10; if (temperature < 10) { SendSmsAlert(temperature); Thread.Sleep(2 * 60 * 60 * 1000); // Don't alert more than once every 2 hrs. } Thread.Sleep(1000); } void SendSmsAlert(double temperature) { var wifi = new SPWF04SxInterface(spi, irq, reset); wifi.TurnOn(); Thread.Sleep(10000); wifi.JoinNetwork(\"SSID\", \"password\"); Thread.Sleep(10000); var triggerString = \"/trigger/FEZ_Temp_Alert/with/key/Paste_IFTTT_Key_Here?value1=\" + temperature.ToString(); wifi.SendHttpGet(\"maker.ifttt.com\", triggerString, 80, SPWF04SxConnectionSecurityType.None); wifi.TurnOff(); wifi.Dispose(); } } }"
  },
  "software/tinyclr/tutorials/image-decoders.html": {
    "href": "software/tinyclr/tutorials/image-decoders.html",
    "title": "Image Decoders",
    "keywords": "Image Decoders TinyCLR OS provides methods for converting JPG, BMP, and GIF files into bitmaps that can be used in your application. The image can be added to your project as a resource , or the image can be loaded from a byte array, like from and SD card. Tip BMP supports 256 colors and 24bit. GIF does not support animated images. var screen = Graphics.FromImage(new Bitmap(displayController.ActiveConfiguration.Width, displayController.ActiveConfiguration.Height)); //Image is in a resource file named \"jpegImageFile\": var imageBitmap = Resource1.GetBitmap(Resource1.BitmapResources.jpegImageFile); var b1 = new Bitmap(dataArray, BitmapImageType.Jpeg); var b2 = new Bitmap(dataArray, BitmapImageType.Gif); var b3 = new Bitmap(dataArray, BitmapImageType.Bmp); var imageX = 0; var imageY = 0; screen.DrawImage(imageBitmap, imageX, imageY); Video playback Video playback can be achieved through Motion JPEG ."
  },
  "software/tinyclr/tutorials/in-field-update.html": {
    "href": "software/tinyclr/tutorials/in-field-update.html",
    "title": "In-Field Update",
    "keywords": "In-Field Update TinyCLR OS allows for secure, encrypted, In-Field Update (IFU) of your application. The updates can be done from application code stored in a buffer or read over file system. Note The application key is generated by the TinyCLR Config tool when you create your application. Update via Buffer Systems with external memory can use the buffer updater, which first copies the new update from a file, network, or bus, and stores it in a buffer. When the entire firmware file is in memory, the IFU will then check the buffer for authenticity. Only then will it decrypt the data and flash it into the chip's internal memory. This is the recommended update mode; however, this will only work on systems with external memory. Warning Be careful not to interrupt power during application for firmware updates. A power interruption will cause the update to fail making it necessary to manually update your board. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Storage, GHIElectronics.TinyCLR.IO, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Update. using GHIElectronics.TinyCLR.Devices.Storage; using GHIElectronics.TinyCLR.IO; using GHIElectronics.TinyCLR.Native; using GHIElectronics.TinyCLR.Update; using System.IO; class Program { private static void Main() { const string FSSD_API_CONTROLLER = SC20100.StorageController.SdCard; const string FSUSB_API_CONTROLLER = SC20100.StorageController.UsbHostMassStorage; var media = StorageController.FromName(FSSD_API_CONTROLLER); //Update from SD card. var drive = FileSystem.Mount(media.Hdc); FileStream fsFw = new FileStream(@\"A:\\sc20xxx Firmware.ghi\", FileMode.Open); FileStream fsApp = new FileStream(@\"A:\\yourApplication.tca\", FileMode.Open); InFieldUpdate updater; UnmanagedBuffer fwUnmagedBuf = new UnmanagedBuffer((int)fsFw.Length); UnmanagedBuffer fwUnmagedApp = new UnmanagedBuffer((int)fsApp.Length); var fwBuf = fwUnmagedBuf.Bytes; var appBuf = fwUnmagedApp.Bytes; fsFw.Read(fwBuf, 0, fwBuf.Length); fsApp.Read(appBuf, 0, appBuf.Length); updater = new InFieldUpdate(fwBuf, appBuf); updater.ApplicationKey = new byte[] { }; //Add key as byte array here. try { updater.AuthenticateFirmware(out var versionFw); } catch { //Firmware authentication failed. } try { updater.AuthenticateApplication(out var versionApp); } catch { //Application authentication failed. } updater.FlashAndReset(); } } Update via File The file updater reads files from memory, SD card or USB port, and then handles the updated directly without the need for external memory. This update works on systems with or without external memory. You cannot update the firmware using this method, only the application. Warning Be careful not to interrupt power during updating your board. A power interruption will cause the update to fail making it necessary to manually update your board. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Storage, GHIElectronics.TinyCLR.IO, GHIElectronics.TinyCLR.Update. using GHIElectronics.TinyCLR.Devices.Storage; using GHIElectronics.TinyCLR.IO; using GHIElectronics.TinyCLR.Update; using System.IO; class Program { private static void Main() { const string FSSD_API_CONTROLLER = SC20100.StorageController.SdCard; const string FSUSB_API_CONTROLLER = SC20100.StorageController.UsbHostMassStorage; var media = StorageController.FromName(FSSD_API_CONTROLLER); //Using SD card. var drive = FileSystem.Mount(media.Hdc); FileStream fsApp = new FileStream(@\"A:\\yourApplication.tca\", FileMode.Open); InFieldUpdate updater; updater = new InFieldUpdate(fsApp); updater.ApplicationKey = new byte[] { }; //Add key as byte array here. try { updater.AuthenticateApplication(out var versionApp); } catch { //Application authentication failed. } updater.FlashAndReset(); } } Firmware and Application Must Match It is important that the firmware on your chip is the same version expected by your application. To make sure your application and firmware match, it is best to update both simultaneously if possible."
  },
  "software/tinyclr/tutorials/intro.html": {
    "href": "software/tinyclr/tutorials/intro.html",
    "title": "TinyCLR Tutorials",
    "keywords": "TinyCLR Tutorials Here you will find programming tutorials and code examples for our TinyCLR OS. We try to keep the documents as hardware generic as possible but changes may be required to get the sample code to run on your target device. Use the sub menu on the left to navigate the long list of available tutorials."
  },
  "software/tinyclr/tutorials/ip-protection.html": {
    "href": "software/tinyclr/tutorials/ip-protection.html",
    "title": "IP Protection",
    "keywords": "IP Protection Designed with security as a top priority, TinyCLR OS provides protection for both code and data. Application Protection Companies need a way to protect their applications from piracy -- TinyCLR OS running on SITCore devices gives you exactly what you need! Secure Assemblies Secure assemblies are assemblies that are deployed only to flash memory internal to the processor. As this secure code never leaves the SITCore processor, it is very difficult for anyone to access or copy your code. By default, all assemblies are deployed to internal flash memory. Unless external flash is enabled, assemblies will never be deployed to external flash. However, if external flash is enabled, assemblies will be deployed to external flash when the amount of internal flash is running low. In such cases, we have provided a way to protect your most sensitive code. By tagging an assembly as secure, you can ensure that it will never be deployed to external flash. If there is not enough internal flash to hold all of the secure assemblies, an out of memory exception will be raised. To tag an assembly as secure, you will have to edit the AssemblyInfo.cs file in the Properties folder within your project's folder. Change the line [assembly: AssemblyConfiguration(\"\")] to [assembly: AssemblyConfiguration(\"secure\")] (the word \"secure\" is case insensitive). If this is not done, by default the assembly will not be secure. Note that this only matters when external flash is enabled and the size of the assemblies is larger than the internal flash capacity. During deployment Visual Studio will display an allocation table showing both the secure and unsecure assemblies and their address, so it is easy to check the security status of your assemblies. This is found in the TinyCLR Device Deployment Visual Studio output window. Disabling the Debug Interface As USB and serial ports are used for application deployment and debugging, these interfaces can also be used by unauthorized parties to read or pirate your application. TinyCLR OS supports disabling of the debug interface to prevent unauthorized access. You can disable the debug interface with the TinyCLR Config utility program or with the following method: GHIElectronics.TinyCLR.Update.Application.Lock() As this instruction is stored internally in non-volatile flash, it is persistent and the chip can only be unlocked by completely erasing the device through the bootloader. This also erases your application, so locking the chip provides a great deal of security for your application. You can also check what interface is active, or if it is disabled: GHIElectronics.TinyCLR.Native.DeviceInformation.DebugInterface Once you lock your device, everyone, including you and GHI Electronics, is locked out of accessing and debugging your application. So how do you update the application code on your device? The first step is to create an encrypted copy of the application. This is easily done using the TinyCLR Config tool. You need to enter a key, or the tool will generate a key for you. The tool will then read the application, encrypt it, and store the encrypted application and the key as files on your machine. Of course, this needs to be done before you disable the debug interface on your device! You can now use application deployment to deploy to other devices. This is good for mass production as well. If you are sending the deployment to a contract manufacturer, remember to send the key too! In-Field Update You can use TinyCLR Config to create an encrypted application deployment that can be securely loaded by your customer. You can send this application deployment to the field (the customer) as a file in an email or automate it using the cloud. You have options. Of course, when you send the application deployment out to the field, you would not send the key with it. They key is securely stored inside your application, in your in-field update code. Check out our In-Field Update tutorial for implementation information. Secure RAM SITCore devices provide security for your sensitive data by using RAM that is inside the processor, making it almost impossible to get at your data. However, sometimes additional RAM is needed by your application. TinyCLR OS allows you to extend the heap into external SDRAM (if supported by your hardware). Please refer to the External Memory page for more info. However, the impact upon data security must be considered when the heap is extended. Extending Heap While extending the heap into external SDRAM provides more RAM for your application, it also reduces security as it is possible for bad actors to probe the memory interface and reconstruct your data. If you are storing sensitive data in RAM, extending heap memory will reduce security. To keep data secure it is best not to extend the heap. If you need more RAM and must extend the heap, encrypt or obfuscate sensitive data before storing it in RAM if possible. The other option is to include a physical barrier to the circuit, such as potting the circuit board, to make it more difficult to probe the data."
  },
  "software/tinyclr/tutorials/memory.html": {
    "href": "software/tinyclr/tutorials/memory.html",
    "title": "Memory Management",
    "keywords": "Memory Management RAM Memory This memory type loses its contents when the system is turned off. The system uses this memory at runtime to quickly store and retrieve data. TinyCLR OS is a managed operating system -- objects in RAM are automatically tracked and freed as needed. The Garbage Collector (GC) runs when the system is low on available RAM, where it will look for unused objects and free the memory they occupy. You may also invoke the GC at any time using GC.Collect() . RAM is the main workspace for your application -- running out of memory will cause your application to fail. It is important to understand the memory needs of your application and to plan accordingly. When creating a buffer for a UART for example, use a reasonable size buffer that's large enough to handle your communication needs without being so large as to waste memory. RAM Memory Size The amount of free and used memory can be shown at runtime, which can be helpful for debugging and optimizing your application. var freeRam = GHIElectronics.TinyCLR.Native.Memory.ManagedMemory.FreeBytes; var usedRam = GHIElectronics.TinyCLR.Native.Memory.ManagedMemory.UsedBytes; Allocating Memory The TinyCLR OS Garbage Collector allocates and frees objects automatically on the heap. When the memory gets fragmented, the system will compact the heap. This is desired behavior, but this also creates a problem when sharing resource between TinyCLR OS and native drivers. In a more advanced application, a user may have a buffer that gets written from an interrupt routine. Assuming this is implemented in native code, we would need a buffer that always sits at a fixed address. Using var buffer = new byte[12] will not work as the garbage collector may move the buffer to compact the heap. A fixed location buffer can be allocated using GHIElectronics.TinyCLR.Native.Memory.ManagedMemory.Allocate() . Keep in mind that this is not managed memory anymore, and you are responsible for freeing this memory using GHIElectronics.TinyCLR.Native.Memory.ManagedMemory.Free() . Memory Allocation Cost Creating and disposing of objects is costly, especially when done in inner loops. The following code sends 10,000 bytes from an array over a network one byte at a time. for (int i=0; i<10000; i++) { var byteArray = new byte[1]; byteArray[0] = arrayData[i]; Network.SendByteArray(byteArray); } The code will work just fine, but as byteArray[] is created within the loop, 10,000 single element byte arrays will be created and disposed of. It is much more efficient to create the array only once. byte[] byteArray = new byte[1]; for (int i=0; i<10000; i++) { byteArray[0] = arrayData[i]; Network.SendByteArray(byteArray); } Disposing of Objects As TinyCLR OS is a managed system that monitors and frees resources, memory leaks are less of a concern than they are for unmanaged systems. However, there is still chance that issues can arise, especially in embedded systems where objects can be a combination of memory and other hardware. Take a GPIO pin for example. What happens when we no longer have a reference to a GPIO pin? Will the GC free the object? Will the pin change in state when the GC frees the pin? And finally, why would a pin (or any physical object) be left for the GC to decide how it should be freed? The answer is that we need to understand and track these resources manually. This example code will declare and initialize a GPIO pin in a function, causing the main program to lose control of the pin. The BadExample method uses the LED's GPIO pin, but it doesn't free it. class Program { static void Main() { BadExample(); //The following line will raise an exception: var led = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PE11); led.SetDriveMode(GpioPinDriveMode.Output); led.Write(GpioPinValue.Low); } static void BadExample() { var led = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PE11); led.SetDriveMode(GpioPinDriveMode.Output); led.Write(GpioPinValue.High); } } The next example will Dispose of the pin and the code will work; however, disposing the pin may take the pin back to its default state. There is no exact definition on what a piece of hardware (the GPIO pin in this example) does when disposed. class Program { static void Main() { GoodExample(); //This code will now work var led = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PE11); led.SetDriveMode(GpioPinDriveMode.Output); led.Write(GpioPinValue.Low); //... } static void GoodExample() { var led = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PE11); led.SetDriveMode(GpioPinDriveMode.Output); led.Write(GpioPinValue.High); //Free the pin, but this may cause the pin to revert to its default state. led.Dispose(); } } The following example shows the best way to handle the situation by moving the LED object declaration so it is available and accessible to the entire class. class Program { static GpioPin led; //You can now use 'led' anywhere within 'Program' static void Main() { // Init the hardware led = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PE11); led.SetDriveMode(GpioPinDriveMode.Output); Example(); led.Write(GpioPinValue.Low); } static void Example() { led.Write(GpioPinValue.High); } } Garbage Collection TinyCLR OS automatically disposes of objects that are no longer needed. Garbage collection eliminates the need to manage memory manually, and reduces or eliminates some types of bugs. The act of garbage collection can temporarily reduce the responsiveness of your system, so it may be beneficial to actively manage garbage collection to improve real time response. Garbage collection will usually only run when there is a failed memory allocation, so by properly structuring your program you should be able to eliminate garbage collection or greatly reduce it. String operations are particularly troublesome in the creation of garbage as strings are immutable. To reduce garbage collection, minimize the use of dynamically allocated buffers and minimize allocations in routines that get called often by preallocating or using static objects. Minimize string manipulation. As strings are immutable, manipulating a string creates a new string and the old string becomes garbage. Using StringBuilder to manipulate strings may help reduce garbage generation. You can use GC.GetTotalMemory(true) to find out how much memory is being used. Checking free memory often during program execution will let you know if the amount of free memory is decreasing and how quickly. You can use Debug.GC(true) to force garbage collection. You might use this to ensure that garbage collection occurs during a period when responsiveness is less important. Debug.EnableGCMessages(true) can be used to make sure that garbage collection messages are sent out over the debug port. TinyCLR also supports unmanaged heap space. Unmanaged heap space can be used for large graphic buffers, for example. In unmanaged heap space, it is up to the programmer to make sure memory is correctly allocated and deallocated. Read more about unmanaged heap space here . Finalizers The Garbage Collector does a lot of work in the background. To keep the system running smoothly, some of this work is done when the system is idle, like running finalizers and compacting the heap. When the system running a tight loop with continuous allocations, there will be no idle time for the Garbage Collector to finish its tasks. In this case, it is possible to force the Garbage Collector to finish the tasks. GC.Collect(); GC.WaitForPendingFinalizers(); Battery Backed RAM SITCore devices support 4 KBytes of battery backed RAM. Details can be found in the Real Time Clock Tutorial . Flash Memory Flash memory does not lose its contents on power loss. There are special requirements to write to flash but you can read Flash just like RAM. When deploying a program, the TinyCLR Device Deployment window will show what is being loaded and how large it is. It will then show how much free Flash is still available. Assemblies deployed. There are 2,408,408 bytes left in the deployment area. Flash is not typically written to at runtime. The system will function even with no free available FLASH. Resources TinyCLR OS allows resources, like fonts and images, to be merged into the project as a resource and then deployed to the device's flash. Those resources can then be fetched into RAM and used at runtime. The Resource tutorial has more details. Direct Access Unsupported at this time. Tip You can only read from Flash, not write."
  },
  "software/tinyclr/tutorials/memory-management.html": {
    "href": "software/tinyclr/tutorials/memory-management.html",
    "title": "Memory Management",
    "keywords": "Memory Management"
  },
  "software/tinyclr/tutorials/mjpeg-video.html": {
    "href": "software/tinyclr/tutorials/mjpeg-video.html",
    "title": "MJPEG Video",
    "keywords": "MJPEG Video The MJPEG video format is simply a chain of JPG images that are stored in a single file. The following code sample runs on the SC20100S Dev Board and plays an MJPEG video file that is stored on a USB flash drive. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Display, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.I2c, GHIElectronics.TinyCLR.Devices.Spi, GHIElectronics.TinyCLR.Devices.Storage, GHIElectronics.TinyCLR.Drawing, GHIElectronics.TinyCLR.Drivers.Media, GHIElectronics.TinyCLR.Drivers.Sitronix.ST7735, GHIElectronics.TinyCLR.IO, GHIElectronics.TinyCLR.Native, and GHIElectronics.TinyCLR.Pins. class Program { private static GHIElectronics.TinyCLR.Drivers.Sitronix.ST7735.ST7735Controller st7735; private const int SCREEN_WIDTH = 128; private const int SCREEN_HEIGHT = 160; private static System.Drawing.Graphics graphic; private static void Main() { var spi = GHIElectronics.TinyCLR.Devices.Spi.SpiController.FromName (GHIElectronics.TinyCLR.Pins.SC20100.SpiBus.Spi3); var gpio = GHIElectronics.TinyCLR.Devices.Gpio.GpioController.GetDefault(); st7735 = new GHIElectronics.TinyCLR.Drivers.Sitronix.ST7735.ST7735Controller( spi.GetDevice(GHIElectronics.TinyCLR.Drivers.Sitronix.ST7735.ST7735Controller. GetConnectionSettings(GHIElectronics.TinyCLR.Devices.Spi.SpiChipSelectType.Gpio, GHIElectronics.TinyCLR.Pins.SC20100.GpioPin.PD10)), //CS pin. gpio.OpenPin(GHIElectronics.TinyCLR.Pins.SC20100.GpioPin.PC4), //RS pin. gpio.OpenPin(GHIElectronics.TinyCLR.Pins.SC20100.GpioPin.PE15) //RESET pin. ); var backlight = gpio.OpenPin(GHIElectronics.TinyCLR.Pins.SC20100.GpioPin.PE5); backlight.SetDriveMode(GHIElectronics.TinyCLR.Devices.Gpio.GpioPinDriveMode.Output); backlight.Write(GHIElectronics.TinyCLR.Devices.Gpio.GpioPinValue.High); st7735.SetDataAccessControl(false, false, false, false); st7735.SetDrawWindow(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT); st7735.Enable(); st7735.SetDataAccessControl(true, true, false, false); //Rotate the screen. st7735.SetDrawWindow(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT); st7735.Enable(); //Create flush event System.Drawing.Graphics.OnFlushEvent += Graphics_OnFlushEvent; //Create bitmap buffer graphic = System.Drawing.Graphics.FromImage(new System.Drawing.Bitmap (SCREEN_WIDTH, SCREEN_HEIGHT)); var media = GHIElectronics.TinyCLR.Devices.Storage.StorageController.FromName (GHIElectronics.TinyCLR.Pins.SC20100.StorageController.UsbHostMassStorage); var drive = GHIElectronics.TinyCLR.IO.FileSystem.Mount(media.Hdc); var stream = new System.IO.FileStream($@\"A:\\128x160.mjpeg\", System.IO.FileMode.Open); var settings = new GHIElectronics.TinyCLR.Drivers.Media.Mjpeg.Setting(); settings.BufferSize = 16 * 1024; settings.BufferCount = 3; var mjpegDecoder = new GHIElectronics.TinyCLR.Drivers.Media.Mjpeg(settings); mjpegDecoder.FrameDecodedEvent += MjpegDecoder_FrameDecodedEvent; mjpegDecoder.StartDecode(stream); // Non-block function System.Threading.Thread.Sleep(-1); } private static void MjpegDecoder_FrameDecodedEvent(byte[] data) { using (var image = new System.Drawing.Bitmap(data, 0, data.Length, System.Drawing.BitmapImageType.Jpeg)) { if (graphic != null) { graphic.DrawImage(image, 0, 0, image.Width, image.Height); graphic.Flush(); } } System.GC.WaitForPendingFinalizers(); } private static void Graphics_OnFlushEvent(System.IntPtr hdc, byte[] data) { st7735.DrawBuffer(data); } }"
  },
  "software/tinyclr/tutorials/modbus.html": {
    "href": "software/tinyclr/tutorials/modbus.html",
    "title": "Modbus",
    "keywords": "Modbus Modbus is an asynchronous serial communications protocol that uses RS485 as its physical layer. It was developed for communicating with programmable logic controllers and is widely used for industrial applications. The following sample is written for the SC20100S Dev Board and uses Uart5 for communication: Tip Needed NuGets: GHIElectronics.TinyCLR.Devices.Uart, GHIElectronics.TinyCLR.Pins, GHIElectronics.TinyCLR.Devices.Modbus var serial = GHIElectronics.TinyCLR.Devices.Uart.UartController.FromName (GHIElectronics.TinyCLR.Pins.SC20100.UartPort.Uart5); serial.SetActiveSettings( 19200, 8, GHIElectronics.TinyCLR.Devices.Uart.UartParity.None, GHIElectronics.TinyCLR.Devices.Uart.UartStopBitCount.One, GHIElectronics.TinyCLR.Devices.Uart.UartHandshake.None); serial.Enable(); GHIElectronics.TinyCLR.Devices.Modbus.Interface.IModbusInterface mbInterface; mbInterface = new GHIElectronics.TinyCLR.Devices.Modbus.Interface.ModbusRtuInterface( serial, 19200, 8, GHIElectronics.TinyCLR.Devices.Uart.UartStopBitCount.One, GHIElectronics.TinyCLR.Devices.Uart.UartParity.None); GHIElectronics.TinyCLR.Devices.Modbus.ModbusMaster mbMaster; mbMaster = new GHIElectronics.TinyCLR.Devices.Modbus.ModbusMaster(mbInterface); var mbTimeout = false; ushort[] reply = null; int count = 0; while (true) { try { mbTimeout = false; reply = mbMaster.ReadHoldingRegisters(10, 0, 1, 3333); count++; if (count == 5) break; } catch (System.Exception error) { System.Diagnostics.Debug.WriteLine(\"Modbus Timeout\"); mbTimeout = true; } if (!mbTimeout) { System.Diagnostics.Debug.WriteLine(\"Modbus : \" + (object)reply[0].ToString()); } System.Threading.Thread.Sleep(1000); }"
  },
  "software/tinyclr/tutorials/mqtt.html": {
    "href": "software/tinyclr/tutorials/mqtt.html",
    "title": "MQTT",
    "keywords": "MQTT MQTT is a light weight messaging protocol for sensors that is supported by all major cloud services. See the following cloud provider pages for further details: Azure , AWS and Google Cloud . The following is a simple example of MQTT: Tip Needed Nugets: GHIElectronics.TinyCLR.Networking.Mqtt static void DoTestMqtt() { var caCertificate = new X509Certificate(UTF8Encoding.UTF8.GetBytes(\"Your certificate\")); var mqttHost = \"your_host\"; var mqttPort = 8883; //default 8883 var deviceId = \"your_device_id\"; var username = \"your_username\"; var password = \"your_password\"; var topic = \"your_topic\"; try { var clientSetting = new MqttClientSetting { BrokerName = mqttHost, BrokerPort = mqttPort, ClientCertificate = null, CaCertificate = caCertificate, SslProtocol = System.Security.Authentication.SslProtocols.Tls12 }; var client = new Mqtt(clientSetting); var connectSetting = new MqttConnectionSetting { ClientId = deviceId, UserName = username, Password = password }; // Connect to host var returnCode = client.Connect(connectSetting); var packetId = 1; // Subscribe to a topic client.Subscribe(new string[] { topic }, new QoSLevel[] { QoSLevel.ExactlyOnce }, (ushort)packetId++); // Publish a topic client.Publish(topic, Encoding.UTF8.GetBytes(\"your message\"), QoSLevel.MostOnce, false, (ushort)packetId); } catch (Exception e) { } } Note The MQTT driver in TinyCLR OS supports client mode only. Event Handler The Mqtt driver provides five events: client.PublishReceivedChanged += (a,b) => { Debug.WriteLine(\"Publish Received Changed.\"); }; client.PublishedChanged += (a, b, c) => { Debug.WriteLine(\"Published Changed.\"); }; ; client.SubscribedChanged += (a, b) => { Debug.WriteLine(\"Subscribed Changed.\"); }; client.ConnectedChanged += (a) => { Debug.WriteLine(\"Connected Changed.\"); }; client.UnsubscribedChanged += (a, b) => { Debug.WriteLine(\"Unsubscribed Changed.\"); };"
  },
  "software/tinyclr/tutorials/multithreading.html": {
    "href": "software/tinyclr/tutorials/multithreading.html",
    "title": "Multithreading",
    "keywords": "Multithreading TinyCLR OS is a single process system, only running your application. This is in fact a good security feature! However, TinyCLR OS supports threading similar to full .NET. void Blinker() { // LED on Thread.Sleep(100); // LED off Thread.Sleep(100); } void main() { var t = new Thread(Blinker); t.Start(); // do secondary task Thread.Sleep(Timout.Infinite); }"
  },
  "software/tinyclr/tutorials/networking-core.html": {
    "href": "software/tinyclr/tutorials/networking-core.html",
    "title": "Networking Core",
    "keywords": "Networking Core Networking support in TinyCLR OS is a subset of Microsoft's .NET Framework networking stack. More details will be added to this tutorial in the future. You might want to look at the Microsoft Sockets Class documentation to get started -- it should very closely resemble the TinyCLR sockets class. MAC Addresses Before using SITCore's built in PHY and ENC28 Ethernet networking, you have to set a MAC address or an exception will be raised. While you may not need a unique MAC address for internal testing, you will need to set a valid and unique MAC address before shipping your product. If you do not have access to an appropriate MAC address, you can either use an online MAC address generator, which is not ideal, or you can use a MAC address from an old computer or network card that is no longer used. Not having a unique MAC address can be a problem. If two devices with the same MAC address are present on the same local network subnet, neither device will be able to communicate properly. The WINC1500 WiFi module supported by SITCore devices ships with a manufacturer assigned unique MAC address. This address is used by default, although you can provide your own MAC address if desired. Secure Sockets TLS is natively support. See the TLS page for details. .NET Sockets TinyCLR OS's support of sockets is very similar to .NET socket support. Most .NET socket code should run with little modification. Socket support is provided as part of the TinyCLR OS core. Tiny CLR sockets work similar to .NET sockets -- most .NET examples are applicable to TinyCLR. TCP/UDP TCP and UDP are the core of the Internet protocols and are supported through standard .NET Sockets. The web is full of examples on using TCP and UDP Sockets that should work as is or with minor changes. DHCP TinyCLR OS supports both static and dynamic IP addressing. Note that static IP addressing does not work with PPP . The following line of code enables dynamic DHCP. For static IP, set IsDhcpEnabled to false . networkInterfaceSetting2.IsDhcpEnabled = true; With static IP addressing, you must provide the following settings. These settings will be ignored if dynamic DHCP is enabled. networkInterfaceSetting.Address = new IPAddress(new byte[] { 192, 168, 1, 122 }); networkInterfaceSetting.SubnetMask = new IPAddress(new byte[] { 255, 255, 255, 0 }); networkInterfaceSetting.GatewayAddress = new IPAddress(new byte[] { 192, 168, 1, 1 }); networkInterfaceSetting.DnsAddresses = new IPAddress[] { new IPAddress(new byte[] { 75, 75, 75, 75 }), new IPAddress(new byte[] { 75, 75, 75, 76 }) }; DNS The TinyCLR Dns class can be used to resolve a URL into its IP address by using the following code: var hostEntry = Dns.GetHostEntry(hostName); if ((hostEntry != null) && (hostEntry.AddressList.Length > 0)) { var i = 0; while (hostEntry.AddressList[i] == null) i++; remoteIpAddress = hostEntry.AddressList[i]; } else { throw new Exception(\"Server not found.\"); ; }"
  },
  "software/tinyclr/tutorials/nuget.html": {
    "href": "software/tinyclr/tutorials/nuget.html",
    "title": "NuGet",
    "keywords": "NuGet All libraries are hosted in the cloud using the industry standard NuGet format. Not only is it easy to install and upgrade libraries, it is also easy to create and publish libraries of your own. Information on adding NuGet Libraries to your application can be found on the Getting Started page. For information on creating your own NuGet Packages, this page from Microsoft is a good place to start."
  },
  "software/tinyclr/tutorials/power-management.html": {
    "href": "software/tinyclr/tutorials/power-management.html",
    "title": "Power Management",
    "keywords": "Power Management TinyCLR OS currently supports the Sleep and Shutdown power saving modes. In sleep mode, any GPIO interrupt can be used to wake the board, but in Shutdown mode, only the WKUP pin can wake up the board. You can also program the device to wake up after a specified time. Sleep In this mode the system goes to sleep to save power and wakes up and resumes processing when the assigned interrupt is received. Any GPIO interrupt can be used to wake from Sleep. The following example runs on both the SC20100 and SCM20260D Dev boards and uses the LDR button to wake up. Note Don't forget to configure the interrupt and interrupt handler for the pin that will be used to wake up from Sleep. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Pins var ldrButton = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PE3); ldrButton.SetDriveMode(GpioPinDriveMode.InputPullUp); ldrButton.ValueChanged += ldrButton_ValueChanged; //The next line starts Sleep. Power.Sleep(); //The system is Sleeping. //Pressing the LDR Button (PE3) wakes up the system. private static void ldrButton_ValueChanged(GpioPin sender, GpioPinValueChangedEventArgs e) { } Shutdown In this mode the system completely shuts down. It can only be awakened by reset, power cycle, or by toggling the WKUP pin. The following code shuts down the system. The false argument configures the system to wake up when the WKUP pin goes from high to low. Make the argument true to wake up when WKUP goes high. Note Waking from Shutdown mode always resets the system. Your application will start over, it will not resume where it left off. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Native, and GHIElectronics.TinyCLR.Pins //The next line shuts down the system. Power.Shutdown(true, DateTime.MaxValue); Sleep or Shutdown for a Specific Time To sleep for a specific time: Power.Sleep(DateTime.Now.AddSeconds(90)); //Will wake up after 90 seconds. //A GPIO can also wake up the system. To shutdown for a specific time: Power.Shutdown(false, DateTime.Now.AddSeconds(90); //Will wake up after 90 seconds. //WKUP pin has no effect. To shutdown for a specific time or when the WKUP pin changes state (whichever comes first): Power.Shutdown(true, DateTime.Now.AddSeconds(90); //Will wake up after 90 seconds or //when WKUP is pressed. Software Reset You can also reset your device from within your application with the following command: GHIElectronics.TinyCLR.Native.Power.Reset();"
  },
  "software/tinyclr/tutorials/ppp.html": {
    "href": "software/tinyclr/tutorials/ppp.html",
    "title": "PPP",
    "keywords": "PPP Point to Point Protocol (PPP) started in the days of dial up Internet and is still used today in cellular modems. While using PPP can be optional for small IoT systems, having a secure connection requires PPP. A MAC address is not needed for PPP. This example uses the LTE IoT 2 click module on the SCM20260D Dev Boards to establish a connection and read a web page. We've also successfully tested the SIMCOM SIM900 and NimbeLink's Skywire cellular embedded modems. Tip Needed Nugets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.Network, GHIElectronics.TinyCLR.Devices.Spi, GHIElectronics.TinyCLR.Devices.Uart, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Networking, and GHIElectronics.TinyCLR.Pins. class Program { static bool linkReady = false; static void Main() { var reset = GHIElectronics.TinyCLR.Devices.Gpio.GpioController.GetDefault(). OpenPin(GHIElectronics.TinyCLR.Pins.SC20260.GpioPin.PI8); reset.SetDriveMode(GHIElectronics.TinyCLR.Devices.Gpio.GpioPinDriveMode.Output); reset.Write(GHIElectronics.TinyCLR.Devices.Gpio.GpioPinValue.High); System.Threading.Thread.Sleep(200); reset.Write(GHIElectronics.TinyCLR.Devices.Gpio.GpioPinValue.Low); System.Threading.Thread.Sleep(7000); //Wait for modem to initialize. InitSimCard(); TestPPP(); } static void InitSimCard() { var serial = GHIElectronics.TinyCLR.Devices.Uart.UartController.FromName (GHIElectronics.TinyCLR.Pins.SC20260.UartPort.Uart8); serial.SetActiveSettings(115200, 8, GHIElectronics.TinyCLR.Devices.Uart.UartParity.None, GHIElectronics.TinyCLR.Devices.Uart.UartStopBitCount.One, GHIElectronics.TinyCLR.Devices.Uart.UartHandshake.None); serial.Enable(); while (!SendAT(serial, \"AT\")) { } SendAT(serial, \"AT+CGDCONT=1,\\\"IP\\\",\\\"h2g2\\\"\"); //Google Fi. SendAT(serial, \"AT+CGDCONT=2,\\\"IP\\\",\\\"telargo.t-mobile.com\\\"\"); //T-Mobile. SendAT(serial, \"AT+CGDCONT=3,\\\"IP\\\",\\\"fast.t-mobile.com\\\"\"); //T-Mobile. SendAT(serial, \"AT+CGDCONT=4,\\\"IPV4V6\\\",\\\"NIMBLINK.GW12.VZWENTP\\\"\"); //NimbeLink. SendAT(serial, \"ATDT*99***1#\"); //Modem dial string. The '1' in this string points // to the Google Fi PDP context previously defined // by the SendAT() method. System.Diagnostics.Debug.WriteLine(\"OK to start PPP....\"); } static void TestPPP() { var networkController = GHIElectronics.TinyCLR.Devices.Network.NetworkController. FromName(\"GHIElectronics.TinyCLR.NativeApis.Ppp.NetworkController\"); GHIElectronics.TinyCLR.Devices.Network.PppNetworkInterfaceSettings networkInterfaceSetting = new GHIElectronics.TinyCLR.Devices. Network.PppNetworkInterfaceSettings() { AuthenticationType = GHIElectronics.TinyCLR.Devices.Network. PppAuthenticationType.Pap, Username = \"\", Password = \"\", }; GHIElectronics.TinyCLR.Devices.Network.UartNetworkCommunicationInterfaceSettings networkCommunicationInterfaceSettings = new GHIElectronics.TinyCLR.Devices. Network.UartNetworkCommunicationInterfaceSettings() { ApiName = GHIElectronics.TinyCLR.Pins.SC20260.UartPort.Uart8, BaudRate = 115200, DataBits = 8, Parity = GHIElectronics.TinyCLR.Devices.Uart.UartParity.None, StopBits = GHIElectronics.TinyCLR.Devices.Uart.UartStopBitCount.One, Handshaking = GHIElectronics.TinyCLR.Devices.Uart.UartHandshake.None, }; networkController.SetInterfaceSettings(networkInterfaceSetting); networkController.SetCommunicationInterfaceSettings (networkCommunicationInterfaceSettings); networkController.SetAsDefaultController(); networkController.NetworkAddressChanged += NetworkController_NetworkAddressChanged; networkController.NetworkLinkConnectedChanged += NetworkController_NetworkLinkConnectedChanged; networkController.Enable(); while (linkReady == false) { } //Network is now ready to use. } private static void NetworkController_NetworkLinkConnectedChanged (GHIElectronics.TinyCLR.Devices.Network.NetworkController sender, GHIElectronics.TinyCLR.Devices.Network.NetworkLinkConnectedChangedEventArgs e) { //Raise event connect/disconnect } private static void NetworkController_NetworkAddressChanged (GHIElectronics.TinyCLR.Devices.Network.NetworkController sender, GHIElectronics.TinyCLR.Devices.Network.NetworkAddressChangedEventArgs e) { var ipProperties = sender.GetIPProperties(); var address = ipProperties.Address.GetAddressBytes(); System.Diagnostics.Debug.WriteLine(\"IP Address: \" + address[0] + \".\" + address[1] + \".\" + address[2] + \".\" + address[3]); linkReady = address[0] != 0; } static bool SendAT(GHIElectronics.TinyCLR.Devices.Uart.UartController port, string command) { command += \"\\r\"; var sendBuffer = System.Text.Encoding.UTF8.GetBytes(command); var readBuffer = new byte[256]; var read = 0; var count = 10; port.Write(sendBuffer, 0, sendBuffer.Length); while (count-- > 0) { System.Threading.Thread.Sleep(100); read += port.Read(readBuffer, read, readBuffer.Length - read); var response = new string (System.Text.Encoding.UTF8.GetChars(readBuffer, 0, read)); if (response.IndexOf(\"OK\") != -1 || response.IndexOf(\"CONNECT\") != -1) { System.Diagnostics.Debug.WriteLine(\" \" + response); return true; } } return false; } } Switching to Command Mode When a PPP connection is set up successfully, you can switch the modem from data mode to command mode with the +++ escape sequence. To prevent the +++ escape sequence from being misinterpreted as data, the following guidelines should be followed: 1) Do not send any other characters within one second (before or after) of sending +++ . 2) Send +++ quickly, sending all three characters within one second. When the +++ sequence is received, the modem will switch from data mode to command mode and reply with an \"OK\" response. Switching to Data Mode When the modem is in command mode, sending the ATO command will switch the modem to Data Mode. Wait for the \"CONNECT 150000000\" response after sending the ATO command to make sure the modem is in data mode. All data sent will now be treated as PPP frames. The following example switches from Data mode to Command Mode, sends a few AT commands, then switches back to Data mode. TinyCLR OS provides two functions, Suspend() and Resume() that are needed for this example. This code uses SC20260.UartPort.Uart8 for PPP configuration. //PPP is connected //.... networkController.Suspend(); //Suspend PPP, release UART Port from TinyCLR OS. { //Open UART. var serial = GHIElectronics.TinyCLR.Devices.Uart.UartController.FromName (SC20260.UartPort.Uart8); serial.SetActiveSettings( 115200, 8, GHIElectronics.TinyCLR.Devices.Uart.UartParity.None, GHIElectronics.TinyCLR.Devices.Uart.UartStopBitCount.One, GHIElectronics.TinyCLR.Devices.Uart.UartHandshake.None); serial.Enable(); Thread.Sleep(1000); SendAT(serial, \"+++\"); //Send \"+++\" to enter command mode. Thread.Sleep(1000); //Send any AT command here. //For example, AT+CSQ to check signal strength. SendAT(serial, \"AT+CSQ\"); SendAT(serial, \"ATO\"); //Enable \"PPP\" modem, wait for \"CONNECT 150000000\" response. serial.Dispose(); serial = null; //Release UART, resume PPP interface. } networkController.Resume(); // Continue network ... Note When sending \"+++\", do not send \"\\r\" or \"\\n\" at the end. While most AT commands need end of line characters, +++ does not. Security Clarification Most users of embedded systems that connect to mobile networks assume they are secure, but often they are not. Typically, a serial connection with AT commands is used to communicate with the modem. While the data over the air is secure, all data transmitted over the serial connection is raw unencrypted data that can be easily scoped. This is not the case with TinyCLR OS. With TinyCLR OS, serial data between the device and the modem is encrypted. All data handling is done internally inside the core processor, which is extremely difficult to hack into."
  },
  "software/tinyclr/tutorials/pwm.html": {
    "href": "software/tinyclr/tutorials/pwm.html",
    "title": "PWM",
    "keywords": "PWM Pulse Width Modulation (PWM) is a very useful feature found on most microcontrollers. PWM is a method of generating a square wave signal of uniform frequency with variable duty cycle. PWM is often used to generate analog voltages, but has many other uses such as generating digital pulses for driving servo motors or driving infrared LEDs for communication. The ratio of the pulse width to it's period is called the duty cycle. Through software, you can control both the PWM frequency and duty cycle. Tip We usually use GetDefault() for most peripherals. For example, there is only one GPIO controller on most systems. This is not the case with PWM. Never use the Default controller and always select the proper channel on the corresponding controller. Tip PWM2.3 is channel 3 on controller 2. Energy Level PWM is perfect for dimming an LED or controlling the speed of a motor. When the duty cycle is 50%, half the energy is transferred to the attached load. var controller = PwmController.FromName(SC20260.PwmChannel.Controller3.Id); var led = controller.OpenChannel(SC20260.PwmChannel.Controller3.PB0); controller.SetDesiredFrequency(10000); double duty = 0.5, speed = 0.01; led.Start(); while (true) { if (duty <= 0 || duty >= 1.0) { speed *= -1; //Reverse direction. duty += speed; } led.SetActiveDutyCyclePercentage(duty); duty += speed; Thread.Sleep(10); //Always give the system time to think! } Musical Tones Musical notes have specific frequencies; C for example is about 261Hz. Plugging these numbers into an array and knowing the length of each tone is all that is needed to play some simple music. When playing notes by changing the frequency, keep the duty cycle set to 0.5. The following example is written for the SC20100S Dev Board. using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Pins; using System.Threading; class Program { const int NOTE_C = 261; const int NOTE_D = 294; const int NOTE_E = 330; const int NOTE_F = 349; const int NOTE_G = 392; const int WHOLE_DURATION = 24; const int EIGHTH = WHOLE_DURATION / 8; const int QUARTER = WHOLE_DURATION / 4; const int QUARTERDOT = WHOLE_DURATION / 3; const int HALF = WHOLE_DURATION / 2; const int WHOLE = WHOLE_DURATION; //Make sure the two below arrays match in length. Each duration element corresponds to // one note element. private static int[] note = { NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_E, NOTE_D, NOTE_D, NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_D, NOTE_C, NOTE_C}; private static int[] duration = { QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, HALF, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, WHOLE}; private static void Main() { var controller = PwmController.FromName(SC20100.PwmChannel.Controller14.Id); var toneOut = controller.OpenChannel(SC20100.PwmChannel.Controller14.PA7); toneOut.SetActiveDutyCyclePercentage(0.5); while (true) { toneOut.Start(); for (int i = 0; i < note.Length; i++) { controller.SetDesiredFrequency(note[i]); Thread.Sleep(duration[i]); } toneOut.Stop(); Thread.Sleep(1000); } } } Servo Motors A servo motor is a motor that has a small internal circuit allowing you to control it using electrical pulses. Servo motors are available as either continuous or positional servos. While they look identical, a positional servo only turns to a given position and then holds that position until you tell it to move to another position. A continuous servo motor will rotate continuously in one direction until it is told to either stop or reverse direction. The pulse that controls servos is sent every 20 ms. This pulse will usually have a width between 1 ms and 2 ms which varies depending on the make and model of the motor. The position of a positional servo is based on the width of the pulse, with a 1.5 ms pulse moving to the middle of travel (90 degree position). With a rotational servo, 1.5ms will stop the motor, 1 ms is full speed, and 2 ms is full speed in the opposite direction. Tip As a rule, servos have three wires. Be sure the central wire is connected to 5V. The lighter color wire on one side of the connector is a signal and should be connected to a PWM pin. The third one, which is usually a darker color, is ground. This example is written for the SC20100S Dev Board. It will turn the positional servo (servo1) to the zero degree position, wait a second, and then turn it to 180 degrees. It will then rotate the continuous servo (servo2) at maximum speed for five seconds, and then reverse direction for five seconds. You must add the servo class (the code below this example) to your project for it to work. Tip Most servos will have a 1 ms minimum pulse width and a 2 ms maximum pulse width, but check the specs of the motor to be sure. using GHIElectronics.TinyCLR.Pins; using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Devices.Servo; using System.Threading; class Program { private static void Main() { ServoMotor servo1 = new ServoMotor(ServoMotor.ServoType.Positional, PwmController.FromName(SC20100.PwmChannel.Controller15.Id), SC20100.PwmChannel.Controller15.PE6); servo1.ConfigurePulseParameters(0.5, 2.4); //Settings for TowerPro SG90 micro servo. ServoMotor servo2 = new ServoMotor(ServoMotor.ServoType.Continuous, PwmController.FromName(SC20100.PwmChannel.Controller2.Id), SC20100.PwmChannel.Controller2.PA3); servo1.Set(0); Thread.Sleep(1000); servo1.Set(180); Thread.Sleep(1000); servo1.Stop(); servo2.Set(100); Thread.Sleep(5000); servo2.Set(-100); Thread.Sleep(5000); servo2.Stop(); Thread.Sleep(-1); } } This is the servo.cs class that provides the methods used in the above code to control the servos: using GHIElectronics.TinyCLR.Devices.Pwm; using System; namespace GHIElectronics.TinyCLR.Devices.Servo { public class ServoMotor { private PwmChannel servo; private ServoType type; private double minPulseLength; private double maxPulseLength; public double position { get; set; } public enum ServoType { Positional, Continuous } public ServoMotor(ServoType type, PwmController controller, int PwmPin) { this.servo = controller.OpenChannel(PwmPin); this.ConfigurePulseParameters(1.0, 2.0); controller.SetDesiredFrequency(50); this.type = type; this.position = 0; } public void ConfigurePulseParameters(double minimumPulseWidth, double maximumPulseWidth) { if (minimumPulseWidth > 1.5 || minimumPulseWidth < 0.1) throw new ArgumentOutOfRangeException(\"Must be between 0.1 and 1.5 ms\"); if (maximumPulseWidth > 3 || maximumPulseWidth < 1.6) throw new ArgumentOutOfRangeException(\"Must be between 1.6 and 3 ms\"); this.minPulseLength = minimumPulseWidth; this.maxPulseLength = maximumPulseWidth; } public void Set(double value) { if (this.type == ServoType.Positional) { this.PositionalSetPosition(value); this.position = value; } else { this.ContinousSetSpeed(value); } } private void PositionalSetPosition(double angle) { if (angle < 0 || angle > 180) throw new ArgumentOutOfRangeException(\"degrees\", \"degrees must be between 0 and 180.\"); var duty = ((angle / 180.0 * (this.maxPulseLength - this.minPulseLength)) + this.minPulseLength) / 20; this.servo.SetActiveDutyCyclePercentage(duty); this.servo.Start(); } private void ContinousSetSpeed(double speed) { if (speed < -100 || speed > 100) throw new ArgumentOutOfRangeException(\"speed\", \"speed must be between -100 and 100.\"); PositionalSetPosition(speed / 100 * 90 + 90); } public void Stop() => this.servo.Stop(); } }"
  },
  "software/tinyclr/tutorials/real-time-clock.html": {
    "href": "software/tinyclr/tutorials/real-time-clock.html",
    "title": "Real Time Clock",
    "keywords": "Real Time Clock The Real Time Clock (RTC) is a circuit that runs off a small battery or a super capacitor. It has its own crystal and keeps running even when the system is powered off. Not all hardware has a built in RTC, so check your hardware's documentation for more details. Generally, the RTC is accurate to plus or minus two seconds per day. However, this error may be larger for boards operating in high or low temperature environments. In the event the RTC battery was drained or the RTC was never initialized, the RTC will not have a correct value. Use the rtc.IsValid method to determine if the time was set correctly. Setting Vbat Charge Mode Important Make sure the RTC battery charge mode is correctly set. Charging a lithium coin cell may cause damage to the cell and could cause it to leak. Not charging a supercap will result in a discharged supercap and loss of correct time and battery backed ram data when your board is powered down. The RTC is powered by a battery or supercap when your board is powered down. It is important to correctly set the charge mode based on the RTC power source. Lithium coin cells, such as the common CR2032, may be damaged and could possibly leak if recharging is attempted. Supercaps need to be charged every few days or so (depending on supercap size) or they will lose power. More information is found in the Vbat section of the Special Pins page. var rtc = GHIElectronics.TinyCLR.Devices.Rtc.RtcController.GetDefault(); //The following line turns off charging. Used for lithium coin cells. rtc.SetChargeMode(GHIElectronics.TinyCLR.Devices.Rtc.BatteryChargeMode.None); //The following line charges slowly through a 5 K resistor. Used for supercaps. rtc.SetChargeMode(GHIElectronics.TinyCLR.Devices.Rtc.BatteryChargeMode.Slow) //The following line charges quickly through a 1.5 K resistor. // This is the mode we use for the supercaps on SITCore Dev boards. rtc.SetChargeMode(GHIElectronics.TinyCLR.Devices.Rtc.BatteryChargeMode.Fast) Tip Needed NuGets: GHIElectronics.TinyCLR.Devices.Rtc, GHIElectronics.TinyCLR.Native using GHIElectronics.TinyCLR.Devices.Rtc; using GHIElectronics.TinyCLR.Native; using System; using System.Diagnostics; using System.Threading; class Program { static void Main() { var rtc = RtcController.GetDefault(); if (rtc.IsValid) { Debug.WriteLine(\"RTC is Valid\"); // RTC is good so let's use it SystemTime.SetTime(rtc.Now); } else { Debug.WriteLine(\"RTC is Invalid\"); // RTC is not valid. Get user input to set it // This example will simply set it to January 1st 2020 at 11:11:11 var MyTime = new DateTime(2020, 1, 1, 11, 11, 11); rtc.Now = MyTime; SystemTime.SetTime(MyTime); } while (true) { Debug.WriteLine(\"Current Time : \" + DateTime.Now); Debug.WriteLine(\"Current RTC Time: \" + rtc.Now); Thread.Sleep(1000); } } } The output will show both times and they should match. If the RTC time is invalid when you first run the program, the program will detect the invalid time and will set the RTC. RTC is Valid Current Time : 01/01/2019 11:15:35 Current RTC Time: 01/01/2019 11:15:35 Current Time : 01/01/2019 11:15:36 Current RTC Time: 01/01/2019 11:15:36 System Clock You can get the current system time using DateTime.Now . The system clock starts running at power up, but until you set the clock, the time and date will be incorrect. The following command is used to set the time: GHIElectronics.TinyCLR.Native.SystemTime.SetTime(DateTime utcTime); To set the system clock to the RTC time, use the following command: GHIElectronics.TinyCLR.Native.SystemTime.SetTime(rtc.Now); SNTP You can use SNTP (Simple Network Time Protocol) to accurately set the time in your application. The following method will return the current date and time after retrieving it from an NTP server. Your device will need an active network connection for this code to work. public static DateTime GetNetworkTime(int CorrectLocalTime = 0) { const string ntpServer = \"pool.ntp.org\"; var ntpData = new byte[48]; ntpData[0] = 0x1B; //LeapIndicator = 0 (no warning), VersionNum = 3 (IPv4 only), // Mode = 3 (Client Mode) var addresses = System.Net.Dns.GetHostEntry(ntpServer).AddressList; var ipEndPoint = new System.Net.IPEndPoint(addresses[0], 123); var socket = new System.Net.Sockets.Socket( System.Net.Sockets.AddressFamily.InterNetwork, System.Net.Sockets.SocketType.Dgram, System.Net.Sockets.ProtocolType.Udp); socket.Connect(ipEndPoint); System.Threading.Thread.Sleep(1); //Added to support TinyCLR OS. socket.Send(ntpData); socket.Receive(ntpData); socket.Close(); ulong intPart = (ulong)ntpData[40] << 24 | (ulong)ntpData[41] << 16 | (ulong)ntpData[42] << 8 | (ulong)ntpData[43]; ulong fractPart = (ulong)ntpData[44] << 24 | (ulong)ntpData[45] << 16 | (ulong)ntpData[46] << 8 | (ulong)ntpData[47]; var milliseconds = (intPart * 1000) + ((fractPart * 1000) / 0x100000000L); var networkDateTime = (new System.DateTime(1900, 1, 1)). AddMilliseconds((long)milliseconds); return networkDateTime.AddHours(CorrectLocalTime); } The above method is used as follows, with the argument indicating how many hours to add to convert UTC time to your local time zone: DateTime dateTime = GetNetworkTime(-5); Battery Backed Memory SITCore devices include 4 KBytes of battery backed memory. This memory accepts and returns byte arrays of data. The commands and their overloads for accessing this memory are as follows: BackupMemorySize; //Returns 4096, total size in bytes of battery backed memory. ReadBackupMemory(byte[] destinationData); ReadBackupMemory(byte[] destinationData, uint sourceOffset); ReadBackupMemory(byte[] destinationData, uint destinationOffset, uint sourceOffset, int count); public void WriteBackupMemory(byte[] sourceData, uint destinationOffset); public void WriteBackupMemory(byte[] sourceData); public void WriteBackupMemory(byte[] sourceData, uint sourceOffset, uint destinationOffset, int count); Note that the battery backed memory is not managed at all. There is no allocate, dispose, or garbage collection. The commands used to access battery backed memory only copy the bytes from your array into memory, or from memory into your array. Until you overwrite it or lose RTC battery power, the data will always be in battery backed memory. Here is a simple example that displays the size of the battery backed memory, and then writes and reads five bytes of data. Tip Needed NuGet: GHIElectronics.TinyCLR.Devices.Rtc var rtc = GHIElectronics.TinyCLR.Devices.Rtc.RtcController.GetDefault(); System.Diagnostics.Debug.WriteLine(rtc.BackupMemorySize.ToString()); //Displays \"4096\" var writeData = new byte[] { 1, 2, 3, 4, 5 }; rtc.WriteBackupMemory(writeData); var readData = new byte[5]; rtc.ReadBackupMemory(readData); for (int i=0; i < 5; i++) { System.Diagnostics.Debug.WriteLine(readData[i].ToString()); //Displays 1, 2, 3, 4, 5 }"
  },
  "software/tinyclr/tutorials/reflection.html": {
    "href": "software/tinyclr/tutorials/reflection.html",
    "title": "Reflection",
    "keywords": "Reflection Reflection objects are used for obtaining type information at runtime. This class is in the System.Reflection namespace. var i=20; Type type = i.GetType(); //type = System.Int32 Another example below shows how to access a private function from a different class. Let's say we have a class named ReflectionExample with private functions named FunctionA() and FunctionB(). public class ReflectionExample { private uint FunctionA() => 0x1234; private uint FunctionB(uint numPlus) => 0x1234 + numPlus; } Reflection provides a way to access these two functions even though they are declared as private. var r = new ReflectionExample(); var type = r.GetType(); var methodA = type.GetMethod(\"FunctionA\", BindingFlags.NonPublic | BindingFlags.Instance); var valueA = methodA.Invoke(r, null); var methodB= type.GetMethod(\"FunctionB\", BindingFlags.NonPublic | BindingFlags.Instance); var valueB = methodB.Invoke(r, new object[] { (uint)1 }); Debug.WriteLine(\"methodA : \" + valueA); Debug.WriteLine(\"methodB : \" + valueB); The output will be: methodA : 4660 methodB : 4661"
  },
  "software/tinyclr/tutorials/resources.html": {
    "href": "software/tinyclr/tutorials/resources.html",
    "title": "Resources",
    "keywords": "Resources Resource files can be used to store strings, images, audio files, and other binary or text files that will be used by your application. Right-click on your project and Add->New Item... . From here select Resource File . You can now drag resources right into the file. In the background, a file is generated to reflect the added resources. Using the resource will look similar to var resourceData = Resource.GetBytes(Resource.BinaryResources.data); Tip If you are copying example code that uses resource files, some changes may be needed to match the resources' names in your project."
  },
  "software/tinyclr/tutorials/sd-cards.html": {
    "href": "software/tinyclr/tutorials/sd-cards.html",
    "title": "SD/MMC Cards",
    "keywords": "SD/MMC Cards SD and MMC cards are fully supported through the File System libraries. This is a sample on how setup the SD driver. var sd = StorageController.FromName(SC20100.StorageController.SdCard); var drive = FileSystem.Mount(sd.Hdc);"
  },
  "software/tinyclr/tutorials/secure-boot.html": {
    "href": "software/tinyclr/tutorials/secure-boot.html",
    "title": "Secure Boot",
    "keywords": "Secure Boot TinyCLR OS is designed with security in mind. The system boots up from an internal memories that are not accessible externally. The boot code only boots up an authenticated firmware that is provided by GHI Electronics. The user then controls the application and how it is updated though an encrypted In-Field Update and can also take advantage of the IP Protection feature."
  },
  "software/tinyclr/tutorials/secure-storage.html": {
    "href": "software/tinyclr/tutorials/secure-storage.html",
    "title": "Secure Storage",
    "keywords": "Secure Storage There are two secure storage areas you may find useful. Programmable Storage This 128 KByte secure storage area can be modified. Performing an `erase all in TinyCLR Config will wipe out this area. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Storage, GHIElectronics.TinyCLR.Native using GHIElectronics.TinyCLR.Devices.Storage; using System; using System.Diagnostics; using System.Threading; class Program { private static void Main() { const uint STORAGE_SIZE = 128 * 1024; var data = new byte[STORAGE_SIZE]; var realStorageSize = Configuration.Size; bool isErased = Configuration.IsErased(0, realStorageSize); if (isErased == false) { Debug.WriteLine(\"Configuration is not empty\"); Debug.WriteLine(\"Erasing...\"); bool erased = Configuration.Erase(0, realStorageSize); Debug.WriteLine(\"Erased ? \" + erased); } Debug.WriteLine(\"Fill buffer....\"); for (var i = 0; i < data.Length; i++) { data[i] = (byte)(i % 255); } Debug.WriteLine(\"Writing buffer....\"); Configuration.Write(data, 0, 0, (uint)data.Length); Debug.WriteLine(\"Clear buffer....\"); Array.Clear(data, 0, data.Length); Debug.WriteLine(\"Read configuration....\"); Configuration.Read(data, 0, 0, realStorageSize); Debug.WriteLine(\"Compare buffer....\"); for (var i = 0; i < data.Length; i++) { if (data[i] != (byte)(i % 255)) { Debug.WriteLine(\"Configuration corrupted\"); Thread.Sleep(-1); } } Debug.WriteLine(\"The Configuration driver is good to go!!!!\"); Thread.Sleep(-1); } } One Time Programmable Area The one time programmable (OTP) secure flash region is organized into 2048 blocks of 32 bytes each. Once you write to a block, that block can be read but never changed. There is no way to modify written data. Erasing the entire device Erase All in TinyCLR Config will not mot modify this area. The static GHIElectronics.TinyCLR.Native.Flash class has methods to read and write OTP flash blocks and also to see if blocks are blank. Writing an OTP Block To write a block of 32 bytes to the OTP region of flash memory, use the following command: GHIElectronics.TinyCLR.Native.Flash.OtpWrite(uint blockIndex, byte[] data); The byte array of data must be exactly 32 bytes in length or an ArgumentOutOfRangeException will be thrown. Reading an OTP Block To read a block from the OTP region of flash memory, use the following command: GHIElectronics.TinyCLR.Native.Flash.OtpRead(uint blockIndex, byte[] data); A byte array 32 bytes long will be returned. Checking if an OTP Block is Blank Note If all 32 bytes of any OTP flash block contain 0xFF, the block is considered unused. If you write only 0xFF to the contents of a block, the block will be regarded as unused and you will be able to rewrite the block. To see if a block is blank (all 32 bytes in block are 0xFF): GHIElectronics.TinyCLR.Native.Flash.OtpIsBlank(uint blockIndex); Returns a boolean value that is true if the block is blank."
  },
  "software/tinyclr/tutorials/serialization.html": {
    "href": "software/tinyclr/tutorials/serialization.html",
    "title": "Serialization",
    "keywords": "Serialization Serialization is the process of converting the state of an object into a form that can be persisted or transported. The complement of serialization is deserialization, which converts a stream into an object. Together, these processes allow objects to be stored and transferred. Binary Serialization Binary Serialization is a native, fast and lean way to serialize objects. To keep serialization fast and efficient on embedded devices, TinyCLR's serialization is not compatible with binary serialization on desktop PCs. However, an implementation on the PC can be used to process the serialized binary data if necessary. Tip Needed NuGets: GHIElectronics.TinyCLR.Core and System.Reflection. class Program { public enum MyEnum : short { A, B, C }; private static void Main() { MySerializableClass original = new MySerializableClass(1, \"ABCD\", 3, MyEnum.B, 0.1f); System.Diagnostics.Debug.WriteLine(\"original: \" + original.ToString()); byte[] buffer = System.Reflection.Reflection.Serialize(original, typeof(MySerializableClass)); MySerializableClass restored = (MySerializableClass)System.Reflection.Reflection. Deserialize(buffer, typeof(MySerializableClass)); System.Diagnostics.Debug.WriteLine(\"restored: \" + restored.ToString()); System.Diagnostics.Debug.WriteLine(\"Number of bytes: \" + buffer.Length.ToString()); } [System.Serializable] public class MySerializableClass { public int a; public string b; private byte c; private MyEnum d; private float e; private System.DateTime dt; public MySerializableClass(int a, string b, byte c, MyEnum d, float e) { this.a = a; this.b = b; this.c = c; this.d = d; this.e = e; this.dt = this.dt = new System.DateTime(2007, 1, 22); } public override string ToString() { return \"a=\" + a.ToString() + \", b=\" + b + \", c=\" + c.ToString() + \", d=\" + ((object)d).ToString() + \", e=\" + e.ToString(\"F2\"); } } } Note Serialization in TinyCLR OS is not compatible with full .NET. That means you cannot deserialize an object with .NET on a PC from a byte stream that was created with TinyCLR OS and vice versa. There is a solution which allows Serialization in TinyCLR OS and the .NET Framework to be compatible. For details, look at the BinarySerializationDesktopSample here: https://github.com/Apress/exp-.net-micro-framework/tree/master/source/Chapter09/BinarySerializationDesktopSample Warning GHI Electronics does not own or have rights to the code in this repository: https://github.com/Apress/exp-.net-micro-framework . It is your responsibility to adhere to the license provided by the owner of this code. JSON TinyCLR OS includes a built in JSON library. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Data.Json. class Program { private static void Main() { var intArray = new int[] { 1, 3, 5, 7, 9 }; var result = GHIElectronics.TinyCLR.Data.Json.JsonConverter.Serialize(intArray); var bson = result.ToBson(); var compare = (System.Array)GHIElectronics.TinyCLR.Data.Json.JsonConverter. FromBson(bson, typeof(int[])); for (var i = 0; i < intArray.Length; i++) { if (intArray[i] != (int)compare.GetValue(i)) { System.Diagnostics.Debug.WriteLine(\"Array test failed\"); break; } } System.Diagnostics.Debug.WriteLine(\"Array test succeeded\"); } }"
  },
  "software/tinyclr/tutorials/signal-control.html": {
    "href": "software/tinyclr/tutorials/signal-control.html",
    "title": "Signal Control",
    "keywords": "Signal Control Pulse Feedback The PulseFeedback class can be used in three different modes. These modes are used to measure Echo Duration, Duration Until Echo, and Drain Duration. Echo Duration Echo Duration sends a trigger pulse of a given state over the provided pin. It then waits for an echo on the other specified pin and measures the length of that echo pulse. The trigger and echo pins cannot be the same pin. The following code will read the distance in centimeters from an HC-SR04 ultrasonic distance sensor. This sensor has a trigger pin that is pulsed high to start distance measurement. It has a separate echo pin that the sensor holds high until it receives an echo. Therefore, the time the echo pin is high represents the time it takes for the sound to hit the target and reflect back to the sensor. To test this code, I plugged the sensor directly into the SCM20260D Dev board and ran a couple short wires for power. It was convenient having 5V on the header. I was surprised how well this inexpensive sensor worked. Note The HC-SR04 ultrasonic distance sensor requires a 5 volt power supply. While the module accepts 3.3 volt logic on the Trig and Echo pins, it will not work with a 3.3 volt supply for power. class Program { private static GHIElectronics.TinyCLR.Devices.Signals.PulseFeedback pulseFeedback; static void Main() { var distanceTriggerPin = GHIElectronics.TinyCLR.Devices.Gpio.GpioController. GetDefault().OpenPin(GHIElectronics.TinyCLR.Pins.SC20260.GpioPin.PA15); var distanceEchoPin = GHIElectronics.TinyCLR.Devices.Gpio.GpioController. GetDefault().OpenPin(GHIElectronics.TinyCLR.Pins.SC20260.GpioPin.PJ14); pulseFeedback = new GHIElectronics.TinyCLR.Devices.Signals.PulseFeedback (distanceTriggerPin, distanceEchoPin, GHIElectronics.TinyCLR.Devices. Signals.PulseFeedbackMode.EchoDuration) { DisableInterrupts = false, Timeout = System.TimeSpan.FromSeconds(1), PulseLength = System.TimeSpan.FromTicks(100), EchoValue = GHIElectronics.TinyCLR.Devices.Gpio.GpioPinValue.High, PulseValue = GHIElectronics.TinyCLR.Devices.Gpio.GpioPinValue.High, }; while (true) { System.Diagnostics.Debug.WriteLine(ReadDistance().ToString()); System.Threading.Thread.Sleep(1000); } } public static double ReadDistance() { var time = pulseFeedback.Trigger(); var microseconds = time.TotalMilliseconds * 1000.0; var distance = microseconds * 0.036 / 2.0; return distance; } } Duration Until Echo Duration Until Echo is very similar to Echo Duration, although instead of sending a pulse and measuring the length of the resulting echo, it measures how long it takes until that echo is received. Pulse and echo cannot use the same pins. The following code reads the distance in centimeters from a Polaroid 6500 Ranging Module. This module is similar to the HC-SR04 distance sensor, however the time it takes for the sensor to pulse the ECHO pin after your device pulses the INIT must be measured. class Program { private static GHIElectronics.TinyCLR.Devices.Signals.PulseFeedback pulseFeedback; static void Main() { var distanceTriggerPin = GHIElectronics.TinyCLR.Devices.Gpio.GpioController. GetDefault().OpenPin(GHIElectronics.TinyCLR.Pins.SC20260.GpioPin.PA15); var distanceEchoPin = GHIElectronics.TinyCLR.Devices.Gpio.GpioController. GetDefault().OpenPin(GHIElectronics.TinyCLR.Pins.SC20260.GpioPin.PJ14); pulseFeedback = new GHIElectronics.TinyCLR.Devices.Signals.PulseFeedback (distanceTriggerPin, distanceEchoPin, GHIElectronics.TinyCLR.Devices. Signals.PulseFeedbackMode.DurationUntilEcho) { DisableInterrupts = false, Timeout = System.TimeSpan.FromSeconds(1), PulseLength = System.TimeSpan.FromTicks(100), EchoValue = GHIElectronics.TinyCLR.Devices.Gpio.GpioPinValue.High, PulseValue = GHIElectronics.TinyCLR.Devices.Gpio.GpioPinValue.High, }; while (true) { System.Diagnostics.Debug.WriteLine(ReadDistance().ToString()); System.Threading.Thread.Sleep(1000); } } public static double ReadDistance() { var time = pulseFeedback.Trigger(); var microseconds = time.TotalMilliseconds * 1000.0; var distance = microseconds * 0.036 / 2.0; return distance; } } Drain Duration The final mode is DrainDuration. This mode is often used to implement capacitive touch. When calling Trigger, the pulse line will be held in the specified state for the specified time and then set to an input. When a resistor and capacitor are connected to this pin and ground, the pin will fall to ground after a short period of time dependent upon the size of the capacitor and the size of the resistor in parallel with it. The image below shows a sample circuit. Note that this mode can only be used with a single pin. The following example illustrates the reading of a capacitive touch sensor. It sends a pulse of 10us to charge a capacitor and then measures the length of time it takes the capacitor to discharge on the same pin. It prints out the total discharge duration in milliseconds. It repeats every second. class Program { static void Main() { var capacitiveSensePin = GHIElectronics.TinyCLR.Devices.Gpio.GpioController. GetDefault().OpenPin(GHIElectronics.TinyCLR.Pins.SC20260.GpioPin.PJ14); var pulseFeedback = new GHIElectronics.TinyCLR.Devices.Signals.PulseFeedback (capacitiveSensePin, GHIElectronics.TinyCLR.Devices.Signals. PulseFeedbackMode.DrainDuration) { DisableInterrupts = false, Timeout = System.TimeSpan.FromSeconds(1), PulseLength = System.TimeSpan.FromTicks(100), EchoValue = GHIElectronics.TinyCLR.Devices.Gpio.GpioPinValue.High, PulseValue = GHIElectronics.TinyCLR.Devices.Gpio.GpioPinValue.High, }; while (true) { System.Diagnostics.Debug.WriteLine(pulseFeedback.Trigger(). TotalMilliseconds.ToString()); System.Threading.Thread.Sleep(1000); } } } Signal Capture The SignalCapture class monitors a pin and records any changes (high-low or low-high transitions) of the pin to an array. It is a digital waveform recorder. Each array element is the number of microseconds between each signal change. When calling Read, it blocks other code from executing until it either fills the input buffer or it has captured the number of transitions specified by the count argument. If your signal is shorter than that, the call will never return. Make sure to request only what you plan to capture. The following sample code captures the signal generated by pressing LDR button on the SC20100S Dev board. It will attempt to capture 100 transitions, waiting no more than 10 seconds. It will also enable the pull-up resistor on the pin. It will return the initial state of the pin when it started capturing and how many transitions it captured. Note that the signal capture may record button bounces, resulting in a number of transitions in rapid succession. var capturePin = GHIElectronics.TinyCLR.Devices.Gpio.GpioController.GetDefault(). OpenPin(GHIElectronics.TinyCLR.Pins.SC20100.GpioPin.PE3); var capture = new SignalCapture(capturePin); var buffer = new TimeSpan[100]; capture.DisableInterrupts = false; capture.Timeout = TimeSpan.FromSeconds(10); capture.DriveMode = GpioPinDriveMode.InputPullUp; while (true) { var count = capture.Read(out var init, buffer); Thread.Sleep(100); } Signal Generator SignalGenerator is a digital waveform generator. SignalGenerator works by comparing an internal counter to an array of time values, one by one. When the value of the argument matches the counter, the output pin is changed. The time values are in microseconds. SignalGenerator can also be used to generate PWM. Unlike the PWM class, SignalGenerator can be used to generate PWM on any available output pin. It does use processor time -- the higher the frequency the more processor time it uses. At this time, SignalGenerator only operates in blocking mode. While SignalGenerator is running, it will not yield any processor time to other code. The following sample code will blink the user LED on the SC20100S Dev board four times (for one second each time) every five seconds. var signalPin = GHIElectronics.TinyCLR.Devices.Gpio.GpioController. GetDefault().OpenPin(GHIElectronics.TinyCLR.Pins.SC20100.GpioPin.PE11); var signalGen = new SignalGenerator(signalPin); var buffer = new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), }; signalGen.DisableInterrupts = false; signalGen.IdleValue = GpioPinValue.Low; while (true) { signalGen.Write(buffer); Thread.Sleep(5000); }"
  },
  "software/tinyclr/tutorials/spi.html": {
    "href": "software/tinyclr/tutorials/spi.html",
    "title": "SPI",
    "keywords": "SPI SPI uses three or sometimes four wires for transferring data. A SPI bus consists of a single master and one or more slaves. The master will send the clock signal to the slaves over the SCK (Serial Clock) pin. It will also send data over MOSI (Master Out Slave In) pin, while reading incoming data on the MISO (Master In Slave Out) pin. The SCK line is used to determine how fast the data is moved. If you know electronics, this is simply a shift register. The master selects which slave it will swap the data with using the SSEL (Slave SELect) pin, sometimes called CS (Chip Select). In its simplest terms, the master will swap data between itself and the slave. You cannot write data without reading data at the same time. However, often you want to write data and don't care about the incoming data. To do this you can use the Write method. Keep in mind that the Write method is discarding whatever data the slave is sending back. In TinyCLR OS, SPI transfers are dynamically sent in batches that are internally optimized to allow for maximum speed back-to-back transfers. This is helpful when sending large buffers, such as when refreshing displays. Tip Some SPI devices (slaves) can have more than one select pin, like the VS1053 MP3 decoder chip that uses one select pin for data and the other for commands. Both share the three data transfer pins (SCK, MOSI, MISO). Tip SPI needs more wires than other similar buses, but it can transfer data very quickly. A 50Mhz clock is possible on SPI, that is 50 million bits transferred in one second. Tip Note that a board running TinyCLR OS is always an SPI master, not slave. var cs = GHIElectronics.TinyCLR.Devices.Gpio.GpioController.GetDefault(). OpenPin(GHIElectronics.TinyCLR.Pins.SC20260.GpioPin.PE4); var settings = new SpiConnectionSettings() { ChipSelectType = SpiChipSelectType.Gpio, ChipSelectLine = cs, Mode = SpiMode.Mode1, ClockFrequency = 4_000_000, }; var controller = SpiController.FromName(SC20100.SpiBus.Spi4); var device = controller.GetDevice(settings); device.Write(new byte[] { 1, 2 }); //Write something. device.TransferSequential(...); //This is good for reading registers. device.TransferFullDuplex(...); //This is the only one that truly represents how SPI works."
  },
  "software/tinyclr/tutorials/sqlite-database.html": {
    "href": "software/tinyclr/tutorials/sqlite-database.html",
    "title": "SQLite Database",
    "keywords": "SQLite Database According to the SQLite homepage, \"SQLite is a software library that implements a self-contained, serverless, zero-configuration, transactional SQL database engine. SQLite is the most widely deployed SQL database engine in the world.\" SQLite lets you set up a database that resides entirely in a single file on a persistent storage device. The code below is a simple example that creates a database file in RAM (SD cards and USB drives can be used as well). A table is created, a few rows are filled, and then this data is read from the database. This data is then iterated over and printed out. ColumnOriginNames returns the name of each of the columns. using System.Collections; using System.Diagnostics; using GHIElectronics.TinyCLR.Data.SQLite; namespace TinyCLRDocTesting { class Program { static void Main() { using (var db = new SQLiteDatabase()) { Debug.WriteLine(\"Executing 1...\"); db.ExecuteNonQuery(\"CREATE Table Test (Var1 TEXT, Var2 INTEGER, Var3 DOUBLE);\"); Debug.WriteLine(\"Executing 2...\"); db.ExecuteNonQuery(\"INSERT INTO Test (Var1, Var2, Var3) VALUES ('Hello, World!', 25, 3.14);\"); Debug.WriteLine(\"Executing 3...\"); db.ExecuteNonQuery(\"INSERT INTO Test (Var1, Var2, Var3) VALUES ('Goodbye, World!', 15, 6.28);\"); Debug.WriteLine(\"Executing 4...\"); var result = db.ExecuteQuery (\"SELECT Var1, Var2, Var3 FROM Test WHERE Var2 > 10;\"); Debug.WriteLine(\"Executing 5...\"); Debug.WriteLine(result.ColumnCount.ToString() + \" \" + result.RowCount.ToString()); var str = \"\"; //foreach (var j in result.ColumnNames) // str += j + \" \"; //Debug.WriteLine(str); foreach (ArrayList i in result.Data) { str = \"\"; foreach (object j in i) str += j.ToString() + \" \"; Debug.WriteLine(str); } } } } } More Info Further details on SQLite can be found at the official SQLite website http://www.sqlite.org/"
  },
  "software/tinyclr/tutorials/timers.html": {
    "href": "software/tinyclr/tutorials/timers.html",
    "title": "Timers",
    "keywords": "Timers A timer is used to call a method at a specific time. This example will call or invoke the Ticker method after a three second delay, and then it will call Ticker once a second indefinitely. static void Ticker(object o) { Debug.WriteLine(\"Hello!\"); } static void Main() { Timer timer = new Timer(Ticker, null, 3000, 1000); Thread.Sleep(Timeout.Infinite); } A thread can also be created that loops once a second on its own, without being called by a timer. The difference is that a thread that contains a one second sleep will execute for that one second in addition to the time used by other code in the thread. So, if a thread needs 0.5 second to complete what it is doing, sleeping for one second will cause the thread to execute every 1.5 seconds. This also gets more complex as a thread can be interrupted by the system. There is no guarantee of exact timing when using threads. A timer set to invoke a method every second will do so every second regardless of how long the thread takes to execute. However, care must be taken, because if a timer calls a method every 10 milliseconds, but the method needs more than 10 milliseconds to execute, you will end up flooding the system. The best practice is for timers to invoke methods that execute in a very short time."
  },
  "software/tinyclr/tutorials/tls.html": {
    "href": "software/tinyclr/tutorials/tls.html",
    "title": "TLS",
    "keywords": "TLS TLS is how the Internet securely works, for banks, airports and security systems. We support TLS 1.3, a global security standard. All encryption, decryption and certification are done in secure internal memory to keep sensitive data safe. Below is simple example showing how to connect to https://www.google.com Tip Needed Nugets: GHIElectronics.TinyCLR.Devices.Network, GHIElectronics.TinyCLR.Networking.Http static void DoTestHttps() { var url = \"https://www.google.com\"; var certificates = Resources.GetBytes(Properties.Resources.BinaryResources.GlobalSign); X509Certificate[] certx509 = new X509Certificate[] { new X509Certificate(certificates) }; int read = 0, total = 0; byte[] result = new byte[512]; try { using (var req = HttpWebRequest.Create(url) as HttpWebRequest) { req.KeepAlive = false; req.HttpsAuthentCerts = certx509; req.ReadWriteTimeout = 2000; using (var res = req.GetResponse() as HttpWebResponse) { using (var stream = res.GetResponseStream()) { do { read = stream.Read(result, 0, result.Length); total += read; System.Diagnostics.Debug.WriteLine(\"read : \" + read); System.Diagnostics.Debug.WriteLine(\"total : \" + total); var page = new String(System.Text.Encoding.UTF8. GetChars(result, 0, read)); System.Diagnostics.Debug.WriteLine(\"Response : \" + page); } while (read != 0); } } } } catch { } } You need a root certificate to access secure websites. TinyCLR OS accepts certificates in both text and binary formats. The following instructions show how to download certificates:"
  },
  "software/tinyclr/tutorials/touch-screen.html": {
    "href": "software/tinyclr/tutorials/touch-screen.html",
    "title": "Touch Screen",
    "keywords": "Touch Screen Introduction Displays may optionally include a touch sensitive screen to detect user touch input. Touch Screens can be resistive or capacitive. Resistive Touch A resistive touch screen measures the resistance across the X and Y axes to determine the touch position. While it is possible to use GPIO and ADC, it is better to use dedicated chips. The only advantage of resistive touch over capacitive is that resistive touch works through a change in resistance induced by finger pressure, meaning you can use it while wearing gloves. However, resistive touch is not very accurate and requires calibration. Unless you have specific reason to use resistive touch, capacitive touch is preferred. This is a simple example showing how to read a resistive display. A better approach would be to use a resistive touch controller chip that works over SPI or I2C. private void TouchReader() { var adc = AdcController.GetDefault(); var gpio = GpioController.GetDefault(); int x, y; while (this.active) { // Read X { var XR = gpio.OpenPin(this.PinXR); XR.SetDriveMode(GpioPinDriveMode.Output); XR.Write(GpioPinValue.High); var XL = gpio.OpenPin(this.PinXL); XL.SetDriveMode(GpioPinDriveMode.Output); XL.Write(GpioPinValue.Low); var YD = gpio.OpenPin(this.PinYD); YD.SetDriveMode(GpioPinDriveMode.Input); var YU = adc.OpenChannel(this.ChannelYUA); x = (int)(YU.ReadRatio()*1000); XR.Dispose(); XL.Dispose(); YU.Dispose(); YD.Dispose(); } // Read Y { var YD = gpio.OpenPin(this.PinYD); YD.SetDriveMode(GpioPinDriveMode.Output); YD.Write(GpioPinValue.High); var YU = gpio.OpenPin(this.PinYU); YU.SetDriveMode(GpioPinDriveMode.Output); YU.Write(GpioPinValue.Low); var XR = gpio.OpenPin(this.PinXR); XR.SetDriveMode(GpioPinDriveMode.Input); var XL = adc.OpenChannel(this.ChannelXLA); y = (int)(XL.ReadRatio()*1000); XR.Dispose(); XL.Dispose(); YU.Dispose(); YD.Dispose(); } if (x > 50 && y > 50) { var sx = this.Scale(x, 50, 830, 0, 320); var sy = this.Scale(y, 150, 830, 0, 240); this.TouchMove?.Invoke(this, new TouchEventArgs(sx, sy)); } Thread.Sleep(20); } } Capacitive Touch Capacitive touch screens are used on most modern devices, including phones. They are very accurate and capable of detecting multiple simultaneous touches. A special capacitive controller chip must be used to read the touch panel. This chip is usually mounted right on the flat cable going to the touch panel. These chips are usually I2C or SPI, with I2C being more common. The capacitive displays used in our development options use a touch controller from FocalTech. We provide the GHIElectronics.TinyCLR.Drivers.FocalTech.FT5xx6 NuGet package to interact with capacitive touch screens. The constructor simply needs to know which I2C bus and reset pin are being used. The event fires giving the exact position using display pixels as units -- there is no need for scaling or calibration. The driver source code is found on the TinyCLR Drivers repo . This simple example will draw a dot on touch move: using GHIElectronics.TinyCLR.Drivers.FocalTech.FT5xx6; var touch = new FT5xx6Controller( i2cController.GetDevice(FT5xx6Controller.GetConnectionSettings()), gpioController.OpenPin(UCMStandard.GpioPin.B)); touch.Orientation = FT5xx6Controller.TouchOrientation.Degrees0; //Rotate touch coordinates. touch.TouchMove += (_, e) => { screen.FillEllipse(brush, e.X, e.Y, 5, 5); screen.Flush(); };"
  },
  "software/tinyclr/tutorials/uart.html": {
    "href": "software/tinyclr/tutorials/uart.html",
    "title": "UART",
    "keywords": "UART Serial data ports, called UARTs, transfer data between devices using two pins: TXD (transmit data) and RXD (receive data). UART stands for Universal Asynchronous Receiver Transmitter. Asynchronous means there is no clock signal to synchronize the two devices. The devices agree on a data rate, called the baud rate, and send a start bit the beginning of each transmitted character to keep the devices synchronized. Tip the TXD on one end (output) goes to the RXD on the other side (input) and vice versa. Tip UART ports are also referred to as COM ports, especially on PCs.. The easiest way to test a UART is by wiring a device's TXD to its RXD so any transmitted data is received by the same device. This is called a \"loopback\" test. The following code performs a simple loopback test. Tip UART requires the GHIElectronics.TinyCLR.Devices.Uart NuGet package! var txBuffer = new byte[] { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 }; //A, B, C, D, E, F var rxBuffer = new byte[txBuffer.Length]; var myUart = UartController.FromName(SC20100.UartPort.Uart7); myUart.SetActiveSettings(9600, 8, UartParity.None, UartStopBitCount.One, UartHandshake.None); myUart.Enable(); myUart.Write(txBuffer, 0, txBuffer.Length); while (true) { if (myUart.BytesToRead > 0) { var bytesReceived = myUart.Read(rxBuffer, 0, myUart.BytesToRead); Debug.WriteLine(Encoding.UTF8.GetString(rxBuffer, 0, bytesReceived)); } Thread.Sleep(20); } Event Handlers TinyCLR's UART API included the following event listeners: ClearToSendChanged DataReceived ErrorReceived private static void Main() { txBuffer = new byte[] { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 }; //A, B, C, D, E, F rxBuffer = new byte[txBuffer.Length]; myUart = UartController.FromName(SC20100.UartPort.Uart7); myUart.SetActiveSettings(9600, 8, UartParity.None, UartStopBitCount.One, UartHandshake.None); myUart.Enable(); myUart.DataReceived += MyUart_DataReceived; myUart.Write(txBuffer, 0, txBuffer.Length); while (true) Thread.Sleep(20); } private static void MyUart_DataReceived(UartController sender, DataReceivedEventArgs e) { var bytesReceived = myUart.Read(rxBuffer, 0, e.Count); Debug.WriteLine(Encoding.UTF8.GetString(rxBuffer, 0, bytesReceived)); } Tip Once you type += after the event, hit the tab key and Visual Studio will automatically create the event for you. RS232 UART uses the processor's voltage levels (logic levels) for transferring data. On the SITCore this is 0 to 3.3 volts. In the early days of computers, UARTs used -12 to +12 volts to communicate reliably over longer distances. This is known as the RS232 standard. Some PCs still include serial ports, but those are RS232 serial ports. A voltage level shifter is needed to properly connect a logic level UART to an RS232 device. Warning Connecting your device to an RS232 port without a proper voltage level shifter can damage your device."
  },
  "software/tinyclr/tutorials/unmanaged-heap.html": {
    "href": "software/tinyclr/tutorials/unmanaged-heap.html",
    "title": "Unmanaged Heap",
    "keywords": "Unmanaged Heap TinyCLR's memory management system takes care of everything in internal secure memory; however, TinyCLR OS also supports external unsecure memory through a special unmanaged heap. This memory is used in two different ways, for Large Buffers and for the Graphics system, and is only available on boards with that include external SDRAM memory. Most SITCore SoMs have 32 MBytes of external SDRAM. To ensure that unmanaged resources get disposed of properly, it is necessary to dispose of the buffer pointing to unmanaged heap manually, as shown in the sample code below. Unmanaged Buffers This is an easy way to create buffers that reside in external memory, which typically provides much more storage than internal memory. The following example creates an array uTable[] in unmanaged heap space on the SCM20260D Dev Board and then disposes of it. Tip Needed Nuget: GHIElectronics.TinyCLR.Native Needed Namespace: GHIElectronics.TinyCLR.Native //Allocate space for 100,000 byte array in unmanaged heap. UnmanagedBuffer uBuffer = new UnmanagedBuffer(100000); var uTable = uBuffer.Bytes; //uTable is now available as a byte array with 100,000 elements. // Properly release the objects. This is unmanaged so it is mandatory! uTable = null; uBuffer.Dispose(); Graphical Memory When the graphics engine detects available external memory, it automatically uses it. Also, garbage collection will dispose of unmanaged graphics buffers automatically. You do not have to dispose of unmanaged graphics buffers like you do for unmanaged non-graphic buffers. Helper Methods //Print number of available bytes in unmanaged memory. System.Diagnostics.Debug.WriteLine(Memory.UnmanagedMemory.FreeBytes.ToString()); //Print the number of bytes being used in unmanaged memory. System.Diagnostics.Debug.WriteLine(Memory.UnmanagedMemory.UsedBytes.ToString());"
  },
  "software/tinyclr/tutorials/usb.html": {
    "href": "software/tinyclr/tutorials/usb.html",
    "title": "USB",
    "keywords": "USB TinyCLR OS supports both USB Client and USB Host and includes support for using USB keyboards, mice, and mass storage devices with your SITCore devices. USB Client USB client support is mainly used for deploying and debugging applications. It can also be used to transfer data between a SITCore device and a PC. See USB CDC & WinUSB for details. USB Host The USB Host API supports USB keyboards, mice, raw devices, and USB MSC (Mass Storage Class), which allows file access on USB memory devices. The following code sample shows how to detect devices as they are connected to your SITCore device's USB host port. Note USB hubs are not currently supported. Special USB memory devices that have multiple interfaces or built in hubs will not work. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Storage, GHIElectronics.TinyCLR.Devices.UsbHost, GHIElectronics.TinyCLR.IO, GHIElectronics.TinyCLR.Native, and GHIElectronics.TinyCLR.Pins. class Program { static void Main() { var usbHostController = GHIElectronics.TinyCLR.Devices.UsbHost. UsbHostController.GetDefault(); usbHostController.OnConnectionChangedEvent += UsbHostController_OnConnectionChangedEvent; usbHostController.Enable(); System.Threading.Thread.Sleep(-1); } private static void UsbHostController_OnConnectionChangedEvent (GHIElectronics.TinyCLR.Devices.UsbHost.UsbHostController sender, GHIElectronics.TinyCLR.Devices.UsbHost.DeviceConnectionEventArgs e) { System.Diagnostics.Debug.WriteLine(\"e.Id = \" + e.Id + \" \\n\"); System.Diagnostics.Debug.WriteLine(\"e.InterfaceIndex = \" + e.InterfaceIndex + \" \\n\"); System.Diagnostics.Debug.WriteLine(\"e.PortNumber = \" + e.PortNumber); System.Diagnostics.Debug.WriteLine(\"e.Type = \" + ((object)(e.Type)). ToString() + \" \\n\"); System.Diagnostics.Debug.WriteLine(\"e.VendorId = \" + e.VendorId + \" \\n\"); System.Diagnostics.Debug.WriteLine(\"e.ProductId = \" + e.ProductId + \" \\n\"); switch (e.DeviceStatus) { case GHIElectronics.TinyCLR.Devices.UsbHost.DeviceConnectionStatus.Connected: switch (e.Type) { case GHIElectronics.TinyCLR.Devices.UsbHost.BaseDevice. DeviceType.Keyboard: var keyboard = new GHIElectronics.TinyCLR.Devices.UsbHost. Keyboard(e.Id, e.InterfaceIndex); keyboard.KeyUp += Keyboard_KeyUp; keyboard.KeyDown += Keyboard_KeyDown; break; case GHIElectronics.TinyCLR.Devices.UsbHost.BaseDevice.DeviceType.Mouse: var mouse = new GHIElectronics.TinyCLR.Devices.UsbHost. Mouse(e.Id, e.InterfaceIndex); mouse.ButtonChanged += Mouse_ButtonChanged; mouse.CursorMoved += Mouse_CursorMoved; break; case GHIElectronics.TinyCLR.Devices.UsbHost.BaseDevice. DeviceType.MassStorage: var strogareController = GHIElectronics.TinyCLR.Devices.Storage. StorageController.FromName(GHIElectronics.TinyCLR.Pins. SC20260.StorageController.UsbHostMassStorage); var driver = GHIElectronics.TinyCLR.IO.FileSystem. Mount(strogareController.Hdc); var driveInfo = new System.IO.DriveInfo(driver.Name); System.Diagnostics.Debug.WriteLine (\"Free: \" + driveInfo.TotalFreeSpace); System.Diagnostics.Debug.WriteLine (\"TotalSize: \" + driveInfo.TotalSize); System.Diagnostics.Debug.WriteLine (\"VolumeLabel:\" + driveInfo.VolumeLabel); System.Diagnostics.Debug.WriteLine (\"RootDirectory: \" + driveInfo.RootDirectory); System.Diagnostics.Debug.WriteLine (\"DriveFormat: \" + driveInfo.DriveFormat); break; default: var rawDevice = new GHIElectronics.TinyCLR.Devices.UsbHost. RawDevice(e.Id, e.InterfaceIndex, e.Type); var devDesc = rawDevice.GetDeviceDescriptor(); var cfgDesc = rawDevice.GetConfigurationDescriptor(0); var endpointData = new byte[7]; endpointData[0] = 7; //Length in bytes of this descriptor. endpointData[1] = 5; //Descriptor type (endpoint). endpointData[2] = 0x81; //Input endpoint address. endpointData[3] = 3; //Transfer type is interrupt endpoint. endpointData[4] = 8; //Max packet size LSB. endpointData[5] = 0; //Max packet size MSB. endpointData[6] = 10; //Polling interval. var endpoint = new GHIElectronics.TinyCLR.Devices.UsbHost. Descriptors.Endpoint(endpointData, 0); var pipe = rawDevice.OpenPipe(endpoint); pipe.TransferTimeout = 10; var data = new byte[8]; var read = pipe.Transfer(data); if (read > 0) { System.Diagnostics.Debug.WriteLine(\"Raw Device has new data \" + data[0] + \", \" + data[1] + \", \" + data[2] + \", \" + data[3]); } else if (read == 0) { System.Diagnostics.Debug.WriteLine(\"No new data\"); } System.Threading.Thread.Sleep(500); break; } break; case GHIElectronics.TinyCLR.Devices.UsbHost.DeviceConnectionStatus.Disconnected: System.Diagnostics.Debug.WriteLine(\"Device Disconnected\"); //Unmount filesystem if it was mounted. break; case GHIElectronics.TinyCLR.Devices.UsbHost.DeviceConnectionStatus.Bad: System.Diagnostics.Debug.WriteLine(\"Bad Device\"); break; } } private static void Keyboard_KeyDown(GHIElectronics.TinyCLR.Devices.UsbHost.Keyboard sender, GHIElectronics.TinyCLR.Devices.UsbHost.Keyboard.KeyboardEventArgs args) { System.Diagnostics.Debug.WriteLine(\"Key pressed: \" + ((object)args.Which).ToString()); System.Diagnostics.Debug.WriteLine(\"Key pressed ASCII: \" + ((object)args.ASCII).ToString()); } private static void Keyboard_KeyUp(GHIElectronics.TinyCLR.Devices.UsbHost.Keyboard sender, GHIElectronics.TinyCLR.Devices.UsbHost.Keyboard.KeyboardEventArgs args) { System.Diagnostics.Debug.WriteLine (\"Key released: \" + ((object)args.Which).ToString()); System.Diagnostics.Debug.WriteLine (\"Key released ASCII: \" + ((object)args.ASCII).ToString()); } private static void Mouse_CursorMoved(GHIElectronics.TinyCLR.Devices.UsbHost.Mouse sender, GHIElectronics.TinyCLR.Devices.UsbHost.Mouse.CursorMovedEventArgs e) { System.Diagnostics.Debug.WriteLine(\"Mouse moved to: \" + e.NewPosition.X + \", \" + e.NewPosition.Y); } private static void Mouse_ButtonChanged(GHIElectronics.TinyCLR.Devices.UsbHost.Mouse sender, GHIElectronics.TinyCLR.Devices.UsbHost.Mouse.ButtonChangedEventArgs args) { System.Diagnostics.Debug.WriteLine (\"Mouse button changed: \" + ((object)args.Which).ToString()); } }"
  },
  "software/tinyclr/tutorials/usb-cdc-winusb.html": {
    "href": "software/tinyclr/tutorials/usb-cdc-winusb.html",
    "title": "USB CDC & WinUSB",
    "keywords": "USB CDC & WinUSB These protocols facilitate communication between your SITCore device and a PC. Note that the debug interface needs to be switched to serial (UART) to free up the USB Client port for PC communication. This is accomplished by pulling the MOD pin low during reset as detailed on the SITCore System on Chip page. USB CDC The USB Communications Device Class (CDC) is natively supported by Windows and Linux. It is a way for a PC to use a USB port as a virtual serial port. Once loaded, the PC will use this port like any other serial port (COM port). Windows 10 works without the need for any drivers, but earlier operating systems may need a driver. While it works with most operating systems, CDC is typically limited to 64 KBytes/second. Tip Needed Nugets: GHIElectronics.TinyCLR.Devices.UsbClient static void DoTestCDC { var usbclient = GHIElectronics.TinyCLR.Devices.UsbClient.UsbClientController.GetDefault(); usbclient.SetActiveSetting (GHIElectronics.TinyCLR.Devices.UsbClient.UsbClientMode.Cdc,0x1234, 0x5678); usbclient.Enable(); usbclient.DeviceStateChanged += (a,b) => Debug.WriteLine(\"Connection changed.\"); usbclient.DataReceived += (a,count) => Debug.WriteLine(\"Data received:\" + count); while (usbclient.DeviceState != GHIElectronics.TinyCLR.Devices.UsbClient.DeviceState.Configured) ; Debug.WriteLine(\"UsbClient Connected\"); // The example will read data from port to dataR array // Copy dataR to dataW array, plus 1 for each element // Write dataW array back to port while (true) { var len = usbclient.ByteToRead; if (len > 0) { var dataR = new byte[len]; var dataW = new byte[len]; int read = usbclient.Read(dataR); for (var i = 0; i < read; i++) { dataW[i] = (byte)(dataR[i] + 1); } usbclient.Write(dataW); } Thread.Sleep(100); } } WinUSB The WinUSB drivers are unique to Windows and take advantage of the power and speed of USB to provide faster communication than CDC. The speed is limited by the data processing on the IoT device. Windows 10 loads the drivers automatically, Windows 7 requires drivers. static void DoTestWinUsb { var usbclient = GHIElectronics.TinyCLR.Devices.UsbClient.UsbClientController.GetDefault(); usbclient.SetActiveSetting(GHIElectronics.TinyCLR.Devices.UsbClient.UsbClientMode.WinUsb, \"Manufacture_Name\", \"Product_Name\", \"SerailNumber\", 0x1234, 0x5678, \"{your guid}\"); usbclient.Enable(); usbclient.DeviceStateChanged += (a,b) => Debug.WriteLine(\"Connection changed.\"); usbclient.DataReceived += (a,count) => Debug.WriteLine(\"Data received:\" + count); while (usbclient.DeviceState != GHIElectronics.TinyCLR.Devices.UsbClient.DeviceState.Configured) ; Debug.WriteLine(\"UsbClient Connected\"); // The example will read data from port to dataR array // Copy dataR to dataW array, plus 1 for each element // Write dataW array back to port while (true) { var len = usbclient.ByteToRead; if (len > 0) { var dataR = new byte[len]; var dataW = new byte[len]; int read = usbclient.Read(dataR); for (var i = 0; i < read; i++) { dataW[i] = (byte)(dataR[i] + 1); } usbclient.Write(dataW); } Thread.Sleep(100); } } Note Unlike CDC mode, a disadvantage of WinUSB is that it requires a special code on the PC side to read and write to the device."
  },
  "software/tinyclr/tutorials/user-interface.html": {
    "href": "software/tinyclr/tutorials/user-interface.html",
    "title": "User Interface",
    "keywords": "User Interface You can use the GHIElectronics.TinyCLR.UI library to create user interfaces for your application. The UI library is inspired by Windows Presentation Foundation on the desktop. Application Management The UI library requires internal management that is handled by the application class. The following code provides a good starting point. Tip Needed NuGets: GHIElectronics.TinyCLR.Devices.Display, GHIElectronics.TinyCLR.UI using GHIElectronics.TinyCLR.Devices.Display; using GHIElectronics.TinyCLR.UI; namespace UserInterfaceExample { class Program : Application { public Program(DisplayController d) : base(d) { } static void Main() { var display = DisplayController.GetDefault(); display.SetConfiguration(new ParallelDisplayControllerSettings { //Your display configuration }); display.Enable(); var app = new Program(display); app.Run(Program.CreateWindow(display)); } private static Window CreateWindow(DisplayController display) { var window = ... return window; } } } Windows While you can have multiple windows in your UI application, it is mandatory to have at least one window. Here is a complete example that shows a window with a gradient brush background. The code is for SCM20260D Dev board with the 4.3 inch display. Tip Needed NuGets: GHIElectronics.TinyCLR.Devices.Display, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.I2c, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Pins, GHIElectronics.TinyCLR.UI, GHIElectronics.TinyCLR.UI.Media using GHIElectronics.TinyCLR.Devices.Display; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Devices.I2c; using GHIElectronics.TinyCLR.Native; using GHIElectronics.TinyCLR.Pins; using GHIElectronics.TinyCLR.UI; using GHIElectronics.TinyCLR.UI.Media; using System.Drawing; namespace UserInterfaceExample { class Program : Application { public Program(DisplayController d) : base(d) { } static Program app; static void Main() { GpioPin backlight = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PA15); backlight.SetDriveMode(GpioPinDriveMode.Output); backlight.Write(GpioPinValue.High); var display = DisplayController.GetDefault(); var controllerSetting = new GHIElectronics.TinyCLR.Devices.Display.ParallelDisplayControllerSettings { Width = 480, Height = 272, DataFormat = GHIElectronics.TinyCLR.Devices.Display.DisplayDataFormat.Rgb565, Orientation = DisplayOrientation.Degrees0, //Rotate display. PixelClockRate = 10000000, PixelPolarity = false, DataEnablePolarity = false, DataEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, }; display.SetConfiguration(controllerSetting); display.Enable(); var screen = Graphics.FromHdc(display.Hdc); var controller = I2cController.GetDefault(); app = new Program(display); app.Run(Program.CreateWindow(display)); } private static Window CreateWindow(DisplayController display) { var window = new Window { Height = (int)display.ActiveConfiguration.Height, Width = (int)display.ActiveConfiguration.Width }; window.Background = new LinearGradientBrush (Colors.Blue, Colors.Teal, 0, 0, window.Width, window.Height); window.Visibility = Visibility.Visible; return window; } } } When using the 7\" display with the above code sample, change the display configuration to the following: var controllerSetting = new GHIElectronics.TinyCLR.Devices.Display.ParallelDisplayControllerSettings { Width = 800, Height = 480, DataFormat = DisplayDataFormat.Rgb565, Orientation = DisplayOrientation.Degrees0, //Rotate Display. PixelClockRate = 24000000, PixelPolarity = false, DataEnablePolarity = false, DataEnableIsFixed = false, HorizontalFrontPorch = 16, HorizontalBackPorch = 46, HorizontalSyncPulseWidth = 1, HorizontalSyncPolarity = false, VerticalFrontPorch = 7, VerticalBackPorch = 23, VerticalSyncPulseWidth = 1, VerticalSyncPolarity = false, }; This code is for the SC20100S Dev Board with the N18 1.8 inch display. Tip Needed NuGets: GHIElectronics.TinyCLR.Devices.Display, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.Spi, GHIElectronics.TinyCLR.Drivers.Sitronix.ST7735, GHIElectronics.TinyCLR.Pins, GHIElectronics.TinyCLR.UI, GHIElectronics.TinyCLR.UI.Media using GHIElectronics.TinyCLR.Devices.Display; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Devices.Spi; using GHIElectronics.TinyCLR.Drivers.Sitronix.ST7735; using GHIElectronics.TinyCLR.Pins; using GHIElectronics.TinyCLR.UI; using GHIElectronics.TinyCLR.UI.Media; using System; using System.Drawing; namespace SC20100_N18_WPF{ class Program : Application{ public Program(int width, int height) : base(width, height) { } private static ST7735Controller st7735; private const int SCREEN_WIDTH = 160; private const int SCREEN_HEIGHT = 128; private static void Main(){ var spi = SpiController.FromName(SC20100.SpiBus.Spi3); var gpio = GpioController.GetDefault(); st7735 = new ST7735Controller( spi.GetDevice(ST7735Controller.GetConnectionSettings (SpiChipSelectType.Gpio, SC20100.GpioPin.PD10)), //CS pin. gpio.OpenPin(SC20100.GpioPin.PC4), //RS pin. gpio.OpenPin(SC20100.GpioPin.PE15) //RESET pin. ); var backlight = gpio.OpenPin(SC20100.GpioPin.PE5); backlight.SetDriveMode(GpioPinDriveMode.Output); backlight.Write(GpioPinValue.High); st7735.SetDataAccessControl(true, true, false, false); //Rotate the screen. st7735.SetDrawWindow(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT); st7735.Enable(); Graphics.OnFlushEvent += Graphics_OnFlushEvent; app = new Program(SCREEN_WIDTH, SCREEN_HEIGHT); app.Run(Program.CreateWindow(SCREEN_WIDTH, SCREEN_HEIGHT)); } private static void Graphics_OnFlushEvent(IntPtr hdc, byte[] data){ st7735.DrawBuffer(data); } private static Window CreateWindow(int width, int height){ var window = new Window{ Height = height, Width = width }; window.Background = new LinearGradientBrush Colors.Blue, Colors.Red, 0, 0, window.Width, -20); window.Visibility = Visibility.Visible; return window; } } } Elements A window is not very useful without some elements (controls). There are many available standard elements, and you can make your own custom elements as well. All elements descend from the UIElement class. Explore the GHIElectronics.TinyCLR.UI.Controls namespace to see what's available. For the sake of simplifying the rest of this tutorial, we've added the private static UIElement Elements() method that creates and returns the elements. This is then assigned to the child of our window. You will need to add window.Child = Elements() right before returning from CreateWindow . Tip This example needs a font . private static UIElement Elements() { var txt = new TextBox { Font = font, Text = \"Hello World!\", HorizontalAlignment = HorizontalAlignment.Center, VerticalAlignment = VerticalAlignment.Center }; return txt; } Label, TextBlock, and TextBox A TextBlock just displays text that cannot be changed at runtime. A TextBlock could be used for a window title, for example. A Label is like a TextBlock, but Label text can be changed at runtime. The Label control can also host controls other than text strings. The TextBox allows for both single line and multiple line text input. Panel A Window can carry only a single Child , that is a single element. This is not a concern because the single element can be a container, like a Panel , which holds multiple elements. You can even have panels within panels with each having its own elements. This example will introduce shapes found in the GHIElectronics.TinyCLR.UI.Shapes namespace. It also shows an example of the TextBox element. We will also set margins for a better look. private static UIElement Elements() { var panel = new Panel(); var txt1 = new TextBox() { HorizontalAlignment = HorizontalAlignment.Left, VerticalAlignment = VerticalAlignment.Top, }; txt1.Font = font; txt1.SetMargin(20); txt1.Text = \"Hello World!\"; var txt2 = new Text(font, \"TinyCLR is Great!\") { ForeColor = Colors.White, HorizontalAlignment = HorizontalAlignment.Right, }; txt2.SetMargin(20); var rect = new Rectangle(200, 10) { Fill = new SolidColorBrush(Colors.Green), HorizontalAlignment = HorizontalAlignment.Center, }; panel.Children.Add(txt1); panel.Children.Add(txt2); panel.Children.Add(rect); return panel; } StackPanel There are also two types of elements that descend from panels, Canvas and StackPanel . The Canvas control allows elements to be added anywhere. StackPanels, on the other hand, place elements in order. We will modify the previous example to use a vertical StackPanel. The elements will stack and be arranged to the right and the left. Note that setting vertical alignment will be ignored as the vertical StackPanel overrides how elements are stacked. private static UIElement Elements() { var panel = new StackPanel(Orientation.Vertical); var txt1 = new TextBox() { HorizontalAlignment = HorizontalAlignment.Left, VerticalAlignment = VerticalAlignment.Top, }; txt1.Font = font; txt1.SetMargin(20); txt1.Text = \"Hello World!\"; var txt2 = new Text(font, \"TinyCLR is Great!\") { ForeColor = Colors.White, HorizontalAlignment = HorizontalAlignment.Right, }; txt2.SetMargin(20); var rect = new Rectangle(200, 10) { Fill = new SolidColorBrush(Colors.Green), HorizontalAlignment = HorizontalAlignment.Center, }; panel.Children.Add(txt1); panel.Children.Add(txt2); panel.Children.Add(rect); return panel; } Canvas The Canvas element provides pixel level control over the placement of its child controls. The Width and Height properties of Canvas are requested dimensions, but the actual size depends on the size of the parent element. The ActualWidth and ActualHeight properties can be used to determine the actual size of the Canvas. Controls within a Canvas are positioned relative to the four edges of the Canvas. private static UIElement Elements() { var canvas = new Canvas(); var txt = new Text(font, \"TinyCLR is Great!\") { ForeColor = Colors.White, }; var rect = new Rectangle(150, 30) { Fill = new SolidColorBrush(Colors.Green), HorizontalAlignment = HorizontalAlignment.Center, }; Canvas.SetLeft(rect, 20); Canvas.SetBottom(rect, 20); canvas.Children.Add(rect); Canvas.SetLeft(txt, 30); Canvas.SetBottom(txt, 25); canvas.Children.Add(txt); return canvas; } Border This element defines a border inside another element. The position of child elements is constrained to the area inside the border. In this example the border thickness is set to 10, but if the children do not fill the area within the border, the border's thickness will automatically increase. Uncomment the two alignment lines to see an undesired effect of how borders work. private static UIElement Elements() { var border = new Border(); border.SetBorderThickness(10); border.BorderBrush = new SolidColorBrush(Colors.Red) var txt = new TextBox() { //HorizontalAlignment = HorizontalAlignment.Center, //VerticalAlignment= VerticalAlignment.Center, }; txt.Font = font; txt.Text = \"TinyCLR is Great!\"; border.Child = txt; return border; } The fix is to add a container and then the container will have a border. In this example, the parent of the border is the canvas instead of the window. private static UIElement Elements() { var canvas = new Canvas(); var border = new Border(); border.SetBorderThickness(10); border.BorderBrush = new SolidColorBrush(Colors.Red); Canvas.SetLeft(border, 20); Canvas.SetTop(border, 20); var txt = new TextBox(); txt.Font = font; txt.Text = \"TinyCLR is Great!\"; border.Child = txt; canvas.Children.Add(border); return canvas; } Button Buttons are simple controls that accept user input in the form of a click, which in embedded devices is usually a finger tap on a touch screen. The button needs a child, typically text, which describes the button's function. Buttons have a Click event to respond to user input. private static UIElement Elements() { var txt = new Text(font, \"Push me!\") { VerticalAlignment = VerticalAlignment.Center, HorizontalAlignment = HorizontalAlignment.Center, }; var button = new Button() { Child = txt, Width = 100, Height = 40, }; button.Click += Button_Click; return button; } private static void Button_Click(object sender, RoutedEventArgs e) { // Add button click event code here... } TextFlow TextFlow is a more powerful version of TextBlock that supports more advanced text formatting, and works well with large blocks of text. private static UIElement Elements() { var textFlow = new TextFlow(); textFlow.TextRuns.Add(\"Hello \", font, Colors.Red); textFlow.TextRuns.Add(\"World!\", font, Colors.Purple); textFlow.TextRuns.Add(TextRun.EndOfLine); textFlow.TextRuns.Add(\"TinyCLR is Great!\", font, Colors.Yellow); return textFlow; } ListBox This element provides a list of options for users to select from. private static UIElement Elements() { var listBox = new ListBox(); listBox.Items.Add(new Text(font, \"Item 1\")); listBox.Items.Add(new Text(font, \"Item 2\")); listBox.Items.Add(new Text(font, \"Item 3\")); listBox.Items.Add(new Text(font, \"Item 4\")); return listBox; } It is also possible to add a separator between items, simply by using a rectangle. This item will be set to be not selectable. private static UIElement Elements() { var rect = new Rectangle() { Height = 1, Width=30, Stroke = new Pen(Colors.Black), }; var separator = new ListBoxItem() { Child = rect, IsSelectable = false, }; separator.SetMargin(2); var listBox = new ListBox(); listBox.Items.Add(new Text(font, \"Item 1\")); listBox.Items.Add(new Text(font, \"Item 2\")); listBox.Items.Add(separator); listBox.Items.Add(new Text(font, \"Item 3\")); listBox.Items.Add(new Text(font, \"Item 4\")); return listBox; } ScrollViewer The scroll viewer allows for viewing content that is larger than the viewing area. User input is used to shift the content within the viewing area. The Dispatcher The User Interface libraries rely on a dispatcher to handle system events and update invalidated elements. All elements are changed and updated from within the dispatcher. In this example, we will show the time on the screen. The time will be in a text box that is updated every second using a Timer . Since timers run in their own thread, a dispatcher invoke is needed. static void Counter(object o) { Application.Current.Dispatcher.Invoke(TimeSpan.FromMilliseconds(1), _ => { Text txt = (Text)o; txt.TextContent = DateTime.Now.ToString(); txt.Invalidate(); return null; }, null); } private static UIElement Elements() { var txt = new Text(font, \"Hello World!\") { ForeColor = Colors.White, VerticalAlignment = VerticalAlignment.Center, HorizontalAlignment = HorizontalAlignment.Center, }; Timer timer = new Timer(Counter, txt, 2000, 1000); return txt; } You can also use the dispatcher timer directly: private static UIElement Elements() { var txt = new Text(font, \"Hello World!\") { ForeColor = Colors.White, VerticalAlignment = VerticalAlignment.Center, HorizontalAlignment = HorizontalAlignment.Center, }; var timer = new DispatcherTimer(); timer.Tag = txt; timer.Tick += Counter; timer.Interval = new TimeSpan(0, 0, 1); timer.Start(); return txt; } private static void Counter(object sender, EventArgs e) { var txt = (Text)((DispatcherTimer)sender).Tag; txt.TextContent = DateTime.Now.ToString(); txt.Invalidate(); } User Input A user can feed input to the graphical interface through touch or button input. app.InputProvider.RaiseTouch(x, y, touchState, DateTime.UtcNow); app.InputProvider.RaiseButton(btn, btnState, DateTime.UtcNow); The touch tutorial has further details."
  },
  "software/tinyclr/tutorials/watchdog-timer.html": {
    "href": "software/tinyclr/tutorials/watchdog-timer.html",
    "title": "Watchdog",
    "keywords": "Watchdog A watchdog timer is used to reset the system if the system fails or locks up. A watchdog timer is a countdown timer that will reset the system when the timer reaches zero. During normal operation, the application will regularly reset the watchdog timer so it never reaches zero and doesn't reset the system. However, when the system fails or locks up, the timer will time out and reset the system. Note Once Watchdog is enabled it can't be disabled without resetting the system or a power cycle. // Set watchdog to 5 seconds and reset it every 4 seconds Watchdog.Enable(5000); While(true) { // reset the timer Watchdog.Reset() Thread.Sleep(4000); } Note Enabling the watchdog timer when debugging is a bad idea since the system will probably reset while stepping through code."
  },
  "software/tinyclr/tutorials/wifi.html": {
    "href": "software/tinyclr/tutorials/wifi.html",
    "title": "WiFi",
    "keywords": "WiFi First introduced over twenty years ago, WiFi has become the most popular wireless networking technology. Our SITCore line of products includes native support for the Microchip ATWINC1500 series of WiFi modules. These modules are available pre-certified from FCC, CE, and other regulatory agencies. For added security, WiFi module communication is handled through SPI, not through AT commands. The sample code is meant for the FEZ Portal with it's built in WiFi module. If you want to use a bare ATWINC1500 module instead, you'll need to connect interrupt, reset, and chip select lines in addition to the SPI lines (MOSI, MISO, SCK). This example uses the FEZ Portal with its built in ATWINC1500 WiFi module. Tip Needed Nugets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.Network, GHIElectronics.TinyCLR.Devices.Spi, GHIElectronics.TinyCLR.Devices.Uart, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Networking, and GHIElectronics.TinyCLR.Pins. using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Devices.Network; using GHIElectronics.TinyCLR.Devices.Spi; using GHIElectronics.TinyCLR.Pins; using System; using System.Diagnostics; using System.Net; using System.Threading; static void Wifi_Example() { var enablePin = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PI0); enablePin.SetDriveMode(GpioPinDriveMode.Output); enablePin.Write(GpioPinValue.High); SpiNetworkCommunicationInterfaceSettings netInterfaceSettings = new SpiNetworkCommunicationInterfaceSettings(); var cs = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PG12); var settings = new SpiConnectionSettings() { ChipSelectLine = cs, ClockFrequency = 4000000, Mode = SpiMode.Mode0, ChipSelectType = SpiChipSelectType.Gpio, ChipSelectHoldTime = TimeSpan.FromTicks(10), ChipSelectSetupTime = TimeSpan.FromTicks(10) }; netInterfaceSettings.SpiApiName = SC20260.SpiBus.Spi3; netInterfaceSettings.GpioApiName = SC20260.GpioPin.Id; netInterfaceSettings.SpiSettings = settings; netInterfaceSettings.InterruptPin = GpioController.GetDefault(). OpenPin(SC20260.GpioPin.PG6); netInterfaceSettings.InterruptEdge = GpioPinEdge.FallingEdge; netInterfaceSettings.InterruptDriveMode = GpioPinDriveMode.InputPullUp; netInterfaceSettings.ResetPin = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PI8); netInterfaceSettings.ResetActiveState = GpioPinValue.Low; var networkController = NetworkController.FromName (\"GHIElectronics.TinyCLR.NativeApis.ATWINC15xx.NetworkController\"); WiFiNetworkInterfaceSettings wifiSettings = new WiFiNetworkInterfaceSettings() { Ssid = \"Your SSID\", Password = \"Your Password\", }; wifiSettings.Address = new IPAddress(new byte[] { 192, 168, 1, 122 }); wifiSettings.SubnetMask = new IPAddress(new byte[] { 255, 255, 255, 0 }); wifiSettings.GatewayAddress = new IPAddress(new byte[] { 192, 168, 1, 1 }); wifiSettings.DnsAddresses = new IPAddress[] { new IPAddress(new byte[] { 75, 75, 75, 75 }), new IPAddress(new byte[] { 75, 75, 75, 76 }) }; wifiSettings.MacAddress = new byte[] { 0x00, 0x4, 0x00, 0x00, 0x00, 0x00 }; wifiSettings.IsDhcpEnabled = true; wifiSettings.IsDynamicDnsEnabled = true; wifiSettings.TlsEntropy = new byte[] { 0, 1, 2, 3 }; networkController.SetInterfaceSettings(wifiSettings); networkController.SetCommunicationInterfaceSettings(netInterfaceSettings); networkController.SetAsDefaultController(); networkController.NetworkAddressChanged += NetworkController_NetworkAddressChanged; networkController.NetworkLinkConnectedChanged += NetworkController_NetworkLinkConnectedChanged; networkController.Enable(); // Network is ready to used Thread.Sleep(Timeout.Infinite); } private static void NetworkController_NetworkLinkConnectedChanged (NetworkController sender, NetworkLinkConnectedChangedEventArgs e) { // Raise event connect/disconnect } private static void NetworkController_NetworkAddressChanged (NetworkController sender, NetworkAddressChangedEventArgs e) { var ipProperties = sender.GetIPProperties(); var address = ipProperties.Address.GetAddressBytes(); Debug.WriteLine(\"IP: \" + address[0] + \".\" + address[1] + \".\" + address[2] + \".\" + address[3]); } Important There is an enable pin which needs to be pulled high on the WiFI 7 click module. var enablePin = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PI0); enablePin.SetDriveMode(GpioPinDriveMode.Output); enablePin.Write(GpioPinValue.High); WINC1500 Utilities We provide the static Winc15x0Interface class to access some of the native functions of the WINC1500 WiFi module. Commands for getting the WiFi module's MAC address, getting RSSI (Relative Signal Strength Indicator), scanning for access points, checking the firmware version, and over-the-air (OTA) firmware update are supported. Unless you provide your own MAC address, the MAC address of the WiFi module will be used by default. More information about MAC addresses can be found here . //Scan for WiFi access points: string[] ssidList = Winc15x0Interface.Scan(); //Get Relative Signal Strength Indicator for the connected access point: int signalStrength = Winc15x0Interface.GetRssi(); //Get the WiFi module's MAC address: byte[] macAddress = Winc15x0Interface.GetMacAddress(); //Get the version of the installed WiFi firmware: string fwVersion = Winc15x0Interface.GetFirmwareVersion(); //Print a list of WiFi firmware versions that have been tested with TinyCLR OS. // Note: Untested WiFi firmware versions may also work. for (int i = 0; i < Winc15x0Interface.FirmwareSupports.Length; i++) { System.Diagnostics.Debug.WriteLine(\"Supported firmware version #\" + (i + 1).ToString() + \": \" + Winc15x0Interface.FirmwareSupports[i].ToString()); } //Download and install firmware from an OTA download (web) server: // Must upload firmware file to root folder in server // (e.g. http://192.168.0.137/m2m_ota_3a0.bin). bool success = Winc15x0Interface.FirmwareUpdate(string url, int timeout);"
  }
}