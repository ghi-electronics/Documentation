{
  "hardware/brainpad.html": {
    "href": "hardware/brainpad.html",
    "title": "BrainPad",
    "keywords": "BrainPad Educators now have the power to use their beloved language-of-choice with BrainPad devices, thanks to the power of the DUE platform. Both BrainPad Pulse and BrainPad Edge are fully supported. However, BrainPad Pulse include additional natively-supported, which are the display and the buzzer. tip: The heart to the BrainPad Pulse is SITCore SC13 chipset. And for BrainPad Edge is SITCore SC007. BrainPad Pulse BrainPad Edge Getting Ready The first step is to load the appropriate firmware onto the device. Follow the steps found at the BrainPad loader page. and select the appropriate DUE firmware. Hardware Demos The edge connector on the supported BrainPad hardware combined with the ease of the DUE platform, open up many possiblities to try the existing accessories available on the market. Here are just a few: Smart House This example demostrates the extensibility of the DUE platform. Using the DUE library from within full .NET. See the code samples repo for all the available sensors. We added a BrainClip IR remote control to our demo. Smart House Sample Repo A.I. Mask Detector Harnessing the power of A.I. on a tiny microcontroller is a challenge, but easy work for the DUE platform. In this example full Python is used with the DUE platform connecting the pieces together. A.I. Mask Detector Sample Repo NeoPixel Matrix NeoPixel Matrix panels pair well with the DUE platform, because NeoPixel support is built-in. Using DUE you can quickly create games, images, or led-effects. In our samples repo, we demonstrate using DUE Script, Python, and .NET. and make a simple Falling Bird Game. Falling Bird Sample Repo More NeoPixel Matrix Projects BrainGamer Sketch Creating art is easy when you pair the BrainPad Pulse with the BrainGamer BrainGamer Sketch Demo"
  },
  "hardware/fez.html": {
    "href": "hardware/fez.html",
    "title": "FEZ",
    "keywords": "FEZ These FEZ products can be used with the DUE platform. FEZ Flea The FEZ Flea form factor is the same as the Seeed Studio Xiao. This opens up the option for many existing accessories. The FEZ Flea can also be soldered to a PCB just like a SoM. FEZ Pico The FEZ Pico form factor is the same as the Raspberry Pi Pico. This opens up the option for many existing accessories. The FEZ Pico also includes a STEMMA connector that can connect to many existing STEMMA modules. Hardware Demos The supported hardware's form factor opens the opportunity to use some of the many available accesories on the market. Here are just a few examples. PicoMate The PicoMate is a single-pcb with multiple Grove compatible sensors that are removable or work in place. Samples in the repo demonstrate extending DUE with Python or .NET. PicoMate Samples Repo Grove Module Shields These Grove shields are a great way to connect the many Grove modules on the market to DUE. There are many drivers located in the DUE samples driver repo to get you started. Drivers Repo Qwiic/STEMMA QT Connector The built in JST connector on the FEZ Pico opens up the door for even more expansion options, using Qwiic or STEMMA QT sensors. LED Bar Demo Mikroe Click Shield for Pico Mikroe Electronica has 1000's of Click sensors available, this shield provides an interface to those modules. Our demo in Due Samples repo uses the LEDRing Click module. Warning Click shield for Pi Pico has a major flaw. MISO and MOSI pins are swapped on board rev 1.00. LEDRing Click Module"
  },
  "hardware/intro.html": {
    "href": "hardware/intro.html",
    "title": "DUE Hardware",
    "keywords": "DUE Hardware The DUE platform is supported on several GHI Electronics' devices, including the educational BrainPad devices. If you're already a Maker then the FEZ options are a great place to jump in and start. If you're new to hardware then BrainPad is great option to get you started. Note All DUE supported hardware has an onboard LED that is located at pin 100. dwrite(100,1) BrainPad Educators now have the power to use their beloved language-of-choice with BrainPad devices, thanks to the power of the DUE platform. Learn more... SITCore / FEZ The power of DUE is available on a Fast-and-Easy (FEZ) developer-friendly boards. Learn more..."
  },
  "index.html": {
    "href": "index.html",
    "title": "DUE Link",
    "keywords": "DUE Link What is DUE Link? DUE is a Dynamic, Universal, and Extensible platform that gives devices access to the physical world. These devices can be desktops, laptops, phones, or even a Raspberry PI. Developers have the option to use any modern operating system and use the programming language of their choice. DUE Link Software Learn about all the great software features and how DUE can change \"physical-computing\" forever! Hardware A range of hardware options are available off-the-shelf Continuous Innovation GHI Electronics has been bridging the hardware-to-software gap since 2003 with modern platforms,devices,systems, and coding languages. GHI Electronics is yet again bringing you an new innovation to make physical computing accessible to everyone. Not just the hardware developer. GHI Electronics is where hardware meets software!"
  },
  "README.html": {
    "href": "README.html",
    "title": "Documentation",
    "keywords": "Documentation This is the repository for all of our docs. To generate the docs locally: Clone/Fork the repo Open the command prompt in the documents' root folder (\"Run as Administrator\" may be necessary) Execute docfx --serve After executing the above command, a temporary webpage will appear to allow you to view the files in your browser fully rendered in HTML, for example http://localhost:8080. To install DocFX, please review and download from the following site: https://dotnet.github.io/docfx/. From there, you can go to the Getting Started page for instructions on how to install and you can go to Download Latest to download the most up to date DocFX files. Please note, you will not need to use the docfx init command as the initial JSON file is already present in our repository. WK<html>TOpdf is an optional part of the build process. You will find the needed files at the following address: https://wkhtmltopdf.org/downloads.html. Once downloaded, execute the command to install. Once installed, add the path to the installed binary to the environment variable PATH, for example \"C:\\Program Files\\wkhtmltopdf\\bin\"."
  },
  "software/coding-options/coding-options.html": {
    "href": "software/coding-options/coding-options.html",
    "title": "Coding Options",
    "keywords": "Coding Options The DUE Link Platform ships with multiple supported languages. Users interested in supporting other languages can convert one of the open-source libraries (such as Python) to their language of choice. Developers have the choice to use any development environment and IDE of choice. Additionally, any modern operating system or language can be used. Some languages are supported out-of-the-box and others can be added. Note This section talks about supported languages running on a host (computer, table, phone...etc.). DUE Platform also includes DUE Script allowing a DUE-enabled hardware to run independently. Open Source Libraries for the supported languages are provided open-source. We invite you to learn more about the internal workings of DUE Link and also invite you to support additional systems and languages. DUE Libraries Repo. The Transport The host connects to a due device using a standard USB connection. All the necessary USB descriptors are built in a standard manner that no drivers are necessary. Once a device is plugged in, the host (computer, phone, Windows, Android, Mac...etc.) will detect and enable a new serial port. The library will then use this serial port to communicate with the DUE-enabled device. On Windows, the device manager can be used to see a list of available serial ports. Troubleshooting The DUE console is the perfect place to connect and verify functionality. The first thing to do when facing any troubles is making sure the device is loaded with the latest firmware. The instructions are found on the device's Hardware page. Next, verify that you have the latest library. Visit the Downloads page to download the latest library."
  },
  "software/coding-options/dotnet.html": {
    "href": "software/coding-options/dotnet.html",
    "title": ".NET",
    "keywords": ".NET The .NET DUE library allows full .NET programs to access physical sensors and actuators. This allows complex .NET programs to do all the heavy lifting and send only the necessary components to control devices. The provided library is implemented in C# but the user can use any .NET system, such as Visual Basic. Setup This page assumes the user is already familiar with .NET C# and there is a development machine that is already setup to build and run .NET programs. No changes are needed there but we are using Microsoft Visual Studio Code as a personal preference. Tip If this is the first time you use your device, start by visiting the Hardware page and load your device with the appropriate firmware. The Console is also a great place to start. Start a new project with a simple line of code to test out the project is running Tip C# Top level statements feature is being utilized. Console.WriteLine(\"Hello, World!\"); Download and install the latest library from NuGet.org. Alternatively, get it from the Downloads page. Blinky! Our first program will blink the on-board LED 20 times, where it comes on for 200ms and then it is off for 800ms. Note We can access which COM port our DUE enable device is connected to by calling the GetConnectionPort() using GHIElectronics.Due; Console.WriteLine(\"Hello DUE!\"); var availablePort = DueController.GetConnectionPort(); var dev = new DueController(availablePort); dev.Led.Set(200, 800, 20); Console.WriteLine(\"Bye DUE!\"); .NET API The provided API mirrors DUE Script Core library. Referencing those APIs is a good place to learn about the available functionality."
  },
  "software/coding-options/excel.html": {
    "href": "software/coding-options/excel.html",
    "title": "Excel",
    "keywords": "Excel DUE Link allows supports many systems, and Microsoft Excel is one the supported options! Yes, you can access devices right from spreadsheets! Combine that with VB macros and you have unlimited options. Setup The access to the device is done though Excel Data Streamer plug-in. Enabling the streamer is simple as it is already built in: Go to File > Options In the Excel Options dialog click Add-ins At the bottom of the dialog in the Manage: drop-down select COM Add-ins and click Go Check the box for Microsoft Data Streamer for Excel You should now see the Data Streamer tab in the Excel ribbon. Connect the correct COM port and you will be presented with 4 new tabs (Data In, Data Out, Settings, and Manifest). Blinky! Our first program will blink the on-board LED 20 times, where it comes on for 200ms and then it is off for 800ms. Go to Settings and change the Data Channels to 1 Go to the Data Out tab and enter the following text right under CH1 column Led(200, 800, 20) The LED should be blinking now. The support for Excel is still in progress. Check back this page for more excitement!"
  },
  "software/coding-options/python.html": {
    "href": "software/coding-options/python.html",
    "title": "Python",
    "keywords": "Python The Python DUE library allows for the use of full standard Python to access physical-computing. Setup This page assumes the user is already familiar with Python and there is a development machine that is already setup to build and run Python programs. No changes are needed there but we are using Microsoft Visual Studio Code as a personal preference. Tip If this is the first time you use your device, start by visiting the Hardware page and load your device with the appropriate firmware. The Console is also a great place to start. Start a new project with a simple line of code to test out the project is running print(\"Hello DUE!\") Go to the Downloads page and download the latest Python library. Install the library on your system using pip install DUE-0.0.1-py3-none-any.whl If you do not have the pyserial already installed, then also run pip install pyserial. Blinky! Our first program will blink the on-board LED 20 times, where it comes on for 200ms and then it is off for 800ms. Note Change the serial COM port number to match your port on the system you are using. from DUE.DUEController import DUEController print(\"Hello DUE!\") dev = DUEController(\"COM27\") # Flash the LED 20 times (on for 200ms and off for 800ms) dev.Led.Set(200,800,20) print(\"Bye DUE!\") Python API The provided API mirrors DUE Script's Core library. Referencing those APIs is a good place to learn about the available functionality and available arguments. Python API DUE Script API Description Analog.Read() ARead() Reads analog pin Analog.Write() AWrite() Reads analog pin Button.Enable() BtnEnable() Sets up a button to be used Button.IsPressed() BtnDown() Detects if button is pressed Button.IsReleased() BtnDown() Detects if button is released Button.Buttons NA Enum button A & B DeviceConfig.IsEdge() Version() Checks for specific hardware DeviceConfig.IsFlea() Version() Checks for specific hardware DeviceConfig.IsPico() Version() Checks for specific hardware DeviceConfig.IsPulse() Version() Checks for specific hardware DeviceConfig.MaxPinIO() NA Returns # available GPIOs DeviceConfig.MaxPinAnalog() NA Returns # available Analog pins Digital.Read() DRead() Reads digital pin Digital.Write() DWrite() Writes to digital pin Display.Clear() LcdClear() Clears the display black or white Display.DrawCircle() LcdDrawCirle() Draws a circle on the display Display.DrawBuffer() LcdStream() Updates the entire display, using stream, with automatic Show() Display.DrawLine() LcdDrawLine() Draws a line on the display Display.DrawText() LcdDrawText() Draws a text on the display Display.DrawTextScale() LcdDrawTextS() Draws scaled text on the display Display.SetPixel() LcdSetPixel() Draws pixel on the display Display.Show() LcdShow() Sends the display buffer Distance() ReadDistance() Used to read distance sensors Frequency() Freq() Hardware generated PWM signal I2c.Write() I2cStream() I2C write, using stream I2c.Read() I2cStream() I2C read, using stream I2c.WriteRead() I2cStream() I2C write/read, using stream Infrared.Enable() IrEnable() Enables pin for IR signal capture Infrared.Read() IrRead() Reads value from IR enabled pin Led.Set() LED() Controls the on-board LED Neo.Clear() NeoClear() Clears all LED's in memory Neo.SetColor() NeoSet() Set's a specific LED to a color Neo.Show() NeoShow() Transfers the internal pattern to LEDs Neo.SetMultiple() NeoStream() Updates all LEDs, using streams, with automatic Show() Led.Set() LED() Controls the on-board LED ServoMoto.Set() ServoSet() Sets servo motor connected to a pin Sound.Play() Sound() Sets buzzer sound on supported hardware Sound.Stop() Sound() Stops buzzer sound on supported hardware Spi.Configuration() SpiCfg() Configures SPI bus Spi.Palette() Palette() Sets the desired color for a palette Spi.Read() SpiByte() Reads SPI byte Spi.Write() SpiByte() Sends SPI byte Spi.Write4bpp() Spi4Bpp() Streams and converts data from 4BPP to 16BPP Spi.WriteRead() SpiStream() Write & Read SPI bytes System.Beep() Beep() Uses any pin to generate a tone System.GetTickMicroseconds() TickUs() Returns system time in microseconds System.GetTickMilliseconds() TickMs() Returns system time in milliseconds System.Reset() Reset() Resets the board Touch.Read() TouchRead() Initialize a pin for touch Uart.BytesToRead() UartCount() How many bytes buffered and ready to read Uart.Enable() UartInit() Initialize UART Uart.Read() UartRead() Read UART data Uart.Write() UartWrite() Write UART data Version() Version() Returns the current DUE firmware version Note For convenience, the Pin Enum includes, ButtonA, ButtonB and Led. For example: dev.Digital.Write(dev.Pin.Led, True) Due Script Control These methods allow developers to control DUE Scripts right from within Python Method Description Script.Execute() Executes the single line of code immediately Script.IsRunning() Checks if DUE Script is running Script.Load() Sends the code to flash Script.New() Clears the program stored in flash Script.Read() Read the program stored in flash This example will load a simple program line by line and then run it. Script.New() Script.Load(\"for x = 1 to 10\") Script.Load(\"DWrite('L',1)\") Script.Load(\"Wait(200)\") Script.Load(\"DWrite('L',0)\") Script.Load(\"Wait(200)\") Script.Load(\"next\") Script.Run(); This is an example to execute a single line(immediate mode). This does not modify the application stored in flash. Script.Execute(\"LED(200,200,10)"
  },
  "software/console.html": {
    "href": "software/console.html",
    "title": "DUE Console",
    "keywords": "DUE Console The DUE Console provides many functionalities. It is a great start to verify the device is functioning properly. It is also a great place to learn about and use DUE Scripts. https://console.duelink.com/"
  },
  "software/downloads.html": {
    "href": "software/downloads.html",
    "title": "DUE Downloads",
    "keywords": "DUE Downloads Firmware SC13 (FEZ Flea, FEZ Pico, BrainPad Pulse) Date Revision Firmware Mar 1, 2023 1.0 DUE-SC13 R1 SC007 (BrainPad Edge) Date Revision Firmware Mar 1, 2023 1.0 DUE Script SC007 R1 Library .NET NuGet Date Revision Package Mar 1, 2023 1.0 DUE-NET Nuget R1 Python Date Revision Package Mar 1, 2023 1.0 DUE-Python R1"
  },
  "software/due-script/corelib/analog.html": {
    "href": "software/due-script/corelib/analog.html",
    "title": "Analog",
    "keywords": "Analog These functions provide access to analog pins. Analog Write AWrite(pin, dutyCycle) - Writes to pin using PWM pin: pin number dutyCycle: 0 to 1000 Note Frequency is fixed to 50hz. @Loop For i=0 to 1000 Step 100 AWrite(0,i) Wait(100) next For i=1000 to 0 Step -100 AWrite(0,i) Wait(100) Next Goto Loop Analog Read ARead(pin) - Read an analog output pin: pin number Returns: The analog value of the pin @Loop For i=0 to 100 x=ARead(0) PrintLn(x) Wait(100) Next Goto Loop"
  },
  "software/due-script/corelib/beep.html": {
    "href": "software/due-script/corelib/beep.html",
    "title": "Beep",
    "keywords": "Beep Beep uses any pin to generate a tone. Beep(pin, frequency, duration) - creates a tone for a specified duration on any pin pin: pin number frequency: The frequecy in Hz, max value is 10KHz duration: The duration of the beep in milliseconds, max value is 1000ms Tip Sound function can be used on device specific hardware like the BrainPad Pulse. You can also access any DUE enabled device that has an on-board buzzer by using pin 100 Beep() function arguement. Beep(0,256,1000) Note This feature is blocking,so the rest of your code will stop until beep is completed."
  },
  "software/due-script/corelib/button.html": {
    "href": "software/due-script/corelib/button.html",
    "title": "Buttons",
    "keywords": "Buttons Buttons as a function are only available using pin 0,1,2,A,or B. Alternatively, DRead() can be used with any pin. BtnEnable(pin, enable) - sets up a button to be used pin: pin number, 'a', or 'b' enable: 1 = enable, 0 = disabled BtnUp(pin) pin: pin number, 'a', or 'b' Returns: 1 after release first time called. If called again returns 0 BtnDown(pin) Returns a value when button is pressed pin: pin number, 'a', or 'b' Returns: 1 if button was pressed and continues to return 1 until the button is released Note 'a' is ASCII a or 97, 'b' is ASCII b or 98. Using 'a', 'A', or 97 yields the same results. Tip The timeout for BtnDown() or BtnUp() is fixed to two seconds. Calling after two seconds from last press or release returns 0. If the button is not enabled also returns 0 BtnEnable('a',1) @Loop x=BtnDown('a') If x=1 PrintLn(\"Button A\") End Goto Loop"
  },
  "software/due-script/corelib/corelib.html": {
    "href": "software/due-script/corelib/corelib.html",
    "title": "Core Library",
    "keywords": "Core Library The core library gives DUE Scripts the necessary API to access hardware. It has other software related libraries as well. These API functions are available from within DUE Scripts and runs host-less. When using a host, a library for that particular library is provided to reflect the DUE Core library. For example, when using Python, the provided Python library includes dev.Led.Set(200,800,20) which mirrors the LED API. API Description Analog Read or Write analog pins Beep Beep using any pin Button Read a button. Similar to Digital read but handles debounce Demo Built-in demos Digital Read or write digital pins Distance Read ultrasonic distance sensor Frequency Generate frequency on a specific pin. This uses hardware PWM internally I2C Access the I2C bus for transferring data Infrared Read and decode IR remote control signal LCD Draw on LCD (device specific) LED Control the on-board LED NeoPixel Control smart color LEDs Servo Control servo motors Sound Generate sounds on the device's speaker (device specific) SPI Access the SPI data bus System Functions Built-in functions Touch Allows for capacitive touch sensing UART Transfer data on the UART serial port"
  },
  "software/due-script/corelib/demo.html": {
    "href": "software/due-script/corelib/demo.html",
    "title": "Demos",
    "keywords": "Demos These are demos that are built-in the DUE software. Demo(\"Help\") Returns a list of the demos available on the device. For example: >Demo(\"Help\") DUE DEMOS --------- led analog Demo(\"led\") @Loop DWrite(18,1) : Wait(250) Dwrite(18,0) : Wait(250) Goto Loop Type Run to launch the demo. This demo flashes the on-board LED. Demo(\"analog\") @Loop For i=0 to 1000 Step 100 AWrite(18, i) : Wait(50) Next For i=1000 to 0 Step -100 AWrite(18, i) : wait(50) Next Goto Loop Type Run to launch the demo. This demo fades the on-board LED in & out."
  },
  "software/due-script/corelib/digital.html": {
    "href": "software/due-script/corelib/digital.html",
    "title": "Digital",
    "keywords": "Digital These functions provide access to digital pins. Digital Read DRead(pin, pull) - Read a digital pin output pin: pin number pull: Sets the internal pull resistors to -> 0=none, 1=up, 2=down Returns: 1 = high or 0 = low Note Pin numbers can also be 'a' or 'b' when reading the on-board buttons. Using 'a', 'A', or 97 yields the same results. x = DRead(2,1) If x = 0 Print(\"low\") Else Print(\"high\") End Digital Write DWrite(pin, state) - Sets a pins digital output pin: pin number state: 1 = high or 0 = low Note Pin numbers can also be 'l' when writing the on-board LED. Using 'l', 'L', or 108 yields the same results. for x = 1 to 10 DWrite('L',1) Wait(200) DWrite('L',0) Wait(200) next Note All DUE enabled hardware's on-board LED is found on pin 100."
  },
  "software/due-script/corelib/distance.html": {
    "href": "software/due-script/corelib/distance.html",
    "title": "Distance Sensor",
    "keywords": "Distance Sensor This function is used when using a distance sensors. ReadDistance(trigger, echo) - uses ultrasonic sonic sensor to read distance. trigger: The pin number that is connected to trigger (pulse) signal echo: The pin number that is connected to echo signal Returns: Distance in centimeters Tip most sensors need 5V to work. @Loop x = Distance(0,1) If x>0 PrintLn(x) End Wait(100) Goto Loop"
  },
  "software/due-script/corelib/frequency.html": {
    "href": "software/due-script/corelib/frequency.html",
    "title": "Frequency",
    "keywords": "Frequency Frequency is fixed to pin 0 Freq(frequency, duration, dutyCycle) - provides an accurate hardware generated PWM signal frequency: frequency in KHz duration: 0 to forever dutyCycle: 0 to 1000 Note Freq() is a non-blocking function, calling Freq() a second time before the duration of the first call is over will end the function despite the duration of first calls argument. @Loop For x=1 to 1000 Freq(x,500,500) Wait(200) Next For x=1000 to 1 step -1 Freq(x,500,500) Wait(200) Next Goto Loop"
  },
  "software/due-script/corelib/i2c.html": {
    "href": "software/due-script/corelib/i2c.html",
    "title": "I2C",
    "keywords": "I2C I2cBytes(address, writeCount, readCount) - Reads and/or writes up to 4 bytes to/from I2C bus. Data is transfered from variables A, B, C, D. The return values (if any) are also stored in the same variables. writeCount: The number of bytes to write readCount: The number of bytes to write # Send 0x55 byte to slave address 0x3D a = 0x55 I2cBytes(0x3D, 1, 0) # Read 2 bytes from slave address 0x2C I2cBytes(0x2C, 0, 2) Print(a) Print(b) # Write 1 byte and read 2 bytes from salve address 0x30 # Note how variable \"a\" is used for write and then read a = 0x55 I2cBytes(0x3D, 1, 2) Print(a) Print(b) Note Streams are not coded directly using DUE Script, see Streams I2cStream(address, writeCount, readCount) - address: address of the I2C device writeCount: readCount: Stream size: The stream starts with PC sending \"writeCount\" of bytes and then the PC must read the \"readCount\". If either count is zero then that step can be skipped. Note On SC13 devices only: The I2C pins are different on BrainPad Pulse vs FEZ boards. PB15 is used to determine how I2C should work. Pay attention to the state of PB15 on power up, Pulse has it pulled up through 10k resistor."
  },
  "software/due-script/corelib/infrared.html": {
    "href": "software/due-script/corelib/infrared.html",
    "title": "Infrared",
    "keywords": "Infrared IR decoder is fixed to pin 2 IrEnable(enable) - enables pin for IR signal capture enable: 1 = enable, 0 = disable IrRead() - reads the value from the IR enabled pin Return: Tracks the past 16 key presses and returns them. -1 if none. Button Return Value power 0 up 1 lightbulb 2 left arrow 4 sound 5 right arrow 6 backward 8 down 9 forward 2 + 12 0 13 - 14 1 16 2 17 3 18 4 19 5 20 6 21 7 22 8 23 9 24 IrEnable(1) @Loop x=IrRead() if x >=0: Println(x):end Wait(1000) goto Loop"
  },
  "software/due-script/corelib/lcd.html": {
    "href": "software/due-script/corelib/lcd.html",
    "title": "LCD",
    "keywords": "LCD These functions are device specific and added to support products with built in displays like the one found on the BrainPad Pulse. LcdShow() Sends the display buffer to the LCD. LcdClear(color) Clears the entire screen to black or white color: 0 = black, 1 = white LcdClear(0) LcdShow() Draw Line LcdLine(color, x1,y1,x2,y2) color: 0 = black, 1 = white x1: Starting x point y1: Starting y point x1: Ending x point y1: Ending y point LcdClear(0) LcdLine(1,0,0,128,64) LcdShow() Set Pixel LcdPixel(color, x, y) color: 0 = black, 1 = white x: x pixel value y: y pixel value LcdClear(0) LcdPixel(1,64,32) LcdShow() Draw Circle LcdCircle(color, x,y,radius) color: 0 = black, 1 = white x: x position of circle's center y: y position of circle's center radius: radius of the circle LcdClear(0) LcdCircle(1,64,32,31) LcdShow() Draw Rectangle LcdRect(color, x1, y1, x2, y2) color: 0 = black, 1 = white x1: Starting x point y1: Starting y point x1: Ending x point y1: Ending y point LcdClear(0) LcdRect(1,10,10,118,54) LcdShow() Draw Scaled Text LcdTextS(\"text\", color, x, y, scaleWidth, scaleHeight) text: String message in double quotes. Str(): is used to convert variables to strings color: 0 = black, 1 = white x: x position y: x position scaleWidth: Width scale multiplier scaleHeight: Width scale multiplier LcdClear(0) LcdTextS(\"Hello\",1,0,0,2,2) LcdShow() Wait(1000) x=100 LcdClear(0) LcdTextS(Str(x),1,0,0,2,2) LcdShow() Tip Scale is multiplier for the pixel in width and height to make the font larger Draw Text LcdText(\"text\", color, x, y) Works exactly the same as LcdText() minus scaling. LcdClear(0) LcdText(\"Hello World\",1,10,10) LcdShow() x=100 LcdClear(0) LcdText(str(x),1,0,0) LcdShow() LCD Stream Stream is used to send the entire LCD update. Note Streams are not coded directly using DUE Script, see Streams LcdStream() Stream Size: The size screen size divided by 8, 128x64/8=1K. The data is organized as 8bit columns going left to right and then wrapping around to the next row. Example code to set a pixel at 10x10 int x=10; int y=10; buffer[(y >> 3) * 128 + x] |= (byte)(1 << (y & 7)); Note LCD Stream automatically calls LcdShow() internally."
  },
  "software/due-script/corelib/led.html": {
    "href": "software/due-script/corelib/led.html",
    "title": "LED",
    "keywords": "LED This function is used to take control of the on-board LED. LED() is non-blocking so it can be used as a status indicator for your programs while they run. LED(high, low, count) high: The duration in milliseconds the LED is on. low: The duration in milliseconds the LED is off. count: The number of times the LED will blink, Tip Setting count to -1 will blink the LED forever, and 0 will turn off the LED. LED(1000,1000,10) Note All DUE enabled hardware's on-board LED can also be accessed directly using the DWrite() function using pin 'L' or 'l', which are ASCII 108. DWrite('L',1)"
  },
  "software/due-script/corelib/neopixel.html": {
    "href": "software/due-script/corelib/neopixel.html",
    "title": "Neopixel",
    "keywords": "Neopixel Neopixel is fixed to pin number 1 NeoClear() - Clears all LEDs (in memory). Needs NeoShow() to see the affect NeoSet(index, red, green, blue) - Sets a specific LED to a color. Needs NeoShow() to see affect index: The LED index where 0 is first one and supporting up to 256 LEDs red, green, blue: Color levels, 0 to 255 NeoShow(count) - All NEO code is held internally until show count: The count of LEDs to update and show This example assumes we have 8 LEDs and will set 8 LEDs to red, increasing the color intensity from 0 to 80. Then it waits one second before it sets the first LED to bright purple! NeoClear() For x = 0 to 8 NeoSet(x,x*10,0,0) Next NeoShow(8) Wait(1000) NeoSet(0,200,0,200) NeoShow(8) NeoStream(count) - Streams data directly to LEDs. Automatically calls NeoShow() internally count: The count of LEDs to stream Stream size: It is \"count\" multiplied by 3, DUE to the fact that each LED needs 3 bytes for colors, ordered in GRB format."
  },
  "software/due-script/corelib/servo.html": {
    "href": "software/due-script/corelib/servo.html",
    "title": "Servo Motor",
    "keywords": "Servo Motor ServoSet(pin, degree) - Sets servo motor connected to pin to a specific position pin: pin number degree: 0 to 180 Tip Many servo motors need 5V to work. @Loop ServoSet(0,0) Wait(1000) ServoSet(0,180) Wait(1000) Goto Loop"
  },
  "software/due-script/corelib/sound.html": {
    "href": "software/due-script/corelib/sound.html",
    "title": "Sounds",
    "keywords": "Sounds This function is device specific and added to support products with built in buzzers like the one found on the BrainPad Pulse. Sound(frequency, duration, volume) frequency: sound frequency in Hz duration: in milliseconds. 0 is always on volume: 0 to 100 Note Sound() uses Freq() which is a non-blocking function. Calling Sound() could end the duration of the previous Sound() despite the set duration inside the argument. See Freq() section for more details. Sound(256,1000,50)"
  },
  "software/due-script/corelib/spi.html": {
    "href": "software/due-script/corelib/spi.html",
    "title": "SPI",
    "keywords": "SPI SpiByte(byte) - sends a byte byte: - value 0 to 255 Return: Read byte value SpiCfg(mode,frequency) mode: - 0 to 3 frequency: - 200 to 20000 (200KHz to 20MHz) # Send 0x55 and read the returned byte into x x = SpiByte(0x55) Note Streams are not coded directly using DUE Script, see Streams SpiStream(writeCount, readCount, cs) - Streams data directly to the SPI device writeCount: The number of bytes to write readCount: The number of bytes to read cs: set to -1 if not needed Stream size: The stream starts with PC sending \"writeCount\" of bytes and then the PC must read the \"readCount\". If either count is zero then that step can be skipped. Spi4Bpp(count) - Streams and converts data from 4BPP to 16BPP count: The count of bytes to be written. Stream size: The \"count\". This special function converts 4BPP incoming data to 16BPP on-the-fly. This is added to speed up the use of SPI color displays, namely ones using ST7735 found on the very common 1.8\" SPI color displays. This allows for faster updates, since each byte sent is 2 pixels. Palette(index, colorValue) - Sets the desired color for a palette. index: Index number of color colorValue: A standard HEX value of the RGB color. This function goes hand-in-hand with Spi4Bpp() function to set the colors that are to be used. Default colors: Index Color Value Color 0 0x000000 Black 1 0xFFFFFF White 2 0xFF0000 Red 3 0x32CD32 Lime 4 0x0000FF Blue 5 0xFFFF00 Yellow 6 0x00FFFF Cyan 7 0xFF00FF Magenta 8 0xC0C0C0 Silver 9 0x808080 Gray 10 0x800000 Maroon 11 0xBAB86C Olive 12 0x00FF00 Green 13 0xA020F0 Purple 14 0x008080 Teal 15 0x000080 Navy"
  },
  "software/due-script/corelib/systemfunctions.html": {
    "href": "software/due-script/corelib/systemfunctions.html",
    "title": "System Functions",
    "keywords": "System Functions Cos(number) - Returns the cosine of the argument Echo(enable) enable: 0 = Enable echo , 1 = Disable echo GetCh() - reads character input, in ASCII format. Return -1 when no character detected GetNum() - reads number input, can be used with IsNAN() to determine if value is a number Print(text) - Prints the value of the argument to the console on the same line text: String or variable PrintLn(text) - Prints the value of the argument to the console then moves to the next line text: String or variable Reset(loader) - Resets the board loader: 0 = system reset, 1 = reset and stay in loader mode Rnd(max) - Generates random number max: maximum value of random number Returns: returns random number between 0 and value of argument max Sin(number) - Returns the sine value of the argument Sqrt(number) - Returns the square root of the argument Tan(number) - Returns the tangent of the argument TickMs() - read system ticks in milliseconds TickUs() - read system ticks microseconds Trunc(number) - Returns the truncated value of the argument Version - Returns the current firmware version of DUE The last character returned in Version is board Board Character Pulse P Edge E Flea F Pico I Wait(duration) - holds program from running duration: duration = milliseconds"
  },
  "software/due-script/corelib/touch.html": {
    "href": "software/due-script/corelib/touch.html",
    "title": "Touch",
    "keywords": "Touch TouchRead(pin) - Initializes the pin for touch pin: pin number @Loop a=TouchRead(0):b=TouchRead(1):c=TouchRead(2) If a>0:PrintLn(\"pin 0\"):End If b>0:PrintLn(\"pin 1\"):End If c>0:PrintLn(\"pin 2\"):End Wait(100) Goto Loop"
  },
  "software/due-script/corelib/uart.html": {
    "href": "software/due-script/corelib/uart.html",
    "title": "UART",
    "keywords": "UART UartInit(baudRate) - Sets the baud rate UART baudRate: Any commonly used standard baud rate UartRead() - Read UART data Returns: A byte read from UART UartWrite(data) - Write UART data data: Data byte to send on UART UartCount() - Count Returns: How many bytes have been buffered and ready to be read"
  },
  "software/due-script/due-script.html": {
    "href": "software/due-script/due-script.html",
    "title": "DUE Script",
    "keywords": "DUE Script DUE Scripts run internally on any DUE-enabled hardware. This allows users to run simple quick command, called immediate mode. Additionally, users can extend the DUE language with additional functionality that can be accessed externally or can be executed onto the device. This is called recording mode. Operating Modes Immediate mode, commands are executed immediately. In Record mode, commands are stored in flash and executed with the run command. Immediate Mode A user will know they are in this mode when their cursor prompt is the > character. All statements are executed as soon as entered. > print(\"Hello World\") Note Immediate Mode is the default mode when device is first connected. Record Mode To enter into Record mode, the user enters the $ character. The character prompt will change to the $ sign until Record mode is exited using the > character. All statements entered are stored directly in flash but not executed until run is entered. Statement Description $ Sets the device in record mode > Exits record mode and returns to direct mode The following statements control the program recorded in flash, but can be used in both Immediate or Record modes. When used in Record mode these special statements execute, but are not added to the program in flash. Statement Description Run Executes the program stored in flash New Erases the program stored in flash List Returns all the code in your program Tip A running program can be terminated by hitting the ESC key, DEL Key, or Backspace Key. > $ $ PrintLn (x) $ PrintLn (y) $ > > x=1:y=2 > Run 1 2 >List PrintLn(x) PrintLn(y) >new Note The DUE Console hides the prompts and automatically switches to the appropriate mode. Script Features DUE Scripts are not case sensitive. Its syntax is very simple and inspired by BASIC coding language. The power of DUE Scripts comes from its simplicity rather than from its feature set. This is a perfect language to teach someone coding. Users that require serious coding should be using the DUE Platform combined with one of the many available coding languages. Still, DUE Scripts can be used to extend those languages, as detailed below. Comments The # character is used to identify a comment. Comments are ignored by the program, text added to help developers understand the code. # This is a comment x=10 Print(x) # This is also a comment Variables DUE Script has a fixed set of 26 variables, one for each letter, assigned to a to z. The only data type used in DUE is float. All variables created are global in nature. To use a variable, simply use x=5.5 Arrays Similarly to variables, arrays are fixed to 26 arrays. They are assigned to letters a to z. DUE Script differentiates between variable a and array a[] when square brackets are used. Arrays are size zero by default and can be sized, or resized using Dim. This is an example that uses both, variables and arrays: Dim a[10] For i=0 to 9:a[i]=i*2:Next For i=0 to 9:PrintLn(a[i]):Next The output will look like: 0 2 4 6 8 10 12 14 16 18 Tip Use Dim a[0] to free up the memory reserved for array a[]. For-Loop For i=1 to 1000 Step 10 PrintLn(i) Next If-Statement If statements must end with the End command. This will only end the If statement and not your program. If x=1 PrintLn(\"one\") Else PrintLn(\"not one\") End Labels Labels are needed to redirect the program. They are used by Goto and when calling a subroutine. A Label is created by using the @ symbol in front of the desired label. Labels are limited to 6 characters. Goto A Goto is useful for repeating tasks indefinitely. $@Loop $ add code here that runs forever $Goto Loop End & Return End terminates the program except when used to close an if statement. Print(\"Hello\") End Print(\"This will not get printed\") Return send the execution back from a called subroutine, see Subroutines below. Subroutine Developers can use subroutines to implement \"soft\" like functions in their code. These subroutines are similar to functions but do not take variables or return values. Tip The built-in API offers true functions and therefore do take arguments and return values. User subroutines are always added in recoding mode and resides in nonvolatile memory. A user subroutine starts with a label and ends with a Return. $@Mine $ add code here $Return The subroutine can then be called by its name followed by (). Mine() Note how a subroutine can be called externally from Immediate Mode. This allows for extending DUE Scripts with new commands that can then later be called from Immediate Mode and in turn be called from a high level language, like Python, when connected to a Host. Tip DUE variables are global and any changes inside subroutines will affect variable values outside those subroutines. Recorded DUE Scripts are executed immediately on power up (the run command is issued internally). If the user doesn't want any of the code to run, they can start the program with the End statement. Combining Commands Multiple commands can be combined on a single line. This is especially useful when using immediate mode where a single line is required. To use multiple command, a : symbol is used. This is an example of a for loop in a single line For i=1 to 1000 Step 10:PrintLn(i):Next"
  },
  "software/due-script/samples/falling-bird.html": {
    "href": "software/due-script/samples/falling-bird.html",
    "title": "Falling Bird Game",
    "keywords": "Falling Bird Game In this example we create 2 different versions of the same game one using a NeoPixel Matrix, and other using the BrainPad Pulse and its on-board screen. NeoPixel Falling Bird This sample creates a simple falling bird type game using a NeoPixel matrix. The object is for the player to move to avoid random obstacles. Hardware: Any device supporting DUE-Script. In this case we're using the BrainPad Pulse with its built-in A button. NeoPixel 16x16 Matrix with zig-zag matrix configuration w=16 # Width of the matrix u=4 # Player X position v=8 # Player Y position t=0 # Player tail Y offset b=15 # Wall X position h=4 # Wall height g=6 # Wall gap BtnEnable('a', 1) # Game loop @loop NeoClear() plyr() wall() coll() NeoShow(256) wait(50) goto loop # Handle the player @plyr if BtnDown('a') if v>0:v=v-1:end t=1 else if v<15:v=v+0.5:end t=-1 end x=u y=trunc(v) pxl() NeoSet(p, 64,0,64) x=x-1 y=y+t pxl() NeoSet(p, 64,0,64) return # Update wall @wall b=b-0.25 if b<=0 b=15 g=4+rnd(2) h=2+rnd(6) end for i=0 to 1 x=trunc(b)+i for y=0 to h pxl() NeoSet(p, 0,64,0) next for y=h+g to 15 pxl() NeoSet(p, 0,64,0) next next return # Check collision @coll i=trunc(b) if i != u && i != u-1 :return:end if v<=h:goto die:end if v>=h+g:goto die:end return # Player died @die for i=0 to 20 x=(u-2)+rnd(4) y=(v-2)+rnd(4) pxl() NeoSet(p, rnd(64),0,0) NeoShow(256) next b=15 return # Formula for index into 16x16 NeoPixel Matrix # p=pxl(x,y) @pxl p = x*w+(x&1)*(w-1)+(1-2*(x&1))*y return Pulse Falling Bird This sample creates a falling bird game just like the NeoPixel version NeoPixel version of the game. The object is for the player to move to avoid random obstacles. Hardware: Brainpad Pulse u=4 # Player X position v=8 # Player Y position t=0 # Player tail Y offset b=31 # Wall X position h=4 # Wall height g=6 # Wall gap BtnEnable('a', 1) # Game loop @loop LcdClear(0) plyr() wall() coll() LcdShow() goto loop # Handle the player @plyr if BtnDown('a') if v>0:v=v-1:end t=1 else if v<15:v=v+0.5:end t=-1 end x=u y=trunc(v) pxl() x=x-1 y=y+t pxl() return # Update wall @wall b=b-0.5 if b<=0 b=31 g=4+rnd(2) h=2+rnd(6) end x=trunc(b) for y=0 to h pxl() next for y=h+g to 15 pxl() next return # Check collision @coll i=trunc(b) if i != u:return:end if v<=h:goto die:end if v>=h+g:goto die:end return # Player died @die for i=0 to 20 x=(u-2)+rnd(4) y=(v-2)+rnd(4) pxl() LcdShow() next b=31 return # Plot large pixel # p=pxl(x,y) @pxl #for i=0 to 2: for j=0 to 3:LcdPixel(1, x*4+j, y*3+i):next:next LcdPixel(1, x*4, y*3) LcdPixel(1, x*4+1, y*3) LcdPixel(1, x*4+2, y*3) LcdPixel(1, x*4+3, y*3) LcdPixel(1, x*4, y*3+1) LcdPixel(1, x*4+1, y*3+1) LcdPixel(1, x*4+2, y*3+1) LcdPixel(1, x*4+3, y*3+1) LcdPixel(1, x*4, y*3+2) LcdPixel(1, x*4+1, y*3+2) LcdPixel(1, x*4+2, y*3+2) LcdPixel(1, x*4+3, y*3+2) return"
  },
  "software/due-script/samples/neopixel-matrix.html": {
    "href": "software/due-script/samples/neopixel-matrix.html",
    "title": "NeoPixel 16x16 Matrix",
    "keywords": "NeoPixel 16x16 Matrix These samples uses NeoPixel. NeoPixel is an addressable LED that actually contains 3 LEDs, RED, GREEN, and BLUE. These three LEDs combine to make just about any color. NeoPixel come in many different configurations, from 1 single NeoPixel to panels containing many. DUE allows for up to 256 NeoPixel. This is perfect for a 16x16 setup. Hardware: Any device supporting DUE-Script NeoPixel 16x16 Matrix with zig-zag matrix configuration Set-up: Connecting the panel is easy, we just need to connect three wires POWER, GND, and DATA to control all the LEDs. On the back of most NEOPixel panels are 3 sets of cables connected to the panel. OUT: connector is used to connect panels together. POWER: is used to connect 5V external power source to the panel. This is often necessary when using many LEDs. IN: connector is where we connect our hardware to the NeoPixel. We connect PIN 1 DUE enabled hardware to the wire labeled DIN, in this case the wire is the green wire. Add a picture frame: We took 2 5x7\" picture frames and connected the longer ends together to make a picture frame to hold our NeoPixel. We even used the back of the picture frames as a built-in stand. Sine wave This sample shows a sine wave scrolling along the matrix # NeoPixel - Moving sine wave h=16:w=16 z=3.1415926/6 i=0 @loop NeoClear() for x=0 to 15 y = 8+sin((x+i)*z)*6 pxl() NeoSet(p,0,128,0) next NeoShow(256) i=i+1 goto loop # Formula for index into 16x16 NeoPixel Matrix # p=pxl(x,y) @pxl p = x*w+(x&1)*(w-1)+(1-2*(x&1))*y return Colorful sine wave This sample shows a colorful sine wave scrolling along the matrix # NeoPixel - Colorful Moving sine wave h=16:w=16 i=0 z=3.1415926/6 @loop NeoClear() for x=0 to 15 d = x+i y = 8+sin(d*z)*6 pxl() NeoSet(p,128,0,0) y = 8+sin((d+1)*z)*6 pxl() NeoSet(p,0,128,0) y = 8+sin((d+2)*z)*6 pxl() NeoSet(p,0,0,128) next NeoShow(256) i=i+1 goto loop # Formula for index into 16x16 NeoPixel Matrix # p=pxl(x,y) @pxl p = x*w+(x&1)*(w-1)+(1-2*(x&1))*y return Rainbow This sample shows a colorful rainbow # NeoPixel - Rainbow h=16:w=16 z=3.1415926/15 NeoClear() for x=0 to 15 for i=4 to 8 y = i+sin(x*z)*6 pxl() if i%5=0:NeoSet(p,0,0,128):end if i%5=1:NeoSet(p,0,128,0):end if i%5=2:NeoSet(p,0,128,128):end if i%5=3:NeoSet(p,128,0,0):end if i%5=4:NeoSet(p,128,0,128):end next next neoshow(256) exit # Formula for index into 16x16 NeoPixel Matrix # p=pxl(x,y) @pxl p = x*w+(x&1)*(w-1)+(1-2*(x&1))*y return"
  },
  "software/due-script/samples/pulse-analogclock.html": {
    "href": "software/due-script/samples/pulse-analogclock.html",
    "title": "Pulse Analog Clock",
    "keywords": "Pulse Analog Clock This advanced sample turns your Brainpad Pulse into an analog clock Hardware: Brainpad Pulse BrainPower (Optional) This example demonstrates advanced features of the DUE-Script language. Using arrays to store X,Y coordinates Using variable as both arrays and numbers (very advanced feature to save variables) # Pulse - LCD Clock # Arrays to store the X and Y coordinates of each hand of the clock # Index 0 - X # Index 1 - Y dim h[2] dim m[2] dim s[2] # Numeric variables storing the current value for each of the hands h=5 m=0 s=0 p=3.1415926 @loop LCDClear(0) face() time() LCDShow() Wait(1000) goto loop # Draw the clock face @face # Draw the small dot on the clock face for i=0 to 59 m[0]=25*cos(i*p/30):m[1]=25*sin(i*p/30) LCDPixel(1,64+m[0],32+m[1]) next # Draw the large dots for every hour for i=0 to 11 m[0]=25*cos(i*p/6):m[1]=25*sin(i*p/6) LCDCircle(1,64+m[0],32+m[1],2) next return # Calculate and draw the new hand positions @time h[0]=16*cos(h*p/6):h[1]=16*sin(h*p/6) m[0]=20*cos(m*p/30):m[1]=20*sin(m*p/30) s[0]=25*cos(s*p/30):s[1]=25*sin(s*p/30) if s=60:s=0:m=m+1:end if m=60:m=0:h=h+1:end if h=12:h=0:end s=s+1 LCDLine(1,64,32,64+h[0],32+h[1]) LCDLine(1,64,32,64+m[0],32+m[1]) LCDLine(1,64,32,64+s[0],32+s[1]) return"
  },
  "software/due-script/samples/pulse-bouncingball.html": {
    "href": "software/due-script/samples/pulse-bouncingball.html",
    "title": "Pulse Bouncing Ball",
    "keywords": "Pulse Bouncing Ball This sample bounces a ball of the 4 edges of the screen Hardware: Brainpad Pulse # Pulse - LCD Bouncing ball x=64 # Ball X location y=32 # Ball Y location r=5 # Ball radius a=3 # Ball X Speed b=2 # Ball Y Speed @loop LCDClear(0) # Clear the screen LCDCircle(1,x,y,r) # Draw the ball LCDShow() # Update the screen x=x+a:y=y+b # Move the ball # Check if the ball hit one of the edges # if it did then reverse the direction and make a sound if x<r || x>=(128-r):a=-a:sound(100,16,100):end if y<r || y>=(64-r):b=-b:sound(100,16,100):end goto loop"
  },
  "software/due-script/samples/pulse-falling-bird.html": {
    "href": "software/due-script/samples/pulse-falling-bird.html",
    "title": "Pulse Flappy Birds",
    "keywords": "Pulse Flappy Birds This sample creates a falling bird game just like the NeoPixel version NeoPixel version of the game. The object is for the player to move to avoid random obstacles. Hardware: Brainpad Pulse u=4 # Player X position v=8 # Player Y position t=0 # Player tail Y offset b=31 # Wall X position h=4 # Wall height g=6 # Wall gap BtnEnable('a', 1) # Game loop @loop LcdClear(0) plyr() wall() coll() LcdShow() goto loop # Handle the player @plyr if BtnDown('a') if v>0:v=v-1:end t=1 else if v<15:v=v+0.5:end t=-1 end x=u y=trunc(v) pxl() x=x-1 y=y+t pxl() return # Update wall @wall b=b-0.5 if b<=0 b=31 g=4+rnd(2) h=2+rnd(6) end x=trunc(b) for y=0 to h pxl() next for y=h+g to 15 pxl() next return # Check collision @coll i=trunc(b) if i != u:return:end if v<=h:goto die:end if v>=h+g:goto die:end return # Player died @die for i=0 to 20 x=(u-2)+rnd(4) y=(v-2)+rnd(4) pxl() LcdShow() next b=31 return # Plot large pixel # p=pxl(x,y) @pxl for k=0 to 2:for j=0 to 3:LcdPixel(1, x*4+j, y*3+k):next:next return"
  },
  "software/due-script/samples/pulse-gamer-sketch.html": {
    "href": "software/due-script/samples/pulse-gamer-sketch.html",
    "title": "BrainGamer - Sketch",
    "keywords": "BrainGamer - Sketch Pair your Pulse with the Brain Gamer to create a piece of art Hardware: Brainpad Pulse BrainGamer This example demonstrates the use of both digital and analog inputs. Pin# Rocker X 4 Rocker Y 5 Up 14 Down 15 Left 13 Right 16 # BrainGamer - Sketch init() @loop # Gamer Btn-X - Clear the image if dread(13, 1)=0 init() end # Draw the pixel LCDPixel(1,x,y) LCDShow() # Read the joystick u=aread(4) # Joystick-X v=aread(3) # Joystick-Y # Move the pen based on the joystick position if u<45:x=x+1:end if u>55:x=x-1:end if v<45:y=y-1:end if v>55:y=y+1:end # Wrap around the screen edges if x>127:x=0:end if x<0:x=127:end if y>63:y=0:end if y<0:y=63:end goto loop # Initialize the scetcher @init x=64 y=32 LCDClear(0) return"
  },
  "software/due-script/samples/rotary-neopixel.html": {
    "href": "software/due-script/samples/rotary-neopixel.html",
    "title": "Grove Modules",
    "keywords": "Grove Modules Rotary Module This sample uses a Grove rotary module to control a NeoPixel Ring. This sample uses Analog & Neopixel. Hardware: FEZ Flea Grove XIAO Shield Grove Rotary Angle Sensor NeoPixel Ring Software: @loop NeoClear() NeoShow(24) a=ARead(6) NeoSet(a/4,255,0,0) NeoShow(24) Wait(50) goto loop"
  },
  "software/due-script/samples/samples.html": {
    "href": "software/due-script/samples/samples.html",
    "title": "Samples",
    "keywords": "Samples Here you'll find complete programs that take advantage of the DUE platform. Sample Use NeoPixel Matrix Several examples utilizing a 16x16 LED matrix NeoPixel Rotary Sample using Grove Rotary Module & NeoPixel Ring Falling Bird Game Falling Bird Game 16x16 LED matrix & BrainPad Pulse Pulse Analog Clock Analog Clock using the BrainPad Pulse Pulse Bouncing Ball Example that bouces ball on BrainPad Pulse screen BrainGamer Sketch Create your own art with BrainGamer and BrainPad Pulse"
  },
  "software/due-script/streams.html": {
    "href": "software/due-script/streams.html",
    "title": "Streams",
    "keywords": "Streams DUE Link APIs are built to be ASCII human-friendly. This works great when using DUE Script. However, there are instances where speed or raw binary data is required. For example, when updating a display using I2C. This is where streams come in handy. Provided libraries, such as Python, use streams internally whenever possible. A stream command initiates the request, such as LcdStream(). Once this command is received and accepted by the device, the & symbol will be returned indicating readiness. The host can now send the entire data, exactly to the required byte count. See the individual stream command for details on what data count and structure to be sent. Streams in DUE Script Streams are not used when coding DUE Script directly. They are utilized by the provided libraries, when used in hosted mode."
  },
  "software/intro.html": {
    "href": "software/intro.html",
    "title": "DUE Link",
    "keywords": "DUE Link A DUE Link enabled device can give a computer, tablet or phone access to the physical world. Not only that, the DUE Link platform includes DUE Scripts for extending the device's feature or even run independently from any additional hardware. Host Mode Though a standard USB connection, a DUE-enabled device can be connected to modern devices, such as phones, laptops, tablets, desktops and even smaller devices such as raspberry pi. The device will simply load, with no need to load any USB drivers. This is true on Windows, Mac, Linux, Android and even Chrome OS. Once effortlessly connected, developers can use the coding environment of choice to access a long list of available inputs and outputs. This includes, but not limited to, Analog, Digital, PWM, I2C, and SPI. Several coding languages are officially supported , with provided libraries and sample code; however, any other language can theoretically be supported using our open-source DUE libraries. See all of the Coding Options. DUE Scripts The DUE Link platform includes DUE Scripts allowing for further expandability. Additionally, these scripts allows the system to run independently from any host. Learn more about DUE Script."
  },
  "software/legal.html": {
    "href": "software/legal.html",
    "title": "Legal",
    "keywords": "Legal License This product with its accompanying firmware is licensed royalty-free for commercial and noncommercial use. Using the provided firmware on any non-official product requires additional licensing. The provided documentation/schematics/libraries/sources are not to be used in any manner outside of implementing and using this GHI Electronics product in your design. Disclaimer IN NO EVENT SHALL GHI ELECTRONICS, LLC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS PRODUCT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. GHI ELECTRONICS LINE OF PRODUCTS ARE NOT DESIGNED FOR LIFE SUPPORT APPLICATIONS. SPECIFICATIONS, PRICE AND AVAILABILITY ARE SUBJECT TO CHANGE WITHOUT ANY NOTICE. Security WE DO OUR BEST TO PROVIDE SECURE PRODUCTS THAT PROTECT YOUR INTELLECTUAL PROPERTY (CODE) AND ARE DIFFICULT TO EXPLOIT. HOWEVER, NO PRODUCT IS COMPLETELY SECURE. THERE ARE DISHONEST AND POSSIBLY ILLEGAL METHODS THAT CAN BE USED TO CIRCUMVENT OUR CODE PROTECTION AND SECURITY FEATURES. GHI ELECTRONICS, LLC SHALL IN NO EVENT BE HELD LIABLE IN ANY WAY FOR THE EXPLOITATION OF SECURITY VULNERABILITIES OR ANY USE OR MISUSE OF OUR PRODUCTS RESULTING IN THE LOSS OR THEFT OF CODE OR OTHER INTELLECTUAL PROPERTY. Product Longevity GHI ELECTRONICS, LLC IS PRIMARILY INVOLVED IN PROVIDING ELECTRONIC COMPONENTS, MODULES, AND ACCOMPANYING SOFTWARE THAT ARE USED BY OUR CUSTOMERS TO CREATE NEW AND INNOVATIVE PRODUCTS. IN SUPPORT OF OUR CUSTOMERS, WE DO OUR BEST TO DESIGN AND MANUFACTURE PRODUCTS WITH THE LONGEST LIFE CYCLE POSSIBLE. HOWEVER, OUR PRODUCT AVAILABILITY IS DEPENDENT UPON THE AVAILABILITY OF THE ELECTRONIC COMPONENTS FROM WHICH OUR PRODUCTS ARE BUILT. GHI ELECTRONICS, LLC WILL IN NO WAY BE HELD LIABLE FOR LOSSES OF ANY KIND, INCURRED BY OUR CUSTOMERS OR OTHERS, WHETHER MONETARY OR OTHERWISE, AS A RESULT OF GHI ELECTRONICS' PRODUCT SHORTAGES, DELAYS IN AVAILABILITY, OR DISCONTINUATION."
  }
}