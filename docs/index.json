{
  "README.html": {
    "href": "README.html",
    "title": "Documentation",
    "keywords": "Documentation This is the repository for all of our docs. To generate the docs locally: Clone/Fork the repo Open the command prompt in the documents' root folder (\"Run as Administrator\" may be necessary) Execute docfx --serve After executing the above command, a temporary webpage will appear to allow you to view the files in your browser fully rendered in HTML, for example http://localhost:8080. To install DocFX, please review and download from the following site: https://dotnet.github.io/docfx/. From there, you can go to the Getting Started page for instructions on how to install and you can go to Download Latest to download the most up to date DocFX files. Please note, you will not need to use the docfx init command as the initial JSON file is already present in our repository. WK<html>TOpdf is an optional part of the build process. You will find the needed files at the following address: https://wkhtmltopdf.org/downloads.html. Once downloaded, execute the command to install. Once installed, add the path to the installed binary to the environment variable PATH, for example \"C:\\Program Files\\wkhtmltopdf\\bin\"."
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Adc.Pin.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Adc.Pin.html",
    "title": "Class EPM815.Adc.Pin",
    "keywords": "Class EPM815.Adc.Pin Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public static class EPM815.Adc.Pin Inheritance object EPM815.Adc.Pin Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields ANA0 Adc pin. public const int ANA0 = 65535 Field Value int ANA1 public const int ANA1 = 131071 Field Value int PA0 public const int PA0 = 1048576 Field Value int PA3 public const int PA3 = 983043 Field Value int PA4 public const int PA4 = 1179652 Field Value int PA5 public const int PA5 = 1245189 Field Value int PA6 public const int PA6 = 196614 Field Value int PB0 public const int PB0 = 589840 Field Value int PC0 public const int PC0 = 655392 Field Value int PC3 public const int PC3 = 852003 Field Value int PF11 public const int PF11 = 131163 Field Value int PF12 public const int PF12 = 393308 Field Value int PF13 public const int PF13 = 16908381 Field Value int PF14 public const int PF14 = 17170526 Field Value int"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Adc.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Adc.html",
    "title": "Class EPM815.Adc",
    "keywords": "Class EPM815.Adc Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public static class EPM815.Adc Inheritance object EPM815.Adc Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Can.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Can.html",
    "title": "Class EPM815.Can",
    "keywords": "Class EPM815.Can Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public static class EPM815.Can Inheritance object EPM815.Can Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields Can1 Can controller. public const int Can1 = 1 Field Value int Can2 public const int Can2 = 2 Field Value int"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Dac.Pin.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Dac.Pin.html",
    "title": "Class EPM815.Dac.Pin",
    "keywords": "Class EPM815.Dac.Pin Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public static class EPM815.Dac.Pin Inheritance object EPM815.Dac.Pin Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields PA5 Adc pin. public const int PA5 = 5 Field Value int"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Dac.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Dac.html",
    "title": "Class EPM815.Dac",
    "keywords": "Class EPM815.Dac Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public static class EPM815.Dac Inheritance object EPM815.Dac Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Gpio.Alternate.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Gpio.Alternate.html",
    "title": "Enum EPM815.Gpio.Alternate",
    "keywords": "Enum EPM815.Gpio.Alternate Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public enum EPM815.Gpio.Alternate Fields AF0 = 0 AF1 = 1 AF10 = 10 AF11 = 11 AF12 = 12 AF13 = 13 AF14 = 14 AF15 = 15 AF2 = 2 AF3 = 3 AF4 = 4 AF5 = 5 AF6 = 6 AF7 = 7 AF8 = 8 AF9 = 9 NONE = -1"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Gpio.Edge.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Gpio.Edge.html",
    "title": "Enum EPM815.Gpio.Edge",
    "keywords": "Enum EPM815.Gpio.Edge Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public enum EPM815.Gpio.Edge Fields Falling = 2 Rising = 1"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Gpio.Moder.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Gpio.Moder.html",
    "title": "Enum EPM815.Gpio.Moder",
    "keywords": "Enum EPM815.Gpio.Moder Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public enum EPM815.Gpio.Moder Fields Alternate = 2 Analog = 3 Input = 0 NONE = -1 Output = 1"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Gpio.OutputType.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Gpio.OutputType.html",
    "title": "Enum EPM815.Gpio.OutputType",
    "keywords": "Enum EPM815.Gpio.OutputType Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public enum EPM815.Gpio.OutputType Fields OpenDrain = 1 PushPull = 0"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Gpio.Pin.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Gpio.Pin.html",
    "title": "Class EPM815.Gpio.Pin",
    "keywords": "Class EPM815.Gpio.Pin Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public static class EPM815.Gpio.Pin Inheritance object EPM815.Gpio.Pin Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields NONE GPIO pin. public const int NONE = -1 Field Value int PA0 GPIO pin definitions. public const int PA0 = 0 Field Value int PA1 GPIO pin. public const int PA1 = 1 Field Value int PA10 GPIO pin. public const int PA10 = 10 Field Value int PA11 GPIO pin. public const int PA11 = 11 Field Value int PA12 GPIO pin. public const int PA12 = 12 Field Value int PA13 GPIO pin. public const int PA13 = 13 Field Value int PA14 GPIO pin. public const int PA14 = 14 Field Value int PA15 GPIO pin. public const int PA15 = 15 Field Value int PA2 GPIO pin. public const int PA2 = 2 Field Value int PA3 GPIO pin. public const int PA3 = 3 Field Value int PA4 GPIO pin. public const int PA4 = 4 Field Value int PA5 GPIO pin. public const int PA5 = 5 Field Value int PA6 GPIO pin. public const int PA6 = 6 Field Value int PA7 GPIO pin. public const int PA7 = 7 Field Value int PA8 GPIO pin. public const int PA8 = 8 Field Value int PA9 GPIO pin. public const int PA9 = 9 Field Value int PB0 GPIO pin. public const int PB0 = 16 Field Value int PB1 GPIO pin. public const int PB1 = 17 Field Value int PB10 GPIO pin. public const int PB10 = 26 Field Value int PB11 GPIO pin. public const int PB11 = 27 Field Value int PB12 GPIO pin. public const int PB12 = 28 Field Value int PB13 GPIO pin. public const int PB13 = 29 Field Value int PB14 GPIO pin. public const int PB14 = 30 Field Value int PB15 GPIO pin. public const int PB15 = 31 Field Value int PB2 GPIO pin. public const int PB2 = 18 Field Value int PB3 GPIO pin. public const int PB3 = 19 Field Value int PB4 GPIO pin. public const int PB4 = 20 Field Value int PB5 GPIO pin. public const int PB5 = 21 Field Value int PB6 GPIO pin. public const int PB6 = 22 Field Value int PB7 GPIO pin. public const int PB7 = 23 Field Value int PB8 GPIO pin. public const int PB8 = 24 Field Value int PB9 GPIO pin. public const int PB9 = 25 Field Value int PC0 GPIO pin. public const int PC0 = 32 Field Value int PC1 GPIO pin. public const int PC1 = 33 Field Value int PC10 GPIO pin. public const int PC10 = 42 Field Value int PC11 GPIO pin. public const int PC11 = 43 Field Value int PC12 GPIO pin. public const int PC12 = 44 Field Value int PC13 GPIO pin. public const int PC13 = 45 Field Value int PC14 GPIO pin. public const int PC14 = 46 Field Value int PC15 GPIO pin. public const int PC15 = 47 Field Value int PC2 GPIO pin. public const int PC2 = 34 Field Value int PC3 GPIO pin. public const int PC3 = 35 Field Value int PC4 GPIO pin. public const int PC4 = 36 Field Value int PC5 GPIO pin. public const int PC5 = 37 Field Value int PC6 GPIO pin. public const int PC6 = 38 Field Value int PC7 GPIO pin. public const int PC7 = 39 Field Value int PC8 GPIO pin. public const int PC8 = 40 Field Value int PC9 GPIO pin. public const int PC9 = 41 Field Value int PD0 GPIO pin. public const int PD0 = 48 Field Value int PD1 GPIO pin. public const int PD1 = 49 Field Value int PD10 GPIO pin. public const int PD10 = 58 Field Value int PD11 GPIO pin. public const int PD11 = 59 Field Value int PD12 GPIO pin. public const int PD12 = 60 Field Value int PD13 GPIO pin. public const int PD13 = 61 Field Value int PD14 GPIO pin. public const int PD14 = 62 Field Value int PD15 GPIO pin. public const int PD15 = 63 Field Value int PD2 GPIO pin. public const int PD2 = 50 Field Value int PD3 GPIO pin. public const int PD3 = 51 Field Value int PD4 GPIO pin. public const int PD4 = 52 Field Value int PD5 GPIO pin. public const int PD5 = 53 Field Value int PD6 GPIO pin. public const int PD6 = 54 Field Value int PD7 GPIO pin. public const int PD7 = 55 Field Value int PD8 GPIO pin. public const int PD8 = 56 Field Value int PD9 GPIO pin. public const int PD9 = 57 Field Value int PE0 GPIO pin. public const int PE0 = 64 Field Value int PE1 GPIO pin. public const int PE1 = 65 Field Value int PE10 GPIO pin. public const int PE10 = 74 Field Value int PE11 GPIO pin. public const int PE11 = 75 Field Value int PE12 GPIO pin. public const int PE12 = 76 Field Value int PE13 GPIO pin. public const int PE13 = 77 Field Value int PE14 GPIO pin. public const int PE14 = 78 Field Value int PE15 GPIO pin. public const int PE15 = 79 Field Value int PE2 GPIO pin. public const int PE2 = 66 Field Value int PE3 GPIO pin. public const int PE3 = 67 Field Value int PE4 GPIO pin. public const int PE4 = 68 Field Value int PE5 GPIO pin. public const int PE5 = 69 Field Value int PE6 GPIO pin. public const int PE6 = 70 Field Value int PE7 GPIO pin. public const int PE7 = 71 Field Value int PE8 GPIO pin. public const int PE8 = 72 Field Value int PE9 GPIO pin. public const int PE9 = 73 Field Value int PF0 GPIO pin. public const int PF0 = 80 Field Value int PF1 GPIO pin. public const int PF1 = 81 Field Value int PF10 GPIO pin. public const int PF10 = 90 Field Value int PF11 GPIO pin. public const int PF11 = 91 Field Value int PF12 GPIO pin. public const int PF12 = 92 Field Value int PF13 GPIO pin. public const int PF13 = 93 Field Value int PF14 GPIO pin. public const int PF14 = 94 Field Value int PF15 GPIO pin. public const int PF15 = 95 Field Value int PF2 GPIO pin. public const int PF2 = 82 Field Value int PF3 GPIO pin. public const int PF3 = 83 Field Value int PF4 GPIO pin. public const int PF4 = 84 Field Value int PF5 GPIO pin. public const int PF5 = 85 Field Value int PF6 GPIO pin. public const int PF6 = 86 Field Value int PF7 GPIO pin. public const int PF7 = 87 Field Value int PF8 GPIO pin. public const int PF8 = 88 Field Value int PF9 GPIO pin. public const int PF9 = 89 Field Value int PG0 GPIO pin. public const int PG0 = 96 Field Value int PG1 GPIO pin. public const int PG1 = 97 Field Value int PG10 GPIO pin. public const int PG10 = 106 Field Value int PG11 GPIO pin. public const int PG11 = 107 Field Value int PG12 GPIO pin. public const int PG12 = 108 Field Value int PG13 GPIO pin. public const int PG13 = 109 Field Value int PG14 GPIO pin. public const int PG14 = 110 Field Value int PG15 GPIO pin. public const int PG15 = 111 Field Value int PG2 GPIO pin. public const int PG2 = 98 Field Value int PG3 GPIO pin. public const int PG3 = 99 Field Value int PG4 GPIO pin. public const int PG4 = 100 Field Value int PG5 GPIO pin. public const int PG5 = 101 Field Value int PG6 GPIO pin. public const int PG6 = 102 Field Value int PG7 GPIO pin. public const int PG7 = 103 Field Value int PG8 GPIO pin. public const int PG8 = 104 Field Value int PG9 GPIO pin. public const int PG9 = 105 Field Value int PH0 GPIO pin. public const int PH0 = 112 Field Value int PH1 GPIO pin. public const int PH1 = 113 Field Value int PH10 GPIO pin. public const int PH10 = 122 Field Value int PH11 GPIO pin. public const int PH11 = 123 Field Value int PH12 GPIO pin. public const int PH12 = 124 Field Value int PH13 GPIO pin. public const int PH13 = 125 Field Value int PH14 GPIO pin. public const int PH14 = 126 Field Value int PH15 GPIO pin. public const int PH15 = 127 Field Value int PH2 GPIO pin. public const int PH2 = 114 Field Value int PH3 GPIO pin. public const int PH3 = 115 Field Value int PH4 GPIO pin. public const int PH4 = 116 Field Value int PH5 GPIO pin. public const int PH5 = 117 Field Value int PH6 GPIO pin. public const int PH6 = 118 Field Value int PH7 GPIO pin. public const int PH7 = 119 Field Value int PH8 GPIO pin. public const int PH8 = 120 Field Value int PH9 GPIO pin. public const int PH9 = 121 Field Value int PI0 GPIO pin. public const int PI0 = 128 Field Value int PI1 GPIO pin. public const int PI1 = 129 Field Value int PI10 GPIO pin. public const int PI10 = 138 Field Value int PI11 GPIO pin. public const int PI11 = 139 Field Value int PI12 GPIO pin. public const int PI12 = 140 Field Value int PI13 GPIO pin. public const int PI13 = 141 Field Value int PI14 GPIO pin. public const int PI14 = 142 Field Value int PI15 GPIO pin. public const int PI15 = 143 Field Value int PI2 GPIO pin. public const int PI2 = 130 Field Value int PI3 GPIO pin. public const int PI3 = 131 Field Value int PI4 GPIO pin. public const int PI4 = 132 Field Value int PI5 GPIO pin. public const int PI5 = 133 Field Value int PI6 GPIO pin. public const int PI6 = 134 Field Value int PI7 GPIO pin. public const int PI7 = 135 Field Value int PI8 GPIO pin. public const int PI8 = 136 Field Value int PI9 GPIO pin. public const int PI9 = 137 Field Value int PJ0 GPIO pin. public const int PJ0 = 144 Field Value int PJ1 GPIO pin. public const int PJ1 = 145 Field Value int PJ10 GPIO pin. public const int PJ10 = 154 Field Value int PJ11 GPIO pin. public const int PJ11 = 155 Field Value int PJ12 GPIO pin. public const int PJ12 = 156 Field Value int PJ13 GPIO pin. public const int PJ13 = 157 Field Value int PJ14 GPIO pin. public const int PJ14 = 158 Field Value int PJ15 GPIO pin. public const int PJ15 = 159 Field Value int PJ2 GPIO pin. public const int PJ2 = 146 Field Value int PJ3 GPIO pin. public const int PJ3 = 147 Field Value int PJ4 GPIO pin. public const int PJ4 = 148 Field Value int PJ5 GPIO pin. public const int PJ5 = 149 Field Value int PJ6 GPIO pin. public const int PJ6 = 150 Field Value int PJ7 GPIO pin. public const int PJ7 = 151 Field Value int PJ8 GPIO pin. public const int PJ8 = 152 Field Value int PJ9 GPIO pin. public const int PJ9 = 153 Field Value int PK0 GPIO pin. public const int PK0 = 160 Field Value int PK1 GPIO pin. public const int PK1 = 161 Field Value int PK10 GPIO pin. public const int PK10 = 170 Field Value int PK11 GPIO pin. public const int PK11 = 171 Field Value int PK12 GPIO pin. public const int PK12 = 172 Field Value int PK13 GPIO pin. public const int PK13 = 173 Field Value int PK14 GPIO pin. public const int PK14 = 174 Field Value int PK15 GPIO pin. public const int PK15 = 175 Field Value int PK2 GPIO pin. public const int PK2 = 162 Field Value int PK3 GPIO pin. public const int PK3 = 163 Field Value int PK4 GPIO pin. public const int PK4 = 164 Field Value int PK5 GPIO pin. public const int PK5 = 165 Field Value int PK6 GPIO pin. public const int PK6 = 166 Field Value int PK7 GPIO pin. public const int PK7 = 167 Field Value int PK8 GPIO pin. public const int PK8 = 168 Field Value int PK9 GPIO pin. public const int PK9 = 169 Field Value int PZ0 GPIO pin. public const int PZ0 = 144 Field Value int PZ1 GPIO pin. public const int PZ1 = 145 Field Value int PZ2 GPIO pin. public const int PZ2 = 146 Field Value int PZ3 GPIO pin. public const int PZ3 = 147 Field Value int PZ4 GPIO pin. public const int PZ4 = 148 Field Value int PZ5 GPIO pin. public const int PZ5 = 149 Field Value int PZ6 GPIO pin. public const int PZ6 = 150 Field Value int PZ7 GPIO pin. public const int PZ7 = 151 Field Value int"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Gpio.Port.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Gpio.Port.html",
    "title": "Enum EPM815.Gpio.Port",
    "keywords": "Enum EPM815.Gpio.Port Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public enum EPM815.Gpio.Port : uint Fields A = 0 B = 1 C = 2 D = 3 E = 4 F = 5 G = 6 H = 7 I = 8 Z = 9"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Gpio.Pull.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Gpio.Pull.html",
    "title": "Enum EPM815.Gpio.Pull",
    "keywords": "Enum EPM815.Gpio.Pull Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public enum EPM815.Gpio.Pull Fields Down = 2 None = 0 Up = 1"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Gpio.Speed.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Gpio.Speed.html",
    "title": "Enum EPM815.Gpio.Speed",
    "keywords": "Enum EPM815.Gpio.Speed Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public enum EPM815.Gpio.Speed Fields High = 2 Low = 0 Medium = 1 VeryHigh = 3"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Gpio.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Gpio.html",
    "title": "Class EPM815.Gpio",
    "keywords": "Class EPM815.Gpio Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public static class EPM815.Gpio Inheritance object EPM815.Gpio Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetPin(int) public static int GetPin(int pin) Parameters pin int Returns int GetPort(int) public static int GetPort(int pin) Parameters pin int Returns int IsPinReserved(int) public static bool IsPinReserved(int pin) Parameters pin int Returns bool PinRelease(int) public static void PinRelease(int pin) Parameters pin int PinReserve(int) public static void PinReserve(int pin) Parameters pin int SetAlternate(int, Alternate) public static void SetAlternate(int pin_id, EPM815.Gpio.Alternate alt) Parameters pin_id int alt EPM815.Gpio.Alternate SetModer(int, Moder) public static void SetModer(int pin_id, EPM815.Gpio.Moder moder) Parameters pin_id int moder EPM815.Gpio.Moder SetOutputType(int, OutputType) public static void SetOutputType(int pin_id, EPM815.Gpio.OutputType type) Parameters pin_id int type EPM815.Gpio.OutputType SetPull(int, Pull) public static void SetPull(int pin_id, EPM815.Gpio.Pull pull) Parameters pin_id int pull EPM815.Gpio.Pull SetSpeed(int, Speed) public static void SetSpeed(int pin_id, EPM815.Gpio.Speed speed) Parameters pin_id int speed EPM815.Gpio.Speed"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.I2c.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.I2c.html",
    "title": "Class EPM815.I2c",
    "keywords": "Class EPM815.I2c Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public static class EPM815.I2c Inheritance object EPM815.I2c Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields I2c1 I2c controller. public const int I2c1 = 0 Field Value int I2c4 public const int I2c4 = 2 Field Value int I2c5 public const int I2c5 = 1 Field Value int I2c6 public const int I2c6 = 3 Field Value int Methods Initialize(int) public static void Initialize(int port) Parameters port int Initialize(int, int) public static void Initialize(int port, int frequency_hz) Parameters port int frequency_hz int UnInitialize(int) public static void UnInitialize(int port) Parameters port int"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Pwm.Pin.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Pwm.Pin.html",
    "title": "Class EPM815.Pwm.Pin",
    "keywords": "Class EPM815.Pwm.Pin Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public static class EPM815.Pwm.Pin Inheritance object EPM815.Pwm.Pin Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields PA0 public const int PA0 = 0 Field Value int PA10 public const int PA10 = 10 Field Value int PA11 public const int PA11 = 11 Field Value int PA15 public const int PA15 = 15 Field Value int PA3 public const int PA3 = 3 Field Value int PA6 public const int PA6 = 6 Field Value int PA8 public const int PA8 = 8 Field Value int PB0 public const int PB0 = 16 Field Value int PB3 public const int PB3 = 19 Field Value int PB5 public const int PB5 = 21 Field Value int PB7 public const int PB7 = 23 Field Value int PB8 public const int PB8 = 24 Field Value int PB9 public const int PB9 = 25 Field Value int PC6 public const int PC6 = 38 Field Value int PD12 public const int PD12 = 60 Field Value int PD14 public const int PD14 = 62 Field Value int PD15 public const int PD15 = 63 Field Value int PE11 public const int PE11 = 75 Field Value int PE5 public const int PE5 = 69 Field Value int PE6 public const int PE6 = 70 Field Value int PF9 public const int PF9 = 89 Field Value int PH11 public const int PH11 = 123 Field Value int PH12 public const int PH12 = 124 Field Value int PH6 public const int PH6 = 118 Field Value int PH9 public const int PH9 = 121 Field Value int PI0 public const int PI0 = 128 Field Value int PI2 public const int PI2 = 130 Field Value int PI5 public const int PI5 = 133 Field Value int PI6 public const int PI6 = 134 Field Value int PI7 public const int PI7 = 135 Field Value int"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Pwm.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Pwm.html",
    "title": "Class EPM815.Pwm",
    "keywords": "Class EPM815.Pwm Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public static class EPM815.Pwm Inheritance object EPM815.Pwm Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetChannelId(int) public static int GetChannelId(int pin) Parameters pin int Returns int GetChipId(int) public static int GetChipId(int pin) Parameters pin int Returns int Initialize(int) public static void Initialize(int pin) Parameters pin int UnInitialize(int) public static void UnInitialize(int pin) Parameters pin int"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Sdmmc.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Sdmmc.html",
    "title": "Class EPM815.Sdmmc",
    "keywords": "Class EPM815.Sdmmc Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public static class EPM815.Sdmmc Inheritance object EPM815.Sdmmc Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields SdCard2 Can controller. public const int SdCard2 = 0 Field Value int"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.SerialPort.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.SerialPort.html",
    "title": "Class EPM815.SerialPort",
    "keywords": "Class EPM815.SerialPort Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public static class EPM815.SerialPort Inheritance object EPM815.SerialPort Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields Uart1 Uart controller. public const string Uart1 = \"/dev/ttySTM0\" Field Value string Uart2 public const string Uart2 = \"/dev/ttySTM1\" Field Value string Uart3 public const string Uart3 = \"/dev/ttySTM2\" Field Value string Uart4 public const string Uart4 = \"/dev/ttySTM3\" Field Value string Uart5 public const string Uart5 = \"/dev/ttySTM4\" Field Value string Uart7 public const string Uart7 = \"/dev/ttySTM6\" Field Value string Uart8 public const string Uart8 = \"/dev/ttySTM7\" Field Value string Methods Initialize(string, bool) public static void Initialize(string portname, bool enableHardwareFlowControl = false) Parameters portname string enableHardwareFlowControl bool UnInitialize(string, bool) public static void UnInitialize(string portname, bool enabledHardwareFlowControl) Parameters portname string enabledHardwareFlowControl bool"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Spi.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.Spi.html",
    "title": "Class EPM815.Spi",
    "keywords": "Class EPM815.Spi Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public static class EPM815.Spi Inheritance object EPM815.Spi Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields Spi1 SPI bus. public const int Spi1 = 0 Field Value int Spi4 public const int Spi4 = 1 Field Value int Spi5 public const int Spi5 = 2 Field Value int Methods Initialize(int, int) public static void Initialize(int port, int bufferSize = 4096) Parameters port int bufferSize int UnInitialize(int) public static void UnInitialize(int port) Parameters port int"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.EPM815.html",
    "title": "Class EPM815",
    "keywords": "Class EPM815 Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public static class EPM815 Inheritance object EPM815 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.Interop.FileOpenFlags.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.Interop.FileOpenFlags.html",
    "title": "Enum Interop.FileOpenFlags",
    "keywords": "Enum Interop.FileOpenFlags Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public enum Interop.FileOpenFlags Fields O_NONBLOCK = 2048 O_RDONLY = 0 O_RDWR = 2 O_SYNC = 1052672"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.Interop.MemoryMappedFlags.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.Interop.MemoryMappedFlags.html",
    "title": "Enum Interop.MemoryMappedFlags",
    "keywords": "Enum Interop.MemoryMappedFlags Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll [Flags] public enum Interop.MemoryMappedFlags Fields MAP_FIXED = 16 MAP_PRIVATE = 2 MAP_SHARED = 1"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.Interop.MemoryMappedProtections.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.Interop.MemoryMappedProtections.html",
    "title": "Enum Interop.MemoryMappedProtections",
    "keywords": "Enum Interop.MemoryMappedProtections Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll [Flags] public enum Interop.MemoryMappedProtections Fields PROT_EXEC = 4 PROT_NONE = 0 PROT_READ = 1 PROT_WRITE = 2"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.Interop.SeekFlags.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.Interop.SeekFlags.html",
    "title": "Enum Interop.SeekFlags",
    "keywords": "Enum Interop.SeekFlags Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public enum Interop.SeekFlags Fields SEEK_SET = 0"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.Interop.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.Interop.html",
    "title": "Class Interop",
    "keywords": "Class Interop Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public class Interop Inheritance object Interop Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Close(int) public static int Close(int fd) Parameters fd int Returns int Ioctl(int, uint, nint) public static int Ioctl(int fd, uint request, nint argp) Parameters fd int request uint argp nint Returns int Ioctl(int, uint, ulong) public static int Ioctl(int fd, uint request, ulong argp) Parameters fd int request uint argp ulong Returns int Mmap(nint, int, MemoryMappedProtections, MemoryMappedFlags, int, int) public static nint Mmap(nint addr, int length, Interop.MemoryMappedProtections prot, Interop.MemoryMappedFlags flags, int fd, int offset) Parameters addr nint length int prot Interop.MemoryMappedProtections flags Interop.MemoryMappedFlags fd int offset int Returns nint Munmap(nint, int) public static int Munmap(nint addr, int length) Parameters addr nint length int Returns int Open(string, FileOpenFlags) public static int Open(string pathname, Interop.FileOpenFlags flags) Parameters pathname string flags Interop.FileOpenFlags Returns int Read(int, nint, int) public static int Read(int fd, nint buf, int count) Parameters fd int buf nint count int Returns int Seek(int, int, SeekFlags) public static int Seek(int fd, int offset, Interop.SeekFlags whence) Parameters fd int offset int whence Interop.SeekFlags Returns int Write(int, nint, int) public static int Write(int fd, nint buf, int count) Parameters fd int buf nint count int Returns int"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.NativeRpmsgHelper.DataReceivedEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.NativeRpmsgHelper.DataReceivedEventHandler.html",
    "title": "Delegate NativeRpmsgHelper.DataReceivedEventHandler",
    "keywords": "Delegate NativeRpmsgHelper.DataReceivedEventHandler Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public delegate void NativeRpmsgHelper.DataReceivedEventHandler(uint[] data) Parameters data uint[]"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.NativeRpmsgHelper.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.NativeRpmsgHelper.html",
    "title": "Class NativeRpmsgHelper",
    "keywords": "Class NativeRpmsgHelper Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public static class NativeRpmsgHelper Inheritance object NativeRpmsgHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields BlockDelay public static int BlockDelay Field Value int Properties BlockSize public static int BlockSize { get; } Property Value int Methods Acquire() public static int Acquire() Returns int Release() public static int Release() Returns int Send(uint[], int, int) public static int Send(uint[] data, int offset, int count) Parameters data uint[] offset int count int Returns int TaskReceive() public static Task TaskReceive() Returns Task Test() public static int Test() Returns int Events DataReceived public static event NativeRpmsgHelper.DataReceivedEventHandler DataReceived Event Type NativeRpmsgHelper.DataReceivedEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.NativeUtils.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.NativeUtils.html",
    "title": "Class NativeUtils",
    "keywords": "Class NativeUtils Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public static class NativeUtils Inheritance object NativeUtils Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods JpegtoRGB888(byte[], int, byte[]) public static void JpegtoRGB888(byte[] src, int size, byte[] dest) Parameters src byte[] size int dest byte[] WFI() public static void WFI()"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.Processor.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.Processor.html",
    "title": "Class Processor",
    "keywords": "Class Processor Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public static class Processor Inheritance object Processor Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields STM32MP1 public const string STM32MP1 = \"STM32MP1\" Field Value string Properties Name public static string Name { get; } Property Value string"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.Register.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.Register.html",
    "title": "Class Register",
    "keywords": "Class Register Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public static class Register Inheritance object Register Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ClearBits(uint, uint) public static void ClearBits(uint register, uint bits) Parameters register uint bits uint Read(uint) public static uint Read(uint register) Parameters register uint Returns uint SetBits(uint, uint) public static void SetBits(uint register, uint bits) Parameters register uint bits uint Write(uint, uint) public static void Write(uint register, uint value) Parameters register uint value uint"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.Script.OutputDataRecivedEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.Script.OutputDataRecivedEventHandler.html",
    "title": "Delegate Script.OutputDataRecivedEventHandler",
    "keywords": "Delegate Script.OutputDataRecivedEventHandler Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public delegate void Script.OutputDataRecivedEventHandler(Script sender, string received) Parameters sender Script received string"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.Script.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.Script.html",
    "title": "Class Script",
    "keywords": "Class Script Namespace GHIElectronics.Endpoint.Core Assembly GHIElectronics.Endpoint.Core.dll public class Script Inheritance object Script Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Script(string, string, string) public Script(string filename, string workingdir, string arguments) Parameters filename string workingdir string arguments string Properties Busy public bool Busy { get; } Property Value bool Error public string Error { get; } Property Value string ExitCode public int ExitCode { get; } Property Value int Output public string Output { get; } Property Value string Methods Start(bool) public void Start(bool waitforexit = true) Parameters waitforexit bool Stop() public void Stop() Events OutputDataRecivedEvent public event Script.OutputDataRecivedEventHandler OutputDataRecivedEvent Event Type Script.OutputDataRecivedEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.Core.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Core.html",
    "title": "Namespace GHIElectronics.Endpoint.Core",
    "keywords": "Namespace GHIElectronics.Endpoint.Core Classes EPM815 EPM815.Adc EPM815.Adc.Pin EPM815.Can EPM815.Dac EPM815.Dac.Pin EPM815.Gpio EPM815.Gpio.Pin EPM815.I2c EPM815.Pwm EPM815.Pwm.Pin EPM815.Sdmmc EPM815.SerialPort EPM815.Spi Interop NativeRpmsgHelper NativeUtils Processor Register Script Enums EPM815.Gpio.Alternate EPM815.Gpio.Edge EPM815.Gpio.Moder EPM815.Gpio.OutputType EPM815.Gpio.Port EPM815.Gpio.Pull EPM815.Gpio.Speed Interop.FileOpenFlags Interop.MemoryMappedFlags Interop.MemoryMappedProtections Interop.SeekFlags Delegates NativeRpmsgHelper.DataReceivedEventHandler Script.OutputDataRecivedEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Adc.AdcController.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Adc.AdcController.html",
    "title": "Class AdcController",
    "keywords": "Class AdcController Namespace GHIElectronics.Endpoint.Devices.Adc Assembly GHIElectronics.Endpoint.Devices.Adc.dll public class AdcController : IDisposable Inheritance object AdcController Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples ADC is used to read Analog values from a specific pin using GHIElectronics.Endpoint.Core; using GHIElectronics.Endpoint.Devices.Adc; var adcController = new AdcController(EPM815.Adc.Pin.ANA1); while (true){ var v = adcController.Read(); var v1 = (v * 3.3 / 65535); Console.WriteLine(v1.ToString()); Thread.Sleep(1000); } Constructors AdcController(int) public AdcController(int adcPin) Parameters adcPin int Properties ResolutionInBits public int ResolutionInBits { get; } Property Value int Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Read() public double Read() Returns double ReadRaw() public uint ReadRaw() Returns uint"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Adc.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Adc.html",
    "title": "Namespace GHIElectronics.Endpoint.Devices.Adc",
    "keywords": "Namespace GHIElectronics.Endpoint.Devices.Adc Classes AdcController"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Camera.CameraConfiguration.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Camera.CameraConfiguration.html",
    "title": "Class CameraConfiguration",
    "keywords": "Class CameraConfiguration Namespace GHIElectronics.Endpoint.Devices.Camera Assembly GHIElectronics.Endpoint.Devices.Camera.dll public class CameraConfiguration Inheritance object CameraConfiguration Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties FrameRate public int FrameRate { get; set; } Property Value int Height public int Height { get; set; } Property Value int ImageFormat public Format ImageFormat { get; set; } Property Value Format Width public int Width { get; set; } Property Value int"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Camera.ConvertImage.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Camera.ConvertImage.html",
    "title": "Class ConvertImage",
    "keywords": "Class ConvertImage Namespace GHIElectronics.Endpoint.Devices.Camera Assembly GHIElectronics.Endpoint.Devices.Camera.dll public static class ConvertImage Inheritance object ConvertImage Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Convert(byte[], int, int, Format, Format) public static byte[] Convert(byte[] imageData, int width, int height, Format inPixelFormat, Format outPixelFormat) Parameters imageData byte[] width int height int inPixelFormat Format outPixelFormat Format Returns byte[]"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Camera.Format.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Camera.Format.html",
    "title": "Enum Format",
    "keywords": "Enum Format Namespace GHIElectronics.Endpoint.Devices.Camera Assembly GHIElectronics.Endpoint.Devices.Camera.dll public enum Format Fields Jpeg = 2 Rgb565 = 0 Rgb888 = 1"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Camera.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Camera.html",
    "title": "Namespace GHIElectronics.Endpoint.Devices.Camera",
    "keywords": "Namespace GHIElectronics.Endpoint.Devices.Camera Classes CameraConfiguration ConvertImage Enums Format"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Can.CanController.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Can.CanController.html",
    "title": "Class CanController",
    "keywords": "Class CanController Namespace GHIElectronics.Endpoint.Devices.Can Assembly GHIElectronics.Endpoint.Devices.Can.dll public class CanController : IDisposable Inheritance object CanController Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples using GHIElectronics.Endpoint.Core; using GHIElectronics.Endpoint.Devices.Can; var canController = new CanController(EPM815.Can.Can2, 250_000, 500_000); int messageCount = 0; canController.MessageReceived += (a) =>{ messageCount++; Console.WriteLine(\"Receiving message: \" + messageCount); }; canController.ErrorReceived += (a, b) =>{ uint error = (uint)b.Error; if ((error & (uint)CanError.ErrorBusOff) == (uint)CanError.ErrorBusOff){ Console.WriteLine(\"Error bus off\"); } else{ Console.WriteLine(\"Receiving error: 0x\" + error.ToString(\"x8\")); } }; canController.Disable(); canController.EnableFilter(new uint[] { 0x123 }, new uint[] { 0x000007FF}, true); canController.EnableError(0x1FF); canController.Enable(); while (true){ if (canController.MessagesToRead > 0){ var msgRead = canController.Read(); if (msgRead != null){ Console.WriteLine(\"ID: \" + msgRead.ArbitrationId.ToString(\"x8\")); Console.WriteLine(\"Ext: \" + msgRead.ExtendedFrameFormat); Console.WriteLine(\"Remote: \" + msgRead.RemoteTransmissionRequest); var msgWrite = msgRead; var data = new byte[msgRead.Data.Length]; for (int i = 0; i < data.Length; i++){ data[i] = (byte)(msgRead.Data[i] + 1); } msgWrite.Data = data; msgWrite.ArbitrationId = msgRead.ArbitrationId + 1; canController.Write(msgWrite); } } Thread.Sleep(2); } Constructors CanController(int, int, int) public CanController(int controllerId, int nominalBitrate, int dataBitrate = 0) Parameters controllerId int nominalBitrate int dataBitrate int Properties IsEnabled public bool IsEnabled { get; } Property Value bool MessagesToRead public int MessagesToRead { get; } Property Value int ReadBufferSize public int ReadBufferSize { get; set; } Property Value int Methods Disable() public void Disable() Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Enable() public void Enable() EnableErrorEvent(uint) public void EnableErrorEvent(uint error) Parameters error uint EnableFilter(uint[], uint[], bool) public void EnableFilter(uint[] id, uint[] mask, bool invert = false) Parameters id uint[] mask uint[] invert bool Read() public CanMessage Read() Returns CanMessage Reset() public void Reset() Write(CanMessage) public void Write(CanMessage message) Parameters message CanMessage Events ErrorReceived public event ErrorReceivedEventHandler ErrorReceived Event Type ErrorReceivedEventHandler MessageReceived public event MessageReceivedEventHandler MessageReceived Event Type MessageReceivedEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Can.CanError.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Can.CanError.html",
    "title": "Enum CanError",
    "keywords": "Enum CanError Namespace GHIElectronics.Endpoint.Devices.Can Assembly GHIElectronics.Endpoint.Devices.Can.dll public enum CanError : uint Fields ErrorAck = 32 ErrorBusError = 128 ErrorBusOff = 64 ErrorCrtl = 4 ErrorLostArbitration = 2 ErrorProtocol = 8 ErrorRestarted = 256 ErrorTransceiver = 16 ErrorTxTimeout = 1"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Can.CanMessage.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Can.CanMessage.html",
    "title": "Class CanMessage",
    "keywords": "Class CanMessage Namespace GHIElectronics.Endpoint.Devices.Can Assembly GHIElectronics.Endpoint.Devices.Can.dll public class CanMessage Inheritance object CanMessage Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CanMessage() public CanMessage() CanMessage(uint) public CanMessage(uint arbitrationId) Parameters arbitrationId uint CanMessage(uint, byte[]) public CanMessage(uint arbitrationId, byte[] data) Parameters arbitrationId uint data byte[] CanMessage(uint, byte[], int, int) public CanMessage(uint arbitrationId, byte[] data, int offset, int count) Parameters arbitrationId uint data byte[] offset int count int CanMessage(uint, byte[], int, int, bool, bool) public CanMessage(uint arbitrationId, byte[] data, int offset, int count, bool isRemoteTransmissionRequesti, bool isExtendedId) Parameters arbitrationId uint data byte[] offset int count int isRemoteTransmissionRequesti bool isExtendedId bool CanMessage(uint, byte[], int, int, bool, bool, bool) public CanMessage(uint arbitrationId, byte[] data, int offset, int count, bool isRemoteTransmissionRequesti, bool isExtendedId, bool isFdCan) Parameters arbitrationId uint data byte[] offset int count int isRemoteTransmissionRequesti bool isExtendedId bool isFdCan bool CanMessage(uint, byte[], int, int, bool, bool, bool, bool) public CanMessage(uint arbitrationId, byte[] data, int offset, int count, bool isRemoteTransmissionRequesti, bool isExtendedId, bool isFdCan, bool isBitRateSwitch) Parameters arbitrationId uint data byte[] offset int count int isRemoteTransmissionRequesti bool isExtendedId bool isFdCan bool isBitRateSwitch bool Properties ArbitrationId public uint ArbitrationId { get; set; } Property Value uint BitRateSwitch public bool BitRateSwitch { get; set; } Property Value bool Data public byte[] Data { get; set; } Property Value byte[] ExtendedFrameFormat public bool ExtendedFrameFormat { get; set; } Property Value bool FdCan public bool FdCan { get; set; } Property Value bool Length public int Length { get; set; } Property Value int RemoteTransmissionRequest public bool RemoteTransmissionRequest { get; set; } Property Value bool Timestamp public DateTime Timestamp { get; set; } Property Value DateTime"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Can.ErrorReceivedEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Can.ErrorReceivedEventArgs.html",
    "title": "Class ErrorReceivedEventArgs",
    "keywords": "Class ErrorReceivedEventArgs Namespace GHIElectronics.Endpoint.Devices.Can Assembly GHIElectronics.Endpoint.Devices.Can.dll public class ErrorReceivedEventArgs Inheritance object ErrorReceivedEventArgs Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Error public CanError Error { get; } Property Value CanError Timestamp public DateTime Timestamp { get; } Property Value DateTime"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Can.ErrorReceivedEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Can.ErrorReceivedEventHandler.html",
    "title": "Delegate ErrorReceivedEventHandler",
    "keywords": "Delegate ErrorReceivedEventHandler Namespace GHIElectronics.Endpoint.Devices.Can Assembly GHIElectronics.Endpoint.Devices.Can.dll public delegate void ErrorReceivedEventHandler(CanController sender, ErrorReceivedEventArgs e) Parameters sender CanController e ErrorReceivedEventArgs"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Can.MessageReceivedEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Can.MessageReceivedEventHandler.html",
    "title": "Delegate MessageReceivedEventHandler",
    "keywords": "Delegate MessageReceivedEventHandler Namespace GHIElectronics.Endpoint.Devices.Can Assembly GHIElectronics.Endpoint.Devices.Can.dll public delegate void MessageReceivedEventHandler(CanController sender) Parameters sender CanController"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Can.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Can.html",
    "title": "Namespace GHIElectronics.Endpoint.Devices.Can",
    "keywords": "Namespace GHIElectronics.Endpoint.Devices.Can Classes CanController CanMessage ErrorReceivedEventArgs Enums CanError Delegates ErrorReceivedEventHandler MessageReceivedEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Dac.DacController.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Dac.DacController.html",
    "title": "Class DacController",
    "keywords": "Class DacController Namespace GHIElectronics.Endpoint.Devices.Dac Assembly GHIElectronics.Endpoint.Devices.Dac.dll public class DacController : IDisposable Inheritance object DacController Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DacController(int) public DacController(int dacPin) Parameters dacPin int Properties MaxValue public int MaxValue { get; } Property Value int MinValue public int MinValue { get; } Property Value int Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Powerdown(bool) public void Powerdown(bool enable) Parameters enable bool Scale() public double Scale() Returns double WriteValue(double) public void WriteValue(double ratio) Parameters ratio double WriteValue(int) public void WriteValue(int value) Parameters value int"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Dac.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Dac.html",
    "title": "Namespace GHIElectronics.Endpoint.Devices.Dac",
    "keywords": "Namespace GHIElectronics.Endpoint.Devices.Dac Classes DacController"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Dcmi.DcmiController.FrameReceived.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Dcmi.DcmiController.FrameReceived.html",
    "title": "Delegate DcmiController.FrameReceived",
    "keywords": "Delegate DcmiController.FrameReceived Namespace GHIElectronics.Endpoint.Devices.Dcmi Assembly GHIElectronics.Endpoint.Devices.Dcmi.dll public delegate void DcmiController.FrameReceived(DcmiController sender, byte[] data) Parameters sender DcmiController data byte[]"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Dcmi.DcmiController.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Dcmi.DcmiController.html",
    "title": "Class DcmiController",
    "keywords": "Class DcmiController Namespace GHIElectronics.Endpoint.Devices.Dcmi Assembly GHIElectronics.Endpoint.Devices.Dcmi.dll public abstract class DcmiController : IDisposable Inheritance object DcmiController Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DcmiController(string) public DcmiController(string devicePath = \"/dev/video0\") Parameters devicePath string Properties Height public int Height { get; } Property Value int IsVideoStreaming public bool IsVideoStreaming { get; } Property Value bool Setting public CameraConfiguration Setting { get; set; } Property Value CameraConfiguration Width public int Width { get; } Property Value int Methods Capture() public byte[] Capture() Returns byte[] Close() protected void Close() Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Dispose(bool) protected void Dispose(bool disposing) Parameters disposing bool GetResolution() public string[] GetResolution() Returns string[] Open() protected void Open() VideoStreamStart() public void VideoStreamStart() VideoStreamStop() public void VideoStreamStop() Events FrameReceivedEvent public event DcmiController.FrameReceived FrameReceivedEvent Event Type DcmiController.FrameReceived"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Dcmi.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Dcmi.html",
    "title": "Namespace GHIElectronics.Endpoint.Devices.Dcmi",
    "keywords": "Namespace GHIElectronics.Endpoint.Devices.Dcmi Classes DcmiController Delegates DcmiController.FrameReceived"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.DigitalSignalController.Error.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.DigitalSignalController.Error.html",
    "title": "Enum DigitalSignalController.Error",
    "keywords": "Enum DigitalSignalController.Error Namespace GHIElectronics.Endpoint.Devices.DigitalSignal Assembly GHIElectronics.Endpoint.Devices.DigitalSignal.dll public enum DigitalSignalController.Error Fields None = 0 OutOfMemory = 1 Timeout = 2"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.DigitalSignalController.ErrorEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.DigitalSignalController.ErrorEventHandler.html",
    "title": "Delegate DigitalSignalController.ErrorEventHandler",
    "keywords": "Delegate DigitalSignalController.ErrorEventHandler Namespace GHIElectronics.Endpoint.Devices.DigitalSignal Assembly GHIElectronics.Endpoint.Devices.DigitalSignal.dll public delegate void DigitalSignalController.ErrorEventHandler(DigitalSignalController sender, DigitalSignalMode mode, DigitalSignalError error) Parameters sender DigitalSignalController mode DigitalSignalMode error DigitalSignalError"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.DigitalSignalController.Mode.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.DigitalSignalController.Mode.html",
    "title": "Enum DigitalSignalController.Mode",
    "keywords": "Enum DigitalSignalController.Mode Namespace GHIElectronics.Endpoint.Devices.DigitalSignal Assembly GHIElectronics.Endpoint.Devices.DigitalSignal.dll public enum DigitalSignalController.Mode Fields CapturePulse = 2 GeneratePulse = 0 ReadPulse = 1"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.DigitalSignalController.PulseCaptureEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.DigitalSignalController.PulseCaptureEventHandler.html",
    "title": "Delegate DigitalSignalController.PulseCaptureEventHandler",
    "keywords": "Delegate DigitalSignalController.PulseCaptureEventHandler Namespace GHIElectronics.Endpoint.Devices.DigitalSignal Assembly GHIElectronics.Endpoint.Devices.DigitalSignal.dll public delegate void DigitalSignalController.PulseCaptureEventHandler(DigitalSignalController sender, double[] buffer, uint count, uint pinState, bool aborted) Parameters sender DigitalSignalController buffer double[] count uint pinState uint aborted bool"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.DigitalSignalController.PulseGenerateEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.DigitalSignalController.PulseGenerateEventHandler.html",
    "title": "Delegate DigitalSignalController.PulseGenerateEventHandler",
    "keywords": "Delegate DigitalSignalController.PulseGenerateEventHandler Namespace GHIElectronics.Endpoint.Devices.DigitalSignal Assembly GHIElectronics.Endpoint.Devices.DigitalSignal.dll public delegate void DigitalSignalController.PulseGenerateEventHandler(DigitalSignalController sender, uint endState, bool aborted) Parameters sender DigitalSignalController endState uint aborted bool"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.DigitalSignalController.PulseReadEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.DigitalSignalController.PulseReadEventHandler.html",
    "title": "Delegate DigitalSignalController.PulseReadEventHandler",
    "keywords": "Delegate DigitalSignalController.PulseReadEventHandler Namespace GHIElectronics.Endpoint.Devices.DigitalSignal Assembly GHIElectronics.Endpoint.Devices.DigitalSignal.dll public delegate void DigitalSignalController.PulseReadEventHandler(DigitalSignalController sender, TimeSpan duration, uint count, uint pinState, bool aborted) Parameters sender DigitalSignalController duration TimeSpan count uint pinState uint aborted bool"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.DigitalSignalController.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.DigitalSignalController.html",
    "title": "Class DigitalSignalController",
    "keywords": "Class DigitalSignalController Namespace GHIElectronics.Endpoint.Devices.DigitalSignal Assembly GHIElectronics.Endpoint.Devices.DigitalSignal.dll public class DigitalSignalController Inheritance object DigitalSignalController Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DigitalSignalController(int) public DigitalSignalController(int pin) Parameters pin int Properties CanCapture public bool CanCapture { get; } Property Value bool CanGeneratePulse public bool CanGeneratePulse { get; } Property Value bool CanReadPulse public bool CanReadPulse { get; } Property Value bool Methods Abort() public void Abort() Capture(uint, Edge, bool) public void Capture(uint count, EPM815.Gpio.Edge edge, bool waitForEdge = false) Parameters count uint edge EPM815.Gpio.Edge waitForEdge bool Capture(uint, Edge, bool, TimeSpan) public void Capture(uint count, EPM815.Gpio.Edge edge, bool waitForEdge, TimeSpan timeout) Parameters count uint edge EPM815.Gpio.Edge waitForEdge bool timeout TimeSpan Dispose() public void Dispose() Generate(uint[]) public void Generate(uint[] data) Parameters data uint[] Generate(uint[], uint, int) public void Generate(uint[] data, uint offset, int count) Parameters data uint[] offset uint count int Generate(uint[], uint, int, uint, Edge) public void Generate(uint[] data, uint offset, int count, uint multiplier, EPM815.Gpio.Edge edge) Parameters data uint[] offset uint count int multiplier uint edge EPM815.Gpio.Edge ReadPulse(uint, Edge, bool) public void ReadPulse(uint pulseNum, EPM815.Gpio.Edge edge, bool waitForEdge = false) Parameters pulseNum uint edge EPM815.Gpio.Edge waitForEdge bool Events CaptureFinished public event DigitalSignalController.PulseCaptureEventHandler CaptureFinished Event Type DigitalSignalController.PulseCaptureEventHandler ErrorReceived public event DigitalSignalController.ErrorEventHandler ErrorReceived Event Type DigitalSignalController.ErrorEventHandler GenerateFinished public event DigitalSignalController.PulseGenerateEventHandler GenerateFinished Event Type DigitalSignalController.PulseGenerateEventHandler ReadPulseFinished public event DigitalSignalController.PulseReadEventHandler ReadPulseFinished Event Type DigitalSignalController.PulseReadEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.DigitalSignalError.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.DigitalSignalError.html",
    "title": "Enum DigitalSignalError",
    "keywords": "Enum DigitalSignalError Namespace GHIElectronics.Endpoint.Devices.DigitalSignal Assembly GHIElectronics.Endpoint.Devices.DigitalSignal.dll public enum DigitalSignalError Fields None = 0 OutOfMemory = 1 Timeout = 2"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.DigitalSignalMode.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.DigitalSignalMode.html",
    "title": "Enum DigitalSignalMode",
    "keywords": "Enum DigitalSignalMode Namespace GHIElectronics.Endpoint.Devices.DigitalSignal Assembly GHIElectronics.Endpoint.Devices.DigitalSignal.dll public enum DigitalSignalMode Fields CapturePulse = 2 GeneratePulse = 0 ReadPulse = 1"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.PulseFeedbackController.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.PulseFeedbackController.html",
    "title": "Class PulseFeedbackController",
    "keywords": "Class PulseFeedbackController Namespace GHIElectronics.Endpoint.Devices.DigitalSignal Assembly GHIElectronics.Endpoint.Devices.DigitalSignal.dll public class PulseFeedbackController : IDisposable Inheritance object PulseFeedbackController Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PulseFeedbackController(int, PulseFeedbackMode) public PulseFeedbackController(int pin, PulseFeedbackMode mode) Parameters pin int mode PulseFeedbackMode PulseFeedbackController(int, int, PulseFeedbackMode) public PulseFeedbackController(int pulsePin, int echoPin, PulseFeedbackMode mode) Parameters pulsePin int echoPin int mode PulseFeedbackMode Properties DisableInterrupts public bool DisableInterrupts { get; set; } Property Value bool EchoValue public bool EchoValue { get; set; } Property Value bool PulseLength public TimeSpan PulseLength { get; set; } Property Value TimeSpan PulseValue public bool PulseValue { get; set; } Property Value bool Timeout public TimeSpan Timeout { get; set; } Property Value TimeSpan Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Trigger() public TimeSpan Trigger() Returns TimeSpan"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.PulseFeedbackMode.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.PulseFeedbackMode.html",
    "title": "Enum PulseFeedbackMode",
    "keywords": "Enum PulseFeedbackMode Namespace GHIElectronics.Endpoint.Devices.DigitalSignal Assembly GHIElectronics.Endpoint.Devices.DigitalSignal.dll public enum PulseFeedbackMode Fields DrainDuration = 0 DurationUntilEcho = 2 EchoDuration = 1"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.DigitalSignal.html",
    "title": "Namespace GHIElectronics.Endpoint.Devices.DigitalSignal",
    "keywords": "Namespace GHIElectronics.Endpoint.Devices.DigitalSignal Classes DigitalSignalController PulseFeedbackController Enums DigitalSignalError DigitalSignalMode PulseFeedbackMode Delegates DigitalSignalController.ErrorEventHandler DigitalSignalController.PulseCaptureEventHandler DigitalSignalController.PulseGenerateEventHandler DigitalSignalController.PulseReadEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Display.DisplayConfiguration.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Display.DisplayConfiguration.html",
    "title": "Class DisplayConfiguration",
    "keywords": "Class DisplayConfiguration Namespace GHIElectronics.Endpoint.Devices.Display Assembly GHIElectronics.Endpoint.Devices.Display.dll public class DisplayConfiguration Inheritance object DisplayConfiguration Derived FBDisplay.Configuration Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Height public int Height { get; set; } Property Value int Width public int Width { get; set; } Property Value int"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Display.DisplayController.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Display.DisplayController.html",
    "title": "Class DisplayController",
    "keywords": "Class DisplayController Namespace GHIElectronics.Endpoint.Devices.Display Assembly GHIElectronics.Endpoint.Devices.Display.dll public class DisplayController Inheritance object DisplayController Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples using System.Device.Gpio; using System.Device.Gpio.Drivers; using GHIElectronics.Endpoint.Core; using GHIElectronics.Endpoint.Devices.Display; using SkiaSharp; using EndpointDisplayTest.Properties; var backlightPort = EPM815.Gpio.Pin.PD14 /16; var backlightPin = EPM815.Gpio.Pin.PD14 % 16; var gpioDriver = new LibGpiodDriver((int)backlightPort); var gpioController = new GpioController(PinNumberingScheme.Logical, gpioDriver); gpioController.OpenPin(backlightPin, PinMode.Output); gpioController.Write(backlightPin, PinValue.High); var screenWidth = 480; var screenHeight = 272; SKBitmap bitmap = new SKBitmap(screenWidth, screenHeight, SKImageInfo.PlatformColorType, SKAlphaType.Premul); bitmap.Erase(SKColors.Transparent); var configuration = new FBDisplay.Configuration(){ Clock = 10000, Width = 480, Hsync_start = 480 + 2, Hsync_end = 480 + 2 + 41, Htotal = 480 + 2 + 41 + 2, Height = 272, Vsync_start = 272 + 2, Vsync_end = 272 + 2 + 10, Vtotal = 272 + 2 + 10 + 2, }; var fbDisplay = new FBDisplay(configuration); var displayController = new DisplayController(fbDisplay); var imageWidth = 100; var imageHeight = 67; while (true){ //Initialize Screen using (var screen = new SKCanvas(bitmap)){ //Create Black Screen screen.DrawColor(SKColors.Black); screen.Clear(SKColors.Black); //same thing but also erases anything else on the canvas first // Draw Logo from Resources var logo = Resources.logo; var info = new SKImageInfo(imageWidth, imageHeight); var sk_img = SKBitmap.Decode(logo, info); screen.DrawBitmap(sk_img, 0, 200); // Draw circle using (SKPaint circle = new SKPaint()){ circle.Color = SKColors.Blue; circle.IsAntialias = true; circle.StrokeWidth = 15; circle.Style = SKPaintStyle.Stroke; screen.DrawCircle(410, 220, 30, circle); //arguments are x position, y position, radius, and paint } // Draw Oval using (SKPaint oval = new SKPaint()){ oval.Style = SKPaintStyle.Stroke; oval.Color = SKColors.Blue; oval.StrokeWidth = 10; screen.DrawOval(300, 20, 60, 10, oval); oval.Style = SKPaintStyle.Fill; oval.Color = SKColors.SkyBlue; screen.DrawOval(300, 20, 60, 10, oval); } // Draw Line float[] intervals = [10, 20, 10, 20, 5, 40,];//sets the dash intervals using (SKPaint line = new SKPaint()){ line.Color = SKColors.Red; line.IsAntialias = true; line.StrokeWidth = 20; line.Style = SKPaintStyle.Stroke; //Rounds the ends of the line line.StrokeCap = SKStrokeCap.Round; //Creates dashes in line based on intervals array line.PathEffect = SKPathEffect.CreateDash(intervals, 25); // Create linear gradient from upper-left to lower-right line.Shader = SKShader.CreateLinearGradient( new SKPoint(0, 0), new SKPoint(screenWidth, screenHeight), new SKColor[] { SKColors.Red, SKColors.Blue }, new float[] { 0, 1 }, SKShaderTileMode.Repeat); screen.DrawLine(0, 0, 400, 200, line); } //Using SkiaTypeface byte[] fontfile = Resources.OldeEnglish; Stream stream = new MemoryStream(fontfile); using (SKPaint textPaint = new SKPaint()) using (SKTypeface tf = SKTypeface.FromStream(stream)){ textPaint.Color = SKColors.White; textPaint.IsAntialias = true; textPaint.StrokeWidth = 2; textPaint.Style = SKPaintStyle.Stroke; //SKFont Text - SKFont font = new SKFont(); font.Size = 40; font.ScaleX = 2; font.Typeface = tf; SKTextBlob textBlob = SKTextBlob.Create(\"D\", font); screen.DrawText(textBlob, 10, 150, textPaint); } // Draw Basic text using (SKPaint text = new SKPaint()){ text.Color = SKColors.Yellow; text.IsAntialias = true; text.StrokeWidth = 2; text.Style = SKPaintStyle.Stroke; screen.DrawText(\"Hello World\", 20, 20, text); } // Draw text using (SKPaint text = new SKPaint()){ text.Color = SKColors.Yellow; text.IsAntialias = true; text.StrokeWidth = 2; text.Style = SKPaintStyle.Stroke; //SKFont Text - SKFont font = new SKFont(); font.Size = 22; font.ScaleX = 2; SKTextBlob textBlob = SKTextBlob.Create(\"I am Yellow\", font); screen.DrawText(textBlob, 50, 100, text); } // Character Outlines using (SKPaint textPaint = new SKPaint()){ // Set Style for the character outlines textPaint.Style = SKPaintStyle.Stroke; // Set TextSize 100x100 textPaint.TextSize = Math.Min(100, 100); // Measure the text SKRect textBounds = new SKRect(); textPaint.MeasureText(\"@\", ref textBounds); // Coordinates to center text on screen float xText = screenWidth / 2 - textBounds.MidX; float yText = screenHeight / 2 - textBounds.MidY; // Get the path for the character outlines using (SKPath textPath = textPaint.GetTextPath(\"@\", xText, yText)){ // Create a new path for the outlines of the path using (SKPath outlinePath = new SKPath()){ // Convert the path to the outlines of the stroked path textPaint.StrokeWidth = 1; textPaint.GetFillPath(textPath, outlinePath); // Stroke that new path using (SKPaint outlinePaint = new SKPaint()){ outlinePaint.Style = SKPaintStyle.Stroke; outlinePaint.StrokeWidth = 1; outlinePaint.Color = SKColors.Red; screen.DrawPath(outlinePath, outlinePaint); } } } //Text along a path const string text = \"SKIASHARP library ENDPOINT uses \"; using (SKPath circularPath = new SKPath()){ float radius = 0.35f * Math.Min(screenWidth, screenHeight); circularPath.AddCircle(screenWidth / 2, screenHeight / 2, radius); using (SKPaint textPaint2 = new SKPaint()){ textPaint2.TextSize = 100; float textWidth = textPaint2.MeasureText(text); textPaint.TextSize *= 2 * 3.14f * radius / textWidth; textPaint.Color = SKColors.Green; screen.DrawTextOnPath(text, circularPath, 0, 0, textPaint); } } // Draw Italic text using (SKPaint italicText = new SKPaint()){ SKFontStyle fontStyle = new SKFontStyle(); italicText.Color = SKColors.Yellow; italicText.IsAntialias = true; italicText.StrokeWidth = 2; italicText.Style = SKPaintStyle.Stroke; SKFont font2 = new SKFont(SKTypeface.Default, 12, 1, 0); font2.Size = 22; SKTextBlob textBlob = SKTextBlob.Create(\"ItalicFonts\", font2); screen.DrawText(textBlob, 200, 200, italicText); } // Flush to screen var data = bitmap.Copy(SKColorType.Rgb565).Bytes; displayController.Flush(data); Thread.Sleep(1); } } } Constructors DisplayController(IDisplayProvider) public DisplayController(IDisplayProvider display) Parameters display IDisplayProvider Properties Configuration public DisplayConfiguration Configuration { get; } Property Value DisplayConfiguration Methods Flush(byte[]) public void Flush(byte[] data) Parameters data byte[] Flush(byte[], int, int) public void Flush(byte[] data, int offset, int length) Parameters data byte[] offset int length int Flush(byte[], int, int, int, int, int, int, int) public void Flush(byte[] data, int offset, int length, int x, int y, int width, int height, int originalWidth) Parameters data byte[] offset int length int x int y int width int height int originalWidth int"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Display.FBDisplay.Configuration.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Display.FBDisplay.Configuration.html",
    "title": "Class FBDisplay.Configuration",
    "keywords": "Class FBDisplay.Configuration Namespace GHIElectronics.Endpoint.Devices.Display Assembly GHIElectronics.Endpoint.Devices.Display.dll public class FBDisplay.Configuration : DisplayConfiguration Inheritance object DisplayConfiguration FBDisplay.Configuration Inherited Members DisplayConfiguration.Width DisplayConfiguration.Height object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Properties Bpc public int Bpc { get; set; } Property Value int Bus_flags public int Bus_flags { get; set; } Property Value int Bus_format public int Bus_format { get; set; } Property Value int Clock public int Clock { get; set; } Property Value int Connector_type public int Connector_type { get; set; } Property Value int Dpi_height public int Dpi_height { get; set; } Property Value int Dpi_width public int Dpi_width { get; set; } Property Value int Hsync_end public int Hsync_end { get; set; } Property Value int Hsync_start public int Hsync_start { get; set; } Property Value int Htotal public int Htotal { get; set; } Property Value int Num_modes public int Num_modes { get; set; } Property Value int Vsync_end public int Vsync_end { get; set; } Property Value int Vsync_start public int Vsync_start { get; set; } Property Value int Vtotal public int Vtotal { get; set; } Property Value int Methods ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object."
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Display.FBDisplay.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Display.FBDisplay.html",
    "title": "Class FBDisplay",
    "keywords": "Class FBDisplay Namespace GHIElectronics.Endpoint.Devices.Display Assembly GHIElectronics.Endpoint.Devices.Display.dll public class FBDisplay : IDisplayProvider, IDisposable Inheritance object FBDisplay Implements IDisplayProvider IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors FBDisplay(DisplayConfiguration) public FBDisplay(DisplayConfiguration configuration) Parameters configuration DisplayConfiguration Properties Height public int Height { get; } Property Value int Width public int Width { get; } Property Value int Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Flush(byte[], int, int) public void Flush(byte[] data, int offset, int length) Parameters data byte[] offset int length int Flush(byte[], int, int, int, int, int, int, int) public void Flush(byte[] data, int offset, int length, int x, int y, int width, int height, int orginalWidth) Parameters data byte[] offset int length int x int y int width int height int orginalWidth int"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Display.IDisplayProvider.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Display.IDisplayProvider.html",
    "title": "Interface IDisplayProvider",
    "keywords": "Interface IDisplayProvider Namespace GHIElectronics.Endpoint.Devices.Display Assembly GHIElectronics.Endpoint.Devices.Display.dll public interface IDisplayProvider : IDisposable Inherited Members IDisposable.Dispose() Properties Configuration DisplayConfiguration Configuration { get; } Property Value DisplayConfiguration Methods Flush(byte[]) void Flush(byte[] data) Parameters data byte[] Flush(byte[], int, int) void Flush(byte[] data, int offset, int length) Parameters data byte[] offset int length int Flush(byte[], int, int, int, int, int, int, int) void Flush(byte[] data, int offset, int length, int x, int y, int width, int height, int originalWidth) Parameters data byte[] offset int length int x int y int width int height int originalWidth int"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Display.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Display.html",
    "title": "Namespace GHIElectronics.Endpoint.Devices.Display",
    "keywords": "Namespace GHIElectronics.Endpoint.Devices.Display Classes DisplayConfiguration DisplayController FBDisplay FBDisplay.Configuration Interfaces IDisplayProvider"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Mmc.DeviceConnectionEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Mmc.DeviceConnectionEventArgs.html",
    "title": "Class DeviceConnectionEventArgs",
    "keywords": "Class DeviceConnectionEventArgs Namespace GHIElectronics.Endpoint.Devices.Mmc Assembly GHIElectronics.Endpoint.Devices.Sdmmc.dll public class DeviceConnectionEventArgs : EventArgs Inheritance object EventArgs DeviceConnectionEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties DeviceId public int DeviceId { get; } Property Value int DeviceName public string DeviceName { get; } Property Value string DeviceStatus public DeviceConnectionStatus DeviceStatus { get; } Property Value DeviceConnectionStatus"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Mmc.DeviceConnectionStatus.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Mmc.DeviceConnectionStatus.html",
    "title": "Enum DeviceConnectionStatus",
    "keywords": "Enum DeviceConnectionStatus Namespace GHIElectronics.Endpoint.Devices.Mmc Assembly GHIElectronics.Endpoint.Devices.Sdmmc.dll public enum DeviceConnectionStatus Fields Bad = 2 Connected = 1 Disconnected = 0"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Mmc.OnConnectionChanged.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Mmc.OnConnectionChanged.html",
    "title": "Delegate OnConnectionChanged",
    "keywords": "Delegate OnConnectionChanged Namespace GHIElectronics.Endpoint.Devices.Mmc Assembly GHIElectronics.Endpoint.Devices.Sdmmc.dll public delegate void OnConnectionChanged(SdmmcController sender, DeviceConnectionEventArgs e) Parameters sender SdmmcController e DeviceConnectionEventArgs"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Mmc.Sdmmc.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Mmc.Sdmmc.html",
    "title": "Class Sdmmc",
    "keywords": "Class Sdmmc Namespace GHIElectronics.Endpoint.Devices.Mmc Assembly GHIElectronics.Endpoint.Devices.Sdmmc.dll public class Sdmmc Inheritance object Sdmmc Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Sdmmc(int, string, SdmmcType) public Sdmmc(int id, string name, SdmmcType type) Parameters id int name string type SdmmcType Fields CurrentId public static int CurrentId Field Value int Properties DeviceId public int DeviceId { get; } Property Value int DeviceName public string DeviceName { get; } Property Value string Type public SdmmcType Type { get; } Property Value SdmmcType"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Mmc.SdmmcController.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Mmc.SdmmcController.html",
    "title": "Class SdmmcController",
    "keywords": "Class SdmmcController Namespace GHIElectronics.Endpoint.Devices.Mmc Assembly GHIElectronics.Endpoint.Devices.Sdmmc.dll public class SdmmcController : IDisposable Inheritance object SdmmcController Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples Connecting to an SD Card using GHIElectronics.Endpoint.Devices.Mmc; var sdcard = new SdmmcController(SdmmcType.SdCard2); sdcard.OnConnectionChangedEvent += Sdcard_OnConnectionChangedEvent; sdcard.Enable(); private static void Sdcard_OnConnectionChangedEvent(SdmmcController sender, DeviceConnectionEventArgs e){ Console.WriteLine(\"Detect SDCard connection changed on\" + e.DeviceName + \", status: \" + e.DeviceStatus + \", id = \" + e.DeviceId); } Constructors SdmmcController(SdmmcType) public SdmmcController(SdmmcType type) Parameters type SdmmcType Methods Disable() public void Disable() Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Enable() public void Enable() Events OnConnectionChangedEvent public event OnConnectionChanged OnConnectionChangedEvent Event Type OnConnectionChanged"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Mmc.SdmmcType.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Mmc.SdmmcType.html",
    "title": "Enum SdmmcType",
    "keywords": "Enum SdmmcType Namespace GHIElectronics.Endpoint.Devices.Mmc Assembly GHIElectronics.Endpoint.Devices.Sdmmc.dll public enum SdmmcType : uint Fields Emmc = 2 SdCard1 = 1 SdCard2 = 0"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Mmc.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Mmc.html",
    "title": "Namespace GHIElectronics.Endpoint.Devices.Mmc",
    "keywords": "Namespace GHIElectronics.Endpoint.Devices.Mmc Classes DeviceConnectionEventArgs Sdmmc SdmmcController Enums DeviceConnectionStatus SdmmcType Delegates OnConnectionChanged"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Network.NetworkAddressChangedEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Network.NetworkAddressChangedEventArgs.html",
    "title": "Class NetworkAddressChangedEventArgs",
    "keywords": "Class NetworkAddressChangedEventArgs Namespace GHIElectronics.Endpoint.Devices.Network Assembly GHIElectronics.Endpoint.Devices.Network.dll public class NetworkAddressChangedEventArgs : EventArgs Inheritance object EventArgs NetworkAddressChangedEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Address public IPAddress Address { get; } Property Value IPAddress Dns public IPAddress[] Dns { get; } Property Value IPAddress[] Gateway public IPAddress[] Gateway { get; } Property Value IPAddress[] MACAddress public string MACAddress { get; } Property Value string Timestamp public DateTime Timestamp { get; } Property Value DateTime"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Network.NetworkAddressChangedEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Network.NetworkAddressChangedEventHandler.html",
    "title": "Delegate NetworkAddressChangedEventHandler",
    "keywords": "Delegate NetworkAddressChangedEventHandler Namespace GHIElectronics.Endpoint.Devices.Network Assembly GHIElectronics.Endpoint.Devices.Network.dll public delegate void NetworkAddressChangedEventHandler(NetworkController sender, NetworkAddressChangedEventArgs e) Parameters sender NetworkController e NetworkAddressChangedEventArgs"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Network.NetworkController.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Network.NetworkController.html",
    "title": "Class NetworkController",
    "keywords": "Class NetworkController Namespace GHIElectronics.Endpoint.Devices.Network Assembly GHIElectronics.Endpoint.Devices.Network.dll public class NetworkController : IDisposable Inheritance object NetworkController Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples Ethernet Network var networkType = NetworkInterfaceType.Ethernet; var networkSetting = new NetworkInterfaceSettings { Address = new IPAddress(new byte[] { 192, 168, 86, 106 }), SubnetMask = new IPAddress(new byte[] { 255, 255, 255, 0 }), GatewayAddress = new IPAddress(new byte[] { 192, 168, 86, 1 }), DnsAddresses = new IPAddress[] { new IPAddress(new byte[] { 75, 75, 75, 75 }) }, DhcpEnable = false, }; var network = new NetworkController(networkType, networkSetting); network.NetworkLinkConnectedChanged += (a, b) => { if (b.Connected) { Console.WriteLine(\"Connected\"); } else { Console.WriteLine(\"Disconnected\"); } }; network.NetworkAddressChanged += (a, b) => { Console.WriteLine(string.Format(\"Address: {0}\\n gateway: {1}\\n DNS: {2}\\n MAC: {3} \", b.Address, b.Gateway, b.Dns[0], b.MACAddress)); }; network.Enable(); Thread.Sleep(-1); network.Disable(); Constructors NetworkController(NetworkInterfaceType, NetworkInterfaceSettings) public NetworkController(NetworkInterfaceType interfaceType, NetworkInterfaceSettings interfaceSetting) Parameters interfaceType NetworkInterfaceType interfaceSetting NetworkInterfaceSettings Methods Disable() public void Disable() Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Enable() public void Enable() Events NetworkAddressChanged public event NetworkAddressChangedEventHandler NetworkAddressChanged Event Type NetworkAddressChangedEventHandler NetworkLinkConnectedChanged public event NetworkLinkConnectedChangedEventHandler NetworkLinkConnectedChanged Event Type NetworkLinkConnectedChangedEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Network.NetworkInterfaceSettings.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Network.NetworkInterfaceSettings.html",
    "title": "Class NetworkInterfaceSettings",
    "keywords": "Class NetworkInterfaceSettings Namespace GHIElectronics.Endpoint.Devices.Network Assembly GHIElectronics.Endpoint.Devices.Network.dll public class NetworkInterfaceSettings Inheritance object NetworkInterfaceSettings Derived WiFiNetworkInterfaceSettings Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Address public IPAddress Address { get; set; } Property Value IPAddress DhcpEnable public bool DhcpEnable { get; set; } Property Value bool DnsAddresses public IPAddress[] DnsAddresses { get; set; } Property Value IPAddress[] GatewayAddress public IPAddress GatewayAddress { get; set; } Property Value IPAddress MacAddress public byte[] MacAddress { get; set; } Property Value byte[] SubnetMask public IPAddress SubnetMask { get; set; } Property Value IPAddress"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Network.NetworkInterfaceType.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Network.NetworkInterfaceType.html",
    "title": "Enum NetworkInterfaceType",
    "keywords": "Enum NetworkInterfaceType Namespace GHIElectronics.Endpoint.Devices.Network Assembly GHIElectronics.Endpoint.Devices.Network.dll public enum NetworkInterfaceType Fields Ethernet = 0 UsbEthernet = 2 WiFi = 1"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Network.NetworkLinkConnectedChangedEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Network.NetworkLinkConnectedChangedEventArgs.html",
    "title": "Class NetworkLinkConnectedChangedEventArgs",
    "keywords": "Class NetworkLinkConnectedChangedEventArgs Namespace GHIElectronics.Endpoint.Devices.Network Assembly GHIElectronics.Endpoint.Devices.Network.dll public class NetworkLinkConnectedChangedEventArgs : EventArgs Inheritance object EventArgs NetworkLinkConnectedChangedEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Connected public bool Connected { get; } Property Value bool Timestamp public DateTime Timestamp { get; } Property Value DateTime"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Network.NetworkLinkConnectedChangedEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Network.NetworkLinkConnectedChangedEventHandler.html",
    "title": "Delegate NetworkLinkConnectedChangedEventHandler",
    "keywords": "Delegate NetworkLinkConnectedChangedEventHandler Namespace GHIElectronics.Endpoint.Devices.Network Assembly GHIElectronics.Endpoint.Devices.Network.dll public delegate void NetworkLinkConnectedChangedEventHandler(NetworkController sender, NetworkLinkConnectedChangedEventArgs e) Parameters sender NetworkController e NetworkLinkConnectedChangedEventArgs"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Network.WiFiNetworkInterfaceSettings.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Network.WiFiNetworkInterfaceSettings.html",
    "title": "Class WiFiNetworkInterfaceSettings",
    "keywords": "Class WiFiNetworkInterfaceSettings Namespace GHIElectronics.Endpoint.Devices.Network Assembly GHIElectronics.Endpoint.Devices.Network.dll public class WiFiNetworkInterfaceSettings : NetworkInterfaceSettings Inheritance object NetworkInterfaceSettings WiFiNetworkInterfaceSettings Inherited Members NetworkInterfaceSettings.Address NetworkInterfaceSettings.SubnetMask NetworkInterfaceSettings.GatewayAddress NetworkInterfaceSettings.DnsAddresses NetworkInterfaceSettings.MacAddress NetworkInterfaceSettings.DhcpEnable object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Examples Wi-Fi Network var networkType = NetworkInterfaceType.WiFi; var networkSetting = new WifiNetworkInterfaceSetting { Ssid = ******, Password = ******, DhcpEnable = true, }; var network = new NetworkController(networkType, networkSetting); network.NetworkLinkConnectedChanged += (a, b) => { if (b.Connected) { Console.WriteLine(\"Connected\"); } else { Console.WriteLine(\"Disconnected\"); } }; network.NetworkAddressChanged += (a, b) => { Console.WriteLine(string.Format(\"Address: {0}\\n gateway: {1}\\n DNS: {2}\\n MAC: {3} \", b.Address, b.Gateway, b.Dns[0], b.MACAddress)); }; network.Enable(); Thread.Sleep(-1); network.Disable(); Properties Password public string Password { get; set; } Property Value string Ssid public string Ssid { get; set; } Property Value string"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Network.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Network.html",
    "title": "Namespace GHIElectronics.Endpoint.Devices.Network",
    "keywords": "Namespace GHIElectronics.Endpoint.Devices.Network Classes NetworkAddressChangedEventArgs NetworkController NetworkInterfaceSettings NetworkLinkConnectedChangedEventArgs WiFiNetworkInterfaceSettings Enums NetworkInterfaceType Delegates NetworkAddressChangedEventHandler NetworkLinkConnectedChangedEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Rtc.BatteryChargeMode.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Rtc.BatteryChargeMode.html",
    "title": "Enum BatteryChargeMode",
    "keywords": "Enum BatteryChargeMode Namespace GHIElectronics.Endpoint.Devices.Rtc Assembly GHIElectronics.Endpoint.Devices.Rtc.dll public enum BatteryChargeMode Fields Fast = 1 None = 0 Slow = 2"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Rtc.RtcController.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Rtc.RtcController.html",
    "title": "Class RtcController",
    "keywords": "Class RtcController Namespace GHIElectronics.Endpoint.Devices.Rtc Assembly GHIElectronics.Endpoint.Devices.Rtc.dll public class RtcController : RtcBase, IDisposable Inheritance object RtcBase RtcController Implements IDisposable Inherited Members RtcBase.Dispose(bool) RtcBase.RtcDateTime RtcBase.DateTime RtcBase.LocalTimeZone object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RtcController() public RtcController() Properties Now public DateTime Now { get; set; } Property Value DateTime Methods Dispose() public void Dispose() EnableChargeMode(BatteryChargeMode) public void EnableChargeMode(BatteryChargeMode chargeMode) Parameters chargeMode BatteryChargeMode GetSystemTime() public DateTime GetSystemTime() Returns DateTime ReadTime() Read time from the device protected override DateTime ReadTime() Returns DateTime Time from the device SetSystemTime(DateTime) public void SetSystemTime(DateTime value) Parameters value DateTime SetTime(DateTime) Set the device time protected override void SetTime(DateTime time) Parameters time DateTime Time"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Rtc.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Rtc.html",
    "title": "Namespace GHIElectronics.Endpoint.Devices.Rtc",
    "keywords": "Namespace GHIElectronics.Endpoint.Devices.Rtc Classes RtcController Enums BatteryChargeMode"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Usb.DeviceType.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Usb.DeviceType.html",
    "title": "Enum DeviceType",
    "keywords": "Enum DeviceType Namespace GHIElectronics.Endpoint.Devices.Usb Assembly GHIElectronics.Endpoint.Devices.Usb.dll public enum DeviceType : byte Fields HID = 2 Human Interface Device. Hub = 1 USB Hub. MassStorage = 3 Mass Storage. This includes USB storage devices such as USB Thumbs drives and USB hard disks. Unknown = 0 The device is not recognized. Webcam = 4 Webcam."
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Usb.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Usb.html",
    "title": "Namespace GHIElectronics.Endpoint.Devices.Usb",
    "keywords": "Namespace GHIElectronics.Endpoint.Devices.Usb Enums DeviceType"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.BaseDevice.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.BaseDevice.html",
    "title": "Class BaseDevice",
    "keywords": "Class BaseDevice Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll Represents a USB device connected. public class BaseDevice Inheritance object BaseDevice Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors BaseDevice(int, string, DeviceType) public BaseDevice(int id, string name, DeviceType type) Parameters id int name string type DeviceType Fields CurrentId public static int CurrentId Field Value int Properties DeviceId public int DeviceId { get; } Property Value int DeviceName public string DeviceName { get; } Property Value string Type public DeviceType Type { get; } Property Value DeviceType"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.DeviceConnectionEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.DeviceConnectionEventArgs.html",
    "title": "Class DeviceConnectionEventArgs",
    "keywords": "Class DeviceConnectionEventArgs Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll public class DeviceConnectionEventArgs : EventArgs Inheritance object EventArgs DeviceConnectionEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties DeviceId public int DeviceId { get; } Property Value int DeviceName public string DeviceName { get; } Property Value string DeviceStatus public DeviceConnectionStatus DeviceStatus { get; } Property Value DeviceConnectionStatus Type public DeviceType Type { get; } Property Value DeviceType"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.DeviceConnectionStatus.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.DeviceConnectionStatus.html",
    "title": "Enum DeviceConnectionStatus",
    "keywords": "Enum DeviceConnectionStatus Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll public enum DeviceConnectionStatus Fields Bad = 2 Connected = 1 Disconnected = 0"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.EventCode.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.EventCode.html",
    "title": "Enum EventCode",
    "keywords": "Enum EventCode Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll public enum EventCode Fields A = 30 Again = 129 AltErase = 222 Apostrophe = 40 B = 48 Back = 158 Backslash = 43 Backspace = 14 BassBoost = 209 Battery = 236 Bluetooth = 237 Bookmarks = 156 BrightnessAuto = 244 BrightnessCycle = 243 BrightnessDown = 224 BrightnessUp = 225 C = 46 Calc = 140 Camera = 212 Cancel = 223 Capslock = 58 Chat = 216 Close = 206 CloseCd = 160 Coffee = 152 Comma = 51 Compose = 127 Computer = 157 Config = 171 Connect = 218 Copy = 133 Cut = 137 CycleWindows = 154 D = 32 Dashboard = 204 Delete = 111 DeleteFile = 146 DisplayOff = 245 Documents = 235 Dot = 52 Down = 108 E = 18 Edit = 176 EjectCd = 161 EjectCloseCd = 162 Email = 215 End = 107 Enter = 28 Equal = 13 Esc = 1 Exit = 174 F = 33 F1 = 59 F10 = 68 F11 = 87 F12 = 88 F13 = 183 F14 = 184 F15 = 185 F16 = 186 F17 = 187 F18 = 188 F19 = 189 F20 = 190 F21 = 191 F22 = 192 F23 = 193 F24 = 194 F3 = 61 F4 = 62 F5 = 63 F6 = 64 F7 = 65 F8 = 66 FastForward = 208 File = 144 Finance = 219 Find = 136 Forward = 159 ForwardMail = 233 Front = 132 G = 34 Grave = 41 H = 35 Hangeul = 122 Hanja = 123 Help = 138 Henkan = 92 Hiragana = 91 Home = 102 Homepage = 172 Hp = 211 I = 23 Insert = 110 Iso = 170 J = 36 K = 37 Katakana = 90 Katakanahiragana = 93 KbdIllumDown = 229 KbdIllumToggle = 228 KbdIllumUp = 230 Kp0 = 82 Kp1 = 79 Kp2 = 80 Kp3 = 81 Kp4 = 75 Kp5 = 76 Kp6 = 77 Kp7 = 71 Kp8 = 72 Kp9 = 73 KpAsterisk = 55 KpComma = 121 KpDot = 83 KpEnter = 96 KpEqual = 117 KpJpComma = 95 KpLeftParen = 179 KpPlus = 78 KpPlusMinus = 118 KpRightParen = 180 KpSlash = 98 L = 38 Left = 105 LeftAlt = 56 LeftBrace = 26 LeftCtrl = 29 LeftMeta = 125 LeftMouse = 272 LeftShift = 42 LineFeed = 101 M = 50 Macro = 112 Mail = 155 Media = 226 Menu = 139 Mic = 582 MicMute = 248 MiddleMouse = 274 Minus = 12 MouseBack = 275 MouseForward = 276 Move = 175 MsDos = 151 Muhenkan = 94 Mute = 113 N = 49 ND102 = 86 New = 181 NextSong = 163 Num0 = 11 Num1 = 2 Num2 = 3 Num3 = 4 Num4 = 5 Num5 = 6 Num6 = 7 Num7 = 8 Num8 = 9 Num9 = 10 Numlock = 69 O = 24 Open = 134 P = 25 Pagedown = 109 Pageup = 104 Paste = 135 Pause = 119 PauseCd = 201 Pf2 = 60 Pf9 = 67 Phone = 169 PkpMinus = 74 Play = 207 PlayCd = 200 PlayPause = 164 Power = 116 PreviousSong = 165 Print = 210 Prog1 = 148 Prog2 = 149 Prog3 = 202 Prog4 = 203 Props = 130 Q = 16 Question = 214 R = 19 Record = 167 Redo = 182 Refresh = 173 Reply = 232 Reserved = 0 Rewind = 168 RfKill = 247 Right = 106 RightAlt = 100 RightBrace = 27 RightCtrl = 97 RightMeta = 126 RightMouse = 273 RightShift = 54 Ro = 89 RotateDisplay = 153 S = 31 Save = 234 Scale = 120 ScrollDown = 178 ScrollLock = 70 ScrollUp = 177 Search = 217 Semicolon = 39 Send = 231 Sendfile = 145 Setup = 141 Shop = 221 Slash = 53 Sleep = 142 Sound = 213 Space = 57 Sport = 220 Stop = 128 StopCd = 166 Suspend = 205 SwitchVideoMode = 227 SysRq = 99 T = 20 Tab = 15 ToolDoubleTap = 333 ToolFinger = 325 ToolQuadTap = 335 ToolQuintTap = 328 ToolTripleTap = 334 Touch = 330 U = 22 Undo = 131 Unknown = 240 Up = 103 Uwb = 239 V = 47 VideoNext = 241 VideoPrev = 242 VolumeDown = 114 VolumeUp = 115 W = 17 Wakeup = 143 Wlan = 238 Wwan = 246 Www = 150 X = 45 Xfer = 147 Y = 21 Yen = 124 Z = 44 Zenkakuhankaku = 85"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.EventType.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.EventType.html",
    "title": "Enum EventType",
    "keywords": "Enum EventType Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll public enum EventType Fields EV_ABS = 3 Used to describe absolute axis value changes, e.g. describing the coordinates of a touch on a touchscreen. EV_FF = 9 Used to send force feedback commands to an input device. EV_FF_STATUS = 11 Used to receive force feedback device status. EV_KEY = 1 Used to describe state changes of keyboards, buttons, or other key-like devices. EV_LED = 6 Used to turn LEDs on devices on and off. EV_MSC = 4 Used to describe miscellaneous input data that do not fit into other types. EV_PWR = 10 A special type for power button and switch input. EV_REL = 2 Used to describe relative axis value changes, e.g. moving the mouse 5 units to the left. EV_REP = 8 Used for autorepeating devices. EV_SND = 7 Used to output sound to devices. EV_SW = 5 Used to describe binary state input switches. EV_SYN = 0 Used as markers to separate events. Events may be separated in time or in space, such as with the multitouch protocol."
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.HidInput.RaiseDisconnected.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.HidInput.RaiseDisconnected.html",
    "title": "Delegate HidInput.RaiseDisconnected",
    "keywords": "Delegate HidInput.RaiseDisconnected Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll public delegate void HidInput.RaiseDisconnected()"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.HidInput.RaiseKeyPress.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.HidInput.RaiseKeyPress.html",
    "title": "Delegate HidInput.RaiseKeyPress",
    "keywords": "Delegate HidInput.RaiseKeyPress Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll public delegate void HidInput.RaiseKeyPress(KeyPressEvent e) Parameters e KeyPressEvent"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.HidInput.RaiseMouseMove.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.HidInput.RaiseMouseMove.html",
    "title": "Delegate HidInput.RaiseMouseMove",
    "keywords": "Delegate HidInput.RaiseMouseMove Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll public delegate void HidInput.RaiseMouseMove(MouseMoveEvent e) Parameters e MouseMoveEvent"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.HidInput.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.HidInput.html",
    "title": "Class HidInput",
    "keywords": "Class HidInput Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll public class HidInput : IDisposable Inheritance object HidInput Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors HidInput() public HidInput() Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Events OnButtonPress public event HidInput.RaiseKeyPress OnButtonPress Event Type HidInput.RaiseKeyPress OnDisconnected public event HidInput.RaiseDisconnected OnDisconnected Event Type HidInput.RaiseDisconnected OnMouseMove public event HidInput.RaiseMouseMove OnMouseMove Event Type HidInput.RaiseMouseMove"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.InputReader.RaiseData.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.InputReader.RaiseData.html",
    "title": "Delegate InputReader.RaiseData",
    "keywords": "Delegate InputReader.RaiseData Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll public delegate void InputReader.RaiseData(byte[] data) Parameters data byte[]"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.InputReader.RaiseDisconnected.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.InputReader.RaiseDisconnected.html",
    "title": "Delegate InputReader.RaiseDisconnected",
    "keywords": "Delegate InputReader.RaiseDisconnected Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll public delegate void InputReader.RaiseDisconnected()"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.InputReader.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.InputReader.html",
    "title": "Class InputReader",
    "keywords": "Class InputReader Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll public class InputReader : IDisposable Inheritance object InputReader Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors InputReader(string) public InputReader(string path) Parameters path string Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Events OnData public event InputReader.RaiseData OnData Event Type InputReader.RaiseData OnDisconnected public event InputReader.RaiseDisconnected OnDisconnected Event Type InputReader.RaiseDisconnected"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.KeyPressEvent.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.KeyPressEvent.html",
    "title": "Class KeyPressEvent",
    "keywords": "Class KeyPressEvent Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll public class KeyPressEvent : EventArgs Inheritance object EventArgs KeyPressEvent Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors KeyPressEvent(EventCode, KeyState) public KeyPressEvent(EventCode code, KeyState state) Parameters code EventCode state KeyState Properties Code public EventCode Code { get; } Property Value EventCode State public KeyState State { get; } Property Value KeyState"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.KeyState.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.KeyState.html",
    "title": "Enum KeyState",
    "keywords": "Enum KeyState Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll public enum KeyState Fields Down = 1 Hold = 2 Up = 0"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.MouseAxis.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.MouseAxis.html",
    "title": "Enum MouseAxis",
    "keywords": "Enum MouseAxis Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll public enum MouseAxis Fields X = 0 Y = 1"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.MouseMoveEvent.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.MouseMoveEvent.html",
    "title": "Class MouseMoveEvent",
    "keywords": "Class MouseMoveEvent Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll public class MouseMoveEvent : EventArgs Inheritance object EventArgs MouseMoveEvent Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors MouseMoveEvent(MouseAxis, int) public MouseMoveEvent(MouseAxis axis, int amount) Parameters axis MouseAxis amount int Properties Amount public int Amount { get; set; } Property Value int Axis public MouseAxis Axis { get; } Property Value MouseAxis"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.OnConnectionChanged.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.OnConnectionChanged.html",
    "title": "Delegate OnConnectionChanged",
    "keywords": "Delegate OnConnectionChanged Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll public delegate void OnConnectionChanged(UsbHostController sender, DeviceConnectionEventArgs e) Parameters sender UsbHostController e DeviceConnectionEventArgs"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.UsbHostController.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.UsbHostController.html",
    "title": "Class UsbHostController",
    "keywords": "Class UsbHostController Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll public class UsbHostController : IDisposable Inheritance object UsbHostController Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors UsbHostController() public UsbHostController() Methods Disable() public void Disable() Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Enable() public void Enable() Events OnConnectionChangedEvent public event OnConnectionChanged OnConnectionChangedEvent Event Type OnConnectionChanged"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.Webcam.FrameReceived.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.Webcam.FrameReceived.html",
    "title": "Delegate Webcam.FrameReceived",
    "keywords": "Delegate Webcam.FrameReceived Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll public delegate void Webcam.FrameReceived(Webcam sender, byte[] data) Parameters sender Webcam data byte[]"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.Webcam.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.Webcam.html",
    "title": "Class Webcam",
    "keywords": "Class Webcam Namespace GHIElectronics.Endpoint.Devices.UsbHost Assembly GHIElectronics.Endpoint.Devices.UsbHost.dll public class Webcam : IDisposable Inheritance object Webcam Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Webcam(string) public Webcam(string devicePath = \"/dev/video0\") Parameters devicePath string Properties Height public int Height { get; } Property Value int IsVideoStreaming public bool IsVideoStreaming { get; } Property Value bool Setting public CameraConfiguration Setting { get; set; } Property Value CameraConfiguration Width public int Width { get; } Property Value int Methods Capture() public byte[] Capture() Returns byte[] Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Dispose(bool) protected void Dispose(bool disposing) Parameters disposing bool GetResolution() public string[] GetResolution() Returns string[] VideoStreamStart() public void VideoStreamStart() VideoStreamStop() public void VideoStreamStop() Events FrameReceivedEvent public event Webcam.FrameReceived FrameReceivedEvent Event Type Webcam.FrameReceived"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.UsbHost.html",
    "title": "Namespace GHIElectronics.Endpoint.Devices.UsbHost",
    "keywords": "Namespace GHIElectronics.Endpoint.Devices.UsbHost Classes BaseDevice Represents a USB device connected. DeviceConnectionEventArgs HidInput InputReader KeyPressEvent MouseMoveEvent UsbHostController Webcam Enums DeviceConnectionStatus EventCode EventType KeyState MouseAxis Delegates HidInput.RaiseDisconnected HidInput.RaiseKeyPress HidInput.RaiseMouseMove InputReader.RaiseData InputReader.RaiseDisconnected OnConnectionChanged Webcam.FrameReceived"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Watchdog.WatchdogController.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Watchdog.WatchdogController.html",
    "title": "Class WatchdogController",
    "keywords": "Class WatchdogController Namespace GHIElectronics.Endpoint.Devices.Watchdog Assembly GHIElectronics.Endpoint.Devices.Watchdog.dll public class WatchdogController Inheritance object WatchdogController Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors WatchdogController() public WatchdogController() Properties MaxTimeout public uint MaxTimeout { get; } Property Value uint Timeout public uint Timeout { get; } Property Value uint Methods Reset() public void Reset() Start(uint) public bool Start(uint second) Parameters second uint Returns bool"
  },
  "endpoint/api/GHIElectronics.Endpoint.Devices.Watchdog.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Devices.Watchdog.html",
    "title": "Namespace GHIElectronics.Endpoint.Devices.Watchdog",
    "keywords": "Namespace GHIElectronics.Endpoint.Devices.Watchdog Classes WatchdogController"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.Bitmap.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.Bitmap.html",
    "title": "Class Bitmap",
    "keywords": "Class Bitmap Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll public class Bitmap : Image, ICloneable, IDisposable Inheritance object MarshalByRefObject Image Bitmap Implements ICloneable IDisposable Inherited Members Image.Width Image.Height Image.Clone() Image.Dispose(bool) Image.Dispose() Image.GetBitmap() Image.GetBitmap(int, int, int, int) Image.MakeTransparent(Color) MarshalByRefObject.GetLifetimeService() MarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Bitmap(byte[]) public Bitmap(byte[] buffer) Parameters buffer byte[] Bitmap(byte[], int, int) public Bitmap(byte[] data, int width, int height) Parameters data byte[] width int height int Bitmap(int, int) public Bitmap(int width, int height) Parameters width int height int Methods GetPixel(int, int) public override Color GetPixel(int x, int y) Parameters x int y int Returns Color SetPixel(int, int, Color) public override void SetPixel(int x, int y, Color color) Parameters x int y int color Color"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.Brush.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.Brush.html",
    "title": "Class Brush",
    "keywords": "Class Brush Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll public abstract class Brush : MarshalByRefObject, ICloneable, IDisposable Inheritance object MarshalByRefObject Brush Implements ICloneable IDisposable Derived SolidBrush Inherited Members MarshalByRefObject.GetLifetimeService() MarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Clone() Creates a new object that is a copy of the current instance. public abstract object Clone() Returns object A new object that is a copy of this instance. Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Dispose(bool) protected virtual void Dispose(bool disposing) Parameters disposing bool ~Brush() protected ~Brush()"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.Color.BitFormat.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.Color.BitFormat.html",
    "title": "Enum Color.BitFormat",
    "keywords": "Enum Color.BitFormat Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll public enum Color.BitFormat Fields Horizontal = 1 Vertical = 0"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.Color.ColorFormat.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.Color.ColorFormat.html",
    "title": "Enum Color.ColorFormat",
    "keywords": "Enum Color.ColorFormat Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll public enum Color.ColorFormat Fields Rgb332 = 4 Rgb444 = 3 Rgb565 = 2 Rgb888 = 1 Rgb8888 = 0"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.Color.RgbFormat.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.Color.RgbFormat.html",
    "title": "Enum Color.RgbFormat",
    "keywords": "Enum Color.RgbFormat Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll public enum Color.RgbFormat Fields Bgr = 1 Grg = 2 Rbg = 3 Rgb = 0"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.Color.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.Color.html",
    "title": "Struct Color",
    "keywords": "Struct Color Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll [Serializable] public struct Color Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Empty public static readonly Color Empty Field Value Color Properties A public byte A { get; } Property Value byte B public byte B { get; } Property Value byte Black public static Color Black { get; } Property Value Color Blue public static Color Blue { get; } Property Value Color G public byte G { get; } Property Value byte Gray public static Color Gray { get; } Property Value Color Green public static Color Green { get; } Property Value Color IsEmpty public bool IsEmpty { get; } Property Value bool Name public string Name { get; } Property Value string Purple public static Color Purple { get; } Property Value Color R public byte R { get; } Property Value byte Red public static Color Red { get; } Property Value Color Teal public static Color Teal { get; } Property Value Color Transparent public static Color Transparent { get; } Property Value Color White public static Color White { get; } Property Value Color Yellow public static Color Yellow { get; } Property Value Color Methods Convert(byte[], byte[], ColorFormat) public static void Convert(byte[] inArray, byte[] outArray, Color.ColorFormat colorFormat) Parameters inArray byte[] outArray byte[] colorFormat Color.ColorFormat Convert(byte[], byte[], ColorFormat, RgbFormat) public static void Convert(byte[] inArray, byte[] outArray, Color.ColorFormat colorFormat, Color.RgbFormat rgbFormat) Parameters inArray byte[] outArray byte[] colorFormat Color.ColorFormat rgbFormat Color.RgbFormat Convert(byte[], byte[], ColorFormat, RgbFormat, byte) public static void Convert(byte[] inArray, byte[] outArray, Color.ColorFormat colorFormat, Color.RgbFormat rgbFormat, byte alpha) Parameters inArray byte[] outArray byte[] colorFormat Color.ColorFormat rgbFormat Color.RgbFormat alpha byte Convert(byte[], byte[], ColorFormat, RgbFormat, byte, byte[]) public static void Convert(byte[] inArray, byte[] outArray, Color.ColorFormat colorFormat, Color.RgbFormat rgbFormat, byte alpha, byte[] colorTable) Parameters inArray byte[] outArray byte[] colorFormat Color.ColorFormat rgbFormat Color.RgbFormat alpha byte colorTable byte[] ConvertTo1Bpp(byte[], byte[], uint) public static void ConvertTo1Bpp(byte[] inArray, byte[] outArray, uint width) Parameters inArray byte[] outArray byte[] width uint ConvertTo1Bpp(byte[], byte[], uint, BitFormat) public static void ConvertTo1Bpp(byte[] inArray, byte[] outArray, uint width, Color.BitFormat bitFormat) Parameters inArray byte[] outArray byte[] width uint bitFormat Color.BitFormat Equals(object) Indicates whether this instance and a specified object are equal. public override bool Equals(object obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. FromArgb(int) public static Color FromArgb(int argb) Parameters argb int Returns Color FromArgb(int, Color) public static Color FromArgb(int alpha, Color baseColor) Parameters alpha int baseColor Color Returns Color FromArgb(int, int, int) public static Color FromArgb(int red, int green, int blue) Parameters red int green int blue int Returns Color FromArgb(int, int, int, int) public static Color FromArgb(int alpha, int red, int green, int blue) Parameters alpha int red int green int blue int Returns Color GetBrightness() public float GetBrightness() Returns float GetHashCode() Returns the hash code for this instance. public override int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. GetHue() public float GetHue() Returns float GetSaturation() public float GetSaturation() Returns float ToArgb() public int ToArgb() Returns int ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name. Operators operator ==(Color, Color) public static bool operator ==(Color left, Color right) Parameters left Color right Color Returns bool operator !=(Color, Color) public static bool operator !=(Color left, Color right) Parameters left Color right Color Returns bool"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.Drawing2D.PenType.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.Drawing2D.PenType.html",
    "title": "Enum PenType",
    "keywords": "Enum PenType Namespace GHIElectronics.Endpoint.Drawing.Drawing2D Assembly GHIElectronics.Endpoint.Drawing.dll public enum PenType Fields SolidColor = 0"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.Drawing2D.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.Drawing2D.html",
    "title": "Namespace GHIElectronics.Endpoint.Drawing.Drawing2D",
    "keywords": "Namespace GHIElectronics.Endpoint.Drawing.Drawing2D Enums PenType"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.Font.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.Font.html",
    "title": "Class Font",
    "keywords": "Class Font Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll public sealed class Font : MarshalByRefObject, IDisposable Inheritance object MarshalByRefObject Font Implements IDisposable Inherited Members MarshalByRefObject.GetLifetimeService() MarshalByRefObject.InitializeLifetimeService() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors Font() public Font() Font(byte[]) public Font(byte[] data) Parameters data byte[] Font(byte[], int, int) public Font(byte[] data, int offset, int count) Parameters data byte[] offset int count int Font(int) public Font(int size) Parameters size int Properties Height public int Height { get; } Property Value int SkFont public SKFont SkFont { get; } Property Value SKFont Unit public GraphicsUnit Unit { get; } Property Value GraphicsUnit Methods ComputeExtent(string, out int, out int) public void ComputeExtent(string text, out int width, out int height) Parameters text string width int height int ComputeTextInRect(string, out int, out int) public void ComputeTextInRect(string text, out int renderWidth, out int renderHeight) Parameters text string renderWidth int renderHeight int ComputeTextInRect(string, out int, out int, int) public void ComputeTextInRect(string text, out int renderWidth, out int renderHeight, int availableWidth) Parameters text string renderWidth int renderHeight int availableWidth int CountCharactersInWidth(string, int, int, ref int, bool, ref string, ref int) public void CountCharactersInWidth(string text, int maxChars, int width, ref int totWidth, bool fWordWrap, ref string strNext, ref int numChars) Parameters text string maxChars int width int totWidth int fWordWrap bool strNext string numChars int Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() ~Font() protected ~Font()"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.Graphics.DrawTextAlignment.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.Graphics.DrawTextAlignment.html",
    "title": "Enum Graphics.DrawTextAlignment",
    "keywords": "Enum Graphics.DrawTextAlignment Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll public enum Graphics.DrawTextAlignment : uint Fields AlignmentCenter = 2 AlignmentLeft = 0 AlignmentMask = 34 AlignmentRight = 32 Ellipsis = 8 IgnoreHeight = 16 None = 0 TrimmingCharacterEllipsis = 64 TrimmingMask = 72 TrimmingNone = 0 TrimmingWordEllipsis = 8 TruncateAtBottom = 4 WordWrap = 1"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.Graphics.OnFlushHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.Graphics.OnFlushHandler.html",
    "title": "Delegate Graphics.OnFlushHandler",
    "keywords": "Delegate Graphics.OnFlushHandler Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll public delegate void Graphics.OnFlushHandler(Graphics sender, byte[] data, int x, int y, int width, int height, int originalWidth) Parameters sender Graphics data byte[] x int y int width int height int originalWidth int"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.Graphics.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.Graphics.html",
    "title": "Class Graphics",
    "keywords": "Class Graphics Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll public class Graphics : MarshalByRefObject, IDisposable Inheritance object MarshalByRefObject Graphics Implements IDisposable Inherited Members MarshalByRefObject.GetLifetimeService() MarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Height public int Height { get; } Property Value int PageUnit public GraphicsUnit PageUnit { get; } Property Value GraphicsUnit Width public int Width { get; } Property Value int Methods Clear() public void Clear() Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() DrawEllipse(Pen, int, int, int, int) public void DrawEllipse(Pen pen, int x, int y, int width, int height) Parameters pen Pen x int y int width int height int DrawImage(Image, Rectangle, Rectangle, GraphicsUnit) public void DrawImage(Image image, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit) Parameters image Image destRect Rectangle srcRect Rectangle srcUnit GraphicsUnit DrawImage(Image, int, int) public void DrawImage(Image image, int x, int y) Parameters image Image x int y int DrawImage(Image, int, int, Rectangle, GraphicsUnit) public void DrawImage(Image image, int x, int y, Rectangle srcRect, GraphicsUnit srcUnit) Parameters image Image x int y int srcRect Rectangle srcUnit GraphicsUnit DrawImage(Image, int, int, int, int) public void DrawImage(Image image, int x, int y, int width, int height) Parameters image Image x int y int width int height int DrawImage(int, int, Image, int, int, int, int, ushort) public void DrawImage(int xDst, int yDst, Image image, int xSrc, int ySrc, int width, int height, ushort opacity) Parameters xDst int yDst int image Image xSrc int ySrc int width int height int opacity ushort DrawLine(Pen, int, int, int, int) public void DrawLine(Pen pen, int x1, int y1, int x2, int y2) Parameters pen Pen x1 int y1 int x2 int y2 int DrawRectangle(Pen, int, int, int, int) public void DrawRectangle(Pen pen, int x, int y, int width, int height) Parameters pen Pen x int y int width int height int DrawString(string, Font, Brush, RectangleF) public void DrawString(string s, Font font, Brush brush, RectangleF layoutRectangle) Parameters s string font Font brush Brush layoutRectangle RectangleF DrawString(string, Font, Brush, RectangleF, StringFormat) public void DrawString(string s, Font font, Brush brush, RectangleF layoutRectangle, StringFormat format) Parameters s string font Font brush Brush layoutRectangle RectangleF format StringFormat DrawString(string, Font, Brush, float, float) public void DrawString(string s, Font font, Brush brush, float x, float y) Parameters s string font Font brush Brush x float y float DrawTextInRect(string, int, int, int, int, DrawTextAlignment, Color, Font) public void DrawTextInRect(string text, int x, int y, int width, int height, Graphics.DrawTextAlignment dtFlags, Color color, Font font) Parameters text string x int y int width int height int dtFlags Graphics.DrawTextAlignment color Color font Font DrawTextInRect(ref string, ref int, ref int, int, int, int, int, DrawTextAlignment, Color, Font) public bool DrawTextInRect(ref string text, ref int xRelStart, ref int yRelStart, int x, int y, int width, int height, Graphics.DrawTextAlignment dtFlags, Color color, Font font) Parameters text string xRelStart int yRelStart int x int y int width int height int dtFlags Graphics.DrawTextAlignment color Color font Font Returns bool FillEllipse(Brush, int, int, int, int) public void FillEllipse(Brush brush, int x, int y, int width, int height) Parameters brush Brush x int y int width int height int FillRectangle(Brush, int, int, int, int) public void FillRectangle(Brush brush, int x, int y, int width, int height) Parameters brush Brush x int y int width int height int ~Graphics() protected ~Graphics() Flush(int, int, int, int) public void Flush(int x, int y, int width, int height) Parameters x int y int width int height int FromData(byte[]) public static Graphics FromData(byte[] data) Parameters data byte[] Returns Graphics FromData(byte[], int, int) public static Graphics FromData(byte[] data, int width, int height) Parameters data byte[] width int height int Returns Graphics FromImage(Image) public static Graphics FromImage(Image image) Parameters image Image Returns Graphics GetBitmap() public byte[] GetBitmap() Returns byte[] GetBitmap(int, int, int, int) public byte[] GetBitmap(int x, int y, int width, int height) Parameters x int y int width int height int Returns byte[] GetPixel(int, int) public uint GetPixel(int x, int y) Parameters x int y int Returns uint MakeTransparent(Color) public void MakeTransparent(Color color) Parameters color Color MeasureString(string, Font) public SizeF MeasureString(string text, Font font) Parameters text string font Font Returns SizeF MeasureString(string, Font, SizeF, StringFormat) public SizeF MeasureString(string text, Font font, SizeF layoutArea, StringFormat stringFormat) Parameters text string font Font layoutArea SizeF stringFormat StringFormat Returns SizeF RotateImage(int, int, int, Image, int, int, int, int, ushort) public void RotateImage(int angle, int xDst, int yDst, Image image, int xSrc, int ySrc, int width, int height, ushort opacity) Parameters angle int xDst int yDst int image Image xSrc int ySrc int width int height int opacity ushort Scale9Image(int, int, int, int, Image, int, int, int, int, ushort) public void Scale9Image(int xDst, int yDst, int widthDst, int heightDst, Image image, int leftBorder, int topBorder, int rightBorder, int bottomBorder, ushort opacity) Parameters xDst int yDst int widthDst int heightDst int image Image leftBorder int topBorder int rightBorder int bottomBorder int opacity ushort SetClippingRectangle(int, int, int, int) public void SetClippingRectangle(int x, int y, int width, int height) Parameters x int y int width int height int SetPixel(int, int, Color) public void SetPixel(int x, int y, Color color) Parameters x int y int color Color StretchImage(int, int, int, int, Image, int, int, int, int, ushort) public void StretchImage(int xDst, int yDst, int widthDst, int heightDst, Image image, int xSrc, int ySrc, int widthSrc, int heightSrc, ushort opacity) Parameters xDst int yDst int widthDst int heightDst int image Image xSrc int ySrc int widthSrc int heightSrc int opacity ushort TileImage(int, int, Image, int, int, ushort) public void TileImage(int xDst, int yDst, Image image, int width, int height, ushort opacity) Parameters xDst int yDst int image Image width int height int opacity ushort Events OnFlushEvent public static event Graphics.OnFlushHandler OnFlushEvent Event Type Graphics.OnFlushHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.GraphicsUnit.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.GraphicsUnit.html",
    "title": "Enum GraphicsUnit",
    "keywords": "Enum GraphicsUnit Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll public enum GraphicsUnit Fields Display = 1 Document = 5 Inch = 4 Millimeter = 6 Pixel = 2 Point = 3 World = 0"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.Image.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.Image.html",
    "title": "Class Image",
    "keywords": "Class Image Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll [Serializable] public abstract class Image : MarshalByRefObject, ICloneable, IDisposable Inheritance object MarshalByRefObject Image Implements ICloneable IDisposable Derived Bitmap Inherited Members MarshalByRefObject.GetLifetimeService() MarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Height public int Height { get; } Property Value int Width public int Width { get; } Property Value int Methods Clone() Creates a new object that is a copy of the current instance. public object Clone() Returns object A new object that is a copy of this instance. Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Dispose(bool) protected virtual void Dispose(bool disposing) Parameters disposing bool ~Image() protected ~Image() GetBitmap() public byte[] GetBitmap() Returns byte[] GetBitmap(int, int, int, int) public byte[] GetBitmap(int x, int y, int width, int height) Parameters x int y int width int height int Returns byte[] GetPixel(int, int) public virtual Color GetPixel(int x, int y) Parameters x int y int Returns Color MakeTransparent(Color) public void MakeTransparent(Color color) Parameters color Color SetPixel(int, int, Color) public virtual void SetPixel(int x, int y, Color color) Parameters x int y int color Color"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.Imaging.ImageFormat.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.Imaging.ImageFormat.html",
    "title": "Class ImageFormat",
    "keywords": "Class ImageFormat Namespace GHIElectronics.Endpoint.Drawing.Imaging Assembly GHIElectronics.Endpoint.Drawing.dll public sealed class ImageFormat Inheritance object ImageFormat Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ImageFormat(Guid) public ImageFormat(Guid guid) Parameters guid Guid Properties Bmp public static ImageFormat Bmp { get; } Property Value ImageFormat Emf public static ImageFormat Emf { get; } Property Value ImageFormat Exif public static ImageFormat Exif { get; } Property Value ImageFormat Gif public static ImageFormat Gif { get; } Property Value ImageFormat Guid public Guid Guid { get; } Property Value Guid Icon public static ImageFormat Icon { get; } Property Value ImageFormat Jpeg public static ImageFormat Jpeg { get; } Property Value ImageFormat Png public static ImageFormat Png { get; } Property Value ImageFormat RawBitmap public static ImageFormat RawBitmap { get; } Property Value ImageFormat Tiff public static ImageFormat Tiff { get; } Property Value ImageFormat Wmf public static ImageFormat Wmf { get; } Property Value ImageFormat Methods Equals(object) Determines whether the specified object is equal to the current object. public override bool Equals(object o) Parameters o object Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object. ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object."
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.Imaging.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.Imaging.html",
    "title": "Namespace GHIElectronics.Endpoint.Drawing.Imaging",
    "keywords": "Namespace GHIElectronics.Endpoint.Drawing.Imaging Classes ImageFormat"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.Pen.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.Pen.html",
    "title": "Class Pen",
    "keywords": "Class Pen Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll public sealed class Pen : MarshalByRefObject, ICloneable, IDisposable Inheritance object MarshalByRefObject Pen Implements ICloneable IDisposable Inherited Members MarshalByRefObject.GetLifetimeService() MarshalByRefObject.InitializeLifetimeService() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors Pen(Brush) public Pen(Brush brush) Parameters brush Brush Pen(Brush, float) public Pen(Brush brush, float width) Parameters brush Brush width float Pen(Color) public Pen(Color color) Parameters color Color Pen(Color, float) public Pen(Color color, float width) Parameters color Color width float Properties Brush public Brush Brush { get; set; } Property Value Brush Color public Color Color { get; set; } Property Value Color PenType public PenType PenType { get; } Property Value PenType Width public float Width { get; set; } Property Value float Methods Clone() Creates a new object that is a copy of the current instance. public object Clone() Returns object A new object that is a copy of this instance. Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose()"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.Rectangle.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.Rectangle.html",
    "title": "Struct Rectangle",
    "keywords": "Struct Rectangle Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll public struct Rectangle Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors Rectangle(int, int, int, int) public Rectangle(int x, int y, int width, int height) Parameters x int y int width int height int Properties Height public int Height { readonly get; set; } Property Value int Width public int Width { readonly get; set; } Property Value int X public int X { readonly get; set; } Property Value int Y public int Y { readonly get; set; } Property Value int"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.RectangleF.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.RectangleF.html",
    "title": "Struct RectangleF",
    "keywords": "Struct RectangleF Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll public struct RectangleF Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors RectangleF(float, float, float, float) public RectangleF(float x, float y, float width, float height) Parameters x float y float width float height float Properties Height public float Height { readonly get; set; } Property Value float Width public float Width { readonly get; set; } Property Value float X public float X { readonly get; set; } Property Value float Y public float Y { readonly get; set; } Property Value float"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.SizeF.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.SizeF.html",
    "title": "Struct SizeF",
    "keywords": "Struct SizeF Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll public struct SizeF Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors SizeF(SizeF) public SizeF(SizeF size) Parameters size SizeF SizeF(float, float) public SizeF(float width, float height) Parameters width float height float Fields Empty public static readonly SizeF Empty Field Value SizeF Properties Height public float Height { readonly get; set; } Property Value float IsEmpty public bool IsEmpty { get; } Property Value bool Width public float Width { readonly get; set; } Property Value float"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.SolidBrush.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.SolidBrush.html",
    "title": "Class SolidBrush",
    "keywords": "Class SolidBrush Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll public class SolidBrush : Brush, ICloneable, IDisposable Inheritance object MarshalByRefObject Brush SolidBrush Implements ICloneable IDisposable Inherited Members Brush.Dispose() Brush.Dispose(bool) MarshalByRefObject.GetLifetimeService() MarshalByRefObject.InitializeLifetimeService() MarshalByRefObject.MemberwiseClone(bool) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SolidBrush(Color) public SolidBrush(Color color) Parameters color Color Properties Color public Color Color { get; set; } Property Value Color Methods Clone() Creates a new object that is a copy of the current instance. public override object Clone() Returns object A new object that is a copy of this instance."
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.StringAlignment.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.StringAlignment.html",
    "title": "Enum StringAlignment",
    "keywords": "Enum StringAlignment Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll public enum StringAlignment Fields Center = 1 Far = 2 Near = 0"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.StringFormat.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.StringFormat.html",
    "title": "Class StringFormat",
    "keywords": "Class StringFormat Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll public sealed class StringFormat Inheritance object StringFormat Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties Alignment public StringAlignment Alignment { get; set; } Property Value StringAlignment FormatFlags public StringFormatFlags FormatFlags { get; set; } Property Value StringFormatFlags Trimming public StringTrimming Trimming { get; set; } Property Value StringTrimming"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.StringFormatFlags.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.StringFormatFlags.html",
    "title": "Enum StringFormatFlags",
    "keywords": "Enum StringFormatFlags Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll [Flags] public enum StringFormatFlags Fields DirectionRightToLeft = 1 DirectionVertical = 2 DisplayFormatControl = 32 FitBlackBox = 4 LineLimit = 8192 MeasureTrailingSpaces = 2048 NoClip = 16384 NoFontFallback = 1024 NoWrap = 4096"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.StringTrimming.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.StringTrimming.html",
    "title": "Enum StringTrimming",
    "keywords": "Enum StringTrimming Namespace GHIElectronics.Endpoint.Drawing Assembly GHIElectronics.Endpoint.Drawing.dll public enum StringTrimming Fields Character = 1 EllipsisCharacter = 3 EllipsisPath = 5 EllipsisWord = 4 None = 0 Word = 2"
  },
  "endpoint/api/GHIElectronics.Endpoint.Drawing.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Drawing.html",
    "title": "Namespace GHIElectronics.Endpoint.Drawing",
    "keywords": "Namespace GHIElectronics.Endpoint.Drawing Classes Bitmap Brush Font Graphics Image Pen SolidBrush StringFormat Structs Color Rectangle RectangleF SizeF Enums Color.BitFormat Color.ColorFormat Color.RgbFormat Graphics.DrawTextAlignment GraphicsUnit StringAlignment StringFormatFlags StringTrimming Delegates Graphics.OnFlushHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.FileSystem.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.FileSystem.html",
    "title": "Class FileSystem",
    "keywords": "Class FileSystem Namespace GHIElectronics.Endpoint Assembly GHIElectronics.Endpoint.FileSystem.dll public static class FileSystem Inheritance object FileSystem Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Flush() public static void Flush() Mount(string) public static string Mount(string deviceName) Parameters deviceName string Returns string Unmount(string) public static void Unmount(string path) Parameters path string"
  },
  "endpoint/api/GHIElectronics.Endpoint.Native.DeviceInformation.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Native.DeviceInformation.html",
    "title": "Class DeviceInformation",
    "keywords": "Class DeviceInformation Namespace GHIElectronics.Endpoint.Native Assembly GHIElectronics.Endpoint.Native.dll public static class DeviceInformation Inheritance object DeviceInformation Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Version public static string Version { get; } Property Value string Methods DisableAutoRun() public static void DisableAutoRun() DisableSSH() public static void DisableSSH() EnableAutoRun(string) public static void EnableAutoRun(string applicationName) Parameters applicationName string SdBoot() public static bool SdBoot() Returns bool"
  },
  "endpoint/api/GHIElectronics.Endpoint.Native.Power.WakeupPin.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Native.Power.WakeupPin.html",
    "title": "Enum Power.WakeupPin",
    "keywords": "Enum Power.WakeupPin Namespace GHIElectronics.Endpoint.Native Assembly GHIElectronics.Endpoint.Native.dll public enum Power.WakeupPin : uint Fields None = 255 PA0 = 0 PA2 = 1 PC1 = 5 PC13 = 2 PI11 = 4 PI8 = 3"
  },
  "endpoint/api/GHIElectronics.Endpoint.Native.Power.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Native.Power.html",
    "title": "Class Power",
    "keywords": "Class Power Namespace GHIElectronics.Endpoint.Native Assembly GHIElectronics.Endpoint.Native.dll public static class Power Inheritance object Power Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods EnableWakeup(WakeupPin, PinEventTypes) public static void EnableWakeup(Power.WakeupPin wakeupPin, PinEventTypes edge) Parameters wakeupPin Power.WakeupPin edge PinEventTypes EnableWakeup(DateTime, WakeupPin, PinEventTypes) public static void EnableWakeup(DateTime dtWakeup, Power.WakeupPin wakeupPin = WakeupPin.None, PinEventTypes edge = PinEventTypes.Rising) Parameters dtWakeup DateTime wakeupPin Power.WakeupPin edge PinEventTypes Reboot() public static void Reboot() Shutdown() public static void Shutdown()"
  },
  "endpoint/api/GHIElectronics.Endpoint.Native.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Native.html",
    "title": "Namespace GHIElectronics.Endpoint.Native",
    "keywords": "Namespace GHIElectronics.Endpoint.Native Classes DeviceInformation Power Enums Power.WakeupPin"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Application.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Application.html",
    "title": "Class Application",
    "keywords": "Class Application Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll Application base class public class Application : DispatcherObject Inheritance object DispatcherObject Application Inherited Members DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Application(int, int) Application constructor public Application(int width, int height) Parameters width int height int Properties Current The Current property enables the developer to always get to the application in AppDomain in which they are running. public static Application Current { get; } Property Value Application Height public int Height { get; } Property Value int InputProvider public InputProvider InputProvider { get; } Property Value InputProvider MainWindow The MainWindow property indicates the primary window of the application. public Window MainWindow { get; set; } Property Value Window Remarks By default - MainWindow will be set to the first window opened in the application. However the MainWindow may be set programmatically to indicate \"this is my main window\". It is a recommended programming style to refer to MainWindow in code instead of Windows[0]. ShutdownMode The ShutdownMode property is called to set the shutdown specific mode of the application. Setting this property controls the way in which an application will shutdown. The three values for the ShutdownMode enum are : OnLastWindowClose OnMainWindowClose OnExplicitShutdown OnLastWindowClose - this mode will shutdown the application when the last window is closed, or an explicit call is made to Application.Shutdown(). This is the default mode. OnMainWindowClose - this mode will shutdown the application when the main window has been closed, or Application.Shutdown() is called. Note that if the MainWindow property has not been set - this mode is equivalent to OnExplicitOnly. OnExplicitShutdown- this mode will shutdown the application only when an explicit call to OnShutdown() has been made. public ShutdownMode ShutdownMode { get; set; } Property Value ShutdownMode Width public int Width { get; } Property Value int Windows The Windows property exposes a WindowCollection object, from which a developer can iterate over all the windows that have been opened in the current application. public WindowCollection Windows { get; } Property Value WindowCollection Methods InitializeForEventSource() public void InitializeForEventSource() OnEvent(BaseEvent) public bool OnEvent(BaseEvent ev) Parameters ev BaseEvent Returns bool OnExit(EventArgs) OnExit is called to raise the Exit event. The developer will typically override this method if they want to take action when the application exits ( or they may choose to attach an event). protected virtual void OnExit(EventArgs e) Parameters e EventArgs The event args that will be passed to the Exit event Remarks This method follows the .Net programming guideline of having a protected virtual method that raises an event, to provide a convenience for developers that subclass the event. If you override this method - you need to call Base.OnExit(...) for the corresponding event to be raised. OnStartup(EventArgs) OnStartup is called to raise the Startup event. The developer will typically override this method if they want to take action at startup time ( or they may choose to attach an event). This method will be called once when the application begins, once that application's Run() method has been called. protected virtual void OnStartup(EventArgs e) Parameters e EventArgs The event args that will be passed to the Startup event Remarks This method follows the .Net programming guideline of having a protected virtual method that raises an event, to provide a convenience for developers that subclass the event. If you override this method - you need to call Base.OnStartup(...) for the corresponding event to be raised. Run() Run is called to start an application. Typically a developer will do some setting of properties/attaching to events after instantiating an application object, and then call Run() to start the application. public void Run() Remarks Once run has been called - an application's OnStartup override and Startup event is called immediately afterwards. Run(Window) Run is called to start an application. Typically a developer will do some setting of properties/attaching to events after instantiating an application object, and then call Run() to start the application. public void Run(Window window) Parameters window Window Window that will be added to the Windows property and made the MainWindow of the Applcation. The passed Window must be created on the same thread as the Application object. Furthermore, this Window is shown once the Application is run. Remarks Once run has been called - an application's OnStartup override and Startup event is called immediately afterwards. Shutdown() Shutdown is called to programmatically shutdown an application. Once shutdown() is called, the application gets called with the OnShutdown method to raise the Shutdown event. public void Shutdown() Events Exit The Exit event is fired when an application is shutting down. This event is raised by the OnExit method. public event EventHandler Exit Event Type EventHandler Startup The Startup event is fired when an application is starting. This event is raised by the OnStartup method. public event EventHandler Startup Event Type EventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.CancelEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.CancelEventArgs.html",
    "title": "Class CancelEventArgs",
    "keywords": "Class CancelEventArgs Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll public class CancelEventArgs : EventArgs Inheritance object EventArgs CancelEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields Cancel public bool Cancel Field Value bool"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.CancelEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.CancelEventHandler.html",
    "title": "Delegate CancelEventHandler",
    "keywords": "Delegate CancelEventHandler Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll public delegate void CancelEventHandler(object sender, CancelEventArgs e) Parameters sender object e CancelEventArgs"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Border.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Border.html",
    "title": "Class Border",
    "keywords": "Class Border Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class Border : ContentControl Inheritance object DispatcherObject UIElement Control ContentControl Border Inherited Members ContentControl.Child Control.Background Control.Font Control.Foreground Control._background Control._foreground Control._font UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Border() public Border() Properties BorderBrush public Brush BorderBrush { get; set; } Property Value Brush Methods ArrangeOverride(int, int) ArrangeOverride allows for the customization of the final sizing and positioning of children. protected override void ArrangeOverride(int arrangeWidth, int arrangeHeight) Parameters arrangeWidth int Final width arrangeHeight int Final height Remarks UIElement authors should override this method, call Arrange on each visible child UIElement, to size and position each child UIElement by passing a rectangle reserved for the child within parent space. Note: It is required that a parent UIElement calls Arrange on each child or they won't be rendered. Typical override follows a pattern roughly like this (pseudo-code): protected override void ArrangeOverride(int arrangeWidth, int arrangeHeight) { foreach (UIElement child in VisualChildren) { child.Arrange(new Rect(childX, childY, childWidth, childHeight); } }</code></pre></example> GetBorderThickness(out int, out int, out int, out int) public void GetBorderThickness(out int left, out int top, out int right, out int bottom) Parameters left int top int right int bottom int MeasureOverride(int, int, out int, out int) Measurement override. Implement your size-to-content logic here. protected override void MeasureOverride(int availableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) Parameters availableWidth int Available size that parent can give to the child. May be MaxValue(when parent wants to measure to content). This is soft constraint. Child can return bigger size to indicate that it wants bigger space and hope that parent can throw in scrolling... availableHeight int desiredWidth int desiredHeight int Remarks MeasureOverride is designed to be the main customizability point for size control of layout. UIElement authors should override this method, call Measure on each child UIElement, and compute their desired size based upon the measurement of the children. The return value should be the desired size. Note: It is required that a parent UIElement calls Measure on each child or they won't be sized/arranged. Typical override follows a pattern roughly like this (pseudo-code): protected override void MeasureOverride(int avialableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) { foreach (UIElement child in VisualChildren) { child.Measure(availableSize); availableSize.Deflate(child.DesiredSize); _cache.StoreInfoAboutChild(child); } Size desired = CalculateBasedOnCache(_cache); return desired; }</code></pre></example> The key aspects of this snippet are: You must call Measure on each child UIElement It is common to cache measurement information between the MeasureOverride and ArrangeOverride method calls Calling base.MeasureOverride is not required. Calls to Measure on children are passing either the same availableSize as the parent, or a subset of the area depending on the type of layout the parent will perform (for example, it would be valid to remove the area for some border or padding). OnRender(DrawingContext) public override void OnRender(DrawingContext dc) Parameters dc DrawingContext SetBorderThickness(int) public void SetBorderThickness(int length) Parameters length int SetBorderThickness(int, int, int, int) public void SetBorderThickness(int left, int top, int right, int bottom) Parameters left int top int right int bottom int"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Button.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Button.html",
    "title": "Class Button",
    "keywords": "Class Button Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class Button : ContentControl, IDisposable Inheritance object DispatcherObject UIElement Control ContentControl Button Implements IDisposable Inherited Members ContentControl.Child ContentControl.MeasureOverride(int, int, out int, out int) Control.Background Control.Font Control.Foreground Control._background Control._foreground Control._font UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Button() public Button() Properties Alpha public ushort Alpha { get; set; } Property Value ushort IsPressed public bool IsPressed { get; } Property Value bool RadiusBorder public int RadiusBorder { get; set; } Property Value int Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Dispose(bool) protected virtual void Dispose(bool disposing) Parameters disposing bool ~Button() protected ~Button() OnRender(DrawingContext) public override void OnRender(DrawingContext dc) Parameters dc DrawingContext OnTouchDown(TouchEventArgs) protected override void OnTouchDown(TouchEventArgs e) Parameters e TouchEventArgs OnTouchUp(TouchEventArgs) protected override void OnTouchUp(TouchEventArgs e) Parameters e TouchEventArgs Events Click public event RoutedEventHandler Click Event Type RoutedEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Canvas.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Canvas.html",
    "title": "Class Canvas",
    "keywords": "Class Canvas Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class Canvas : Panel Inheritance object DispatcherObject UIElement Panel Canvas Derived MessageBox WindowManager Inherited Members Panel.Children UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.OnRender(DrawingContext) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Canvas() public Canvas() Methods ArrangeOverride(int, int) ArrangeOverride allows for the customization of the final sizing and positioning of children. protected override void ArrangeOverride(int arrangeWidth, int arrangeHeight) Parameters arrangeWidth int Final width arrangeHeight int Final height Remarks UIElement authors should override this method, call Arrange on each visible child UIElement, to size and position each child UIElement by passing a rectangle reserved for the child within parent space. Note: It is required that a parent UIElement calls Arrange on each child or they won't be rendered. Typical override follows a pattern roughly like this (pseudo-code): protected override void ArrangeOverride(int arrangeWidth, int arrangeHeight) { foreach (UIElement child in VisualChildren) { child.Arrange(new Rect(childX, childY, childWidth, childHeight); } }</code></pre></example> GetBottom(UIElement) public static int GetBottom(UIElement e) Parameters e UIElement Returns int GetLeft(UIElement) public static int GetLeft(UIElement e) Parameters e UIElement Returns int GetRight(UIElement) public static int GetRight(UIElement e) Parameters e UIElement Returns int GetTop(UIElement) public static int GetTop(UIElement e) Parameters e UIElement Returns int MeasureOverride(int, int, out int, out int) Measurement override. Implement your size-to-content logic here. protected override void MeasureOverride(int availableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) Parameters availableWidth int Available size that parent can give to the child. May be MaxValue(when parent wants to measure to content). This is soft constraint. Child can return bigger size to indicate that it wants bigger space and hope that parent can throw in scrolling... availableHeight int desiredWidth int desiredHeight int Remarks MeasureOverride is designed to be the main customizability point for size control of layout. UIElement authors should override this method, call Measure on each child UIElement, and compute their desired size based upon the measurement of the children. The return value should be the desired size. Note: It is required that a parent UIElement calls Measure on each child or they won't be sized/arranged. Typical override follows a pattern roughly like this (pseudo-code): protected override void MeasureOverride(int avialableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) { foreach (UIElement child in VisualChildren) { child.Measure(availableSize); availableSize.Deflate(child.DesiredSize); _cache.StoreInfoAboutChild(child); } Size desired = CalculateBasedOnCache(_cache); return desired; }</code></pre></example> The key aspects of this snippet are: You must call Measure on each child UIElement It is common to cache measurement information between the MeasureOverride and ArrangeOverride method calls Calling base.MeasureOverride is not required. Calls to Measure on children are passing either the same availableSize as the parent, or a subset of the area depending on the type of layout the parent will perform (for example, it would be valid to remove the area for some border or padding). SetBottom(UIElement, int) public static void SetBottom(UIElement e, int bottom) Parameters e UIElement bottom int SetLeft(UIElement, int) public static void SetLeft(UIElement e, int left) Parameters e UIElement left int SetRight(UIElement, int) public static void SetRight(UIElement e, int right) Parameters e UIElement right int SetTop(UIElement, int) public static void SetTop(UIElement e, int top) Parameters e UIElement top int"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Chart.ChartMode.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Chart.ChartMode.html",
    "title": "Enum Chart.ChartMode",
    "keywords": "Enum Chart.ChartMode Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public enum Chart.ChartMode Fields LineMode = 0 RectangleMode = 1"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Chart.DataItem.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Chart.DataItem.html",
    "title": "Class Chart.DataItem",
    "keywords": "Class Chart.DataItem Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class Chart.DataItem Inheritance object Chart.DataItem Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Name public string Name { get; set; } Property Value string Value public double Value { get; set; } Property Value double"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Chart.Point.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Chart.Point.html",
    "title": "Class Chart.Point",
    "keywords": "Class Chart.Point Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class Chart.Point Inheritance object Chart.Point Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Point() public Point() Point(int, int) public Point(int ax, int ay) Parameters ax int ay int Properties X public int X { get; set; } Property Value int Y public int Y { get; set; } Property Value int"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Chart.PointF.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Chart.PointF.html",
    "title": "Class Chart.PointF",
    "keywords": "Class Chart.PointF Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class Chart.PointF Inheritance object Chart.PointF Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PointF(float, float) public PointF(float ax, float ay) Parameters ax float ay float Properties X public float X { get; set; } Property Value float Y public float Y { get; set; } Property Value float"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Chart.PointModel.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Chart.PointModel.html",
    "title": "Class Chart.PointModel",
    "keywords": "Class Chart.PointModel Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class Chart.PointModel Inheritance object Chart.PointModel Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Point public Chart.Point Point { get; set; } Property Value Chart.Point Value public double Value { get; set; } Property Value double"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Chart.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Chart.html",
    "title": "Class Chart",
    "keywords": "Class Chart Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class Chart : Image, IDisposable Inheritance object DispatcherObject UIElement Image Chart Implements IDisposable Inherited Members Image.Stretch Image.Source Image.MeasureOverride(int, int, out int, out int) UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Chart(int, int) public Chart(int width, int height) Parameters width int height int Properties AxisPen public Pen AxisPen { get; set; } Property Value Pen BackgroundColor public Brush BackgroundColor { get; set; } Property Value Brush ChartPen public Pen ChartPen { get; set; } Property Value Pen ChartTitle public string ChartTitle { get; set; } Property Value string DivisionAxisX public int DivisionAxisX { get; set; } Property Value int DivisionAxisY public int DivisionAxisY { get; set; } Property Value int DivisionColor public Brush DivisionColor { get; set; } Property Value Brush EllipseColor public Brush EllipseColor { get; set; } Property Value Brush Font public Font Font { get; set; } Property Value Font Items public ArrayList Items { get; set; } Property Value ArrayList Mode public Chart.ChartMode Mode { get; set; } Property Value Chart.ChartMode RadiusPoint public int RadiusPoint { get; set; } Property Value int TextColor public Brush TextColor { get; set; } Property Value Brush Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Dispose(bool) protected virtual void Dispose(bool disposing) Parameters disposing bool ~Chart() protected ~Chart() OnRender(DrawingContext) public override void OnRender(DrawingContext dc) Parameters dc DrawingContext"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.CheckBox.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.CheckBox.html",
    "title": "Class CheckBox",
    "keywords": "Class CheckBox Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class CheckBox : ContentControl, IDisposable Inheritance object DispatcherObject UIElement Control ContentControl CheckBox Implements IDisposable Inherited Members ContentControl.Child ContentControl.MeasureOverride(int, int, out int, out int) Control.Background Control.Font Control.Foreground Control._background Control._foreground Control._font UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CheckBox() public CheckBox() Properties Alpha public ushort Alpha { get; set; } Property Value ushort IsChecked public bool IsChecked { get; set; } Property Value bool Name public string Name { get; set; } Property Value string RadiusBorder public ushort RadiusBorder { get; set; } Property Value ushort Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Dispose(bool) protected virtual void Dispose(bool disposing) Parameters disposing bool ~CheckBox() protected ~CheckBox() OnRender(DrawingContext) public override void OnRender(DrawingContext dc) Parameters dc DrawingContext OnTouchDown(TouchEventArgs) protected override void OnTouchDown(TouchEventArgs e) Parameters e TouchEventArgs OnTouchUp(TouchEventArgs) protected override void OnTouchUp(TouchEventArgs e) Parameters e TouchEventArgs Events Checked public event RoutedEventHandler Checked Event Type RoutedEventHandler Click public event RoutedEventHandler Click Event Type RoutedEventHandler Unchecked public event RoutedEventHandler Unchecked Event Type RoutedEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ContentControl.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ContentControl.html",
    "title": "Class ContentControl",
    "keywords": "Class ContentControl Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public abstract class ContentControl : Control Inheritance object DispatcherObject UIElement Control ContentControl Derived Border Button CheckBox DataGrid ListBox ListBoxItem RadioButton ScrollViewer Slider Window Inherited Members Control.Background Control.Font Control.Foreground Control.OnRender(DrawingContext) Control._background Control._foreground Control._font UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Child public UIElement Child { get; set; } Property Value UIElement Methods MeasureOverride(int, int, out int, out int) Measurement override. Implement your size-to-content logic here. protected override void MeasureOverride(int availableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) Parameters availableWidth int Available size that parent can give to the child. May be MaxValue(when parent wants to measure to content). This is soft constraint. Child can return bigger size to indicate that it wants bigger space and hope that parent can throw in scrolling... availableHeight int desiredWidth int desiredHeight int Remarks MeasureOverride is designed to be the main customizability point for size control of layout. UIElement authors should override this method, call Measure on each child UIElement, and compute their desired size based upon the measurement of the children. The return value should be the desired size. Note: It is required that a parent UIElement calls Measure on each child or they won't be sized/arranged. Typical override follows a pattern roughly like this (pseudo-code): protected override void MeasureOverride(int avialableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) { foreach (UIElement child in VisualChildren) { child.Measure(availableSize); availableSize.Deflate(child.DesiredSize); _cache.StoreInfoAboutChild(child); } Size desired = CalculateBasedOnCache(_cache); return desired; }</code></pre></example> The key aspects of this snippet are: You must call Measure on each child UIElement It is common to cache measurement information between the MeasureOverride and ArrangeOverride method calls Calling base.MeasureOverride is not required. Calls to Measure on children are passing either the same availableSize as the parent, or a subset of the area depending on the type of layout the parent will perform (for example, it would be valid to remove the area for some border or padding)."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Control.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Control.html",
    "title": "Class Control",
    "keywords": "Class Control Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class Control : UIElement Inheritance object DispatcherObject UIElement Control Derived ContentControl TextBox Inherited Members UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.MeasureOverride(int, int, out int, out int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields _background protected Brush _background Field Value Brush _font protected Font _font Field Value Font _foreground protected Brush _foreground Field Value Brush Properties Background public Brush Background { get; set; } Property Value Brush Font public Font Font { get; set; } Property Value Font Foreground public Brush Foreground { get; set; } Property Value Brush Methods OnRender(DrawingContext) public override void OnRender(DrawingContext dc) Parameters dc DrawingContext"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.DataGrid.OnTapCell.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.DataGrid.OnTapCell.html",
    "title": "Delegate DataGrid.OnTapCell",
    "keywords": "Delegate DataGrid.OnTapCell Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll Tap cell event handler. public delegate void DataGrid.OnTapCell(object sender, DataGrid.TapCellEventArgs args) Parameters sender object Object associated with this event. args DataGrid.TapCellEventArgs Tap cell event arguments."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.DataGrid.Order.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.DataGrid.Order.html",
    "title": "Enum DataGrid.Order",
    "keywords": "Enum DataGrid.Order Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll The order in which rows are sorted. public enum DataGrid.Order Fields ASC = 0 Ascending DESC = 1 Descending Remarks ASC stands for ascending ex: 1 to 10 or A to Z. DESC stands for descending ex: 10 to 1 or Z to A."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.DataGrid.TapCellEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.DataGrid.TapCellEventArgs.html",
    "title": "Class DataGrid.TapCellEventArgs",
    "keywords": "Class DataGrid.TapCellEventArgs Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll Tap cell event arguments. public class DataGrid.TapCellEventArgs Inheritance object DataGrid.TapCellEventArgs Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors TapCellEventArgs(int, int) Creates a new TapCellEventArgs. public TapCellEventArgs(int columnIndex, int rowIndex) Parameters columnIndex int X coordinate rowIndex int Y coordinate Properties ColumnIndex Column index. public int ColumnIndex { get; } Property Value int RowIndex Row index. public int RowIndex { get; } Property Value int Methods ToString() ToString public override string ToString() Returns string Tap cell event properties."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.DataGrid.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.DataGrid.html",
    "title": "Class DataGrid",
    "keywords": "Class DataGrid Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll The DataGrid component is a list-based component that provides a grid of rows and columns. public class DataGrid : ContentControl Inheritance object DispatcherObject UIElement Control ContentControl DataGrid Inherited Members ContentControl.Child ContentControl.MeasureOverride(int, int, out int, out int) Control.Background Control.Font Control.Foreground Control._background Control._foreground Control._font UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DataGrid(int, int, int, Font) Creates a new DataGrid component. public DataGrid(int width, int rowHeight, int rowCount, Font font) Parameters width int width rowHeight int rowHeight rowCount int rowCount font Font font Properties Draggable Indicates whether or not the item list can be dragged up and down. public bool Draggable { get; set; } Property Value bool GridColor Grid color. public Color GridColor { get; set; } Property Value Color HeadersBackColor Headers background color. public Color HeadersBackColor { get; set; } Property Value Color HeadersFontColor Headers font color. public Color HeadersFontColor { get; set; } Property Value Color ItemsAltBackColor Items alternate background color. public Color ItemsAltBackColor { get; set; } Property Value Color ItemsBackColor Items background color. public Color ItemsBackColor { get; set; } Property Value Color ItemsFontColor Items font color. public Color ItemsFontColor { get; set; } Property Value Color MaxIgnoredTouchMoves Touch senstitive. public int MaxIgnoredTouchMoves { get; set; } Property Value int NumItems Number of items in the DataGrid. public int NumItems { get; } Property Value int RowCount Number of rows displayed. public int RowCount { get; set; } Property Value int RowHeight Row height. public int RowHeight { get; set; } Property Value int ScrollbarBackColor Scrollbar background color. public Color ScrollbarBackColor { get; set; } Property Value Color ScrollbarScrubberColor Scrollbar scrubber color. public Color ScrollbarScrubberColor { get; set; } Property Value Color ScrollbarWidth Scrollbar width. public int ScrollbarWidth { get; set; } Property Value int SelectedIndex The currently selected index. public int SelectedIndex { get; set; } Property Value int SelectedItemBackColor Selected item background color. public Color SelectedItemBackColor { get; set; } Property Value Color SelectedItemFontColor Selected item font color. public Color SelectedItemFontColor { get; set; } Property Value Color ShowHeaders Indicates whether the headers are shown. public bool ShowHeaders { get; set; } Property Value bool ShowScrollbar Indicates whether the scrollbar is shown. public bool ShowScrollbar { get; set; } Property Value bool SortableHeaders Indicates whether the headers are sortable. public bool SortableHeaders { get; set; } Property Value bool TappableCells Indicates whether items trigger cell tap events or not. public bool TappableCells { get; set; } Property Value bool Methods AddColumn(DataGridColumn) Adds a column. public void AddColumn(DataGridColumn dataGridColumn) Parameters dataGridColumn DataGridColumn dataGridColumn AddColumnAt(int, DataGridColumn) Adds a column at a specified index. public void AddColumnAt(int index, DataGridColumn dataGridColumn) Parameters index int index dataGridColumn DataGridColumn dataGridColumn AddItem(DataGridItem) Adds an item. public void AddItem(DataGridItem dataGridItem) Parameters dataGridItem DataGridItem dataGridItem AddItemAt(int, DataGridItem) Adds an item at a specified index. public void AddItemAt(int index, DataGridItem dataGridItem) Parameters index int index dataGridItem DataGridItem dataGridItem Clear() Clears all items including their data and resets the data grid. public void Clear() Dispose() public void Dispose() Dispose(bool) protected virtual void Dispose(bool disposing) Parameters disposing bool ~DataGrid() protected ~DataGrid() GetCellData(int, int) Get a cell's data. public object GetCellData(int columnIndex, int rowIndex) Parameters columnIndex int columnIndex rowIndex int rowIndex Returns object GetRowData(int) Gets row data. public object[] GetRowData(int index) Parameters index int index Returns object[] Data object array. OnRender(DrawingContext) Renders the DataGrid onto it's parent container's graphics. public override void OnRender(DrawingContext dc) Parameters dc DrawingContext OnTouchDown(TouchEventArgs) Handles the touch down event. protected override void OnTouchDown(TouchEventArgs e) Parameters e TouchEventArgs Touch event arguments. OnTouchMove(TouchEventArgs) Handles the touch move event. protected override void OnTouchMove(TouchEventArgs e) Parameters e TouchEventArgs Touch event arguments. OnTouchUp(TouchEventArgs) Handles the touch up event. protected override void OnTouchUp(TouchEventArgs e) Parameters e TouchEventArgs Touch event arguments. RemoveColumn(DataGridColumn) Removes a column. public void RemoveColumn(DataGridColumn dataGridColumn) Parameters dataGridColumn DataGridColumn dataGridColumn RemoveColumnAt(int) Removes a column at a specified index. public void RemoveColumnAt(int index) Parameters index int index RemoveItem(DataGridItem) Removes an item. public void RemoveItem(DataGridItem dataGridItem) Parameters dataGridItem DataGridItem dataGridItem RemoveItemAt(int) Removes an item a specified index. public void RemoveItemAt(int index) Parameters index int index ScrollDown(int) Scroll the rows down by a specified amount. public void ScrollDown(int amount) Parameters amount int amount ScrollTo(int) Scroll the rows to a specified index. public void ScrollTo(int index) Parameters index int index ScrollUp(int) Scroll the rows up by a specified amount. public void ScrollUp(int amount) Parameters amount int amount SetCellData(int, int, object) Sets a cell's data. public void SetCellData(int columnIndex, int rowIndex, object data) Parameters columnIndex int columnIndex rowIndex int rowIndex data object data SetRowData(int, object[]) Sets new row data. public void SetRowData(int index, object[] data) Parameters index int index data object[] Data object array. Sort(int) Sorts the items on a specified column index. public void Sort(int columnIndex) Parameters columnIndex int TriggerTapCellEvent(object, TapCellEventArgs) Triggers a tap cell event. public void TriggerTapCellEvent(object sender, DataGrid.TapCellEventArgs args) Parameters sender object Object associated with this event. args DataGrid.TapCellEventArgs Tap cell event arguments. Events TapCellEvent Tap grid event. public event DataGrid.OnTapCell TapCellEvent Event Type DataGrid.OnTapCell"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.DataGridColumn.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.DataGridColumn.html",
    "title": "Class DataGridColumn",
    "keywords": "Class DataGridColumn Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll The DataGridColumn class describes a column in a DataGrid component. public class DataGridColumn Inheritance object DataGridColumn Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DataGridColumn(string, int) Creates a new DataGridColumn instance. public DataGridColumn(string label, int width) Parameters label string width int Fields label The column name to be displayed. public string label Field Value string order Indicates the default order of this column. public DataGrid.Order order Field Value DataGrid.Order width The width of the column, in pixels. public int width Field Value int Methods ToggleOrder() Toggles the ordering of this column. public void ToggleOrder()"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.DataGridItem.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.DataGridItem.html",
    "title": "Class DataGridItem",
    "keywords": "Class DataGridItem Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll The DataGridItem class describes an item in a DataGrid component. public class DataGridItem : IComparable Inheritance object DataGridItem Implements IComparable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DataGridItem(object[]) Creates a new DataGridItem. public DataGridItem(object[] data) Parameters data object[] Object containing data for each column. Fields data Contains the data for each column within this row. public object[] data Field Value object[] dataType Contains the data type for each column within this row. public string[] dataType Field Value string[] Methods CompareTo(DataGridItem, int) Compares this item's column to another DataGridItem's column. public int CompareTo(DataGridItem row, int columnIndex) Parameters row DataGridItem DataGridItem object. columnIndex int Column index. Returns int Number indicating how it should be positioned. CompareTo(object) This is used to be compliant with IComparable. public int CompareTo(object obj) Parameters obj object Returns int"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.DataGridItemComparer.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.DataGridItemComparer.html",
    "title": "Class DataGridItemComparer",
    "keywords": "Class DataGridItemComparer Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll The DataGridItemComparer class allows comparison between DataGridItems. public class DataGridItemComparer : IComparer Inheritance object DataGridItemComparer Implements IComparer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ColumnIndex Column index to compare. public int ColumnIndex { get; set; } Property Value int Methods Compare(object, object) Compare two DataGridRow objects. public int Compare(object x, object y) Parameters x object y object Returns int"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Direction.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Direction.html",
    "title": "Enum Direction",
    "keywords": "Enum Direction Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public enum Direction Fields Down = 3 Left = 0 Right = 1 Up = 2"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Dropdown.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Dropdown.html",
    "title": "Class Dropdown",
    "keywords": "Class Dropdown Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class Dropdown : ListBox, IDisposable Inheritance object DispatcherObject UIElement Control ContentControl ListBox Dropdown Implements IDisposable Inherited Members ListBox.Items ListBox.SelectionChanged ListBox.SelectedIndex ListBox.SelectedItem ListBox.ScrollIntoView(ListBoxItem) ListBox.OnButtonDown(ButtonEventArgs) ListBox.ScrollChanged ListBox.HorizontalOffset ListBox.VerticalOffset ListBox.ExtentHeight ListBox.ExtentWidth ListBox.ScrollingStyle ContentControl.Child ContentControl.MeasureOverride(int, int, out int, out int) Control.Background Control.Font Control.Foreground Control._background Control._foreground Control._font UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Dropdown() public Dropdown() Properties Alpha public ushort Alpha { get; set; } Property Value ushort Options public ArrayList Options { get; set; } Property Value ArrayList RadiusBorder public int RadiusBorder { get; set; } Property Value int Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Dispose(bool) protected virtual void Dispose(bool disposing) Parameters disposing bool ~Dropdown() protected ~Dropdown() OnRender(DrawingContext) public override void OnRender(DrawingContext dc) Parameters dc DrawingContext"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Gauge.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Gauge.html",
    "title": "Class Gauge",
    "keywords": "Class Gauge Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class Gauge : Image, IDisposable Inheritance object DispatcherObject UIElement Image Gauge Implements IDisposable Inherited Members Image.Stretch Image.Source Image.MeasureOverride(int, int, out int, out int) UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Gauge(int) public Gauge(int radius) Parameters radius int Properties BackColor public Color BackColor { get; set; } Property Value Color DialColor Background color of the dial public Color DialColor { get; set; } Property Value Color DialText Gets or Sets the Text to be displayed in the dial public string DialText { get; set; } Property Value string EnableDigitalNumber public bool EnableDigitalNumber { get; set; } Property Value bool EnableThresold public bool EnableThresold { get; set; } Property Value bool EnableTransparentBackground Enables or Disables Transparent Background color. Note: Enabling this will reduce the performance and may make the control flicker. public bool EnableTransparentBackground { get; set; } Property Value bool Font public Font Font { get; set; } Property Value Font Glossiness Glossiness strength. Range: 0-100 public float Glossiness { get; set; } Property Value float MaxValue Maximum value on the scale public float MaxValue { get; set; } Property Value float MinValue Mininum value on the scale public float MinValue { get; set; } Property Value float NoOfDivisions Get or Sets the number of Divisions in the dial scale. public int NoOfDivisions { get; set; } Property Value int NoOfSubDivisions Gets or Sets the number of Sub Divisions in the scale per Division. public int NoOfSubDivisions { get; set; } Property Value int RecommendedValue Threshold value from which green area will be marked. public float RecommendedValue { get; set; } Property Value float ThresholdPercent Gets or Sets the Threshold area from the Recommended Value. (1-99%) public float ThresholdPercent { get; set; } Property Value float Value Value where the pointer will point to. public float Value { get; set; } Property Value float Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Dispose(bool) protected virtual void Dispose(bool disposing) Parameters disposing bool ~Gauge() protected ~Gauge() GetRadian(float) Converts the given degree to radian. public float GetRadian(float theta) Parameters theta float Returns float OnRender(DrawingContext) public override void OnRender(DrawingContext dc) Parameters dc DrawingContext PaintBackground(Graphics) Draws the dial background. protected void PaintBackground(Graphics gfx) Parameters gfx Graphics"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Image.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Image.html",
    "title": "Class Image",
    "keywords": "Class Image Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll Summary description for Image. public class Image : UIElement Inheritance object DispatcherObject UIElement Image Derived Chart Gauge ProgressBar Inherited Members UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Source public ImageSource Source { get; set; } Property Value ImageSource Stretch public Stretch Stretch { get; set; } Property Value Stretch Methods MeasureOverride(int, int, out int, out int) Measurement override. Implement your size-to-content logic here. protected override void MeasureOverride(int availableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) Parameters availableWidth int Available size that parent can give to the child. May be MaxValue(when parent wants to measure to content). This is soft constraint. Child can return bigger size to indicate that it wants bigger space and hope that parent can throw in scrolling... availableHeight int desiredWidth int desiredHeight int Remarks MeasureOverride is designed to be the main customizability point for size control of layout. UIElement authors should override this method, call Measure on each child UIElement, and compute their desired size based upon the measurement of the children. The return value should be the desired size. Note: It is required that a parent UIElement calls Measure on each child or they won't be sized/arranged. Typical override follows a pattern roughly like this (pseudo-code): protected override void MeasureOverride(int avialableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) { foreach (UIElement child in VisualChildren) { child.Measure(availableSize); availableSize.Deflate(child.DesiredSize); _cache.StoreInfoAboutChild(child); } Size desired = CalculateBasedOnCache(_cache); return desired; }</code></pre></example> The key aspects of this snippet are: You must call Measure on each child UIElement It is common to cache measurement information between the MeasureOverride and ArrangeOverride method calls Calling base.MeasureOverride is not required. Calls to Measure on children are passing either the same availableSize as the parent, or a subset of the area depending on the type of layout the parent will perform (for example, it would be valid to remove the area for some border or padding). OnRender(DrawingContext) public override void OnRender(DrawingContext dc) Parameters dc DrawingContext"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ListBox.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ListBox.html",
    "title": "Class ListBox",
    "keywords": "Class ListBox Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class ListBox : ContentControl Inheritance object DispatcherObject UIElement Control ContentControl ListBox Derived Dropdown Inherited Members ContentControl.Child ContentControl.MeasureOverride(int, int, out int, out int) Control.Background Control.Font Control.Foreground Control.OnRender(DrawingContext) Control._background Control._foreground Control._font UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ListBox() public ListBox() Properties ExtentHeight Extent height of the scroll area. public int ExtentHeight { get; } Property Value int ExtentWidth Extent width of the scroll area. public int ExtentWidth { get; } Property Value int HorizontalOffset Horizontal offset of the scroll. public int HorizontalOffset { get; set; } Property Value int Items public ListBoxItemCollection Items { get; } Property Value ListBoxItemCollection ScrollingStyle The scrolling style. public ScrollingStyle ScrollingStyle { get; set; } Property Value ScrollingStyle SelectedIndex public int SelectedIndex { get; set; } Property Value int SelectedItem public ListBoxItem SelectedItem { get; set; } Property Value ListBoxItem VerticalOffset Vertical offset of the scroll. public int VerticalOffset { get; set; } Property Value int Methods OnButtonDown(ButtonEventArgs) An event reporting a button was pressed. protected override void OnButtonDown(ButtonEventArgs e) Parameters e ButtonEventArgs ScrollIntoView(ListBoxItem) public void ScrollIntoView(ListBoxItem item) Parameters item ListBoxItem Events ScrollChanged Event handler if the scroll changes. public event ScrollChangedEventHandler ScrollChanged Event Type ScrollChangedEventHandler SelectionChanged public event SelectionChangedEventHandler SelectionChanged Event Type SelectionChangedEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ListBoxItem.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ListBoxItem.html",
    "title": "Class ListBoxItem",
    "keywords": "Class ListBoxItem Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class ListBoxItem : ContentControl Inheritance object DispatcherObject UIElement Control ContentControl ListBoxItem Derived ListBoxItemHighlightable Inherited Members ContentControl.Child ContentControl.MeasureOverride(int, int, out int, out int) Control.Background Control.Font Control.Foreground Control.OnRender(DrawingContext) Control._background Control._foreground Control._font UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties IsSelectable public bool IsSelectable { get; set; } Property Value bool IsSelected public bool IsSelected { get; } Property Value bool Methods OnIsSelectedChanged(bool) protected virtual void OnIsSelectedChanged(bool isSelected) Parameters isSelected bool OnTouchUp(TouchEventArgs) protected override void OnTouchUp(TouchEventArgs e) Parameters e TouchEventArgs"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ListBoxItemCollection.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ListBoxItemCollection.html",
    "title": "Class ListBoxItemCollection",
    "keywords": "Class ListBoxItemCollection Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class ListBoxItemCollection : ICollection, IEnumerable Inheritance object ListBoxItemCollection Implements ICollection IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ListBoxItemCollection(ListBox, UIElementCollection) public ListBoxItemCollection(ListBox listBox, UIElementCollection items) Parameters listBox ListBox items UIElementCollection Properties Count Gets the number of elements contained in the ICollection. public int Count { get; } Property Value int The number of elements contained in the ICollection. IsSynchronized Gets a value indicating whether access to the ICollection is synchronized (thread safe). public bool IsSynchronized { get; } Property Value bool true if access to the ICollection is synchronized (thread safe); otherwise, false. this[int] public ListBoxItem this[int index] { get; set; } Parameters index int Property Value ListBoxItem SyncRoot Gets an object that can be used to synchronize access to the ICollection. public object SyncRoot { get; } Property Value object An object that can be used to synchronize access to the ICollection. Methods Add(ListBoxItem) public int Add(ListBoxItem item) Parameters item ListBoxItem Returns int Add(UIElement) public int Add(UIElement element) Parameters element UIElement Returns int Clear() public void Clear() Contains(ListBoxItem) public bool Contains(ListBoxItem item) Parameters item ListBoxItem Returns bool CopyTo(Array, int) Copies the elements of the ICollection to an Array, starting at a particular Array index. public void CopyTo(Array array, int index) Parameters array Array The one-dimensional Array that is the destination of the elements copied from ICollection. The Array must have zero-based indexing. index int The zero-based index in array at which copying begins. Exceptions ArgumentNullException array is null. ArgumentOutOfRangeException index is less than zero. ArgumentException array is multidimensional. -or- The number of elements in the source ICollection is greater than the available space from index to the end of the destination array. -or- The type of the source ICollection cannot be cast automatically to the type of the destination array. GetEnumerator() Returns an enumerator that iterates through a collection. public IEnumerator GetEnumerator() Returns IEnumerator An IEnumerator object that can be used to iterate through the collection. IndexOf(ListBoxItem) public int IndexOf(ListBoxItem item) Parameters item ListBoxItem Returns int Insert(int, ListBoxItem) public void Insert(int index, ListBoxItem item) Parameters index int item ListBoxItem Remove(ListBoxItem) public void Remove(ListBoxItem item) Parameters item ListBoxItem RemoveAt(int) public void RemoveAt(int index) Parameters index int"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ListBoxItemHighlightable.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ListBoxItemHighlightable.html",
    "title": "Class ListBoxItemHighlightable",
    "keywords": "Class ListBoxItemHighlightable Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class ListBoxItemHighlightable : ListBoxItem Inheritance object DispatcherObject UIElement Control ContentControl ListBoxItem ListBoxItemHighlightable Inherited Members ListBoxItem.IsSelected ListBoxItem.IsSelectable ListBoxItem.OnTouchUp(TouchEventArgs) ContentControl.Child ContentControl.MeasureOverride(int, int, out int, out int) Control.Background Control.Font Control.Foreground Control.OnRender(DrawingContext) Control._background Control._foreground Control._font UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ListBoxItemHighlightable(string, Font, int, Color, Color, Color) public ListBoxItemHighlightable(string content, Font font, int margin, Color backgroundSelectedColor, Color foreColorSelectedColor, Color foreColorUnselectColor) Parameters content string font Font margin int backgroundSelectedColor Color foreColorSelectedColor Color foreColorUnselectColor Color Methods OnIsSelectedChanged(bool) protected override void OnIsSelectedChanged(bool isSelected) Parameters isSelected bool"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.MessageBox.DialogResult.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.MessageBox.DialogResult.html",
    "title": "Enum MessageBox.DialogResult",
    "keywords": "Enum MessageBox.DialogResult Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public enum MessageBox.DialogResult Fields Cancel = 1 No = 3 OK = 0 Yes = 2"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.MessageBox.MessageBoxButtons.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.MessageBox.MessageBoxButtons.html",
    "title": "Enum MessageBox.MessageBoxButtons",
    "keywords": "Enum MessageBox.MessageBoxButtons Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public enum MessageBox.MessageBoxButtons Fields Cancel = 1 OK = 0 OKCancel = 2 YesNo = 3"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.MessageBox.MessageBoxRoutedEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.MessageBox.MessageBoxRoutedEventArgs.html",
    "title": "Class MessageBox.MessageBoxRoutedEventArgs",
    "keywords": "Class MessageBox.MessageBoxRoutedEventArgs Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class MessageBox.MessageBoxRoutedEventArgs Inheritance object MessageBox.MessageBoxRoutedEventArgs Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors MessageBoxRoutedEventArgs() public MessageBoxRoutedEventArgs() Properties DialogResult public MessageBox.DialogResult DialogResult { get; } Property Value MessageBox.DialogResult RoutedEventArgs public RoutedEventArgs RoutedEventArgs { get; } Property Value RoutedEventArgs"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.MessageBox.MessageBoxRoutedEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.MessageBox.MessageBoxRoutedEventHandler.html",
    "title": "Delegate MessageBox.MessageBoxRoutedEventHandler",
    "keywords": "Delegate MessageBox.MessageBoxRoutedEventHandler Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public delegate void MessageBox.MessageBoxRoutedEventHandler(object sender, MessageBox.MessageBoxRoutedEventArgs e) Parameters sender object e MessageBox.MessageBoxRoutedEventArgs"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.MessageBox.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.MessageBox.html",
    "title": "Class MessageBox",
    "keywords": "Class MessageBox Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class MessageBox : Canvas, IDisposable Inheritance object DispatcherObject UIElement Panel Canvas MessageBox Implements IDisposable Inherited Members Canvas.GetBottom(UIElement) Canvas.SetBottom(UIElement, int) Canvas.GetLeft(UIElement) Canvas.SetLeft(UIElement, int) Canvas.GetRight(UIElement) Canvas.SetRight(UIElement, int) Canvas.GetTop(UIElement) Canvas.SetTop(UIElement, int) Canvas.ArrangeOverride(int, int) Canvas.MeasureOverride(int, int, out int, out int) Panel.Children UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors MessageBox(Font) public MessageBox(Font font) Parameters font Font Properties Font public Font Font { get; set; } Property Value Font Owner public UIElement Owner { get; set; } Property Value UIElement Methods Close() public void Close() Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Dispose(bool) protected virtual void Dispose(bool disposing) Parameters disposing bool ~MessageBox() protected ~MessageBox() OnRender(DrawingContext) public override void OnRender(DrawingContext dc) Parameters dc DrawingContext Show(UIElement, string, string, MessageBoxButtons) public void Show(UIElement owner, string message, string caption, MessageBox.MessageBoxButtons messageBoxButton) Parameters owner UIElement message string caption string messageBoxButton MessageBox.MessageBoxButtons Show(string, string, MessageBoxButtons) public void Show(string message, string caption, MessageBox.MessageBoxButtons messageBoxButton) Parameters message string caption string messageBoxButton MessageBox.MessageBoxButtons Events ButtonClick public event MessageBox.MessageBoxRoutedEventHandler ButtonClick Event Type MessageBox.MessageBoxRoutedEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Orientation.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Orientation.html",
    "title": "Enum Orientation",
    "keywords": "Enum Orientation Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public enum Orientation Fields Horizontal = 0 Vertical = 1"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Panel.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Panel.html",
    "title": "Class Panel",
    "keywords": "Class Panel Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class Panel : UIElement Inheritance object DispatcherObject UIElement Panel Derived Canvas StackPanel Inherited Members UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.OnRender(DrawingContext) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Children public UIElementCollection Children { get; } Property Value UIElementCollection Methods MeasureOverride(int, int, out int, out int) Measurement override. Implement your size-to-content logic here. protected override void MeasureOverride(int availableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) Parameters availableWidth int Available size that parent can give to the child. May be MaxValue(when parent wants to measure to content). This is soft constraint. Child can return bigger size to indicate that it wants bigger space and hope that parent can throw in scrolling... availableHeight int desiredWidth int desiredHeight int Remarks MeasureOverride is designed to be the main customizability point for size control of layout. UIElement authors should override this method, call Measure on each child UIElement, and compute their desired size based upon the measurement of the children. The return value should be the desired size. Note: It is required that a parent UIElement calls Measure on each child or they won't be sized/arranged. Typical override follows a pattern roughly like this (pseudo-code): protected override void MeasureOverride(int avialableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) { foreach (UIElement child in VisualChildren) { child.Measure(availableSize); availableSize.Deflate(child.DesiredSize); _cache.StoreInfoAboutChild(child); } Size desired = CalculateBasedOnCache(_cache); return desired; }</code></pre></example> The key aspects of this snippet are: You must call Measure on each child UIElement It is common to cache measurement information between the MeasureOverride and ArrangeOverride method calls Calling base.MeasureOverride is not required. Calls to Measure on children are passing either the same availableSize as the parent, or a subset of the area depending on the type of layout the parent will perform (for example, it would be valid to remove the area for some border or padding)."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Point.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Point.html",
    "title": "Class Point",
    "keywords": "Class Point Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class Point Inheritance object Point Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Point(int, int) public Point(int x, int y) Parameters x int y int Properties X public int X { get; set; } Property Value int Y public int Y { get; set; } Property Value int"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ProgressBar.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ProgressBar.html",
    "title": "Class ProgressBar",
    "keywords": "Class ProgressBar Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class ProgressBar : Image, IDisposable Inheritance object DispatcherObject UIElement Image ProgressBar Implements IDisposable Inherited Members Image.Stretch Image.Source Image.MeasureOverride(int, int, out int, out int) UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ProgressBar() public ProgressBar() Properties Alpha public ushort Alpha { get; set; } Property Value ushort Border public int Border { get; set; } Property Value int Direction public Direction Direction { get; set; } Property Value Direction MaxValue public int MaxValue { get; set; } Property Value int Value public int Value { get; set; } Property Value int Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Dispose(bool) protected virtual void Dispose(bool disposing) Parameters disposing bool ~ProgressBar() protected ~ProgressBar() OnRender(DrawingContext) public override void OnRender(DrawingContext dc) Parameters dc DrawingContext"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.RadioButton.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.RadioButton.html",
    "title": "Class RadioButton",
    "keywords": "Class RadioButton Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class RadioButton : ContentControl, IDisposable Inheritance object DispatcherObject UIElement Control ContentControl RadioButton Implements IDisposable Inherited Members ContentControl.Child ContentControl.MeasureOverride(int, int, out int, out int) Control.Background Control.Font Control.Foreground Control._background Control._foreground Control._font UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RadioButton() public RadioButton() RadioButton(string) public RadioButton(string groupName) Parameters groupName string Properties Alpha public ushort Alpha { get; set; } Property Value ushort Checked public bool Checked { get; set; } Property Value bool GroupName public string GroupName { get; set; } Property Value string Name public string Name { get; set; } Property Value string OutlineUnselectColor public Color OutlineUnselectColor { get; set; } Property Value Color RadiusBorder public int RadiusBorder { get; set; } Property Value int SelectedColor public Color SelectedColor { get; set; } Property Value Color SelectedOutlineColor public Color SelectedOutlineColor { get; set; } Property Value Color Value public string Value { get; set; } Property Value string Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Dispose(bool) protected virtual void Dispose(bool disposing) Parameters disposing bool ~RadioButton() protected ~RadioButton() OnRender(DrawingContext) public override void OnRender(DrawingContext dc) Parameters dc DrawingContext OnTouchDown(TouchEventArgs) protected override void OnTouchDown(TouchEventArgs e) Parameters e TouchEventArgs OnTouchUp(TouchEventArgs) protected override void OnTouchUp(TouchEventArgs e) Parameters e TouchEventArgs Toggle() public void Toggle() Events Click public event RoutedEventHandler Click Event Type RoutedEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.RadioButtonManager.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.RadioButtonManager.html",
    "title": "Class RadioButtonManager",
    "keywords": "Class RadioButtonManager Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public static class RadioButtonManager Inheritance object RadioButtonManager Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetCount(string) public static int GetCount(string groupName) Parameters groupName string Returns int GetValue(string) public static string GetValue(string groupName) Parameters groupName string Returns string"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ScrollChangedEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ScrollChangedEventArgs.html",
    "title": "Class ScrollChangedEventArgs",
    "keywords": "Class ScrollChangedEventArgs Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class ScrollChangedEventArgs : EventArgs Inheritance object EventArgs ScrollChangedEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ScrollChangedEventArgs(int, int, int, int) public ScrollChangedEventArgs(int offsetX, int offsetY, int offsetChangeX, int offsetChangeY) Parameters offsetX int offsetY int offsetChangeX int offsetChangeY int Fields HorizontalChange public readonly int HorizontalChange Field Value int HorizontalOffset public readonly int HorizontalOffset Field Value int VerticalChange public readonly int VerticalChange Field Value int VerticalOffset public readonly int VerticalOffset Field Value int"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ScrollChangedEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ScrollChangedEventHandler.html",
    "title": "Delegate ScrollChangedEventHandler",
    "keywords": "Delegate ScrollChangedEventHandler Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public delegate void ScrollChangedEventHandler(object sender, ScrollChangedEventArgs args) Parameters sender object args ScrollChangedEventArgs"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ScrollViewer.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ScrollViewer.html",
    "title": "Class ScrollViewer",
    "keywords": "Class ScrollViewer Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class ScrollViewer : ContentControl Inheritance object DispatcherObject UIElement Control ContentControl ScrollViewer Inherited Members ContentControl.Child Control.Background Control.Font Control.Foreground Control.OnRender(DrawingContext) Control._background Control._foreground Control._font UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ScrollViewer() public ScrollViewer() Properties ExtentHeight public int ExtentHeight { get; } Property Value int ExtentWidth public int ExtentWidth { get; } Property Value int HorizontalOffset public int HorizontalOffset { get; set; } Property Value int LineHeight public int LineHeight { get; set; } Property Value int LineWidth public int LineWidth { get; set; } Property Value int ScrollingStyle public ScrollingStyle ScrollingStyle { get; set; } Property Value ScrollingStyle VerticalOffset public int VerticalOffset { get; set; } Property Value int Methods ArrangeOverride(int, int) ArrangeOverride allows for the customization of the final sizing and positioning of children. protected override void ArrangeOverride(int arrangeWidth, int arrangeHeight) Parameters arrangeWidth int Final width arrangeHeight int Final height Remarks UIElement authors should override this method, call Arrange on each visible child UIElement, to size and position each child UIElement by passing a rectangle reserved for the child within parent space. Note: It is required that a parent UIElement calls Arrange on each child or they won't be rendered. Typical override follows a pattern roughly like this (pseudo-code): protected override void ArrangeOverride(int arrangeWidth, int arrangeHeight) { foreach (UIElement child in VisualChildren) { child.Arrange(new Rect(childX, childY, childWidth, childHeight); } }</code></pre></example> LineDown() public void LineDown() LineLeft() public void LineLeft() LineRight() public void LineRight() LineUp() public void LineUp() MeasureOverride(int, int, out int, out int) Measurement override. Implement your size-to-content logic here. protected override void MeasureOverride(int availableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) Parameters availableWidth int Available size that parent can give to the child. May be MaxValue(when parent wants to measure to content). This is soft constraint. Child can return bigger size to indicate that it wants bigger space and hope that parent can throw in scrolling... availableHeight int desiredWidth int desiredHeight int Remarks MeasureOverride is designed to be the main customizability point for size control of layout. UIElement authors should override this method, call Measure on each child UIElement, and compute their desired size based upon the measurement of the children. The return value should be the desired size. Note: It is required that a parent UIElement calls Measure on each child or they won't be sized/arranged. Typical override follows a pattern roughly like this (pseudo-code): protected override void MeasureOverride(int avialableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) { foreach (UIElement child in VisualChildren) { child.Measure(availableSize); availableSize.Deflate(child.DesiredSize); _cache.StoreInfoAboutChild(child); } Size desired = CalculateBasedOnCache(_cache); return desired; }</code></pre></example> The key aspects of this snippet are: You must call Measure on each child UIElement It is common to cache measurement information between the MeasureOverride and ArrangeOverride method calls Calling base.MeasureOverride is not required. Calls to Measure on children are passing either the same availableSize as the parent, or a subset of the area depending on the type of layout the parent will perform (for example, it would be valid to remove the area for some border or padding). OnButtonDown(ButtonEventArgs) An event reporting a button was pressed. protected override void OnButtonDown(ButtonEventArgs e) Parameters e ButtonEventArgs PageDown() public void PageDown() PageLeft() public void PageLeft() PageRight() public void PageRight() PageUp() public void PageUp() Events ScrollChanged public event ScrollChangedEventHandler ScrollChanged Event Type ScrollChangedEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ScrollingStyle.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.ScrollingStyle.html",
    "title": "Enum ScrollingStyle",
    "keywords": "Enum ScrollingStyle Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public enum ScrollingStyle Fields First = 0 Last = 1 LineByLine = 0 PageByPage = 1"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.SelectionChangedEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.SelectionChangedEventArgs.html",
    "title": "Class SelectionChangedEventArgs",
    "keywords": "Class SelectionChangedEventArgs Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class SelectionChangedEventArgs : EventArgs Inheritance object EventArgs SelectionChangedEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SelectionChangedEventArgs(int, int) public SelectionChangedEventArgs(int previousIndex, int newIndex) Parameters previousIndex int newIndex int Fields PreviousSelectedIndex public readonly int PreviousSelectedIndex Field Value int SelectedIndex public readonly int SelectedIndex Field Value int"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.SelectionChangedEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.SelectionChangedEventHandler.html",
    "title": "Delegate SelectionChangedEventHandler",
    "keywords": "Delegate SelectionChangedEventHandler Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public delegate void SelectionChangedEventHandler(object sender, SelectionChangedEventArgs args) Parameters sender object args SelectionChangedEventArgs"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Slider.ValueChangedEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Slider.ValueChangedEventArgs.html",
    "title": "Class Slider.ValueChangedEventArgs",
    "keywords": "Class Slider.ValueChangedEventArgs Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class Slider.ValueChangedEventArgs : EventArgs Inheritance object EventArgs Slider.ValueChangedEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ValueChangedEventArgs(double) public ValueChangedEventArgs(double newIndex) Parameters newIndex double Fields Value public readonly double Value Field Value double"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Slider.ValueChangedEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Slider.ValueChangedEventHandler.html",
    "title": "Delegate Slider.ValueChangedEventHandler",
    "keywords": "Delegate Slider.ValueChangedEventHandler Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public delegate void Slider.ValueChangedEventHandler(object sender, Slider.ValueChangedEventArgs args) Parameters sender object args Slider.ValueChangedEventArgs"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Slider.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Slider.html",
    "title": "Class Slider",
    "keywords": "Class Slider Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll The Slider component lets users select a value by sliding a knob along a track. public class Slider : ContentControl Inheritance object DispatcherObject UIElement Control ContentControl Slider Inherited Members ContentControl.Child ContentControl.MeasureOverride(int, int, out int, out int) Control.Background Control.Font Control.Foreground Control._background Control._foreground Control._font UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Slider(int, int) Creates a new Slider component. public Slider(int width, int height) Parameters width int Width height int Height Properties Alpha public ushort Alpha { get; set; } Property Value ushort Color public Color Color { get; set; } Property Value Color Direction Direction of the slider; horizontal or vertical. public Orientation Direction { get; set; } Property Value Orientation KnobSize Size of the knob. public int KnobSize { get; set; } Property Value int Maximum Maximum value. public double Maximum { get; set; } Property Value double Minimum Minimum value. public double Minimum { get; set; } Property Value double SnapInterval Increment by which the value is increased or decreased as the user slides the knob. public int SnapInterval { get; set; } Property Value int TickInterval Tick mark spacing relative to the maximum value. public int TickInterval { get; set; } Property Value int Value Gets or sets the current value. public double Value { get; set; } Property Value double Methods Dispose() public void Dispose() Dispose(bool) protected virtual void Dispose(bool disposing) Parameters disposing bool ~Slider() protected ~Slider() OnRender(DrawingContext) Renders the Slider onto it's parent container's graphics. public override void OnRender(DrawingContext dc) Parameters dc DrawingContext OnTouchDown(TouchEventArgs) Handles the touch down event. protected override void OnTouchDown(TouchEventArgs e) Parameters e TouchEventArgs Touch event arguments. OnTouchMove(TouchEventArgs) Handles the touch move event. protected override void OnTouchMove(TouchEventArgs e) Parameters e TouchEventArgs Touch event arguments. OnTouchUp(TouchEventArgs) Handles the touch up event. protected override void OnTouchUp(TouchEventArgs e) Parameters e TouchEventArgs Touch event arguments. Events OnValueChanged Value changed event. public event Slider.ValueChangedEventHandler OnValueChanged Event Type Slider.ValueChangedEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.StackPanel.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.StackPanel.html",
    "title": "Class StackPanel",
    "keywords": "Class StackPanel Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class StackPanel : Panel Inheritance object DispatcherObject UIElement Panel StackPanel Inherited Members Panel.Children UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.OnRender(DrawingContext) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors StackPanel() public StackPanel() StackPanel(Orientation) public StackPanel(Orientation orientation) Parameters orientation Orientation Properties Orientation public Orientation Orientation { get; set; } Property Value Orientation Methods ArrangeOverride(int, int) ArrangeOverride allows for the customization of the final sizing and positioning of children. protected override void ArrangeOverride(int arrangeWidth, int arrangeHeight) Parameters arrangeWidth int Final width arrangeHeight int Final height Remarks UIElement authors should override this method, call Arrange on each visible child UIElement, to size and position each child UIElement by passing a rectangle reserved for the child within parent space. Note: It is required that a parent UIElement calls Arrange on each child or they won't be rendered. Typical override follows a pattern roughly like this (pseudo-code): protected override void ArrangeOverride(int arrangeWidth, int arrangeHeight) { foreach (UIElement child in VisualChildren) { child.Arrange(new Rect(childX, childY, childWidth, childHeight); } }</code></pre></example> MeasureOverride(int, int, out int, out int) Measurement override. Implement your size-to-content logic here. protected override void MeasureOverride(int availableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) Parameters availableWidth int Available size that parent can give to the child. May be MaxValue(when parent wants to measure to content). This is soft constraint. Child can return bigger size to indicate that it wants bigger space and hope that parent can throw in scrolling... availableHeight int desiredWidth int desiredHeight int Remarks MeasureOverride is designed to be the main customizability point for size control of layout. UIElement authors should override this method, call Measure on each child UIElement, and compute their desired size based upon the measurement of the children. The return value should be the desired size. Note: It is required that a parent UIElement calls Measure on each child or they won't be sized/arranged. Typical override follows a pattern roughly like this (pseudo-code): protected override void MeasureOverride(int avialableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) { foreach (UIElement child in VisualChildren) { child.Measure(availableSize); availableSize.Deflate(child.DesiredSize); _cache.StoreInfoAboutChild(child); } Size desired = CalculateBasedOnCache(_cache); return desired; }</code></pre></example> The key aspects of this snippet are: You must call Measure on each child UIElement It is common to cache measurement information between the MeasureOverride and ArrangeOverride method calls Calling base.MeasureOverride is not required. Calls to Measure on children are passing either the same availableSize as the parent, or a subset of the area depending on the type of layout the parent will perform (for example, it would be valid to remove the area for some border or padding)."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Text.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.Text.html",
    "title": "Class Text",
    "keywords": "Class Text Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class Text : UIElement Inheritance object DispatcherObject UIElement Text Inherited Members UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Text() public Text() Text(Font, string) public Text(Font font, string content) Parameters font Font content string Text(string) public Text(string content) Parameters content string Fields _font protected Font _font Field Value Font _text protected string _text Field Value string Properties Font public Font Font { get; set; } Property Value Font ForeColor public Color ForeColor { get; set; } Property Value Color LineHeight public int LineHeight { get; } Property Value int TextAlignment public TextAlignment TextAlignment { get; set; } Property Value TextAlignment TextContent public string TextContent { get; set; } Property Value string TextWrap public bool TextWrap { get; set; } Property Value bool Trimming public TextTrimming Trimming { get; set; } Property Value TextTrimming Methods MeasureOverride(int, int, out int, out int) Measurement override. Implement your size-to-content logic here. protected override void MeasureOverride(int availableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) Parameters availableWidth int Available size that parent can give to the child. May be MaxValue(when parent wants to measure to content). This is soft constraint. Child can return bigger size to indicate that it wants bigger space and hope that parent can throw in scrolling... availableHeight int desiredWidth int desiredHeight int Remarks MeasureOverride is designed to be the main customizability point for size control of layout. UIElement authors should override this method, call Measure on each child UIElement, and compute their desired size based upon the measurement of the children. The return value should be the desired size. Note: It is required that a parent UIElement calls Measure on each child or they won't be sized/arranged. Typical override follows a pattern roughly like this (pseudo-code): protected override void MeasureOverride(int avialableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) { foreach (UIElement child in VisualChildren) { child.Measure(availableSize); availableSize.Deflate(child.DesiredSize); _cache.StoreInfoAboutChild(child); } Size desired = CalculateBasedOnCache(_cache); return desired; }</code></pre></example> The key aspects of this snippet are: You must call Measure on each child UIElement It is common to cache measurement information between the MeasureOverride and ArrangeOverride method calls Calling base.MeasureOverride is not required. Calls to Measure on children are passing either the same availableSize as the parent, or a subset of the area depending on the type of layout the parent will perform (for example, it would be valid to remove the area for some border or padding). OnRender(DrawingContext) public override void OnRender(DrawingContext dc) Parameters dc DrawingContext"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.TextBox.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.TextBox.html",
    "title": "Class TextBox",
    "keywords": "Class TextBox Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class TextBox : Control Inheritance object DispatcherObject UIElement Control TextBox Inherited Members Control.Background Control.Font Control.Foreground Control._background Control._foreground Control._font UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors TextBox() public TextBox() Properties BorderColor public Color BorderColor { get; set; } Property Value Color BorderThickness public ushort BorderThickness { get; set; } Property Value ushort PaddingX public ushort PaddingX { get; set; } Property Value ushort PaddingY public ushort PaddingY { get; set; } Property Value ushort PasswordChar public char PasswordChar { get; set; } Property Value char Text public string Text { get; set; } Property Value string TextAlign public TextAlignment TextAlign { get; set; } Property Value TextAlignment Methods ArrangeOverride(int, int) ArrangeOverride allows for the customization of the final sizing and positioning of children. protected override void ArrangeOverride(int arrangeWidth, int arrangeHeight) Parameters arrangeWidth int Final width arrangeHeight int Final height Remarks UIElement authors should override this method, call Arrange on each visible child UIElement, to size and position each child UIElement by passing a rectangle reserved for the child within parent space. Note: It is required that a parent UIElement calls Arrange on each child or they won't be rendered. Typical override follows a pattern roughly like this (pseudo-code): protected override void ArrangeOverride(int arrangeWidth, int arrangeHeight) { foreach (UIElement child in VisualChildren) { child.Arrange(new Rect(childX, childY, childWidth, childHeight); } }</code></pre></example> MeasureOverride(int, int, out int, out int) Measurement override. Implement your size-to-content logic here. protected override void MeasureOverride(int availableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) Parameters availableWidth int Available size that parent can give to the child. May be MaxValue(when parent wants to measure to content). This is soft constraint. Child can return bigger size to indicate that it wants bigger space and hope that parent can throw in scrolling... availableHeight int desiredWidth int desiredHeight int Remarks MeasureOverride is designed to be the main customizability point for size control of layout. UIElement authors should override this method, call Measure on each child UIElement, and compute their desired size based upon the measurement of the children. The return value should be the desired size. Note: It is required that a parent UIElement calls Measure on each child or they won't be sized/arranged. Typical override follows a pattern roughly like this (pseudo-code): protected override void MeasureOverride(int avialableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) { foreach (UIElement child in VisualChildren) { child.Measure(availableSize); availableSize.Deflate(child.DesiredSize); _cache.StoreInfoAboutChild(child); } Size desired = CalculateBasedOnCache(_cache); return desired; }</code></pre></example> The key aspects of this snippet are: You must call Measure on each child UIElement It is common to cache measurement information between the MeasureOverride and ArrangeOverride method calls Calling base.MeasureOverride is not required. Calls to Measure on children are passing either the same availableSize as the parent, or a subset of the area depending on the type of layout the parent will perform (for example, it would be valid to remove the area for some border or padding). OnRender(DrawingContext) public override void OnRender(DrawingContext dc) Parameters dc DrawingContext OnTouchUp(TouchEventArgs) protected override void OnTouchUp(TouchEventArgs e) Parameters e TouchEventArgs Events TextChanged public event TextChangedEventHandler TextChanged Event Type TextChangedEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.TextChangedEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.TextChangedEventArgs.html",
    "title": "Class TextChangedEventArgs",
    "keywords": "Class TextChangedEventArgs Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class TextChangedEventArgs : RoutedEventArgs Inheritance object EventArgs RoutedEventArgs TextChangedEventArgs Inherited Members RoutedEventArgs.RoutedEvent RoutedEventArgs.Handled RoutedEventArgs.Source RoutedEventArgs.OriginalSource RoutedEventArgs.OnSetSource(object) EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors TextChangedEventArgs(RoutedEvent, object) public TextChangedEventArgs(RoutedEvent routedEvent, object source) Parameters routedEvent RoutedEvent source object"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.TextChangedEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.TextChangedEventHandler.html",
    "title": "Delegate TextChangedEventHandler",
    "keywords": "Delegate TextChangedEventHandler Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public delegate void TextChangedEventHandler(object sender, TextChangedEventArgs e) Parameters sender object e TextChangedEventArgs"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.TextFlow.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.TextFlow.html",
    "title": "Class TextFlow",
    "keywords": "Class TextFlow Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class TextFlow : UIElement Inheritance object DispatcherObject UIElement TextFlow Inherited Members UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors TextFlow() public TextFlow() Fields TextRuns public TextRunCollection TextRuns Field Value TextRunCollection Properties LineCount public int LineCount { get; } Property Value int ScrollingStyle public ScrollingStyle ScrollingStyle { get; set; } Property Value ScrollingStyle TextAlignment public TextAlignment TextAlignment { get; set; } Property Value TextAlignment TopLine public int TopLine { get; set; } Property Value int Methods MeasureOverride(int, int, out int, out int) Measurement override. Implement your size-to-content logic here. protected override void MeasureOverride(int availableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) Parameters availableWidth int Available size that parent can give to the child. May be MaxValue(when parent wants to measure to content). This is soft constraint. Child can return bigger size to indicate that it wants bigger space and hope that parent can throw in scrolling... availableHeight int desiredWidth int desiredHeight int Remarks MeasureOverride is designed to be the main customizability point for size control of layout. UIElement authors should override this method, call Measure on each child UIElement, and compute their desired size based upon the measurement of the children. The return value should be the desired size. Note: It is required that a parent UIElement calls Measure on each child or they won't be sized/arranged. Typical override follows a pattern roughly like this (pseudo-code): protected override void MeasureOverride(int avialableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) { foreach (UIElement child in VisualChildren) { child.Measure(availableSize); availableSize.Deflate(child.DesiredSize); _cache.StoreInfoAboutChild(child); } Size desired = CalculateBasedOnCache(_cache); return desired; }</code></pre></example> The key aspects of this snippet are: You must call Measure on each child UIElement It is common to cache measurement information between the MeasureOverride and ArrangeOverride method calls Calling base.MeasureOverride is not required. Calls to Measure on children are passing either the same availableSize as the parent, or a subset of the area depending on the type of layout the parent will perform (for example, it would be valid to remove the area for some border or padding). OnButtonDown(ButtonEventArgs) An event reporting a button was pressed. protected override void OnButtonDown(ButtonEventArgs e) Parameters e ButtonEventArgs OnRender(DrawingContext) public override void OnRender(DrawingContext dc) Parameters dc DrawingContext"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.TextRun.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.TextRun.html",
    "title": "Class TextRun",
    "keywords": "Class TextRun Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class TextRun Inheritance object TextRun Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors TextRun(string, Font, Color) public TextRun(string text, Font font, Color foreColor) Parameters text string font Font foreColor Color Fields Font public readonly Font Font Field Value Font ForeColor public readonly Color ForeColor Field Value Color Text public readonly string Text Field Value string _height protected int _height Field Value int _width protected int _width Field Value int Properties EndOfLine public static TextRun EndOfLine { get; } Property Value TextRun Methods GetSize(out int, out int) public void GetSize(out int width, out int height) Parameters width int height int"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.TextRunCollection.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.TextRunCollection.html",
    "title": "Class TextRunCollection",
    "keywords": "Class TextRunCollection Namespace GHIElectronics.Endpoint.UI.Controls Assembly GHIElectronics.Endpoint.UI.dll public class TextRunCollection : ICollection, IEnumerable Inheritance object TextRunCollection Implements ICollection IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Count Gets the number of elements contained in the ICollection. public int Count { get; } Property Value int The number of elements contained in the ICollection. IsSynchronized Gets a value indicating whether access to the ICollection is synchronized (thread safe). public bool IsSynchronized { get; } Property Value bool true if access to the ICollection is synchronized (thread safe); otherwise, false. this[int] public TextRun this[int index] { get; set; } Parameters index int Property Value TextRun SyncRoot Gets an object that can be used to synchronize access to the ICollection. public object SyncRoot { get; } Property Value object An object that can be used to synchronize access to the ICollection. Methods Add(TextRun) public int Add(TextRun textRun) Parameters textRun TextRun Returns int Add(string, Font, Color) public int Add(string text, Font font, Color foreColor) Parameters text string font Font foreColor Color Returns int Clear() public void Clear() Contains(TextRun) public bool Contains(TextRun run) Parameters run TextRun Returns bool CopyTo(Array, int) Copies the elements of the ICollection to an Array, starting at a particular Array index. public void CopyTo(Array array, int index) Parameters array Array The one-dimensional Array that is the destination of the elements copied from ICollection. The Array must have zero-based indexing. index int The zero-based index in array at which copying begins. Exceptions ArgumentNullException array is null. ArgumentOutOfRangeException index is less than zero. ArgumentException array is multidimensional. -or- The number of elements in the source ICollection is greater than the available space from index to the end of the destination array. -or- The type of the source ICollection cannot be cast automatically to the type of the destination array. GetEnumerator() Returns an enumerator that iterates through a collection. public IEnumerator GetEnumerator() Returns IEnumerator An IEnumerator object that can be used to iterate through the collection. IndexOf(TextRun) public int IndexOf(TextRun run) Parameters run TextRun Returns int Insert(int, TextRun) public void Insert(int index, TextRun run) Parameters index int run TextRun Remove(TextRun) public void Remove(TextRun run) Parameters run TextRun RemoveAt(int) public void RemoveAt(int index) Parameters index int"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Controls.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Controls.html",
    "title": "Namespace GHIElectronics.Endpoint.UI.Controls",
    "keywords": "Namespace GHIElectronics.Endpoint.UI.Controls Classes Border Button Canvas Chart Chart.DataItem Chart.Point Chart.PointF Chart.PointModel CheckBox ContentControl Control DataGrid The DataGrid component is a list-based component that provides a grid of rows and columns. DataGrid.TapCellEventArgs Tap cell event arguments. DataGridColumn The DataGridColumn class describes a column in a DataGrid component. DataGridItem The DataGridItem class describes an item in a DataGrid component. DataGridItemComparer The DataGridItemComparer class allows comparison between DataGridItems. Dropdown Gauge Image Summary description for Image. ListBox ListBoxItem ListBoxItemCollection ListBoxItemHighlightable MessageBox MessageBox.MessageBoxRoutedEventArgs Panel Point ProgressBar RadioButton RadioButtonManager ScrollChangedEventArgs ScrollViewer SelectionChangedEventArgs Slider The Slider component lets users select a value by sliding a knob along a track. Slider.ValueChangedEventArgs StackPanel Text TextBox TextChangedEventArgs TextFlow TextRun TextRunCollection Enums Chart.ChartMode DataGrid.Order The order in which rows are sorted. Direction MessageBox.DialogResult MessageBox.MessageBoxButtons Orientation ScrollingStyle Delegates DataGrid.OnTapCell Tap cell event handler. MessageBox.MessageBoxRoutedEventHandler ScrollChangedEventHandler SelectionChangedEventHandler Slider.ValueChangedEventHandler TextChangedEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.EventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.EventHandler.html",
    "title": "Delegate EventHandler",
    "keywords": "Delegate EventHandler Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll public delegate void EventHandler(object sender, EventArgs e) Parameters sender object e EventArgs"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.EventRoute.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.EventRoute.html",
    "title": "Class EventRoute",
    "keywords": "Class EventRoute Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll public sealed class EventRoute Inheritance object EventRoute Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors EventRoute(RoutedEvent) public EventRoute(RoutedEvent routedEvent) Parameters routedEvent RoutedEvent Methods Add(object, RoutedEventHandler, bool) Adds this handler for the specified target to the route public void Add(object target, RoutedEventHandler handler, bool handledEventsToo) Parameters target object Target object whose handler is to be added to the route handler RoutedEventHandler Handler to be added to the route handledEventsToo bool Flag indicating whether or not the listener wants to hear about events that have already been handled Remarks NOTE: It is not an error to add a handler for a particular target instance twice (handler will simply be called twice)."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.HorizontalAlignment.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.HorizontalAlignment.html",
    "title": "Enum HorizontalAlignment",
    "keywords": "Enum HorizontalAlignment Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll public enum HorizontalAlignment Fields Center = 1 Left = 0 Right = 2 Stretch = 3"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.BaseEvent.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.BaseEvent.html",
    "title": "Class BaseEvent",
    "keywords": "Class BaseEvent Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public class BaseEvent Inheritance object BaseEvent Derived GenericEvent TouchEvent Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields EventMessage public byte EventMessage Field Value byte Source public ushort Source Field Value ushort"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.ButtonDevice.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.ButtonDevice.html",
    "title": "Class ButtonDevice",
    "keywords": "Class ButtonDevice Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll The ButtonDevice class represents the button device to the members of a context. public sealed class ButtonDevice : InputDevice Inheritance object DispatcherObject InputDevice ButtonDevice Inherited Members DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties DeviceType public override InputManager.InputDeviceType DeviceType { get; } Property Value InputManager.InputDeviceType Target Returns the element that input from this device is sent to. public override UIElement Target { get; } Property Value UIElement Methods Focus(UIElement) Focuses the button input on a particular element. public UIElement Focus(UIElement obj) Parameters obj UIElement Returns UIElement Element focused to GetButtonState(HardwareButton) Returns the state of the specified button. public ButtonState GetButtonState(HardwareButton button) Parameters button HardwareButton Returns ButtonState IsButtonDown(HardwareButton) Returns whether or not the specified button is down. public bool IsButtonDown(HardwareButton button) Parameters button HardwareButton Returns bool IsButtonHeld(HardwareButton) Returns whether or not the specified button is held. public bool IsButtonHeld(HardwareButton button) Parameters button HardwareButton Returns bool IsButtonUp(HardwareButton) Returns whether or not the specified button is up. public bool IsButtonUp(HardwareButton button) Parameters button HardwareButton Returns bool"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.ButtonEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.ButtonEventArgs.html",
    "title": "Class ButtonEventArgs",
    "keywords": "Class ButtonEventArgs Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll The ButtonEventArgs class contains information about button states. public class ButtonEventArgs : InputEventArgs Inheritance object EventArgs RoutedEventArgs InputEventArgs ButtonEventArgs Inherited Members InputEventArgs.Device InputEventArgs.Timestamp RoutedEventArgs.RoutedEvent RoutedEventArgs.Handled RoutedEventArgs.Source RoutedEventArgs.OriginalSource RoutedEventArgs.OnSetSource(object) EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ButtonEventArgs(ButtonDevice, PresentationSource, DateTime, HardwareButton) Constructs an instance of the ButtonEventArgs class. public ButtonEventArgs(ButtonDevice buttonDevice, PresentationSource inputSource, DateTime timestamp, HardwareButton button) Parameters buttonDevice ButtonDevice The button device associated with this event. inputSource PresentationSource timestamp DateTime The time when the input occured. (machine time) button HardwareButton The button referenced by the event. Fields Button The Button referenced by the event. public readonly HardwareButton Button Field Value HardwareButton InputSource The source for this button public readonly PresentationSource InputSource Field Value PresentationSource Properties ButtonState The state of the button referenced by the event. public ButtonState ButtonState { get; } Property Value ButtonState IsRepeat Whether the button pressed is a repeated button or not. public bool IsRepeat { get; } Property Value bool"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.ButtonEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.ButtonEventHandler.html",
    "title": "Delegate ButtonEventHandler",
    "keywords": "Delegate ButtonEventHandler Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll The delegate to use for handlers that receive ButtonEventArgs. public delegate void ButtonEventHandler(object sender, ButtonEventArgs e) Parameters sender object The delegate to use for handlers that receive ButtonEventArgs. e ButtonEventArgs The delegate to use for handlers that receive ButtonEventArgs."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.ButtonState.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.ButtonState.html",
    "title": "Enum ButtonState",
    "keywords": "Enum ButtonState Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll The ButtonState enumeration describes the state that buttons can be in. [Flags] public enum ButtonState : byte Fields Down = 1 The button is down. Held = 2 The button is held None = 0 No state (same as up)."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.Buttons.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.Buttons.html",
    "title": "Class Buttons",
    "keywords": "Class Buttons Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll The Button class represents the button device to the members of a context. public sealed class Buttons Inheritance object Buttons Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks The static members of this class simply delegate to the primary button device of the calling thread's input manager. Fields ButtonDownEvent ButtonDown public static readonly RoutedEvent ButtonDownEvent Field Value RoutedEvent ButtonUpEvent ButtonUp public static readonly RoutedEvent ButtonUpEvent Field Value RoutedEvent GotFocusEvent GotFocus public static readonly RoutedEvent GotFocusEvent Field Value RoutedEvent LostFocusEvent LostFocus public static readonly RoutedEvent LostFocusEvent Field Value RoutedEvent PreviewButtonDownEvent PreviewButtonDown public static readonly RoutedEvent PreviewButtonDownEvent Field Value RoutedEvent PreviewButtonUpEvent PreviewButtonUp public static readonly RoutedEvent PreviewButtonUpEvent Field Value RoutedEvent Properties FocusedElement Returns the element that the button is focused on. public static UIElement FocusedElement { get; } Property Value UIElement PrimaryDevice The primary button device. public static ButtonDevice PrimaryDevice { get; } Property Value ButtonDevice Methods Focus(UIElement) Focuses the button on a particular element. public static UIElement Focus(UIElement element) Parameters element UIElement The element to focus the button on. Returns UIElement GetButtonState(HardwareButton) Returns the state of the specified button. public static ButtonState GetButtonState(HardwareButton button) Parameters button HardwareButton Returns ButtonState IsButtonDown(HardwareButton) Returns whether or not the specified button is down. public static bool IsButtonDown(HardwareButton button) Parameters button HardwareButton Returns bool IsButtonHeld(HardwareButton) Returns whether or not the specified button is held. public static bool IsButtonHeld(HardwareButton button) Parameters button HardwareButton Returns bool IsButtonUp(HardwareButton) Returns whether or not the specified button is up. public static bool IsButtonUp(HardwareButton button) Parameters button HardwareButton Returns bool"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.CaptureMode.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.CaptureMode.html",
    "title": "Enum CaptureMode",
    "keywords": "Enum CaptureMode Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public enum CaptureMode Fields Element = 1 None = 0 SubTree = 2"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.FocusChangedEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.FocusChangedEventArgs.html",
    "title": "Class FocusChangedEventArgs",
    "keywords": "Class FocusChangedEventArgs Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll The FocusChangedEventArgs class contains information about focus states public class FocusChangedEventArgs : InputEventArgs Inheritance object EventArgs RoutedEventArgs InputEventArgs FocusChangedEventArgs Inherited Members InputEventArgs.Device InputEventArgs.Timestamp RoutedEventArgs.RoutedEvent RoutedEventArgs.Handled RoutedEventArgs.Source RoutedEventArgs.OriginalSource RoutedEventArgs.OnSetSource(object) EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors FocusChangedEventArgs(ButtonDevice, DateTime, UIElement, UIElement) Constructs an instance of the FocusChangedEventArgs class. public FocusChangedEventArgs(ButtonDevice buttonDevice, DateTime timestamp, UIElement oldFocus, UIElement newFocus) Parameters buttonDevice ButtonDevice timestamp DateTime The time when the input occured. oldFocus UIElement The element that previously had focus. newFocus UIElement The element that now has focus. Fields NewFocus The element that now has focus. public readonly UIElement NewFocus Field Value UIElement OldFocus The element that previously had focus. public readonly UIElement OldFocus Field Value UIElement"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.FocusChangedEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.FocusChangedEventHandler.html",
    "title": "Delegate FocusChangedEventHandler",
    "keywords": "Delegate FocusChangedEventHandler Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll The delegate to use for handlers that receive FocusChangedEventArgs. public delegate void FocusChangedEventHandler(object sender, FocusChangedEventArgs e) Parameters sender object The delegate to use for handlers that receive FocusChangedEventArgs. e FocusChangedEventArgs The delegate to use for handlers that receive FocusChangedEventArgs."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.GenericDevice.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.GenericDevice.html",
    "title": "Class GenericDevice",
    "keywords": "Class GenericDevice Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll The GenericDevice class represents the Generic device to the members of a context. public sealed class GenericDevice : InputDevice Inheritance object DispatcherObject InputDevice GenericDevice Inherited Members DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties DeviceType public override InputManager.InputDeviceType DeviceType { get; } Property Value InputManager.InputDeviceType Target Returns the element that input from this device is sent to. public override UIElement Target { get; } Property Value UIElement Methods SetTarget(UIElement) public void SetTarget(UIElement target) Parameters target UIElement"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.GenericEvent.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.GenericEvent.html",
    "title": "Class GenericEvent",
    "keywords": "Class GenericEvent Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public class GenericEvent : BaseEvent Inheritance object BaseEvent GenericEvent Inherited Members BaseEvent.Source BaseEvent.EventMessage object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields EventCategory public byte EventCategory Field Value byte EventData public uint EventData Field Value uint Time public DateTime Time Field Value DateTime X public int X Field Value int Y public int Y Field Value int"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.GenericEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.GenericEventArgs.html",
    "title": "Class GenericEventArgs",
    "keywords": "Class GenericEventArgs Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public class GenericEventArgs : InputEventArgs Inheritance object EventArgs RoutedEventArgs InputEventArgs GenericEventArgs Inherited Members InputEventArgs.Device InputEventArgs.Timestamp RoutedEventArgs.RoutedEvent RoutedEventArgs.Handled RoutedEventArgs.Source RoutedEventArgs.OriginalSource RoutedEventArgs.OnSetSource(object) EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors GenericEventArgs(InputDevice, GenericEvent) public GenericEventArgs(InputDevice inputDevice, GenericEvent genericEvent) Parameters inputDevice InputDevice genericEvent GenericEvent Fields InternalEvent public readonly GenericEvent InternalEvent Field Value GenericEvent"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.GenericEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.GenericEventHandler.html",
    "title": "Delegate GenericEventHandler",
    "keywords": "Delegate GenericEventHandler Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public delegate void GenericEventHandler(object sender, GenericEventArgs e) Parameters sender object e GenericEventArgs"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.GenericEvents.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.GenericEvents.html",
    "title": "Class GenericEvents",
    "keywords": "Class GenericEvents Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public sealed class GenericEvents Inheritance object GenericEvents Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Fields GenericStandardEvent public static readonly RoutedEvent GenericStandardEvent Field Value RoutedEvent"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.HardwareButton.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.HardwareButton.html",
    "title": "Enum HardwareButton",
    "keywords": "Enum HardwareButton Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public enum HardwareButton Fields Back = 6 Down = 1 Home = 7 Left = 3 None = 0 Right = 4 Select = 5 Up = 2"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputDevice.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputDevice.html",
    "title": "Class InputDevice",
    "keywords": "Class InputDevice Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll Provides the base class for all input devices. public abstract class InputDevice : DispatcherObject Inheritance object DispatcherObject InputDevice Derived ButtonDevice GenericDevice TouchDevice Inherited Members DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors InputDevice() Constructs an instance of the InputDevice class. protected InputDevice() Properties DeviceType public abstract InputManager.InputDeviceType DeviceType { get; } Property Value InputManager.InputDeviceType Target Returns the element that input from this device is sent to. public abstract UIElement Target { get; } Property Value UIElement"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputEventArgs.html",
    "title": "Class InputEventArgs",
    "keywords": "Class InputEventArgs Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll The InputEventArgs class represents a type of RoutedEventArgs that are relevant to all input events. public class InputEventArgs : RoutedEventArgs Inheritance object EventArgs RoutedEventArgs InputEventArgs Derived ButtonEventArgs FocusChangedEventArgs GenericEventArgs InputReportEventArgs TouchEventArgs Inherited Members RoutedEventArgs.RoutedEvent RoutedEventArgs.Handled RoutedEventArgs.Source RoutedEventArgs.OriginalSource RoutedEventArgs.OnSetSource(object) EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors InputEventArgs(InputDevice, DateTime) Initializes a new instance of the InputEventArgs class. public InputEventArgs(InputDevice inputDevice, DateTime timestamp) Parameters inputDevice InputDevice The input device to associate with this event. timestamp DateTime The time when the input occured. Fields Timestamp Read-only access to the input timestamp. public readonly DateTime Timestamp Field Value DateTime Properties Device Read-only access to the input device that initiated this event. public InputDevice Device { get; } Property Value InputDevice"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputEventHandler.html",
    "title": "Delegate InputEventHandler",
    "keywords": "Delegate InputEventHandler Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll The delegate to use for handlers that receive InputEventArgs. public delegate void InputEventHandler(object sender, InputEventArgs e) Parameters sender object The delegate to use for handlers that receive InputEventArgs. e InputEventArgs The delegate to use for handlers that receive InputEventArgs."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputManager.DeviceEvents.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputManager.DeviceEvents.html",
    "title": "Class InputManager.DeviceEvents",
    "keywords": "Class InputManager.DeviceEvents Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public class InputManager.DeviceEvents : DispatcherObject Inheritance object DispatcherObject InputManager.DeviceEvents Inherited Members DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Events PostNotifyInput Subscribe to all input after it is notified public event NotifyInputEventHandler PostNotifyInput Event Type NotifyInputEventHandler PostProcessInput subscribe to all input after it is processed public event ProcessInputEventHandler PostProcessInput Event Type ProcessInputEventHandler PreNotifyInput Subscribe for all input before it is notified public event NotifyInputEventHandler PreNotifyInput Event Type NotifyInputEventHandler PreProcessInput Subscribe for all input before it is processed public event PreProcessInputEventHandler PreProcessInput Event Type PreProcessInputEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputManager.InputDeviceType.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputManager.InputDeviceType.html",
    "title": "Enum InputManager.InputDeviceType",
    "keywords": "Enum InputManager.InputDeviceType Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public enum InputManager.InputDeviceType Fields Button = 0 Generic = 2 Last = 3 Touch = 1"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputManager.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputManager.html",
    "title": "Class InputManager",
    "keywords": "Class InputManager Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll The InputManager class is responsible for coordinating all of the input system in TinyCore. The input manager exists per Dispatcher public sealed class InputManager : DispatcherObject Inheritance object DispatcherObject InputManager Inherited Members DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Fields InputDeviceEvents public InputManager.DeviceEvents[] InputDeviceEvents Field Value DeviceEvents[] InputReportEvent A routed event indicating that an input report arrived. public static readonly RoutedEvent InputReportEvent Field Value RoutedEvent PreviewInputReportEvent A routed event indicating that an input report arrived. public static readonly RoutedEvent PreviewInputReportEvent Field Value RoutedEvent Properties ButtonDevice public ButtonDevice ButtonDevice { get; } Property Value ButtonDevice CurrentInputManager Return the input manager associated with the current context. public static InputManager CurrentInputManager { get; } Property Value InputManager Remarks This class will not be available in internet zone. GenericDevice public GenericDevice GenericDevice { get; } Property Value GenericDevice InputProviders Returns a collection of input providers registered with the input manager. public ICollection InputProviders { get; } Property Value ICollection MostRecentInputDevice The MostRecentInputDevice represents the last input device to report an \"interesting\" user action. What exactly constitutes such an action is up to each device to implement. public InputDevice MostRecentInputDevice { get; set; } Property Value InputDevice TouchDevice public TouchDevice TouchDevice { get; } Property Value TouchDevice Methods ProcessInput(InputEventArgs) Synchronously processes the specified input. public bool ProcessInput(InputEventArgs input) Parameters input InputEventArgs Returns bool Whether or not any event generated as a consequence of this event was handled. Remarks The specified input is processed by all of the filters and monitors, and is finally dispatched to the appropriate element as an input event. RegisterInputProvider(object) Registers an input provider with the input manager. public InputProviderSite RegisterInputProvider(object inputProvider) Parameters inputProvider object The input provider to register. Returns InputProviderSite"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputProvider.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputProvider.html",
    "title": "Class InputProvider",
    "keywords": "Class InputProvider Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public sealed class InputProvider Inheritance object InputProvider Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors InputProvider(Application) public InputProvider(Application a) Parameters a Application Methods RaiseButton(HardwareButton, bool, DateTime) public void RaiseButton(HardwareButton button, bool state, DateTime time) Parameters button HardwareButton state bool time DateTime RaiseTouch(int, int, TouchMessages, DateTime) public void RaiseTouch(int x, int y, TouchMessages which, DateTime time) Parameters x int y int which TouchMessages time DateTime"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputProviderSite.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputProviderSite.html",
    "title": "Class InputProviderSite",
    "keywords": "Class InputProviderSite Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll The object which input providers use to report input to the input manager. public class InputProviderSite : IDisposable Inheritance object InputProviderSite Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties InputManager Returns the input manager that this site is attached to. public InputManager InputManager { get; } Property Value InputManager IsDisposed Returns true if we are disposed. public bool IsDisposed { get; } Property Value bool Methods Dispose() Unregisters this input provider. public void Dispose() Dispose(bool) protected virtual void Dispose(bool disposing) Parameters disposing bool ReportInput(InputDevice, InputReport) Reports input to the input manager. public bool ReportInput(InputDevice device, InputReport inputReport) Parameters device InputDevice inputReport InputReport Returns bool Whether or not any event generated as a consequence of this event was handled."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputReport.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputReport.html",
    "title": "Class InputReport",
    "keywords": "Class InputReport Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll The InputReport is an abstract base class for all input that is reported to the InputManager. public abstract class InputReport Inheritance object InputReport Derived RawButtonInputReport RawGenericInputReport RawTouchInputReport Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks It is important to note that the InputReport class only contains blittable types. This is required so that the report can be marshalled across application domains. Constructors InputReport(PresentationSource, DateTime) Constructs an instance of the InputReport class. protected InputReport(PresentationSource inputSource, DateTime timestamp) Parameters inputSource PresentationSource The type of input that is being reported. timestamp DateTime The time when the input occured. Fields InputSource Read-only access to the type of input source that reported input. public readonly PresentationSource InputSource Field Value PresentationSource Timestamp Read-only access to the time when the input occured. public readonly DateTime Timestamp Field Value DateTime"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputReportArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputReportArgs.html",
    "title": "Class InputReportArgs",
    "keywords": "Class InputReportArgs Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll report arguments public class InputReportArgs Inheritance object InputReportArgs Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors InputReportArgs(object, object) public InputReportArgs(object dev, object report) Parameters dev object report object Fields Device public readonly InputDevice Device Field Value InputDevice Report public readonly InputReport Report Field Value InputReport"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputReportEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputReportEventArgs.html",
    "title": "Class InputReportEventArgs",
    "keywords": "Class InputReportEventArgs Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll The InputReportEventArgs class contains information about an input report that is being processed. public class InputReportEventArgs : InputEventArgs Inheritance object EventArgs RoutedEventArgs InputEventArgs InputReportEventArgs Inherited Members InputEventArgs.Device InputEventArgs.Timestamp RoutedEventArgs.RoutedEvent RoutedEventArgs.Handled RoutedEventArgs.Source RoutedEventArgs.OriginalSource RoutedEventArgs.OnSetSource(object) EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors InputReportEventArgs(InputDevice, InputReport) Initializes a new instance of the InputReportEventArgs class. public InputReportEventArgs(InputDevice inputDevice, InputReport report) Parameters inputDevice InputDevice The input device to associate this input with. report InputReport The input report being processed. Fields Report Read-only access to the input report being processed. public readonly InputReport Report Field Value InputReport"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputReportEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.InputReportEventHandler.html",
    "title": "Delegate InputReportEventHandler",
    "keywords": "Delegate InputReportEventHandler Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll The delegate to use for handlers that receive InputReportEventArgs public delegate void InputReportEventHandler(object sender, InputReportEventArgs e) Parameters sender object The delegate to use for handlers that receive InputReportEventArgs e InputReportEventArgs The delegate to use for handlers that receive InputReportEventArgs"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.NotifyInputEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.NotifyInputEventArgs.html",
    "title": "Class NotifyInputEventArgs",
    "keywords": "Class NotifyInputEventArgs Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll Provides information about an input event being processed by the input manager. public class NotifyInputEventArgs : EventArgs Inheritance object EventArgs NotifyInputEventArgs Derived ProcessInputEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks An instance of this class, or a derived class, is passed to the handlers of the following events: Fields StagingItem The staging area input item being processed by the input manager. public readonly StagingAreaInputItem StagingItem Field Value StagingAreaInputItem"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.NotifyInputEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.NotifyInputEventHandler.html",
    "title": "Delegate NotifyInputEventHandler",
    "keywords": "Delegate NotifyInputEventHandler Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll Delegate type for handles of events that use NotifyInputEventArgs. public delegate void NotifyInputEventHandler(object sender, NotifyInputEventArgs e) Parameters sender object Delegate type for handles of events that use . e NotifyInputEventArgs Delegate type for handles of events that use ."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.PreProcessInputEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.PreProcessInputEventArgs.html",
    "title": "Class PreProcessInputEventArgs",
    "keywords": "Class PreProcessInputEventArgs Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll Allows the handler to cancel the processing of an input event. public sealed class PreProcessInputEventArgs : ProcessInputEventArgs Inheritance object EventArgs NotifyInputEventArgs ProcessInputEventArgs PreProcessInputEventArgs Inherited Members ProcessInputEventArgs.PushInput(InputEventArgs, StagingAreaInputItem) ProcessInputEventArgs.PushInput(StagingAreaInputItem) ProcessInputEventArgs.PopInput() ProcessInputEventArgs.PeekInput() NotifyInputEventArgs.StagingItem EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks An instance of this class is passed to the handlers of the following events: Properties Canceled Whether or not the input event processing was canceled. public bool Canceled { get; } Property Value bool Methods Cancel() Cancels the processing of the input event. public void Cancel()"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.PreProcessInputEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.PreProcessInputEventHandler.html",
    "title": "Delegate PreProcessInputEventHandler",
    "keywords": "Delegate PreProcessInputEventHandler Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll Delegate type for handles of events that use PreProcessInputEventArgs. public delegate void PreProcessInputEventHandler(object sender, PreProcessInputEventArgs e) Parameters sender object Delegate type for handles of events that use . e PreProcessInputEventArgs Delegate type for handles of events that use ."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.ProcessInputEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.ProcessInputEventArgs.html",
    "title": "Class ProcessInputEventArgs",
    "keywords": "Class ProcessInputEventArgs Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll Provides access to the input manager's staging area. public class ProcessInputEventArgs : NotifyInputEventArgs Inheritance object EventArgs NotifyInputEventArgs ProcessInputEventArgs Derived PreProcessInputEventArgs Inherited Members NotifyInputEventArgs.StagingItem EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks An instance of this class, or a derived class, is passed to the handlers of the following events: Methods PeekInput() Returns the input event on the top of the staging area. public StagingAreaInputItem PeekInput() Returns StagingAreaInputItem The input event that is on the top of the staging area. This can be null, if the staging area is empty. PopInput() Pops off the input event on the top of the staging area. public StagingAreaInputItem PopInput() Returns StagingAreaInputItem The input event that was on the top of the staging area. This can be null, if the staging area was empty. PushInput(InputEventArgs, StagingAreaInputItem) Pushes an input event onto the top of the staging area. public StagingAreaInputItem PushInput(InputEventArgs input, StagingAreaInputItem promote) Parameters input InputEventArgs The input event to place on the staging area. This may not be null, and may not already exist in the staging area. promote StagingAreaInputItem An existing staging area item to promote the state from. Returns StagingAreaInputItem The staging area input item that wraps the specified input. PushInput(StagingAreaInputItem) Pushes an input event onto the top of the staging area. public StagingAreaInputItem PushInput(StagingAreaInputItem input) Parameters input StagingAreaInputItem The input event to place on the staging area. This may not be null, and may not already exist in the staging area. Returns StagingAreaInputItem The specified staging area input item."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.ProcessInputEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.ProcessInputEventHandler.html",
    "title": "Delegate ProcessInputEventHandler",
    "keywords": "Delegate ProcessInputEventHandler Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll Delegate type for handles of events that use ProcessInputEventArgs. public delegate void ProcessInputEventHandler(object sender, ProcessInputEventArgs e) Parameters sender object Delegate type for handles of events that use . e ProcessInputEventArgs Delegate type for handles of events that use ."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.RawButtonActions.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.RawButtonActions.html",
    "title": "Enum RawButtonActions",
    "keywords": "Enum RawButtonActions Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public enum RawButtonActions Fields Activate = 4 ButtonDown = 1 ButtonUp = 2 Deactivate = 8"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.RawButtonInputReport.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.RawButtonInputReport.html",
    "title": "Class RawButtonInputReport",
    "keywords": "Class RawButtonInputReport Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll The RawButtonInputReport class encapsulates the raw input provided from a keyboard. public class RawButtonInputReport : InputReport Inheritance object InputReport RawButtonInputReport Inherited Members InputReport.InputSource InputReport.Timestamp object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks It is important to note that the InputReport class only contains blittable types. This is required so that the report can be marshalled across application domains. Constructors RawButtonInputReport(PresentationSource, DateTime, HardwareButton, RawButtonActions) Constructs an instance of the RawKeyboardInputReport class. public RawButtonInputReport(PresentationSource inputSource, DateTime timestamp, HardwareButton button, RawButtonActions actions) Parameters inputSource PresentationSource source of the input timestamp DateTime The time when the input occured. button HardwareButton actions RawButtonActions Fields Actions Read-only access to the action reported. public readonly RawButtonActions Actions Field Value RawButtonActions Button Read-only access to the button reported. public readonly HardwareButton Button Field Value HardwareButton"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.RawGenericInputReport.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.RawGenericInputReport.html",
    "title": "Class RawGenericInputReport",
    "keywords": "Class RawGenericInputReport Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll The RawGenericInputReport class encapsulates the raw input provided from a keyboard. public class RawGenericInputReport : InputReport Inheritance object InputReport RawGenericInputReport Inherited Members InputReport.InputSource InputReport.Timestamp object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks It is important to note that the InputReport class only contains blittable types. This is required so that the report can be marshalled across application domains. Constructors RawGenericInputReport(PresentationSource, GenericEvent) Constructs an instance of the RawKeyboardInputReport class. public RawGenericInputReport(PresentationSource inputSource, GenericEvent genericEvent) Parameters inputSource PresentationSource source of the input genericEvent GenericEvent RawGenericInputReport(PresentationSource, GenericEvent, UIElement) public RawGenericInputReport(PresentationSource inputSource, GenericEvent genericEvent, UIElement destTarget) Parameters inputSource PresentationSource genericEvent GenericEvent destTarget UIElement Fields InternalEvent public readonly GenericEvent InternalEvent Field Value GenericEvent Target public readonly UIElement Target Field Value UIElement"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.RawTouchActions.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.RawTouchActions.html",
    "title": "Enum RawTouchActions",
    "keywords": "Enum RawTouchActions Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public enum RawTouchActions Fields Activate = 4 Deactivate = 8 TouchDown = 1 TouchMove = 16 TouchUp = 2"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.RawTouchInputReport.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.RawTouchInputReport.html",
    "title": "Class RawTouchInputReport",
    "keywords": "Class RawTouchInputReport Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll The RawTouchInputReport class encapsulates the raw input provided from a multitouch source. public class RawTouchInputReport : InputReport Inheritance object InputReport RawTouchInputReport Inherited Members InputReport.InputSource InputReport.Timestamp object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks It is important to note that the InputReport class only contains blittable types. This is required so that the report can be marshalled across application domains. Constructors RawTouchInputReport(PresentationSource, DateTime, byte, TouchInput[]) Constructs an instance of the RawKeyboardInputReport class. public RawTouchInputReport(PresentationSource inputSource, DateTime timestamp, byte eventMessage, TouchInput[] touches) Parameters inputSource PresentationSource source of the input timestamp DateTime The time when the input occured. eventMessage byte touches TouchInput[] RawTouchInputReport(PresentationSource, DateTime, byte, TouchInput[], UIElement) public RawTouchInputReport(PresentationSource inputSource, DateTime timestamp, byte eventMessage, TouchInput[] touches, UIElement destTarget) Parameters inputSource PresentationSource timestamp DateTime eventMessage byte touches TouchInput[] destTarget UIElement Fields EventMessage public readonly byte EventMessage Field Value byte Target public readonly UIElement Target Field Value UIElement Touches public readonly TouchInput[] Touches Field Value TouchInput[]"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.StagingAreaInputItem.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.StagingAreaInputItem.html",
    "title": "Class StagingAreaInputItem",
    "keywords": "Class StagingAreaInputItem Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll This class encapsulates an input event while it is being processed by the input manager. public class StagingAreaInputItem Inheritance object StagingAreaInputItem Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks This class just provides the dictionary-based storage for all of the listeners of the various input manager events. Fields Input Returns the input event. public readonly InputEventArgs Input Field Value InputEventArgs Methods GetData(object) Provides storage for arbitrary data needed during the processing of this input event. public object GetData(object key) Parameters key object An arbitrary key for the data. This cannot be null. Returns object The data previously set for this key, or null. SetData(object, object) Provides storage for arbitrary data needed during the processing of this input event. public void SetData(object key, object value) Parameters key object An arbitrary key for the data. This cannot be null. value object The data to set for this key. This can be null."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchCapture.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchCapture.html",
    "title": "Class TouchCapture",
    "keywords": "Class TouchCapture Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public static class TouchCapture Inheritance object TouchCapture Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Captured public static UIElement Captured { get; } Property Value UIElement Methods Capture(UIElement) public static bool Capture(UIElement element) Parameters element UIElement Returns bool Capture(UIElement, CaptureMode) public static bool Capture(UIElement element, CaptureMode mode) Parameters element UIElement mode CaptureMode Returns bool"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchDevice.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchDevice.html",
    "title": "Class TouchDevice",
    "keywords": "Class TouchDevice Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll The TouchDevice class represents the stylus/touch device to the members of a context. public sealed class TouchDevice : InputDevice Inheritance object DispatcherObject InputDevice TouchDevice Inherited Members DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties DeviceType public override InputManager.InputDeviceType DeviceType { get; } Property Value InputManager.InputDeviceType Target Returns the element that input from this device is sent to. public override UIElement Target { get; } Property Value UIElement Methods SetTarget(UIElement) public void SetTarget(UIElement target) Parameters target UIElement"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchEvent.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchEvent.html",
    "title": "Class TouchEvent",
    "keywords": "Class TouchEvent Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public class TouchEvent : BaseEvent Inheritance object BaseEvent TouchEvent Inherited Members BaseEvent.Source BaseEvent.EventMessage object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields Time public DateTime Time Field Value DateTime Touches public TouchInput[] Touches Field Value TouchInput[]"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchEventArgs.html",
    "title": "Class TouchEventArgs",
    "keywords": "Class TouchEventArgs Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public class TouchEventArgs : InputEventArgs Inheritance object EventArgs RoutedEventArgs InputEventArgs TouchEventArgs Inherited Members InputEventArgs.Device InputEventArgs.Timestamp RoutedEventArgs.RoutedEvent RoutedEventArgs.Handled RoutedEventArgs.Source RoutedEventArgs.OriginalSource RoutedEventArgs.OnSetSource(object) EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors TouchEventArgs(InputDevice, DateTime, TouchInput[]) public TouchEventArgs(InputDevice inputDevice, DateTime timestamp, TouchInput[] touches) Parameters inputDevice InputDevice timestamp DateTime touches TouchInput[] Fields Touches public TouchInput[] Touches Field Value TouchInput[] Methods GetPosition(UIElement, int, out int, out int) public void GetPosition(UIElement relativeTo, int touchIndex, out int x, out int y) Parameters relativeTo UIElement touchIndex int x int y int"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchEventHandler.html",
    "title": "Delegate TouchEventHandler",
    "keywords": "Delegate TouchEventHandler Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public delegate void TouchEventHandler(object sender, TouchEventArgs e) Parameters sender object e TouchEventArgs"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchEvents.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchEvents.html",
    "title": "Class TouchEvents",
    "keywords": "Class TouchEvents Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public sealed class TouchEvents Inheritance object TouchEvents Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Fields TouchDownEvent public static readonly RoutedEvent TouchDownEvent Field Value RoutedEvent TouchMoveEvent public static readonly RoutedEvent TouchMoveEvent Field Value RoutedEvent TouchUpEvent public static readonly RoutedEvent TouchUpEvent Field Value RoutedEvent"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchGesture.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchGesture.html",
    "title": "Enum TouchGesture",
    "keywords": "Enum TouchGesture Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public enum TouchGesture : uint Fields Begin = 1 DoubleTap = 12 Down = 9 DownLeft = 8 DownRight = 10 End = 2 Left = 7 NoGesture = 0 Pan = 115 Right = 3 Rollover = 118 Rotate = 116 Tap = 11 TwoFingerTap = 117 Up = 5 UpLeft = 6 UpRight = 4 UserDefined = 200 Zoom = 114"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchGestureEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchGestureEventArgs.html",
    "title": "Class TouchGestureEventArgs",
    "keywords": "Class TouchGestureEventArgs Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public class TouchGestureEventArgs : EventArgs Inheritance object EventArgs TouchGestureEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields Arguments public ushort Arguments Field Value ushort Gesture public TouchGesture Gesture Field Value TouchGesture Timestamp public readonly DateTime Timestamp Field Value DateTime X public int X Field Value int Y public int Y Field Value int Properties Angle public double Angle { get; } Property Value double"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchGestureEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchGestureEventHandler.html",
    "title": "Delegate TouchGestureEventHandler",
    "keywords": "Delegate TouchGestureEventHandler Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public delegate void TouchGestureEventHandler(object sender, TouchGestureEventArgs e) Parameters sender object e TouchGestureEventArgs"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchInput.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchInput.html",
    "title": "Class TouchInput",
    "keywords": "Class TouchInput Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public class TouchInput Inheritance object TouchInput Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields X public int X Field Value int Y public int Y Field Value int"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchMessages.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.TouchMessages.html",
    "title": "Enum TouchMessages",
    "keywords": "Enum TouchMessages Namespace GHIElectronics.Endpoint.UI.Input Assembly GHIElectronics.Endpoint.UI.dll public enum TouchMessages : byte Fields Down = 1 Move = 3 Up = 2"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Input.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Input.html",
    "title": "Namespace GHIElectronics.Endpoint.UI.Input",
    "keywords": "Namespace GHIElectronics.Endpoint.UI.Input Classes BaseEvent ButtonDevice The ButtonDevice class represents the button device to the members of a context. ButtonEventArgs The ButtonEventArgs class contains information about button states. Buttons The Button class represents the button device to the members of a context. FocusChangedEventArgs The FocusChangedEventArgs class contains information about focus states GenericDevice The GenericDevice class represents the Generic device to the members of a context. GenericEvent GenericEventArgs GenericEvents InputDevice Provides the base class for all input devices. InputEventArgs The InputEventArgs class represents a type of RoutedEventArgs that are relevant to all input events. InputManager The InputManager class is responsible for coordinating all of the input system in TinyCore. The input manager exists per Dispatcher InputManager.DeviceEvents InputProvider InputProviderSite The object which input providers use to report input to the input manager. InputReport The InputReport is an abstract base class for all input that is reported to the InputManager. InputReportArgs report arguments InputReportEventArgs The InputReportEventArgs class contains information about an input report that is being processed. NotifyInputEventArgs Provides information about an input event being processed by the input manager. PreProcessInputEventArgs Allows the handler to cancel the processing of an input event. ProcessInputEventArgs Provides access to the input manager's staging area. RawButtonInputReport The RawButtonInputReport class encapsulates the raw input provided from a keyboard. RawGenericInputReport The RawGenericInputReport class encapsulates the raw input provided from a keyboard. RawTouchInputReport The RawTouchInputReport class encapsulates the raw input provided from a multitouch source. StagingAreaInputItem This class encapsulates an input event while it is being processed by the input manager. TouchCapture TouchDevice The TouchDevice class represents the stylus/touch device to the members of a context. TouchEvent TouchEventArgs TouchEvents TouchGestureEventArgs TouchInput Enums ButtonState The ButtonState enumeration describes the state that buttons can be in. CaptureMode HardwareButton InputManager.InputDeviceType RawButtonActions RawTouchActions TouchGesture TouchMessages Delegates ButtonEventHandler The delegate to use for handlers that receive ButtonEventArgs. FocusChangedEventHandler The delegate to use for handlers that receive FocusChangedEventArgs. GenericEventHandler InputEventHandler The delegate to use for handlers that receive InputEventArgs. InputReportEventHandler The delegate to use for handlers that receive InputReportEventArgs NotifyInputEventHandler Delegate type for handles of events that use NotifyInputEventArgs. PreProcessInputEventHandler Delegate type for handles of events that use PreProcessInputEventArgs. ProcessInputEventHandler Delegate type for handles of events that use ProcessInputEventArgs. TouchEventHandler TouchGestureEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Media.Brush.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Media.Brush.html",
    "title": "Class Brush",
    "keywords": "Class Brush Namespace GHIElectronics.Endpoint.UI.Media Assembly GHIElectronics.Endpoint.UI.dll public abstract class Brush Inheritance object Brush Derived ImageBrush LinearGradientBrush SolidColorBrush Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Opacity public ushort Opacity { get; set; } Property Value ushort"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Media.BrushMappingMode.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Media.BrushMappingMode.html",
    "title": "Enum BrushMappingMode",
    "keywords": "Enum BrushMappingMode Namespace GHIElectronics.Endpoint.UI.Media Assembly GHIElectronics.Endpoint.UI.dll public enum BrushMappingMode Fields Absolute = 0 RelativeToBoundingBox = 1"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Media.Color.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Media.Color.html",
    "title": "Struct Color",
    "keywords": "Struct Color Namespace GHIElectronics.Endpoint.UI.Media Assembly GHIElectronics.Endpoint.UI.dll public struct Color Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties A public byte A { readonly get; set; } Property Value byte B public byte B { readonly get; set; } Property Value byte G public byte G { readonly get; set; } Property Value byte R public byte R { readonly get; set; } Property Value byte Methods FromArgb(byte, byte, byte, byte) public static Color FromArgb(byte a, byte r, byte g, byte b) Parameters a byte r byte g byte b byte Returns Color FromRgb(byte, byte, byte) public static Color FromRgb(byte r, byte g, byte b) Parameters r byte g byte b byte Returns Color"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Media.Colors.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Media.Colors.html",
    "title": "Class Colors",
    "keywords": "Class Colors Namespace GHIElectronics.Endpoint.UI.Media Assembly GHIElectronics.Endpoint.UI.dll public sealed class Colors Inheritance object Colors Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties Black public static Color Black { get; } Property Value Color Blue public static Color Blue { get; } Property Value Color Gray public static Color Gray { get; } Property Value Color Green public static Color Green { get; } Property Value Color Purple public static Color Purple { get; } Property Value Color Red public static Color Red { get; } Property Value Color Teal public static Color Teal { get; } Property Value Color Transparent public static Color Transparent { get; } Property Value Color White public static Color White { get; } Property Value Color Yellow public static Color Yellow { get; } Property Value Color"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Media.Constants.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Media.Constants.html",
    "title": "Class Constants",
    "keywords": "Class Constants Namespace GHIElectronics.Endpoint.UI.Media Assembly GHIElectronics.Endpoint.UI.dll public static class Constants Inheritance object Constants Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields MaxExtent public const int MaxExtent = 524287 Field Value int"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Media.DrawingContext.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Media.DrawingContext.html",
    "title": "Class DrawingContext",
    "keywords": "Class DrawingContext Namespace GHIElectronics.Endpoint.UI.Media Assembly GHIElectronics.Endpoint.UI.dll Drawing Context. public class DrawingContext : DispatcherObject, IDisposable Inheritance object DispatcherObject DrawingContext Implements IDisposable Inherited Members DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Height public int Height { get; } Property Value int Width public int Width { get; } Property Value int Methods BlendImage(ImageSource, int, int, int, int, int, int, ushort) public void BlendImage(ImageSource source, int destinationX, int destinationY, int sourceX, int sourceY, int sourceWidth, int sourceHeight, ushort opacity) Parameters source ImageSource destinationX int destinationY int sourceX int sourceY int sourceWidth int sourceHeight int opacity ushort Clear() public void Clear() Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Dispose(bool) protected virtual void Dispose(bool disposing) Parameters disposing bool DrawEllipse(Brush, Pen, int, int, int, int) public void DrawEllipse(Brush brush, Pen pen, int x, int y, int xRadius, int yRadius) Parameters brush Brush pen Pen x int y int xRadius int yRadius int DrawImage(ImageSource, int, int) public void DrawImage(ImageSource source, int x, int y) Parameters source ImageSource x int y int DrawImage(ImageSource, int, int, int, int, int, int) public void DrawImage(ImageSource source, int destinationX, int destinationY, int sourceX, int sourceY, int sourceWidth, int sourceHeight) Parameters source ImageSource destinationX int destinationY int sourceX int sourceY int sourceWidth int sourceHeight int DrawLine(Pen, int, int, int, int) public void DrawLine(Pen pen, int x0, int y0, int x1, int y1) Parameters pen Pen x0 int y0 int x1 int y1 int DrawPolygon(Brush, Pen, int[]) public void DrawPolygon(Brush brush, Pen pen, int[] pts) Parameters brush Brush pen Pen pts int[] DrawRectangle(Brush, Pen, int, int, int, int) public void DrawRectangle(Brush brush, Pen pen, int x, int y, int width, int height) Parameters brush Brush pen Pen x int y int width int height int DrawText(string, Font, Color, int, int) public void DrawText(string text, Font font, Color color, int x, int y) Parameters text string font Font color Color x int y int DrawText(ref string, Font, Color, int, int, int, int, TextAlignment, TextTrimming) public bool DrawText(ref string text, Font font, Color color, int x, int y, int width, int height, TextAlignment alignment, TextTrimming trimming) Parameters text string font Font color Color x int y int width int height int alignment TextAlignment trimming TextTrimming Returns bool GetClippingRectangle(out int, out int, out int, out int) public void GetClippingRectangle(out int x, out int y, out int width, out int height) Parameters x int y int width int height int GetTranslation(out int, out int) public void GetTranslation(out int x, out int y) Parameters x int y int PopClippingRectangle() public void PopClippingRectangle() PushClippingRectangle(int, int, int, int) public void PushClippingRectangle(int x, int y, int width, int height) Parameters x int y int width int height int RotateImage(int, int, int, ImageSource, int, int, int, int, ushort) public void RotateImage(int angle, int destinationX, int destinationY, ImageSource bitmap, int sourceX, int sourceY, int sourceWidth, int sourceHeight, ushort opacity) Parameters angle int destinationX int destinationY int bitmap ImageSource sourceX int sourceY int sourceWidth int sourceHeight int opacity ushort Scale9Image(int, int, int, int, ImageSource, int, int, int, int, ushort) public void Scale9Image(int xDst, int yDst, int widthDst, int heightDst, ImageSource bitmap, int leftBorder, int topBorder, int rightBorder, int bottomBorder, ushort opacity) Parameters xDst int yDst int widthDst int heightDst int bitmap ImageSource leftBorder int topBorder int rightBorder int bottomBorder int opacity ushort SetPixel(Color, int, int) public void SetPixel(Color color, int x, int y) Parameters color Color x int y int StretchImage(int, int, int, int, ImageSource, int, int, int, int, ushort) public void StretchImage(int xDst, int yDst, int widthDst, int heightDst, ImageSource bitmap, int xSrc, int ySrc, int widthSrc, int heightSrc, ushort opacity) Parameters xDst int yDst int widthDst int heightDst int bitmap ImageSource xSrc int ySrc int widthSrc int heightSrc int opacity ushort TileImage(int, int, ImageSource, int, int, ushort) public void TileImage(int xDst, int yDst, ImageSource bitmap, int width, int height, ushort opacity) Parameters xDst int yDst int bitmap ImageSource width int height int opacity ushort Translate(int, int) public void Translate(int dx, int dy) Parameters dx int dy int"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Media.ImageBrush.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Media.ImageBrush.html",
    "title": "Class ImageBrush",
    "keywords": "Class ImageBrush Namespace GHIElectronics.Endpoint.UI.Media Assembly GHIElectronics.Endpoint.UI.dll public sealed class ImageBrush : Brush Inheritance object Brush ImageBrush Inherited Members Brush.Opacity object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors ImageBrush(ImageSource) public ImageBrush(ImageSource imagesource) Parameters imagesource ImageSource Fields ImageSource public ImageSource ImageSource Field Value ImageSource Stretch public Stretch Stretch Field Value Stretch"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Media.ImageSource.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Media.ImageSource.html",
    "title": "Class ImageSource",
    "keywords": "Class ImageSource Namespace GHIElectronics.Endpoint.UI.Media Assembly GHIElectronics.Endpoint.UI.dll public abstract class ImageSource Inheritance object ImageSource Derived BitmapSource Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ImageSource(Graphics) protected ImageSource(Graphics g) Parameters g Graphics ImageSource(byte[]) protected ImageSource(byte[] data) Parameters data byte[] ImageSource(byte[], int, int) protected ImageSource(byte[] data, int width, int height) Parameters data byte[] width int height int Properties Height public virtual int Height { get; } Property Value int Width public virtual int Width { get; } Property Value int"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Media.LinearGradientBrush.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Media.LinearGradientBrush.html",
    "title": "Class LinearGradientBrush",
    "keywords": "Class LinearGradientBrush Namespace GHIElectronics.Endpoint.UI.Media Assembly GHIElectronics.Endpoint.UI.dll public sealed class LinearGradientBrush : Brush Inheritance object Brush LinearGradientBrush Inherited Members Brush.Opacity object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors LinearGradientBrush(Color, Color) public LinearGradientBrush(Color startColor, Color endColor) Parameters startColor Color endColor Color LinearGradientBrush(Color, Color, int, int, int, int) public LinearGradientBrush(Color startColor, Color endColor, int startX, int startY, int endX, int endY) Parameters startColor Color endColor Color startX int startY int endX int endY int Fields EndColor public Color EndColor Field Value Color EndX public int EndX Field Value int EndY public int EndY Field Value int MappingMode public BrushMappingMode MappingMode Field Value BrushMappingMode RelativeBoundingBoxSize public const int RelativeBoundingBoxSize = 1000 Field Value int StartColor public Color StartColor Field Value Color StartX public int StartX Field Value int StartY public int StartY Field Value int"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Media.Pen.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Media.Pen.html",
    "title": "Class Pen",
    "keywords": "Class Pen Namespace GHIElectronics.Endpoint.UI.Media Assembly GHIElectronics.Endpoint.UI.dll public class Pen Inheritance object Pen Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Pen(Color) public Pen(Color color) Parameters color Color Pen(Color, ushort) public Pen(Color color, ushort thickness) Parameters color Color thickness ushort Fields Color public Color Color Field Value Color Thickness public ushort Thickness Field Value ushort"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Media.SolidColorBrush.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Media.SolidColorBrush.html",
    "title": "Class SolidColorBrush",
    "keywords": "Class SolidColorBrush Namespace GHIElectronics.Endpoint.UI.Media Assembly GHIElectronics.Endpoint.UI.dll public sealed class SolidColorBrush : Brush Inheritance object Brush SolidColorBrush Inherited Members Brush.Opacity object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors SolidColorBrush(Color) public SolidColorBrush(Color color) Parameters color Color Fields Color public Color Color Field Value Color"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Media.Stretch.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Media.Stretch.html",
    "title": "Enum Stretch",
    "keywords": "Enum Stretch Namespace GHIElectronics.Endpoint.UI.Media Assembly GHIElectronics.Endpoint.UI.dll public enum Stretch Fields Fill = 1 None = 0 Uniform = 2 UniformToFill = 3"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Media.TextAlignment.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Media.TextAlignment.html",
    "title": "Enum TextAlignment",
    "keywords": "Enum TextAlignment Namespace GHIElectronics.Endpoint.UI.Media Assembly GHIElectronics.Endpoint.UI.dll public enum TextAlignment Fields Center = 1 Left = 0 Right = 2"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Media.TextTrimming.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Media.TextTrimming.html",
    "title": "Enum TextTrimming",
    "keywords": "Enum TextTrimming Namespace GHIElectronics.Endpoint.UI.Media Assembly GHIElectronics.Endpoint.UI.dll public enum TextTrimming Fields CharacterEllipsis = 0 None = 1 WordEllipsis = 2"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Media.UIImaging.BitmapSource.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Media.UIImaging.BitmapSource.html",
    "title": "Class BitmapSource",
    "keywords": "Class BitmapSource Namespace GHIElectronics.Endpoint.UI.Media.UIImaging Assembly GHIElectronics.Endpoint.UI.dll public abstract class BitmapSource : ImageSource Inheritance object ImageSource BitmapSource Derived UIBitmap Inherited Members ImageSource.Width ImageSource.Height object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors BitmapSource(Graphics) protected BitmapSource(Graphics g) Parameters g Graphics BitmapSource(byte[]) protected BitmapSource(byte[] data) Parameters data byte[] BitmapSource(byte[], int, int) protected BitmapSource(byte[] data, int width, int height) Parameters data byte[] width int height int"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Media.UIImaging.UIBitmap.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Media.UIImaging.UIBitmap.html",
    "title": "Class UIBitmap",
    "keywords": "Class UIBitmap Namespace GHIElectronics.Endpoint.UI.Media.UIImaging Assembly GHIElectronics.Endpoint.UI.dll public class UIBitmap : BitmapSource Inheritance object ImageSource BitmapSource UIBitmap Inherited Members ImageSource.Width ImageSource.Height object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods FromData(byte[]) public static UIBitmap FromData(byte[] data) Parameters data byte[] Returns UIBitmap FromData(byte[], int, int) public static UIBitmap FromData(byte[] data, int width, int height) Parameters data byte[] width int height int Returns UIBitmap FromGraphics(Graphics) public static UIBitmap FromGraphics(Graphics g) Parameters g Graphics Returns UIBitmap"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Media.UIImaging.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Media.UIImaging.html",
    "title": "Namespace GHIElectronics.Endpoint.UI.Media.UIImaging",
    "keywords": "Namespace GHIElectronics.Endpoint.UI.Media.UIImaging Classes BitmapSource UIBitmap"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Media.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Media.html",
    "title": "Namespace GHIElectronics.Endpoint.UI.Media",
    "keywords": "Namespace GHIElectronics.Endpoint.UI.Media Classes Brush Colors Constants DrawingContext Drawing Context. ImageBrush ImageSource LinearGradientBrush Pen SolidColorBrush Structs Color Enums BrushMappingMode Stretch TextAlignment TextTrimming"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.OnScreenKeyboard.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.OnScreenKeyboard.html",
    "title": "Class OnScreenKeyboard",
    "keywords": "Class OnScreenKeyboard Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll public class OnScreenKeyboard : Window Inheritance object DispatcherObject UIElement Control ContentControl Window OnScreenKeyboard Inherited Members Window.Close() Window.SizeToContent Window.Top Window.Left Window.Topmost Window.MeasureOverride(int, int, out int, out int) Window.ArrangeOverride(int, int) ContentControl.Child Control.Background Control.Foreground Control.OnRender(DrawingContext) Control._background Control._foreground Control._font UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Font public static Font Font { get; set; } Property Value Font"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.PostRenderEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.PostRenderEventHandler.html",
    "title": "Delegate PostRenderEventHandler",
    "keywords": "Delegate PostRenderEventHandler Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll public delegate void PostRenderEventHandler(DrawingContext dc) Parameters dc DrawingContext"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.PresentationSource.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.PresentationSource.html",
    "title": "Class PresentationSource",
    "keywords": "Class PresentationSource Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll Presentation source is our connection to the rest of the managed system. public class PresentationSource : DispatcherObject Inheritance object DispatcherObject PresentationSource Inherited Members DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PresentationSource() Constructs an instance of the PresentationSource object. public PresentationSource() Properties RootUIElement The Root UIElement for this source. public UIElement RootUIElement { get; set; } Property Value UIElement"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.PropertyChangedEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.PropertyChangedEventArgs.html",
    "title": "Class PropertyChangedEventArgs",
    "keywords": "Class PropertyChangedEventArgs Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll Provides data for the various property changed events. public class PropertyChangedEventArgs Inheritance object PropertyChangedEventArgs Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PropertyChangedEventArgs(string, object, object) Initializes a new instance of the PropertyChangedEventArgs class. public PropertyChangedEventArgs(string property, object oldValue, object newValue) Parameters property string The property whose value changed. oldValue object The value of the property before the change. newValue object The value of the property after the change. Fields NewValue The value of the property after the change. public readonly object NewValue Field Value object OldValue The value of the property before the change. public readonly object OldValue Field Value object Property The property whose value changed. public readonly string Property Field Value string"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.PropertyChangedEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.PropertyChangedEventHandler.html",
    "title": "Delegate PropertyChangedEventHandler",
    "keywords": "Delegate PropertyChangedEventHandler Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll Represents the method that will handle the event raised when a Property is changed public delegate void PropertyChangedEventHandler(object sender, PropertyChangedEventArgs e) Parameters sender object Represents the method that will handle the event raised when a Property is changed e PropertyChangedEventArgs Represents the method that will handle the event raised when a Property is changed"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.ReasonSessionEnding.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.ReasonSessionEnding.html",
    "title": "Enum ReasonSessionEnding",
    "keywords": "Enum ReasonSessionEnding Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll Enum for ReasonSessionEnding public enum ReasonSessionEnding : byte Fields Logoff = 0 Shutdown = 1"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.RoutedEvent.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.RoutedEvent.html",
    "title": "Class RoutedEvent",
    "keywords": "Class RoutedEvent Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll public sealed class RoutedEvent Inheritance object RoutedEvent Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) Constructors RoutedEvent(string, RoutingStrategy, Type) Create a new routed event. You have to promise not to duplicate another event name in the system, or you will be sorry. public RoutedEvent(string name, RoutingStrategy routingStrategy, Type handlerType) Parameters name string routingStrategy RoutingStrategy handlerType Type Properties HandlerType Returns Type of Handler for the RoutedEvent public Type HandlerType { get; } Property Value Type Remarks HandlerType is a type of delegate Name Returns the Name of the RoutedEvent public string Name { get; } Property Value string Remarks RoutedEvent Name is unique within the OwnerType (super class types not considered when talking about uniqueness) RoutingStrategy Returns the RoutingStrategy of the RoutedEvent public RoutingStrategy RoutingStrategy { get; } Property Value RoutingStrategy Methods ToString() String representation public override string ToString() Returns string"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.RoutedEventArgs.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.RoutedEventArgs.html",
    "title": "Class RoutedEventArgs",
    "keywords": "Class RoutedEventArgs Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll The container for all state associated with a RoutedEvent public class RoutedEventArgs : EventArgs Inheritance object EventArgs RoutedEventArgs Derived TextChangedEventArgs InputEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks RoutedEventArgs constitutes the RoutedEvent, Handled, Source and OriginalSource Different RoutedEventArgs can be used with a single RoutedEvent The RoutedEventArgs is responsible for packaging the RoutedEvent, providing extra event state info, and invoking the handler associated with the RoutedEvent Constructors RoutedEventArgs() Constructor for RoutedEventArgs public RoutedEventArgs() Remarks All members take default values RoutedEvent defaults to null Handled defaults to false Source defaults to null OriginalSource also defaults to null RoutedEventArgs(RoutedEvent) Constructor for RoutedEventArgs public RoutedEventArgs(RoutedEvent routedEvent) Parameters routedEvent RoutedEvent The new value that the RoutedEvent Property is being set to RoutedEventArgs(RoutedEvent, object) Constructor for RoutedEventArgs public RoutedEventArgs(RoutedEvent routedEvent, object source) Parameters routedEvent RoutedEvent The new value that the RoutedEvent Property is being set to source object The new value that the SourceProperty is being set to Properties Handled Returns a boolean flag indicating if or not this RoutedEvent has been handled this far in the route public bool Handled { get; set; } Property Value bool Remarks Initially starts with a false value before routing has begun OriginalSource Returns OriginalSource object that raised the RoutedEvent public object OriginalSource { get; } Property Value object Remarks Always returns the OriginalSource object that raised the RoutedEvent unlike Source that may vary under specific scenarios This property acquires its value once before the event handlers are invoked and never changes then on RoutedEvent Returns the RoutedEvent associated with this RoutedEventArgs public RoutedEvent RoutedEvent { get; set; } Property Value RoutedEvent Remarks The RoutedEvent cannot be null at any time Source Returns Source object that raised the RoutedEvent public object Source { get; set; } Property Value object Methods OnSetSource(object) Invoked when the source of the event is set protected virtual void OnSetSource(object source) Parameters source object The new value that the SourceProperty is being set to Remarks Changing the source of an event can often require updating the data within the event. For this reason, the OnSource= method is protected virtual and is meant to be overridden by sub-classes of RoutedEventArgs Also see Source"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.RoutedEventHandler.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.RoutedEventHandler.html",
    "title": "Delegate RoutedEventHandler",
    "keywords": "Delegate RoutedEventHandler Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll RoutedEventHandler Definition public delegate void RoutedEventHandler(object sender, RoutedEventArgs e) Parameters sender object RoutedEventHandler Definition e RoutedEventArgs RoutedEventHandler Definition"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.RoutedEventHandlerInfo.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.RoutedEventHandlerInfo.html",
    "title": "Class RoutedEventHandlerInfo",
    "keywords": "Class RoutedEventHandlerInfo Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll Container for handler instance and other invocation preferences for this handler instance public class RoutedEventHandlerInfo Inheritance object RoutedEventHandlerInfo Inherited Members object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks RoutedEventHandlerInfo constitutes the handler instance and flag that indicates if or not this handler must be invoked for already handled events This class needs to be public because it is used by ContentElement in the Framework to store Instance EventHandlers Properties Handler Returns associated handler instance public RoutedEventHandler Handler { get; } Property Value RoutedEventHandler InvokeHandledEventsToo Returns HandledEventsToo Flag public bool InvokeHandledEventsToo { get; } Property Value bool Methods Equals(RoutedEventHandlerInfo) Is the given RoutedEventHandlerInfo equals the current public bool Equals(RoutedEventHandlerInfo handlerInfo) Parameters handlerInfo RoutedEventHandlerInfo Returns bool Equals(object) Is the given object equivalent to the current one public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() Serves as a hash function for a particular type, suitable for use in hashing algorithms and data structures like a hash table public override int GetHashCode() Returns int Operators operator ==(RoutedEventHandlerInfo, RoutedEventHandlerInfo) Equals operator overload public static bool operator ==(RoutedEventHandlerInfo handlerInfo1, RoutedEventHandlerInfo handlerInfo2) Parameters handlerInfo1 RoutedEventHandlerInfo handlerInfo2 RoutedEventHandlerInfo Returns bool operator !=(RoutedEventHandlerInfo, RoutedEventHandlerInfo) NotEquals operator overload public static bool operator !=(RoutedEventHandlerInfo handlerInfo1, RoutedEventHandlerInfo handlerInfo2) Parameters handlerInfo1 RoutedEventHandlerInfo handlerInfo2 RoutedEventHandlerInfo Returns bool"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.RoutingStrategy.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.RoutingStrategy.html",
    "title": "Enum RoutingStrategy",
    "keywords": "Enum RoutingStrategy Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll Routing Strategy can be either of Tunnel or Bubble public enum RoutingStrategy Fields Bubble = 1 Bubble Direct = 2 Direct Tunnel = 0 Tunnel"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Shapes.Direction.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Shapes.Direction.html",
    "title": "Enum Direction",
    "keywords": "Enum Direction Namespace GHIElectronics.Endpoint.UI.Shapes Assembly GHIElectronics.Endpoint.UI.dll public enum Direction Fields BottomToTop = 1 TopToBottom = 0"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Shapes.Ellipse.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Shapes.Ellipse.html",
    "title": "Class Ellipse",
    "keywords": "Class Ellipse Namespace GHIElectronics.Endpoint.UI.Shapes Assembly GHIElectronics.Endpoint.UI.dll public class Ellipse : Shape Inheritance object DispatcherObject UIElement Shape Ellipse Inherited Members Shape.Fill Shape.Stroke UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.MeasureOverride(int, int, out int, out int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Ellipse(int, int) public Ellipse(int xRadius, int yRadius) Parameters xRadius int yRadius int Methods OnRender(DrawingContext) public override void OnRender(DrawingContext dc) Parameters dc DrawingContext"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Shapes.Line.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Shapes.Line.html",
    "title": "Class Line",
    "keywords": "Class Line Namespace GHIElectronics.Endpoint.UI.Shapes Assembly GHIElectronics.Endpoint.UI.dll public class Line : Shape Inheritance object DispatcherObject UIElement Shape Line Inherited Members Shape.Fill Shape.Stroke UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.MeasureOverride(int, int, out int, out int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Line() public Line() Line(int, int) public Line(int dx, int dy) Parameters dx int dy int Properties Direction public Direction Direction { get; set; } Property Value Direction Methods OnRender(DrawingContext) public override void OnRender(DrawingContext dc) Parameters dc DrawingContext"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Shapes.Polygon.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Shapes.Polygon.html",
    "title": "Class Polygon",
    "keywords": "Class Polygon Namespace GHIElectronics.Endpoint.UI.Shapes Assembly GHIElectronics.Endpoint.UI.dll public class Polygon : Shape Inheritance object DispatcherObject UIElement Shape Polygon Inherited Members Shape.Fill Shape.Stroke UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.MeasureOverride(int, int, out int, out int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Polygon() public Polygon() Polygon(int[]) public Polygon(int[] pts) Parameters pts int[] Properties Points public int[] Points { get; set; } Property Value int[] Methods OnRender(DrawingContext) public override void OnRender(DrawingContext dc) Parameters dc DrawingContext"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Shapes.Rectangle.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Shapes.Rectangle.html",
    "title": "Class Rectangle",
    "keywords": "Class Rectangle Namespace GHIElectronics.Endpoint.UI.Shapes Assembly GHIElectronics.Endpoint.UI.dll public class Rectangle : Shape Inheritance object DispatcherObject UIElement Shape Rectangle Inherited Members Shape.Fill Shape.Stroke UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.MeasureOverride(int, int, out int, out int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Rectangle() public Rectangle() Rectangle(int, int) public Rectangle(int width, int height) Parameters width int height int Methods OnRender(DrawingContext) public override void OnRender(DrawingContext dc) Parameters dc DrawingContext"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Shapes.Shape.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Shapes.Shape.html",
    "title": "Class Shape",
    "keywords": "Class Shape Namespace GHIElectronics.Endpoint.UI.Shapes Assembly GHIElectronics.Endpoint.UI.dll public abstract class Shape : UIElement Inheritance object DispatcherObject UIElement Shape Derived Ellipse Line Polygon Rectangle Inherited Members UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.MeasureOverride(int, int, out int, out int) UIElement.ArrangeOverride(int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.OnRender(DrawingContext) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Fill public Brush Fill { get; set; } Property Value Brush Stroke public Pen Stroke { get; set; } Property Value Pen"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Shapes.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Shapes.html",
    "title": "Namespace GHIElectronics.Endpoint.UI.Shapes",
    "keywords": "Namespace GHIElectronics.Endpoint.UI.Shapes Classes Ellipse Line Polygon Rectangle Shape Enums Direction"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.ShutdownMode.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.ShutdownMode.html",
    "title": "Enum ShutdownMode",
    "keywords": "Enum ShutdownMode Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll Enum for ShutdownMode public enum ShutdownMode : byte Fields OnExplicitShutdown = 2 OnLastWindowClose = 0 OnMainWindowClose = 1"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.SizeToContent.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.SizeToContent.html",
    "title": "Enum SizeToContent",
    "keywords": "Enum SizeToContent Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll SizeToContent public enum SizeToContent Fields Height = 2 Sizes Height to content's Height Manual = 0 Does not size to content Width = 1 Sizes Width to content's Width WidthAndHeight = 3 Sizes both Width and Height to content's size"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Threading.Dispatcher.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Threading.Dispatcher.html",
    "title": "Class Dispatcher",
    "keywords": "Class Dispatcher Namespace GHIElectronics.Endpoint.UI.Threading Assembly GHIElectronics.Endpoint.UI.dll Provides UI services for a thread. public sealed class Dispatcher Inheritance object Dispatcher Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties CurrentDispatcher Returns the Dispatcher for the current thread. public static Dispatcher CurrentDispatcher { get; } Property Value Dispatcher Dispatcher HasShutdownFinished Whether or not the dispatcher has been shut down. public bool HasShutdownFinished { get; } Property Value bool HasShutdownStarted Whether or not the dispatcher is shutting down. public bool HasShutdownStarted { get; } Property Value bool Thread Thread for the dispatcher. public Thread Thread { get; } Property Value Thread Methods BeginInvoke(DispatcherOperationCallback, object) Executes the specified delegate asynchronously with the specified arguments, on the thread that the Dispatcher was created on. public DispatcherOperation BeginInvoke(DispatcherOperationCallback method, object args) Parameters method DispatcherOperationCallback A delegate to a method that takes parameters of the same number and type that are contained in the args parameter. args object An object to pass as the argument to the given method. This can be null if no arguments are needed. Returns DispatcherOperation A DispatcherOperation object that represents the result of the BeginInvoke operation. null if the operation could not be queued. CheckAccess() Checks that the calling thread has access to this object. public bool CheckAccess() Returns bool True if the calling thread has access to this object. Remarks Only the dispatcher thread may access DispatcherObjects. This method is public so that any thread can probe to see if it has access to the DispatcherObject. FromThread(Thread) Returns the Dispatcher for the specified thread. public static Dispatcher FromThread(Thread thread) Parameters thread Thread Returns Dispatcher Remarks If there is no dispatcher available for the specified thread, this method will return null. Invoke(TimeSpan, DispatcherOperationCallback, object) Executes the specified delegate synchronously with the specified arguments, on the thread that the Dispatcher was created on. public object Invoke(TimeSpan timeout, DispatcherOperationCallback method, object args) Parameters timeout TimeSpan The maximum amount of time to wait for the operation to complete. method DispatcherOperationCallback A delegate to a method that takes parameters of the same number and type that are contained in the args parameter. args object An object to pass as the argument to the given method. This can be null if no arguments are needed. Returns object The return value from the delegate being invoked, or null if the delegate has no return value or if the operation was aborted. InvokeShutdown() Begins the process of shutting down the dispatcher, synchronously. The process may complete asynchronously, since we may be nested in dispatcher frames. public void InvokeShutdown() PushFrame(DispatcherFrame) Push an execution frame. public static void PushFrame(DispatcherFrame frame) Parameters frame DispatcherFrame The frame for the dispatcher to process. Run() Push the main execution frame. public static void Run() Remarks This frame will continue until the dispatcher is shut down. VerifyAccess() Verifies that the calling thread has access to this object. public void VerifyAccess() Remarks Only the dispatcher thread may access DispatcherObjects. This method is public so that derived classes can probe to see if the calling thread has access to itself. Events ShutdownFinished Raised when the dispatcher is shut down. public event EventHandler ShutdownFinished Event Type EventHandler ShutdownStarted Raised when the dispatcher starts shutting down. public event EventHandler ShutdownStarted Event Type EventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Threading.DispatcherFrame.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Threading.DispatcherFrame.html",
    "title": "Class DispatcherFrame",
    "keywords": "Class DispatcherFrame Namespace GHIElectronics.Endpoint.UI.Threading Assembly GHIElectronics.Endpoint.UI.dll Representation of Dispatcher frame. public class DispatcherFrame Inheritance object DispatcherFrame Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DispatcherFrame() Constructs a new instance of the DispatcherFrame class. public DispatcherFrame() DispatcherFrame(bool) Constructs a new instance of the DispatcherFrame class. public DispatcherFrame(bool exitWhenRequested) Parameters exitWhenRequested bool Indicates whether or not this frame will exit when all frames are requested to exit. Dispatcher frames typically break down into two categories: 1) Long running, general purpose frames, that exit only when told to. These frames should exit when requested. 2) Short running, very specific frames that exit themselves when an important criteria is met. These frames may consider not exiting when requested in favor of waiting for their important criteria to be met. These frames should have a timeout associated with them. Properties Continue Indicates that this dispatcher frame should exit. public bool Continue { get; set; } Property Value bool"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Threading.DispatcherObject.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Threading.DispatcherObject.html",
    "title": "Class DispatcherObject",
    "keywords": "Class DispatcherObject Namespace GHIElectronics.Endpoint.UI.Threading Assembly GHIElectronics.Endpoint.UI.dll A DispatcherObject is an object associated with a Dispatcher. A DispatcherObject instance should only be access by the dispatcher's thread. public abstract class DispatcherObject Inheritance object DispatcherObject Derived Application InputDevice InputManager InputManager.DeviceEvents DrawingContext PresentationSource UIElement Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Subclasses of DispatcherObject should enforce thread safety by calling VerifyAccess() on all their public methods to ensure the calling thread is the appropriate thread. DispatcherObject cannot be independently instantiated; that is, all constructors are protected. Constructors DispatcherObject() Instantiate this object associated with the current Dispatcher. protected DispatcherObject() Fields Dispatcher The Dispatcher that this DispatcherObject is associated with. public readonly Dispatcher Dispatcher Field Value Dispatcher Methods CheckAccess() Checks that the calling thread has access to this object. public bool CheckAccess() Returns bool True if the calling thread has access to this object. Remarks Only the dispatcher thread may access DispatcherObjects. This method is public so that any thread can probe to see if it has access to the DispatcherObject. VerifyAccess() Verifies that the calling thread has access to this object. public void VerifyAccess() Remarks Only the dispatcher thread may access DispatcherObjects. This method is public so that derived classes can probe to see if the calling thread has access to itself. This is only verified in debug builds."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Threading.DispatcherOperation.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Threading.DispatcherOperation.html",
    "title": "Class DispatcherOperation",
    "keywords": "Class DispatcherOperation Namespace GHIElectronics.Endpoint.UI.Threading Assembly GHIElectronics.Endpoint.UI.dll DispatcherOperation represents a delegate that has been posted to the Dispatcher queue. public sealed class DispatcherOperation Inheritance object DispatcherOperation Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties Dispatcher Returns the Dispatcher that this operation was posted to. public Dispatcher Dispatcher { get; } Property Value Dispatcher Result Returns the result of the operation if it has completed. public object Result { get; } Property Value object Status The status of this operation. public DispatcherOperationStatus Status { get; } Property Value DispatcherOperationStatus Methods Abort() Aborts this operation. public bool Abort() Returns bool False if the operation could not be aborted (because the operation was already in progress) Wait() Waits for this operation to complete. public DispatcherOperationStatus Wait() Returns DispatcherOperationStatus The status of the operation. To obtain the return value of the invoked delegate, use the the Result property. Wait(TimeSpan) Waits for this operation to complete. public DispatcherOperationStatus Wait(TimeSpan timeout) Parameters timeout TimeSpan The maximum amount of time to wait. Returns DispatcherOperationStatus The status of the operation. To obtain the return value of the invoked delegate, use the the Result property. Events Aborted An event that is raised when the operation is aborted. public event EventHandler Aborted Event Type EventHandler Completed An event that is raised when the operation completes. public event EventHandler Completed Event Type EventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Threading.DispatcherOperationCallback.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Threading.DispatcherOperationCallback.html",
    "title": "Delegate DispatcherOperationCallback",
    "keywords": "Delegate DispatcherOperationCallback Namespace GHIElectronics.Endpoint.UI.Threading Assembly GHIElectronics.Endpoint.UI.dll A convenient delegate to use for dispatcher operations. public delegate object DispatcherOperationCallback(object arg) Parameters arg object A convenient delegate to use for dispatcher operations. Returns object A convenient delegate to use for dispatcher operations."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Threading.DispatcherOperationStatus.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Threading.DispatcherOperationStatus.html",
    "title": "Enum DispatcherOperationStatus",
    "keywords": "Enum DispatcherOperationStatus Namespace GHIElectronics.Endpoint.UI.Threading Assembly GHIElectronics.Endpoint.UI.dll An enumeration describing the status of a DispatcherOperation. public enum DispatcherOperationStatus Fields Aborted = 1 The operation has been aborted. Completed = 2 The operation has been completed. Executing = 3 The operation has started executing, but has not completed yet. Pending = 0 The operation is still pending."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Threading.DispatcherTimer.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Threading.DispatcherTimer.html",
    "title": "Class DispatcherTimer",
    "keywords": "Class DispatcherTimer Namespace GHIElectronics.Endpoint.UI.Threading Assembly GHIElectronics.Endpoint.UI.dll A timer that is integrated into the Dispatcher queues, and will be processed after a given amount of time public class DispatcherTimer : IDisposable Inheritance object DispatcherTimer Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DispatcherTimer() Creates a timer that uses the current thread's Dispatcher to process the timer event public DispatcherTimer() DispatcherTimer(Dispatcher) Creates a timer that uses the specified Dispatcher to process the timer event. public DispatcherTimer(Dispatcher dispatcher) Parameters dispatcher Dispatcher The dispatcher to use to process the timer. Properties Dispatcher Gets the dispatcher this timer is associated with. public Dispatcher Dispatcher { get; } Property Value Dispatcher Interval Gets or sets the time between timer ticks. public TimeSpan Interval { get; set; } Property Value TimeSpan IsEnabled Gets or sets whether the timer is running. public bool IsEnabled { get; set; } Property Value bool Tag Any data that the caller wants to pass along with the timer. public object Tag { get; set; } Property Value object Methods Close() public virtual void Close() Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Dispose(bool) protected virtual void Dispose(bool disposing) Parameters disposing bool Start() Starts the timer. public void Start() Stop() Stops the timer. public void Stop() Events Tick Occurs when the specified timer interval has elapsed and the timer is enabled. public event EventHandler Tick Event Type EventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Threading.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Threading.html",
    "title": "Namespace GHIElectronics.Endpoint.UI.Threading",
    "keywords": "Namespace GHIElectronics.Endpoint.UI.Threading Classes Dispatcher Provides UI services for a thread. DispatcherFrame Representation of Dispatcher frame. DispatcherObject A DispatcherObject is an object associated with a Dispatcher. A DispatcherObject instance should only be access by the dispatcher's thread. DispatcherOperation DispatcherOperation represents a delegate that has been posted to the Dispatcher queue. DispatcherTimer A timer that is integrated into the Dispatcher queues, and will be processed after a given amount of time Enums DispatcherOperationStatus An enumeration describing the status of a DispatcherOperation. Delegates DispatcherOperationCallback A convenient delegate to use for dispatcher operations."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.UIElement.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.UIElement.html",
    "title": "Class UIElement",
    "keywords": "Class UIElement Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll public abstract class UIElement : DispatcherObject Inheritance object DispatcherObject UIElement Derived Control Image Panel Text TextFlow Shape Inherited Members DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors UIElement() protected UIElement() Fields _horizontalAlignment protected HorizontalAlignment _horizontalAlignment Field Value HorizontalAlignment _verticalAlignment protected VerticalAlignment _verticalAlignment Field Value VerticalAlignment Properties ActualHeight public int ActualHeight { get; } Property Value int ActualWidth public int ActualWidth { get; } Property Value int Height public int Height { get; set; } Property Value int HorizontalAlignment public HorizontalAlignment HorizontalAlignment { get; set; } Property Value HorizontalAlignment InstanceEventHandlersStore Ensure the store has been created. protected Hashtable InstanceEventHandlersStore { get; } Property Value Hashtable IsArrangeValid Determines if the RenderSize and position of child elements is valid. public bool IsArrangeValid { get; } Property Value bool Remarks A developer can force arrangement to be invalidated by calling InvalidateArrange. IsArrangeValid and IsMeasureValid are related, in that arrangement cannot be valid without measurement first being valid. IsEnabled Fetches the value of the IsEnabled property public bool IsEnabled { get; set; } Property Value bool IsFocused A property indicating if the button is focused on this element or not. public bool IsFocused { get; } Property Value bool IsMeasureValid Determines if the DesiredSize is valid. public bool IsMeasureValid { get; } Property Value bool Remarks A developer can force arrangement to be invalidated by calling InvalidateMeasure. IsArrangeValid and IsMeasureValid are related, in that arrangement cannot be valid without measurement first being valid. IsVisible A property indicating if this element is Visible or not. public bool IsVisible { get; } Property Value bool LogicalChildren protected UIElementCollection LogicalChildren { get; } Property Value UIElementCollection Parent public UIElement Parent { get; } Property Value UIElement RootUIElement public UIElement RootUIElement { get; } Property Value UIElement VerticalAlignment public VerticalAlignment VerticalAlignment { get; set; } Property Value VerticalAlignment Visibility Visibility accessor public Visibility Visibility { get; set; } Property Value Visibility Width public int Width { get; set; } Property Value int Methods AddHandler(RoutedEvent, RoutedEventHandler, bool) Adds a routed event handler for the particular RoutedEvent public void AddHandler(RoutedEvent routedEvent, RoutedEventHandler handler, bool handledEventsToo) Parameters routedEvent RoutedEvent RoutedEvent for which the handler is attached handler RoutedEventHandler The handler that will be invoked on this object when the RoutedEvent is raised handledEventsToo bool Flag indicating whether or not the listener wants to hear about events that have already been handled Remarks The handler added thus is also known as an instance handler NOTE: It is not an error to add a handler twice (handler will simply be called twice) Input parameters RoutedEvent and handler cannot be null handledEventsToo input parameter when false means that listener does not care about already handled events. Hence the handler will not be invoked on the target if the RoutedEvent has already been Handled handledEventsToo input parameter when true means that the listener wants to hear about all events even if they have already been handled. Hence the handler will be invoked irrespective of the event being Handled AddToEventRoute(EventRoute, RoutedEventArgs) Add the event handlers for this element to the route. public void AddToEventRoute(EventRoute route, RoutedEventArgs args) Parameters route EventRoute args RoutedEventArgs Arrange(int, int, int, int) Parents or system call this method to arrange the internals of children on a second pass of layout update. public void Arrange(int finalRectX, int finalRectY, int finalRectWidth, int finalRectHeight) Parameters finalRectX int This is the final X location that parent or system wants this UIElement to assume. finalRectY int This is the final Y location that parent or system wants this UIElement to assume. finalRectWidth int This is the Width that parent or system wants this UIElement to assume. finalRectHeight int This is the height that parent or system wants this UIElement to assume. Remarks This method internally calls ArrangeOverride override, giving the derived class opportunity to arrange its children and/or content using final computed size. In their ArrangeOverride overrides, derived class is supposed to create its visual structure and prepare itself for rendering. Arrange is called by parents from their implementation of ArrangeOverride or by system when needed. This method sets Bounds=finalSize before calling ArrangeOverride. ArrangeOverride(int, int) ArrangeOverride allows for the customization of the final sizing and positioning of children. protected virtual void ArrangeOverride(int arrangeWidth, int arrangeHeight) Parameters arrangeWidth int Final width arrangeHeight int Final height Remarks UIElement authors should override this method, call Arrange on each visible child UIElement, to size and position each child UIElement by passing a rectangle reserved for the child within parent space. Note: It is required that a parent UIElement calls Arrange on each child or they won't be rendered. Typical override follows a pattern roughly like this (pseudo-code): protected override void ArrangeOverride(int arrangeWidth, int arrangeHeight) { foreach (UIElement child in VisualChildren) { child.Arrange(new Rect(childX, childY, childWidth, childHeight); } }</code></pre> ChildElementFromPoint(int, int) public UIElement ChildElementFromPoint(int x, int y) Parameters x int y int Returns UIElement ContainsPoint(int, int) public bool ContainsPoint(int x, int y) Parameters x int y int Returns bool GetDesiredSize(out int, out int) public void GetDesiredSize(out int width, out int height) Parameters width int height int GetLayoutOffset(out int, out int) public void GetLayoutOffset(out int x, out int y) Parameters x int y int GetMargin(out int, out int, out int, out int) public void GetMargin(out int left, out int top, out int right, out int bottom) Parameters left int top int right int bottom int GetPointerTarget(int, int) public UIElement GetPointerTarget(int x, int y) Parameters x int y int Returns UIElement GetRenderSize(out int, out int) public void GetRenderSize(out int width, out int height) Parameters width int height int GetUnclippedSize(out int, out int) public void GetUnclippedSize(out int width, out int height) Parameters width int height int Invalidate() public void Invalidate() InvalidateArrange() Invalidates the arrange state for the UIElement. The UIElement will be queued for an update layout that will occur asynchronously. MeasureOverride will not be called unless InvalidateMeasure is also called - or that something else caused the measure state to be invalidated. public void InvalidateArrange() InvalidateMeasure() Invalidates the measurement state for the UIElement. This has the effect of also invalidating the arrange state for the UIElement. The UIElement will be queued for an update layout that will occur asynchronously. public void InvalidateMeasure() InvalidateRect(int, int, int, int) public void InvalidateRect(int x, int y, int w, int h) Parameters x int y int w int h int Measure(int, int) Updates DesiredSize of the UIElement. Must be called by parents from their MeasureOverride, to form recursive update. This is first pass of layout update. public void Measure(int availableWidth, int availableHeight) Parameters availableWidth int Available width that parent can give to the child. May be MaxValue (when parent wants to measure to content). This is soft constraint. Child can return bigger size to indicate that it wants bigger space and hope that parent can throw in scrolling... availableHeight int Available height that parent can give to the child. May be MaxValue (when parent wants to measure to content). This is soft constraint. Child can return bigger size to indicate that it wants bigger space and hope that parent can throw in scrolling... Remarks Measure is called by parents on their children. Internally, Measure calls MeasureOverride override on the same object, giving it opportunity to compute its DesiredSize. This method will return immediately if child is not Dirty, previously measured and availableSize is the same as cached. This method also resets the IsMeasureinvalid bit on the child. In case when \"unbounded measure to content\" is needed, parent can use availableSize as double.PositiveInfinity. Any returned size is OK in this case. MeasureOverride(int, int, out int, out int) Measurement override. Implement your size-to-content logic here. protected virtual void MeasureOverride(int availableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) Parameters availableWidth int Available size that parent can give to the child. May be MaxValue(when parent wants to measure to content). This is soft constraint. Child can return bigger size to indicate that it wants bigger space and hope that parent can throw in scrolling... availableHeight int desiredWidth int desiredHeight int Remarks MeasureOverride is designed to be the main customizability point for size control of layout. UIElement authors should override this method, call Measure on each child UIElement, and compute their desired size based upon the measurement of the children. The return value should be the desired size. Note: It is required that a parent UIElement calls Measure on each child or they won't be sized/arranged. Typical override follows a pattern roughly like this (pseudo-code): protected override void MeasureOverride(int avialableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) { foreach (UIElement child in VisualChildren) { child.Measure(availableSize); availableSize.Deflate(child.DesiredSize); _cache.StoreInfoAboutChild(child); } Size desired = CalculateBasedOnCache(_cache); return desired; }</code></pre> The key aspects of this snippet are: You must call Measure on each child UIElement It is common to cache measurement information between the MeasureOverride and ArrangeOverride method calls Calling base.MeasureOverride is not required. Calls to Measure on children are passing either the same availableSize as the parent, or a subset of the area depending on the type of layout the parent will perform (for example, it would be valid to remove the area for some border or padding). OnButtonDown(ButtonEventArgs) An event reporting a button was pressed. protected virtual void OnButtonDown(ButtonEventArgs e) Parameters e ButtonEventArgs OnButtonUp(ButtonEventArgs) An event reporting a button was released. protected virtual void OnButtonUp(ButtonEventArgs e) Parameters e ButtonEventArgs OnChildDesiredSizeChanged(UIElement) Notification that is called by Measure of a child when it ends up with different desired size for the child. protected virtual void OnChildDesiredSizeChanged(UIElement child) Parameters child UIElement Remarks Default implementation simply calls invalidateMeasure(), assuming that layout of a parent should be updated after child changed its size. Finer point: this method can only be called in the scenario when the system calls Measure on a child, not when parent calls it since if parent calls it, it means parent has dirty layout and is recalculating already. OnChildrenChanged(UIElement, UIElement, int) OnChildrenChanged is called when the UIElementCollection of the UIElement is edited. protected virtual void OnChildrenChanged(UIElement added, UIElement removed, int indexAffected) Parameters added UIElement removed UIElement indexAffected int OnGenericEvent(GenericEventArgs) protected virtual void OnGenericEvent(GenericEventArgs e) Parameters e GenericEventArgs OnGotFocus(FocusChangedEventArgs) An event announcing that the buttons are focused on this element. protected virtual void OnGotFocus(FocusChangedEventArgs e) Parameters e FocusChangedEventArgs OnLostFocus(FocusChangedEventArgs) An event announcing that the buttons is no longer focused on this element protected virtual void OnLostFocus(FocusChangedEventArgs e) Parameters e FocusChangedEventArgs OnPreviewButtonDown(ButtonEventArgs) An event reporting a button was pressed. protected virtual void OnPreviewButtonDown(ButtonEventArgs e) Parameters e ButtonEventArgs OnPreviewButtonUp(ButtonEventArgs) An event reporting a button was released. protected virtual void OnPreviewButtonUp(ButtonEventArgs e) Parameters e ButtonEventArgs OnRender(DrawingContext) public virtual void OnRender(DrawingContext dc) Parameters dc DrawingContext OnTouchDown(TouchEventArgs) protected virtual void OnTouchDown(TouchEventArgs e) Parameters e TouchEventArgs OnTouchGestureChanged(TouchGestureEventArgs) protected virtual void OnTouchGestureChanged(TouchGestureEventArgs e) Parameters e TouchGestureEventArgs OnTouchGestureEnded(TouchGestureEventArgs) protected virtual void OnTouchGestureEnded(TouchGestureEventArgs e) Parameters e TouchGestureEventArgs OnTouchGestureStarted(TouchGestureEventArgs) protected virtual void OnTouchGestureStarted(TouchGestureEventArgs e) Parameters e TouchGestureEventArgs OnTouchMove(TouchEventArgs) protected virtual void OnTouchMove(TouchEventArgs e) Parameters e TouchEventArgs OnTouchUp(TouchEventArgs) protected virtual void OnTouchUp(TouchEventArgs e) Parameters e TouchEventArgs PointToClient(ref int, ref int) public void PointToClient(ref int x, ref int y) Parameters x int y int PointToScreen(ref int, ref int) We are deviating little from their desktop counter parts, mostly for simplicity and perf. public void PointToScreen(ref int x, ref int y) Parameters x int y int RaiseEvent(RoutedEventArgs) public void RaiseEvent(RoutedEventArgs args) Parameters args RoutedEventArgs RenderRecursive(DrawingContext) protected virtual void RenderRecursive(DrawingContext dc) Parameters dc DrawingContext SetMargin(int) public void SetMargin(int length) Parameters length int SetMargin(int, int, int, int) public void SetMargin(int left, int top, int right, int bottom) Parameters left int top int right int bottom int UpdateLayout() Call this method to ensure that the whoel subtree of elements that includes this UIElement is properly updated. public void UpdateLayout() Remarks This ensures that UIElements with IsMeasureInvalid or IsArrangeInvalid will get call to their MeasureOverride and ArrangeOverride, and all computed sizes will be validated. This method does nothing if layout is clean but it does work if layout is not clean so avoid calling it after each change in the UIElement tree. It makes sense to either never call it (system will do this in a deferred manner) or only call it if you absolutely need updated sizes and positions after you do all changes. Events IsEnabledChanged public event PropertyChangedEventHandler IsEnabledChanged Event Type PropertyChangedEventHandler IsVisibleChanged public event PropertyChangedEventHandler IsVisibleChanged Event Type PropertyChangedEventHandler TouchDown public event TouchEventHandler TouchDown Event Type TouchEventHandler TouchGestureChanged public event TouchGestureEventHandler TouchGestureChanged Event Type TouchGestureEventHandler TouchGestureEnd public event TouchGestureEventHandler TouchGestureEnd Event Type TouchGestureEventHandler TouchGestureStart public event TouchGestureEventHandler TouchGestureStart Event Type TouchGestureEventHandler TouchMove public event TouchEventHandler TouchMove Event Type TouchEventHandler TouchUp public event TouchEventHandler TouchUp Event Type TouchEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.UIElementCollection.Enumerator.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.UIElementCollection.Enumerator.html",
    "title": "Struct UIElementCollection.Enumerator",
    "keywords": "Struct UIElementCollection.Enumerator Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll This is a simple UIElementCollection enumerator that is based on the ArrayListEnumeratorSimple that is used for ArrayLists. The following comment is from the CLR people: For a straightforward enumeration of the entire ArrayList, this is faster, because it's smaller. Benchmarks showed this. public struct UIElementCollection.Enumerator : IEnumerator, ICloneable Implements IEnumerator ICloneable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Current Gets the current UIElement. public UIElement Current { get; } Property Value UIElement Methods Clone() Creates a new object that is a copy of the current instance. public object Clone() Returns object MoveNext() Advances the enumerator to the next element of the collection. public bool MoveNext() Returns bool Reset() Sets the enumerator to its initial position, which is before the first element in the collection. public void Reset()"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.UIElementCollection.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.UIElementCollection.html",
    "title": "Class UIElementCollection",
    "keywords": "Class UIElementCollection Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll A UIElementCollection is a ordered collection of UIElements. public class UIElementCollection : ICollection, IEnumerable Inheritance object UIElementCollection Implements ICollection IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks A UIElementCollection has implied context affinity. It is a violation to access the collection from a different context than that of the owning Element This collection is an amalgam of UIElementCollection and UIElementCollection from Avalon Constructors UIElementCollection(UIElement) public UIElementCollection(UIElement owner) Parameters owner UIElement Properties Capacity Gets or sets the number of elements that the UIElementCollection can contain. public virtual int Capacity { get; set; } Property Value int The number of elements that the UIElementCollection can contain. Remarks Capacity is the number of elements that the UIElementCollection is capable of storing. Count is the number of UIElements that are actually in the UIElementCollection. Capacity is always greater than or equal to Count. If Count exceeds Capacity while adding elements, the capacity of the UIElementCollection is increased. By default the capacity is 0. Exceptions ArgumentOutOfRangeException Capacity is set to a value that is less than Count. Count Gets the number of elements contained in the ICollection. public virtual int Count { get; } Property Value int The number of elements contained in the ICollection. IsSynchronized Gets a value indicating whether access to the ICollection is synchronized (thread safe). public virtual bool IsSynchronized { get; } Property Value bool true if access to the ICollection is synchronized (thread safe); otherwise, false. this[int] Indexer for the UIElementCollection. Gets or sets the UIElement stored at the zero-based index of the UIElementCollection. public UIElement this[int index] { get; set; } Parameters index int Property Value UIElement Remarks This property provides the ability to access a specific UIElement in the UIElementCollection by using the following systax: myUIElementCollection[index]. Exceptions ArgumentOutOfRangeException index is less than zero -or- index is equal to or greater than Count. ArgumentException If the new child has already a parent or if the slot a the specified index is not null. SyncRoot Gets an object that can be used to synchronize access to the ICollection. public virtual object SyncRoot { get; } Property Value object An object that can be used to synchronize access to the ICollection. Methods Add(UIElement) Appends a UIElement to the end of the UIElementCollection. public int Add(UIElement element) Parameters element UIElement Returns int The UIElementCollection index at which the UIElement has been added. Remarks Adding a null is allowed. Exceptions ArgumentException If the new child has already a parent. Clear() Removes all elements from the UIElementCollection. public void Clear() Remarks Count is set to zero. Capacity remains unchanged. To reset the capacity of the UIElementCollection, call TrimToSize or set the Capacity property directly. Contains(UIElement) Determines whether a element is in the UIElementCollection. public bool Contains(UIElement element) Parameters element UIElement Returns bool CopyTo(UIElement[], int) Strongly typed version of CopyTo Copies the collection into the Array. public virtual void CopyTo(UIElement[] array, int index) Parameters array UIElement[] index int CopyTo(Array, int) Copies the UIElement collection to the specified array starting at the specified index. public void CopyTo(Array array, int index) Parameters array Array index int IndexOf(UIElement) Returns the zero-based index of the UIElement. If the UIElement is not in the UIElementCollection -1 is returned. If null is passed to the method, the index of the first entry with null is returned. If there is no null entry -1 is returned. public int IndexOf(UIElement element) Parameters element UIElement Returns int Insert(int, UIElement) Inserts an element into the UIElementCollection at the specified index. public void Insert(int index, UIElement element) Parameters index int The zero-based index at which value should be inserted. element UIElement The UIElement to insert. Remarks If Count already equals Capacity, the capacity of the UIElementCollection is increased before the new UIElement is inserted. If index is equal to Count, value is added to the end of UIElementCollection. The UIElements that follow the insertion point move down to accommodate the new UIElement. The indexes of the UIElements that are moved are also updated. Exceptions ArgumentOutOfRangeException index is less than zero. -or- index is greater than Count. Remove(UIElement) Removes the specified element from the UIElementCollection. public void Remove(UIElement element) Parameters element UIElement The UIElement to remove from the UIElementCollection. Remarks The UIElements that follow the removed UIElements move up to occupy the vacated spot. The indexes of the UIElements that are moved are also updated. If element is null then the first null entry is removed. Note that removing a null entry is linear in the size of the collection. RemoveAt(int) Removes the UIElement at the specified index. public void RemoveAt(int index) Parameters index int The zero-based index of the element to remove. Remarks The UIElements that follow the removed UIElements move up to occupy the vacated spot. The indexes of the UIElements that are moved are also updated. Exceptions ArgumentOutOfRangeException index is less than zero - or - index is equal or greater than count. RemoveRange(int, int) Removes a range of UIElements from the UIElementCollection. public void RemoveRange(int index, int count) Parameters index int The zero-based index of the range of elements to remove count int The number of elements to remove. Remarks The UIElements that follow the removed UIElements move up to occupy the vacated spot. The indexes of the UIElements that are moved are also updated. Exceptions ArgumentOutOfRangeException index is less than zero. -or- count is less than zero. ArgumentException index and count do not denote a valid range of elements in the UIElementCollection."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.VerticalAlignment.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.VerticalAlignment.html",
    "title": "Enum VerticalAlignment",
    "keywords": "Enum VerticalAlignment Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll public enum VerticalAlignment Fields Bottom = 2 Center = 1 Stretch = 3 Top = 0"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Visibility.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Visibility.html",
    "title": "Enum Visibility",
    "keywords": "Enum Visibility Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll Visibility - Enum which describes 3 possible visibility options. public enum Visibility Fields Collapsed = 2 Not visible and does not occupy any space in layout, as if it doesn't exist. Hidden = 1 Occupies space in the layout, but is not visible (completely transparent). Visible = 0 Normally visible."
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.Window.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.Window.html",
    "title": "Class Window",
    "keywords": "Class Window Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll public class Window : ContentControl Inheritance object DispatcherObject UIElement Control ContentControl Window Derived OnScreenKeyboard Inherited Members ContentControl.Child Control.Background Control.Font Control.Foreground Control.OnRender(DrawingContext) Control._background Control._foreground Control._font UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.OnChildrenChanged(UIElement, UIElement, int) UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.RenderRecursive(DrawingContext) UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Window() Constructs a window object public Window() Remarks Automatic determination of current Dispatcher. Use alternative constructor that accepts a Dispatcher for best performance. REFACTOR -- consider specifying app default window sizes to cover Aux case for default window size. Properties Left public int Left { get; set; } Property Value int SizeToContent Auto size Window to its content's size public SizeToContent SizeToContent { get; set; } Property Value SizeToContent Default value is SizeToContent.Manual Remarks SizeToContent can be applied to Width Height independently After SizeToContent is set, setting Width/Height does not take affect if that dimension is sizing to content. Top Position for Top of the host window public int Top { get; set; } Property Value int Topmost Determines if this window is always on the top. public bool Topmost { get; set; } Property Value bool Methods ArrangeOverride(int, int) ArrangeOverride allows for the customization of the positioning of children. protected override void ArrangeOverride(int arrangeWidth, int arrangeHeight) Parameters arrangeWidth int arrangeHeight int Remarks Deducts the frame size of the window from the constraint and then arranges it's child. Supports only one child. Close() public void Close() MeasureOverride(int, int, out int, out int) Measurement override. Implements content sizing logic. protected override void MeasureOverride(int availableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) Parameters availableWidth int availableHeight int desiredWidth int desiredHeight int Remarks Deducts the frame size from the constraint and then passes it on to it's child. Only supports one Visual child (just like control)"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.WindowCollection.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.WindowCollection.html",
    "title": "Class WindowCollection",
    "keywords": "Class WindowCollection Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll WindowCollection can be used to interate over all the windows that have been opened in the current application. public sealed class WindowCollection : ICollection, IEnumerable Inheritance object WindowCollection Implements ICollection IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors WindowCollection() Default Constructor public WindowCollection() Properties Count Count property public int Count { get; } Property Value int IsSynchronized IsSynchronized public bool IsSynchronized { get; } Property Value bool this[int] Overloaded [] operator to access the WindowCollection list public Window this[int index] { get; } Parameters index int Property Value Window SyncRoot SyncRoot public object SyncRoot { get; } Property Value object Methods CopyTo(Window[], int) CopyTo public void CopyTo(Window[] array, int index) Parameters array Window[] index int GetEnumerator() GetEnumerator public IEnumerator GetEnumerator() Returns IEnumerator"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.WindowManager.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.WindowManager.html",
    "title": "Class WindowManager",
    "keywords": "Class WindowManager Namespace GHIElectronics.Endpoint.UI Assembly GHIElectronics.Endpoint.UI.dll public class WindowManager : Canvas Inheritance object DispatcherObject UIElement Panel Canvas WindowManager Inherited Members Canvas.GetBottom(UIElement) Canvas.SetBottom(UIElement, int) Canvas.GetLeft(UIElement) Canvas.SetLeft(UIElement, int) Canvas.GetRight(UIElement) Canvas.SetRight(UIElement, int) Canvas.GetTop(UIElement) Canvas.SetTop(UIElement, int) Canvas.ArrangeOverride(int, int) Panel.Children UIElement.OnGenericEvent(GenericEventArgs) UIElement.OnTouchDown(TouchEventArgs) UIElement.OnTouchUp(TouchEventArgs) UIElement.OnTouchMove(TouchEventArgs) UIElement.OnTouchGestureStarted(TouchGestureEventArgs) UIElement.OnTouchGestureChanged(TouchGestureEventArgs) UIElement.OnTouchGestureEnded(TouchGestureEventArgs) UIElement.OnPreviewButtonDown(ButtonEventArgs) UIElement.OnButtonDown(ButtonEventArgs) UIElement.OnPreviewButtonUp(ButtonEventArgs) UIElement.OnButtonUp(ButtonEventArgs) UIElement.OnGotFocus(FocusChangedEventArgs) UIElement.OnLostFocus(FocusChangedEventArgs) UIElement.TouchDown UIElement.TouchUp UIElement.TouchMove UIElement.TouchGestureStart UIElement.TouchGestureChanged UIElement.TouchGestureEnd UIElement.GetDesiredSize(out int, out int) UIElement.GetMargin(out int, out int, out int, out int) UIElement.SetMargin(int) UIElement.SetMargin(int, int, int, int) UIElement.ActualWidth UIElement.ActualHeight UIElement.Height UIElement.Width UIElement.GetLayoutOffset(out int, out int) UIElement.GetRenderSize(out int, out int) UIElement.LogicalChildren UIElement.IsFocused UIElement.Measure(int, int) UIElement.Arrange(int, int, int, int) UIElement.UpdateLayout() UIElement.IsMeasureValid UIElement.IsArrangeValid UIElement.ChildElementFromPoint(int, int) UIElement.GetUnclippedSize(out int, out int) UIElement.ContainsPoint(int, int) UIElement.GetPointerTarget(int, int) UIElement.PointToScreen(ref int, ref int) UIElement.PointToClient(ref int, ref int) UIElement.InvalidateMeasure() UIElement.InvalidateArrange() UIElement.Parent UIElement.RootUIElement UIElement.HorizontalAlignment UIElement.VerticalAlignment UIElement.OnChildDesiredSizeChanged(UIElement) UIElement.OnRender(DrawingContext) UIElement.Visibility UIElement.IsVisible UIElement.IsVisibleChanged UIElement.IsEnabled UIElement.IsEnabledChanged UIElement.InvalidateRect(int, int, int, int) UIElement.Invalidate() UIElement.RaiseEvent(RoutedEventArgs) UIElement.AddToEventRoute(EventRoute, RoutedEventArgs) UIElement.InstanceEventHandlersStore UIElement.AddHandler(RoutedEvent, RoutedEventHandler, bool) UIElement._horizontalAlignment UIElement._verticalAlignment DispatcherObject.CheckAccess() DispatcherObject.VerifyAccess() DispatcherObject.Dispatcher object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields Instance public static WindowManager Instance Field Value WindowManager Methods MeasureOverride(int, int, out int, out int) Measurement override. Implement your size-to-content logic here. protected override void MeasureOverride(int availableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) Parameters availableWidth int Available size that parent can give to the child. May be MaxValue(when parent wants to measure to content). This is soft constraint. Child can return bigger size to indicate that it wants bigger space and hope that parent can throw in scrolling... availableHeight int desiredWidth int desiredHeight int Remarks MeasureOverride is designed to be the main customizability point for size control of layout. UIElement authors should override this method, call Measure on each child UIElement, and compute their desired size based upon the measurement of the children. The return value should be the desired size. Note: It is required that a parent UIElement calls Measure on each child or they won't be sized/arranged. Typical override follows a pattern roughly like this (pseudo-code): protected override void MeasureOverride(int avialableWidth, int availableHeight, out int desiredWidth, out int desiredHeight) { foreach (UIElement child in VisualChildren) { child.Measure(availableSize); availableSize.Deflate(child.DesiredSize); _cache.StoreInfoAboutChild(child); } Size desired = CalculateBasedOnCache(_cache); return desired; }</code></pre></example> The key aspects of this snippet are: You must call Measure on each child UIElement It is common to cache measurement information between the MeasureOverride and ArrangeOverride method calls Calling base.MeasureOverride is not required. Calls to Measure on children are passing either the same availableSize as the parent, or a subset of the area depending on the type of layout the parent will perform (for example, it would be valid to remove the area for some border or padding). OnChildrenChanged(UIElement, UIElement, int) OnChildrenChanged is called when the UIElementCollection of the UIElement is edited. protected override void OnChildrenChanged(UIElement added, UIElement removed, int indexAffected) Parameters added UIElement removed UIElement indexAffected int RenderRecursive(DrawingContext) protected override void RenderRecursive(DrawingContext dc) Parameters dc DrawingContext Events PostRender public event PostRenderEventHandler PostRender Event Type PostRenderEventHandler"
  },
  "endpoint/api/GHIElectronics.Endpoint.UI.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.UI.html",
    "title": "Namespace GHIElectronics.Endpoint.UI",
    "keywords": "Namespace GHIElectronics.Endpoint.UI Classes Application Application base class CancelEventArgs EventRoute OnScreenKeyboard PresentationSource Presentation source is our connection to the rest of the managed system. PropertyChangedEventArgs Provides data for the various property changed events. RoutedEvent RoutedEventArgs The container for all state associated with a RoutedEvent RoutedEventHandlerInfo Container for handler instance and other invocation preferences for this handler instance UIElement UIElementCollection A UIElementCollection is a ordered collection of UIElements. Window WindowCollection WindowCollection can be used to interate over all the windows that have been opened in the current application. WindowManager Structs UIElementCollection.Enumerator This is a simple UIElementCollection enumerator that is based on the ArrayListEnumeratorSimple that is used for ArrayLists. The following comment is from the CLR people: For a straightforward enumeration of the entire ArrayList, this is faster, because it's smaller. Benchmarks showed this. Enums HorizontalAlignment ReasonSessionEnding Enum for ReasonSessionEnding RoutingStrategy Routing Strategy can be either of Tunnel or Bubble ShutdownMode Enum for ShutdownMode SizeToContent SizeToContent VerticalAlignment Visibility Visibility - Enum which describes 3 possible visibility options. Delegates CancelEventHandler EventHandler PostRenderEventHandler PropertyChangedEventHandler Represents the method that will handle the event raised when a Property is changed RoutedEventHandler RoutedEventHandler Definition"
  },
  "endpoint/api/GHIElectronics.Endpoint.Update.UpdateController.Mode.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Update.UpdateController.Mode.html",
    "title": "Enum UpdateController.Mode",
    "keywords": "Enum UpdateController.Mode Namespace GHIElectronics.Endpoint.Update Assembly GHIElectronics.Endpoint.Update.dll public enum UpdateController.Mode : uint Fields Firmware = 1 ProgrameMMC = 0"
  },
  "endpoint/api/GHIElectronics.Endpoint.Update.UpdateController.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Update.UpdateController.html",
    "title": "Class UpdateController",
    "keywords": "Class UpdateController Namespace GHIElectronics.Endpoint.Update Assembly GHIElectronics.Endpoint.Update.dll public class UpdateController Inheritance object UpdateController Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors UpdateController(Mode, int, string) public UpdateController(UpdateController.Mode mode, int pinIndicator = -1, string sourcePath = null) Parameters mode UpdateController.Mode pinIndicator int sourcePath string Methods Update() public bool Update() Returns bool"
  },
  "endpoint/api/GHIElectronics.Endpoint.Update.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.Update.html",
    "title": "Namespace GHIElectronics.Endpoint.Update",
    "keywords": "Namespace GHIElectronics.Endpoint.Update Classes UpdateController Enums UpdateController.Mode"
  },
  "endpoint/api/GHIElectronics.Endpoint.html": {
    "href": "endpoint/api/GHIElectronics.Endpoint.html",
    "title": "Namespace GHIElectronics.Endpoint",
    "keywords": "Namespace GHIElectronics.Endpoint Classes FileSystem"
  },
  "endpoint/api/intro.html": {
    "href": "endpoint/api/intro.html",
    "title": "Libraries",
    "keywords": "Libraries Microsoft standard .NET libraries Endpoint uses the standard .NET 8 API including the .NET IoT API. A good example of this is the .NET GPIO library API. using System.Device.Gpio; using System.Device.Gpio.Drivers; using GHIElectronics.Endpoint.Core; var port = EPM815.Gpio.Pin.PC0 /16; var pin = EPM815.Gpio.Pin.PC0 % 16; var gpioDriver = new LibGpiodDriver((int)port); var gpioController = new GpioController(PinNumberingScheme.Logical, gpioDriver); gpioController.OpenPin(pin); gpioController.SetPinMode(pin, PinMode.Output); while (true) { gpioController.Write(pin, PinValue.High); Thread.Sleep(100); gpioController.Write(pin, PinValue.Low); Thread.Sleep(100); } Endpoint Libraries Additional Endpoint APIs are implemented to cover missing hardware related features not found in the official .NET libraries. A good example of this is the Endpoint ADC library. using GHIElectronics.Endpoint.Core; using GHIElectronics.Endpoint.Devices.Adc; var adcController = new AdcController(EPM815.Adc.Pin.ANA1); while (true){ var v = adcController.Read(); var v1 = (v * 3.3 / 65535); Console.WriteLine(v1.ToString()); Thread.Sleep(1000); }"
  },
  "endpoint/beyond-dotnet.html": {
    "href": "endpoint/beyond-dotnet.html",
    "title": "Beyond .NET",
    "keywords": "Beyond .NET Endpoint's hardware and documentation's main focus is .NET, however the system is capable of supporting other languages as well. Python Getting Started Install the latest version VS Code, https://code.visualstudio.com/ Visit the extension section from within VS Code and search for and install Endpoint VSC Python Debugger. Alternatively, Download and install the latest Endpoint VSC Python Extension (.vsix) file manually. Navigate to View -> Command Palette Search for Endpoint and select Endpoint:Create Python project Give the project a name and location. Tip If you change the default project name you must also change it in the settings.json file Python Libraries Endpoint uses the standard Python libraries when available. When a library doesn't existing inside the Python API relating to embedded hardware we use an Endpoint library to fill in the missing gaps. Additional libraries are under development. Peripheral Endpoint Python Library GPIO GHIElectronics.Endpoint.Core.EPM815.Gpio PWM GHIElectronics.Endpoint.Core.EPM815.PWM SPI GHIElectronics.Endpoint.Core.EPM815.Spi I2C GHIElectronics.Endpoint.Core.EPM815.Adc ADC GHIElectronics.Endpoint.Core.EPM815.Adc DISPLAY GHIElectronics.Endpoint.Core.EPM815.Display RTC GHIElectronics.Endpoint.Core.EPM815.RTC Register GHIElectronics.Endpoint.Core.EPM815.Register Serial Port GHIElectronics.Endpoint.Core.EPM815.SerialPort The Python libraries are built into the release image, user don't need to do anything else, just use import. This uses remote debug, so there is no IntelliSense built in. Optionally users can install on the PC to use IntelliSense when importing the libraries. C:\\pip install GHIElectronics.Endpoint.Core After install, VSC code IntelliSense will show the libraries available. Python Code Samples Here is a couple code samples to get started. Additional code samples can be found in the Endpoint Samples Repo Python GPIO The code sample below blinks an on-board LED. import gpiod import time import GHIElectronics.Endpoint.Core.EPM815.Gpio as Gpio pin = Gpio.Pin.PC0 chip=gpiod.Chip(str(int(pin / 16))) line = chip.get_line(pin % 16) line.request(consumer='test', type=gpiod.LINE_REQ_DIR_OUT) while True: line.set_value(1) time.sleep(0.5) line.set_value(0) time.sleep(0.5) Python PWM The code sample demonstrates PWM using an on-board buzzer. import time import GHIElectronics.Endpoint.Core.EPM815.Pwm as Pwm pwm = Pwm.PwmController(Pwm.Pin.PF9) pwm.Frequency = 1000 pwm.DutyCycle = 0.5 pwm.Start() time.sleep(3) pwm.Stop()"
  },
  "endpoint/configuration.html": {
    "href": "endpoint/configuration.html",
    "title": "Configuration",
    "keywords": "Configuration Endpoint Config Tool Tip An Endpoint device must be fully booted in order for the configuration tool to work. The Endpoint Config tool is used to update & configure Endpoint Hardware. It will also give information about the device. Download and install the latest version to begin. Connecting to the Device Connect the Endpoint device to the PC using a USB cable. Once the booting sequence is complete, the USER LED will be fully lit. Press Connect on the Config tool app. The tool will display device information once connected Adding a BootScreen Bootscreens can be enabled or disabled under Utilities. By default Endpoint compatible screens are already loaded, you can just select the size of the screen and the image you want to use. Once enabled the custom loaded image will display on bootup. Supported image formats are .jpeg, .png, or .bmp, in any size. Images are stretched to fit the screen's resolution. Setting up a Device Password Creating a device password is optional. To create a password for the device, select Security -> Change Password. After selecting a window will appear to enter our a new password and verify it's correct. Tip We can remove an existing password from a device by leaving the fields blank and clicking OK After creating or changing a password, the device will disconnect. To reconnect we will need to add the password we created. Once the correct password is entered, Endpoint Config on the users machine will save the password in the box. Meaning you don't have to enter it every time you use the tool. If you move the device to another computer you'll need to enter the password to connect. Note There is no way to retrieve a forgotten password, the device must be completely erased and a new image created. We also need to set up the programming IDE with our new password. Create or open an existing .NET project and navigate to Debug -> Options Select Endpoint Debugger and highlight the SSH connection and click Edit Add the newly created password and click OK."
  },
  "endpoint/downloads.html": {
    "href": "endpoint/downloads.html",
    "title": "Downloads",
    "keywords": "Downloads This page includes downloads for the Endpoint line of products. Software status legend: Status Meaning Production (RTW) Ready to be used commercially (ready to wear). Update An update to a production release, still RTW. Release Candidate (RC) Could become a production release if proven solid. Preview Preview of the next release, not quite ready for production use. Endpoint OS Image The Endpoint OS image can be downloaded and run from a microSD card or flashed to eMMC if the Endpoint hardware supports it. File Date Status MD5 v0.1.7.0 (Beta) 2024-5-14 Preview 8D5BF770027FA1C9FA5E7AFFBF603732 v0.1.6.1 (Beta) 2024-4-24 Preview BAF47E5A9745BF9136E2085C443BA1C0 Endpoint OS image is large and that take time to update. For quick update/re-install firmware or dotnet, user can select update firmware or dotnet from Endpoint Config tool, and using the files below: Firmware File Date Status MD5 v0.1.7.0 (Beta) 2024-5-14 Preview 8D5BF770027FA1C9FA5E7AFFBF603732 v0.1.6.1 (Beta) 2024-4-24 Preview BB6DDFAEAB03F30413FE6F65F598F4AA Dotnet File Date Status MD5 v8.0.100 (Beta) 2024-02-02 Preview E163B3E8EAF8A162D7871776684C1332 Endpoint Config Endpoint Config is a tool used to update and configure your Endpoint device. File Date Status MD5 v0.1.7.0 (Beta) 2024-5-14 Preview 5C8728F4B669851854E16C09F4F1BA92 v0.1.6.0 (Beta) 2024-4-22 Preview D0DDC758C3411378B9C7C29ACE13DFA8 v0.1.3.0 (Beta) 2024-8-3 Preview 779763643D55D5F91C064C9DA9052D41 v0.1.2.0 (Beta) 2024-21-02 Preview A372D2E3C5A5752D4CEBF819ED85086D v0.1.0.0 (Beta) 2024-02-02 Preview 8440E6358F46199B656F5F61CBF9B62B Endpoint Libraries Endpoint Libraries are designed to fill in any gaps the .NET API is missing for hardware. It is preferred to access these libraries through NuGet.org by using the IDE's default package source. Note Make sure to check the Include prerelease box in Visual Studio's NuGet package manager if you're not using the production release. File Date Status MD5 v0.1.7.0 (Beta) 2024-5-14 Preview 663E01082E712EDE235CC299C07C7465 v0.1.6.0 (Beta) 2024-4-22 Preview B022A7CEFAAF5B16077F0800DFC98461 v0.1.4.0 (Beta) 2024-4-5 Preview F9145F97F1F6E6723830617F3E45D690 v0.1.3.0 (Beta) 2024-8-3 Preview E59F145C850D748C61ACB4CEF2179961 v0.1.2.0 (Beta) 2024-21-02 Preview 5B2077ABB3AC31B024179FD2B0654F0D v0.1.0.0 (Beta) 2024-02-02 Preview 708833FEFCE57C51F9CE01DA47EF0541 Visual Studio & VS Code extension files The extension is what gets loaded on Visual Studio/VS Code to allow it to communicate with an Endpoint device. It also includes project templates. Visual Studio 2022 The Endpoint Debugger for Visual Studio can be installed from within in Visual Studio. It can also be downloaded at the Visual Studio Marketplace VS Code The Endpoint Debugger for VS Code can be installed from within in VS Code. It can also be downloaded at the VS Code Marketplace The Endpoint Debugger for Python can be installed from within in VS Code. It can also be downloaded at the VS Code Marketplace"
  },
  "endpoint/getting-started.html": {
    "href": "endpoint/getting-started.html",
    "title": "Getting Started",
    "keywords": "Getting Started An Endpoint development environment consists of a device running Endpoint OS and a development machine with the required software and extension. Endpoint Device Setup The first step is to boot the Endpoint OS, which can be hosted on a microSD card or loaded inside the hardware's eMMC flash (when available). Creating the OS image Use your preferred disk imaging software to create a disk image on a blank microSD card, Win32 Disk Imager or balenaEtcher for example. Find the latest Endpoint disk image here and burn it to the blank microSD card (4GB minimum). Tip Windows hides the microSD card once the media is loaded with the Endpoint OS image. Win32 Disk Imager will no longer see it. You need to use Disk Management tool to repartition/format the media, or use other tools like balenaEtcher. Boot from SD Once the image file is burned to the microSD card the OS is ready to boot. Insert the card into the microSD card slot of your hardware and connect the device to the PC. If the device has an eMMC, use the SD Boot button to force the device to boot from the SD card. Once the USER LED lights the board has successfully booted the Endpoint OS from the microSD. This should happen in less than 5 seconds. Flashing the eMMC Devices with eMMC will automatically boot from eMMC. The system will fail to boot if the OS image is invalid. SD cards can always be used to boot the system. Once the system is up, the Endpoint Config tool can be used to update the eMMC, as detailed in the Configuration page. Development Machine Setup Now, that the device is running the Endpoint OS, the development machine can be prepared for remote debug and deploy to the Endpoint device (using USB-C). This can be done using either Visual Studio or VS Code. Endpoint for Visual Studio With Endpoint you can deploy and debug using Visual Studio. Even the free community version. If you don't already have the latest version of Visual Studio, download it here: https://visualstudio.microsoft.com/downloads/ Download and install the newest Endpoint Visual Studio Project System by going to Extensions > Manage Extensions. In the Manage Extensions dialog box select Online in the left panel. Type GHI Endpoint in the Search text box in the upper right of the window to search for and install the Endpoint Project System. You'll need to restart Visual Studio to let the extension installer complete the installation. Alternately you can download the Visual Studio Project System from our Downloads page and install the latest Endpoint Visual Studio Extension (.vsix). Open or double click on the file to install the extension. After installing the .vsix file, create a new .NET 8 application. By default the .NET application will run on the PC. We need to switch to run the program on the Endpoint device. At the top of the Visual Studio menu navigate to Debug -> Options From there navigate to the Endpoint Debugger option and make sure the box is checked for root@192.168.82.2. If a password was created using the Endpoint Config Tool also enter it here. If unchecked the application will only run on the PC. Endpoint for VS Code Endpoint also works using the VS Code IDE. If you don't already have the latest version, download it here: https://code.visualstudio.com/ Visit the extension section from within VS Code and search for and install Endpoint VSC Debugger. Alternatively, Download and install the latest Endpoint VS Code Extension (.vsix) file manually. Navigate to View -> Command Palette Search for Endpoint and select Endpoint:Create Net IoT project Give the project a name and location. NuGet Libraries Endpoint uses the standard .NET libraries when available. When a library doesn't existing inside the .NET API relating to embedded hardware we use an Endpoint library to fill in the missing gaps. It is preferred to access NuGet libraries through NuGet.org by using Visual Studio's default package source. The Endpoint libraries are provided here in case you're having trouble with the online source or need an older or pre-release library that's not hosted on NuGet. Learn more about the Endpoint API here."
  },
  "endpoint/hardware/dev.html": {
    "href": "endpoint/hardware/dev.html",
    "title": "Endpoint Dev Boards",
    "keywords": "Endpoint Dev Boards COMING SOON! The Endpoint development board makes it possible to start programming applications within minutes without designing or building new hardware. The DEV board is not only suitable for prototypes, but for short production runs as well. You can visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com."
  },
  "endpoint/hardware/intro.html": {
    "href": "endpoint/hardware/intro.html",
    "title": "Endpoint",
    "keywords": "Endpoint The Endpoint line of products provides an easy way to use FULL .NET 8 on a embedded device using Visual Studio or VS Code. Single Board Computer The Endpoint Domino provides the lowest barrier of entry to the world of Endpoint and .NET 8 on hardware Learn More... You can also visit our main website at main website and our community forum."
  },
  "endpoint/hardware/sbc.html": {
    "href": "endpoint/hardware/sbc.html",
    "title": "Endpoint Single Board Computers",
    "keywords": "Endpoint Single Board Computers Endpoint Domino The Endpoint Domino provides an easy prototyping and evaluating board option, that is low-cost and user friendly. Features: 32bit ARM 650Mhz, 512MB DDR3 Display FPC connector 2x mikroBUS headers USB Host User LED Buzzer 40-pin expansion header microSD card slot USB-C connector Pinout Displays The display FPC connector on EP-Domino uses a common pinout available on many displays. Some of these displays include capacitive touch screens, which are supported as well. Pin Function 1 Backlight Cathode (-) 2 Backlight Anode (+) 3 GND 4 3.3V 5-12 Red Data (top 5 bits only) 13-20 Green Data (top 6 bits only) 21-28 Blue Data (top 5 bits only) 29 GND 30 Clock (PCLK) 31 Enable (Connected to 3.3V) 32 Horizontal Sync (HSYNC) 33 Vertical Sync (VSYNC) 34 Data Enable (DE) 35 Not Connected 36 GND 37 Cap Touch Interrupt 38 Cap Touch Reset 39 Cap Touch SCL 40 Cap Touch SDA Here is a list of tested displays from www.buydisplay.com. If Touch is needed make sure the display is the 40 pin single cable version that includes touch on pins 37-40. Display Type Link ER-TFT043-3 4.3\" 480x272 Link... ER-TFT043A3-3 4.3\" 480x272 Link... ER-TFT043A1-7 4.3\" 800x480 Link... ER-TFT070A2-4 7\" 800x480 no Touch support Link... See the Displays tutorial for coding examples. Cameras The Endpoint OS supports cameras through USB and parallel. For added convenience, the top side of the 40 pin header is pinout compatible with the off-the-shelf OV5640 camera board. See the Camera tutorial for coding examples. mikroBUS Endpoint Domino has 2x mikroBUS headers compatible with over 1000 click modules. Wi-Fi A Wi-Fi dongle can be connected to the USB port to give the board a networking interface. See the Networking tutorial for more details and coding examples. Tip List of potential Wi-Fi dongles (reported by Users) Netis WF2120 TP-Link TL-WN725N"
  },
  "endpoint/hardware/som.html": {
    "href": "endpoint/hardware/som.html",
    "title": "Endpoint System on Modules",
    "keywords": "Endpoint System on Modules COMING SOON! The Endpoint SoMs provide a low cost way to add FULL .NET 8 computing power to any embedded product. They will be available in a 200 pin SO-DIMM format or as surface mount modules. You can visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com. Module Pinouts EPM815N Pinout EPM815E Pinout EPM815D Pinout"
  },
  "endpoint/intro.html": {
    "href": "endpoint/intro.html",
    "title": "Endpoint Introduction",
    "keywords": "Endpoint Introduction Endpoint is FULL .NET 8 for circuits! Load and run applications on embedded hardware. All you need to get started is Visual Studio or VS Code, an Endpoint device, and a USB cable. Getting Started Get started quickly with Endpoint using .NET 8 Learn More... Devices Endpoint hardware to fit all needs. Learn more... Configuration Endpoint Config tool easily connects and configures devices Learn more... Libraries Endpoint uses existing .NET hardware libraries when available. Some we had to create Learn more... Downloads Visual Studio/VS Code and device downloads. Learn more... Release Notes Find the latest changes to Endpoint. Learn more... Limitations Endpoint limitations when using .NET Learn more... You can also visit our main website at main website and our community forum."
  },
  "endpoint/limitations.html": {
    "href": "endpoint/limitations.html",
    "title": "Limitations",
    "keywords": "Limitations There are none! Endpoint runs the FULL Microsoft .NET 8 ARM32. Everything from .NET and NuGet to C# and Visual Basic are all supported. Expect the full experience similar to running .NET on a PC but consider the available memory & processing power of course."
  },
  "endpoint/release-notes.html": {
    "href": "endpoint/release-notes.html",
    "title": "Release Notes",
    "keywords": "Release Notes 0.1.7 - Beta (2024-5-14) Endpoint OS Changes Added BlueZ stack for Bluetooth Added Bluetooth drivers: Broadcom: BCM4335,BCM4350, BCM4356, BCM4371, BCM20702, BCM20703, BCM43142 Added Bluetooth drivers: Realtek: RTL87xx Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues Libraries Changes Core: Class Script supports event Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues Drivers Changes Added Bluetooth driver nuget Known Issues https://github.com/ghi-electronics/endpoint-drivers/issues Endpoint Config Changes Added Set/Remove environment variables Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues. 0.1.6.1 - Beta (2024-4-24) Endpoint OS Changes Fixed python library Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues 0.1.6 - Beta (2024-4-22) Endpoint OS Changes Add DMA for SPI Support Network configuration from Endpoint tool Suport MacOS (192.168.83.2) Fix WiFi don't work with static IP Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues Visual Studio Extension Changes Support debug over WiFi, Ethernet other than USB Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues Libraries Changes Network: WiFi and Ethernet, USB Ethernet can work at the same time Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues Drivers Changes Improved VirtualKeyboard driver Known Issues https://github.com/ghi-electronics/endpoint-drivers/issues Endpoint Config Changes Added Network configuration Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues. 0.1.4 - Beta (2024-4-5) Endpoint OS Changes Added Adc Added PulseFeedback Libraries Changes Added UI Added Adc Added PulseFeedback (DrainDuration, EchoDuration, DurationUntilEcho) Display: Flush(..) supports flushing any size, anywhere within data buffer. Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues 0.1.3 - Beta (2024-3-8) Endpoint OS Changes Added native Watchdog library Added Python (ADC, PWM, I2C, SPI, Serial, GPIO, Display, RTC) Added USB_RTL8152 Ethernet Added timezone info Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues Visual Studio Extension Changes Fixed deployment error when using extensions in languages other than English. Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues VS Code Extension .NET VS Code Extension Changes None Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues Python VS Code Extension Changes Initial Release Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues Libraries Changes SPI: Added change buffer_size ADC: Rename Read() to ReadRaw(). Add Read (scaled to 3.3V) UART: Removed UART6. Fix UART5 does not work Ethernet: Add USB Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues Drivers Changes Added VirtualKeyboard nuget Added ST7735 SPI display nuget Known Issues https://github.com/ghi-electronics/endpoint-drivers/issues Endpoint Config Changes Fixed 800x480 bootscreen setting Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues. 0.1.2 - Beta (2024-2-21) Endpoint OS Changes Added OpenCV Support Bootscreen Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues Visual Studio Extension Changes Improved deploying speed Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues VS Code Extension Changes Fixed Ctrl+Shift+B doesn't work on non-Windows system Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues Libraries Changes Fixed can't initialize multiple ports: https://github.com/ghi-electronics/Endpoint-Libraries/issues/48 Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues Drivers Changes Add Avalonia Touch input driver Known Issues https://github.com/ghi-electronics/endpoint-drivers/issues Endpoint Config Changes Add Enable Bootscreen setting Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues. 0.1.0 - Beta (2024-2-2) Endpoint OS Initial Release Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues Visual Studio Extension Initial Release Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues VS Code Extension Initial Release Known Issues https://github.com/ghi-electronics/Endpoint-Libraries/issues Libraries Initial Release Known Issues None. Drivers Initial Release Known Issues https://github.com/ghi-electronics/endpoint-drivers/issues Endpoint Config Initial Release"
  },
  "endpoint/tutorials/analog-in.html": {
    "href": "endpoint/tutorials/analog-in.html",
    "title": "Analog In",
    "keywords": "Analog In Unlike digital input pins, which can only read high or low, analog pins can read a range of voltage levels. Microcontrollers based on 3.3V can typically read voltages anywhere between zero and 3.3V. Analog inputs connect internally to an Analog to Digital Converter (ADC) that converts the analog voltage level on the pin to a digital value. Tip Note that the analog channel number is not the pin number. You need to determine the channel number of a specific pin using your system's documentation. The resolution of the ADC determines its accuracy. An 8bit ADC has 256 steps to work with, 3.3V/256=0.013V. This means an increase of 0.013V will increase the ADC value by one. In other words, a voltage change of less than 0.013V has no effect. The example below uses a rotary module on the ANA1 pin var adcController = new AdcController(EPM815.Adc.Pin.ANA1); int loop = 10; while (true) { var v = adcController.Read(); var v1 = (v * 3.3 / 65535); Console.WriteLine(v1.ToString()); Thread.Sleep(1000); loop--; }"
  },
  "endpoint/tutorials/analog-out.html": {
    "href": "endpoint/tutorials/analog-out.html",
    "title": "Analog Out",
    "keywords": "Analog Out DAC A Digital to Analog Converter (DAC) will convert a digital input (number) to an analog output (voltage). The voltage of a DAC usually swings from very close to zero volts up to nearly the voltage of the microcontroller (usually 3.3 volts). This output voltage is only a weak signal and is not meant to drive a load. An op-amp or similar circuit can be added to drive a load, such as a speaker. The param accepted by the api is from 0.0 to 1.0. This is ratio from 0V to the microcontroller's voltage source, 3.3V on EPM815. Note EPM815 supports 12 bit resolution. var dac = new DacController(EPM815.Dac.Pin.PA5); double start = 0; double offset = 0.1; var dir = 1; while (true) { dac.WriteValue(start); if (start >=0.9) dir = -1; if (start <=0.1) dir = 1; start += (offset * dir); Thread.Sleep(1000); } Tip Do not use analog outputs to control the power of an LED or a motor. Use PWM for that. PWM PWM can also be used to output an analog voltage. Click here for details. Audio Playback WAV audio playback can be done using an analog output pin. See Audio Playback."
  },
  "endpoint/tutorials/aws.html": {
    "href": "endpoint/tutorials/aws.html",
    "title": "Amazon Web Services",
    "keywords": "Amazon Web Services This example shows how to communicate with AWS using MQTT. This demo assumes the device has established a [Networking(networking.md) interface and the date and time on the device are set correctly. Tip Needed NuGets: GHIElectronics.Endpoint.Core, GHIElectronics.Endpoint.Devices.Network, M2MqttDotnetCore string iotEndpoint = \"your iot endpoint\"; Console.WriteLine(\"AWS IoT Dotnet message publisher starting..\"); int brokerPort = 8883; string topic = \"$aws/things/EPDominoThing2024/shadow/update/documents\"; string message = \"Test message\"; var caCertData = Resources.AmazonRootCA1; // load from resource var caClientCertData = Resources.device_certificate; // this is pfx format load from resource var caCert = new X509Certificate(caCertData); var clientCert = new X509Certificate2(caClientCertData); var client = new MqttClient(iotEndpoint, brokerPort, true, caCert, clientCert, MqttSslProtocols.TLSv1_2); string clientId = Guid.NewGuid().ToString(); client.Connect(clientId); Console.WriteLine($\"Connected to AWS IoT with client id: {clientId}.\"); client.Subscribe(new string[] { topic }, new byte[] { 0 }); client.MqttMsgPublishReceived += (a, b) => { Console.WriteLine(Encoding.UTF8.GetString(b.Message)); }; int i = 0; while (true) { client.Publish(topic, Encoding.UTF8.GetBytes($\"{message} {i}\")); Console.WriteLine($\"Published: {message} {i}\"); i++; Thread.Sleep(5000); } We need a few things to complete the code sample that we'll get from AWS. We need an iotEndPoint, a deviceId, an AWS root certificate, a client certificate and a private key. First, you'll need to create an AWS account. Once you've created your account, we need to find the service to set up our device. On the AWS Management Console, search for the service 'IoT Core' and select it. Create Thing Select default and click next We created Thing name EPDomino24, thing type is optional. Select auto generate certificate and click next Download certificates After created thing name \"EPDominoThing24\", the screen is below: Certificates Device certificate: This file usually ends with \".pem.crt\". When you download this it will save as .txt file extension in windows. Save it in your certificates directory as 'certificates\\certificate.cert.pem' and make sure that it is of file type '.pem', not 'txt' or '.crt' Device public key: This file usually ends with \".pem\" and is of file type \".key\". Save this file as 'certificates\\certificate.public.key'. Device private key: This file usually ends with \".pem\" and is of file type \".key\". Save this file as 'certificates\\certificate.private.key'. Make sure that this file is referred with suffix \".key\" in the code while making MQTT connection to AWS IoT. Root certificate: Download from https://www.amazontrust.com/repository/AmazonRootCA1.pem. Save this file to 'certificates\\AmazonRootCA1.crt' Converting Device Certificate from .pem to .pfx In order to establish an MQTT connection with the AWS IoT platform, the root CA certificate, the private key of the thing, and the certificate of the thing/device are needed. The .NET cryptographic APIs can understand root CA (.crt), device private key (.key) out-of-the-box. It expects the device certificate to be in the .pfx format, not the .pem format. Hence we need to convert the device certificate from .pem to .pfx. We'll leverage the openssl for converting .pem to .pfx. Navigate to the folder where all the security artifacts are present and launch bash for Windows 10. The syntax for converting .pem to .pfx is below: openssl pkcs12 -export -in iotdevicecertificateinpemformat -inkey iotdevivceprivatekey -out devicecertificateinpfxformat -certfile rootcertificatefile Create Policies Name new policy EPDomino24PolicyAll and use * means all action and resource Attach Policies Back to Certificates, select Attach policies The screen is below: Test Publisher All message from/to the device can be seen here: Tip The \"string iotEndpoint = \"your iot endpoint\"; variable can be found here:"
  },
  "endpoint/tutorials/azure.html": {
    "href": "endpoint/tutorials/azure.html",
    "title": "Microsoft Azure",
    "keywords": "Microsoft Azure This example shows how to communicate with Azure IoT Hub using MQTT. User will need to set up a Network Interface connection on the device first. Tip The needed root certificate for Azure is already part of the system internally. No need to load any certificates. The Azure SDK and documentation include full details. This is a good example"
  },
  "endpoint/tutorials/bluetooth.html": {
    "href": "endpoint/tutorials/bluetooth.html",
    "title": "Bluetooth",
    "keywords": "Bluetooth Endpoint supports two kinds of Bluetooth devices through USB, they are: Broadcom: BCM4335,BCM4350, BCM4356, BCM4371, BCM20702, BCM20703, BCM43142 Realtek: RTL87xx Endpoint uses BlueZ stack to control Bluetooth. There is an example for using BlueZ in .NET, can be found here: https://github.com/SuessLabs/Linux.Bluetooth Note Hardware driver needs to be loaded, initialized, and paired before using BlueZ library. Pair is requested from Endpoint only. Example Below is an example how to initialize and pair between Endpoint and another device with provided MAC_ADDRESS const string MAC_ADDRESS = \"80:07:94:46:57:B6\"; // The mac address needed for ep connect to. private static void Main() { Bluetooth.Initialize(); Console.WriteLine($\"Mac Address : {Bluetooth.GetDeviceMacAddress()}\"); Console.WriteLine($\"Name : {Bluetooth.GetDeviceName()}\"); Console.WriteLine($\"Manufacturer : {Bluetooth.GetDeviceManufacturer()}\"); Bluetooth.Power(false); Thread.Sleep(1000); Bluetooth.Power(true); Bluetooth.OnScanEvent += Console.WriteLine; var knownDevices = Bluetooth.DevicePaired(); if (knownDevices != null) { foreach (var device in knownDevices) { Console.WriteLine(\"Known:\" + device); } } Bluetooth.Unpair(MAC_ADDRESS); // unpair and scan to pair again if (Bluetooth.Scan(new TimeSpan(0, 0, 200), MAC_ADDRESS)) { if (Bluetooth.Pair(MAC_ADDRESS)) { Console.WriteLine(\"Pair sucessfully\"); } else { Console.WriteLine(\"Pair failed\"); } } Thread.Sleep(-1); }"
  },
  "endpoint/tutorials/camera.html": {
    "href": "endpoint/tutorials/camera.html",
    "title": "Camera Interface",
    "keywords": "Camera Interface Endpoint supports digital cameras through USB or the parallel interface (DCMI). USB Cameras The use of USB Cameras is straightforward and similar to using other USB devices. The USB tutorials covers the details. DCMI Camera Typically, DCMI cameras need two interfaces, the DCMI itself for transferring the images and an I2C bus for configuring the camera internal controller. Endpoint includes experimental support for OV5640 cameras. Only I2C6 can be used with this camera. var setting = new CameraConfiguration() { Width = 640, Height = 480, ImageFormat = Format.Rgb565, //Format.Jpeg FrameRate = 15, }; var webcam = new OV5640Controller(EPM815.I2c.I2c6, EPM815.Gpio.Pin.PG0, EPM815.Gpio.Pin.PZ3); // i2c, pin reset, power down var resolutions = webcam.GetResolution(); webcam.Setting = setting; var cnt = 0; while (true) { if (webcam != null) { var data = webcam.Capture(); if (data != null) { if (setting.ImageFormat == Format.Rgb565) { // Show on screen //displayController.Flush(data, 0, data.Length, webcam.Width, webcam.Height); } else if (setting.ImageFormat == Format.Jpeg) { // Save to file using (var stream = File.Open($\"/.epdata/{webcam.Width}x{webcam.Height}_{cnt}.jpeg\", FileMode.Create)) { using (var writer = new BinaryWriter(stream, Encoding.UTF8, false)) { writer.Write(data); } } } } } Thread.Sleep(10); }"
  },
  "endpoint/tutorials/can.html": {
    "href": "endpoint/tutorials/can.html",
    "title": "CAN",
    "keywords": "CAN Controller Area Network (CAN) bus is a serial communication protocol with built-in error checking and retransmission. It is generally a two wire bus, but other transceivers with one wire or LSFT (Low Speed Fault Tolerant) are used. The common high-speed two-wire CAN requires termination resistors at the end of the wires, typically 120 ohm. Endpoint supports standard CAN and CAN-FD. var canController = new CanController(EPM815.Can.Can2, 250_000); // When 2 baudrates are needed //var canController = new CanController(EPM815.Can.Can2, 250_000, 500_000); canController.Enable(); // Send a message var msg = new CanMessage(0x123, new byte[] { 11, 22, 33 }); canController.Write(msg); Errors can be monitored as well canController.EnableErrorEvent(CanError.ErrorTxTimeout | CanError.ErrorBusOff); canController.ErrorReceived += (a, b) => { uint error = (uint)b.Error; if ((error & (uint)CanError.ErrorBusOff) == (uint)CanError.ErrorBusOff) { Console.WriteLine(\"Error bus off\"); } else { Console.WriteLine(\"Receving error: 0x\" + error.ToString(\"x8\")); } }; The library includes a message receive event but it is only for notifications and it does not include the message. int messageCount = 0; canController.MessageReceived += (a) => { messageCount++; Console.WriteLine(\"Receving message: \" + messageCount); }; Receiving messages can be handled in a loop. while (true) { if (canController.MessagesToRead > 0) { var msgRead = canController.Read(); if (msgRead != null) { Console.WriteLine(\"ID: \" + msgRead.ArbitrationId.ToString(\"x8\")); Console.WriteLine(\"Ext: \" + msgRead.ExtendedFrameFormat); Console.WriteLine(\"Remote: \" + msgRead.RemoteTransmissionRequest); } } Thread.Sleep(2); } Filter CAN messages can overwhelm the system with traffic. Filters can be used so only desired messages are received. It is a good practice to set the filters before enabling the system. The first argument of the filter is the ArbID we are looking for. The second argument is the mask of what bits we are interested in. A 0x03 for mask means we are only interested in checking the low 2 bits. The last argument is to invert the entire filter from a messages to receive to a filter to receive everything except what is in the filter. canController.EnableFilter(new uint[] { 0x123 }, new uint[] { 0x000007FF }, true);"
  },
  "endpoint/tutorials/databases.html": {
    "href": "endpoint/tutorials/databases.html",
    "title": "Databases",
    "keywords": "Databases SQLite Database According to the SQLite homepage, \"SQLite is a software library that implements a self-contained, server-less, zero-configuration, transactional SQL database engine. SQLite is the most widely deployed SQL database engine in the world.\" SQLite lets you set up a database that resides entirely in a single file on a persistent storage device. Tip Needed NuGet: Microsoft.Data.Sqlite The code below is a simple example that creates an SQLite database file. using Microsoft.Data.Sqlite; var id = 1; var dataFile = \"sqltest.db\"; //Create a new database file using (var connection = new SqliteConnection($\"Data Source={dataFile}\")){ connection.Open(); var command = connection.CreateCommand(); //Create a new table command.CommandText = \"CREATE TABLE IF NOT EXISTS user (id INTEGER PRIMARY KEY, name TEXT)\"; command.ExecuteNonQuery(); //Insert a new row command.CommandText = \"INSERT INTO user (name) VALUES ('World 1')\"; command.ExecuteNonQuery(); //query the database command.CommandText = @\"SELECT name FROM user WHERE id = $id\"; command.Parameters.AddWithValue(\"$id\", id); //print the result using (var reader = command.ExecuteReader()){ while (reader.Read()){ var name = reader.GetString(0); Console.WriteLine($\"Hello, {name}!\"); } } } //delete the data file when done FileInfo dbFile = new FileInfo(dataFile); try{ if (dbFile.Exists){ dbFile.Delete(); } } catch(Exception ex){ Console.WriteLine(\"Unable to delete the data file\"+ex.Message); } More Info Further details on SQLite can be found at the official SQLite website http://www.sqlite.org/ LiteDB Database Often applications need a way to store unstructured or semi-structured data. Using a NonSQL database could be a solution. Tip Needed NuGet: LiteDB The code below is a simple example that creates an LiteDB database file. LiteDB offers several features that makes it useful for an embedded device. using LiteDB; var dataFile = \"SensorData.db\"; // Open database (or create if doesn't exist) using (var db = new LiteDatabase(dataFile)){ // Get a collection (or create, if doesn't exist) var col = db.GetCollection<Sensor>(\"sensors\"); // Create a new sensor instance var sensor = new Sensor { Name = \"MEMS12\", ConfigValues = new string[] { \"0x00\", \"0xAA\" }, IsActive = true }; // Insert new sensor document (Id will be auto-incremented) col.Insert(sensor); // Update a document inside a collection sensor.Name = \"MEMS13\"; col.Update(sensor); // Index document using document Name property col.EnsureIndex(x => x.Name); // Use LINQ to query documents (filter, sort, transform) var results = col.Query() .Where(x => x.Name.StartsWith(\"M\")) .OrderBy(x => x.Name) .Select(x => new { x.Name, NameUpper = x.Name.ToUpper() }) .Limit(10) .ToList(); foreach(var memsSensor in results){ Console.WriteLine(memsSensor.Name); } // Create an index on the ConfigValues property col.EnsureIndex(x => x.ConfigValues); // Query by config value var r = col.FindOne(x => x.ConfigValues.Contains(\"0xAA\")); Console.WriteLine(r.Name); } //delete the data file when done FileInfo dbFile = new FileInfo(dataFile); try{ if (dbFile.Exists){ dbFile.Delete(); } } catch(Exception ex){ Console.WriteLine(\"Unable to delete the data file\"+ex.Message); } //Define Sensor class public class Sensor{ public int Id { get; set; } public required string Name { get; set; } public required string[] ConfigValues { get; set; } public bool IsActive { get; set; } } More Info Further details on SQLite can be found at the official SQLite website http://www.litedb.org/"
  },
  "endpoint/tutorials/displays.html": {
    "href": "endpoint/tutorials/displays.html",
    "title": "Displays",
    "keywords": "Displays Graphical Displays can be grouped into two distinct interface categories, built-in parallel TFT displays and virtual displays, typically serial (SPI/I2C) displays. The display drivers are meant to transfer the pixel data from memory to the actual display. The graphics tutorial shows how drawing is done in memory. Native Displays These displays connect to special dedicated pins on the processor. Internally, the display controller automatically transfers (refreshes) the display directly from memory without any processor interaction, using DMA. When the system needs to update the display, it simply writes to memory. Neither the operating system nor the application program are burdened with display processing. The down side to this is that the system needs to have enough RAM to handle the display. An 800x600 display with 16bpp needs 960,000 bytes! A display must be configured inside the .NET project. To do this create a .NET project with configuration code based on the type of display being used. In the example below an ERTFT043 display and Endpoint Domino are used. Tip Needed NuGets: GHIElectronics.Endpoint.Core, GHIElectronics.Endpoint.Devices.Display using System.Device.Gpio; using System.Device.Gpio.Drivers; using SkiaSharp; using GHIElectronics.Endpoint.Core; using GHIElectronics.Endpoint.Devices.Display; //Initialize Display var backlightPort = EPM815.Gpio.Pin.PD14 / 16; var backlightPin = EPM815.Gpio.Pin.PD14 % 16; var backlightDriver = new LibGpiodDriver((int)backlightPort); var backlightController = new GpioController(PinNumberingScheme.Logical, backlightDriver); backlightController.OpenPin(backlightPin); backlightController.SetPinMode(backlightPin, PinMode.Output); backlightController.Write(backlightPin, PinValue.High); var screenWidth = 480; var screenHeight = 272; var configuration = new FBDisplay.Configuration(){ Clock = 10000, Width = 480, Hsync_start = 480 + 2, Hsync_end = 480 + 2 + 41, Htotal = 480 + 2 + 41 + 2, Height = 272, Vsync_start = 272 + 2, Vsync_end = 272 + 2 + 10, Vtotal = 272 + 2 + 10 + 2, }; var fbDisplay = new FBDisplay(configuration); var displayController = new DisplayController(fbDisplay); //SkiaSharp Initialization SKBitmap bitmap = new SKBitmap(screenWidth, screenHeight, SKImageInfo.PlatformColorType, SKAlphaType.Premul); bitmap.Erase(SKColors.Transparent); // Setup the Canvas using (var screen = new SKCanvas(bitmap)){ /////////////////////////////////////////// // Place SkiaSharp Graphics content here // /////////////////////////////////////////// // Flush to screen var data = bitmap.Copy(SKColorType.Rgb565).Bytes; displayController.Flush(data); Thread.Sleep(1); } Virtual Displays The internal graphics services can be mapped to work with virtual display displays, such as SPI displays. See the Graphics tutorial for more information and sample code. Character Displays These displays are capable of only showing characters. They are available in different sizes, but two lines of 16 characters is most common. These displays types use the standard .NET Iot.Device.CharacterLcd library"
  },
  "endpoint/tutorials/file-system.html": {
    "href": "endpoint/tutorials/file-system.html",
    "title": "File System",
    "keywords": "File System .NET includes everything needed to access files and directories. Developers will only need to mount the device. Endpoint support USB mass storage, SD cards and on-board eMMC (if available). Boot Media Endpoint can boot from eMMC or SD cards. This media device is automatically mounted and used as the destination for deployed applications. There are multiple partitions found on boot devices. The recommended partition is \\.epdata\\. This partition is used to hold the deployed application. Note that Erase Application option in Endpoint Config tool will format this partition. USB Mass Storage This allows file access on USB devices with MSC class, such as USB memory sticks. See the USB page. SD Card The Endpoint system supports 2 SD interfaces. Note that if a device boots from SD then that boot SD is treated differently, as explained above. using GHIElectronics.Endpoint.Devices.Mmc; //... var sdcard = new SdmmcController(SdmmcType.SdCard2); sdcard.OnConnectionChangedEvent += Sdcard_OnConnectionChangedEvent; sdcard.Enable(); void Sdcard_OnConnectionChangedEvent(SdmmcController sender, DeviceConnectionEventArgs e) { Console.WriteLine(\"Detect SDCard connection changed on\" + e.DeviceName + \", status: \" + e.DeviceStatus + \", id = \" + e.DeviceId); }"
  },
  "endpoint/tutorials/gpio.html": {
    "href": "endpoint/tutorials/gpio.html",
    "title": "General Purpose Input Output (GPIO)",
    "keywords": "General Purpose Input Output (GPIO) Microcontrollers include pins that can be controlled through software. They can be logical inputs or outputs, hence the name \"general purpose input/output\". Tip GPIO is found in the System.Device.Gpio and System.Device.Gpio.Drivers of the standard .NET API. These libraries are automatically imported when installing NuGet package GHIElectronics.Endpoint.Core Digital Outputs A digital output pin can be set to either high or low. High means that there is approx. 3.3V on the output pin. When the pin is set to low, it's voltage will be very close to zero. Warning Never connect two output pins together. If they are connected and one is high and the other is low, the entire processor can be damaged. Tip Digital pins on microcontrollers are weak. They can only be used to control small LEDs or drive transistors. Those transistors can, in turn, control devices with high power needs like a motor. using System.Device.Gpio; using System.Device.Gpio.Drivers; using GHIElectronics.Endpoint.Core; var port = EPM815.Gpio.Pin.PC0 / 16; var pin = EPM815.Gpio.Pin.PC0 % 16; var gpioDriver = new LibGpiodDriver((int)port); var gpioController = new GpioController(PinNumberingScheme. Logical, gpioDriver); gpioController.OpenPin(pin); gpioController.SetPinMode(pin, PinMode.Output); while (true){ gpioController.Write(pin, PinValue.High); Thread.Sleep(100); gpioController.Write(pin, PinValue.Low); Thread.Sleep(100); } Digital Inputs Digital inputs sense the state of a pin based on its voltage. Minimum voltage on most pins is 0 volts; a negative voltage may damage the pin or the processor. Most processors run on 3.3V, the highest voltage a pin should see is 3.3V. However, some processors that are powered by 3.3V are 5V tolerant -- they can withstand up to 5V on their inputs. SITCore is 5V tolerant. Warning 5V tolerant doesn't mean the processor can be powered by 5V, only that the input pins can tolerate 5V. Unconnected input pins are called \"floating.\" A resistor can be added to pull the pin high or low. Modern processors include internal pull-up and pull-down resistors that are controlled by software. The code sample below uses an internal pull-up resistor to set the button high. When the button is pressed the GpioPinValue goes low. using System.Device.Gpio; using System.Device.Gpio.Drivers; using GHIElectronics.Endpoint.Core; var buttonPort = EPM815.Gpio.Pin.PF3 / 16; var buttonPin = EPM815.Gpio.Pin.PF3 % 16; var buttonDriver = new LibGpiodDriver((int)buttonPort); var button = new GpioController(PinNumberingScheme.Logical, buttonDriver); button.OpenPin(buttonPin, PinMode.InputPullUp); while (true){ if (button.Read(buttonPin) == PinValue.Low) { Console.WriteLine(\"Button is pressed\"); } Thread.Sleep(10); } Digital Input Events Using events to check an input instead of polling the input (using a loop) is often preferred. The following code demonstrates a GPIO pin event (interrupt) using the F1 user button on Endpoint Domino You will see a reference to a PinEventTypes.Falling in the following code. A falling occurs when the state of a pin goes from high to low. A rising is just the opposite -- it occurs when a pin goes from low to high. using System.Device.Gpio; using System.Device.Gpio.Drivers; using GHIElectronics.Endpoint.Core; var buttonPort = EPM815.Gpio.Pin.PF3 / 16; var buttonPin = EPM815.Gpio.Pin.PF3 % 16; var buttonDriver = new LibGpiodDriver((int)buttonPort); var button = new GpioController(PinNumberingScheme.Logical, buttonDriver); button.OpenPin(buttonPin, PinMode.InputPullUp); button.RegisterCallbackForPinValueChangedEvent( buttonPin, PinEventTypes.Falling | PinEventTypes.Rising, OnPinEvent); //Do other tasks here await Task.Delay(Timeout.Infinite); static void OnPinEvent(object sender, PinValueChangedEventArgs args){ Console.WriteLine(\"Button Pressed\"); } When a mechanical button is pressed it generates multiple edges that are caused by the contact physically bouncing. If debounce is an issue use the GpioButton Class. Endpoint Interrupt limitation Digital input events rely on internal GPIO interrupts to work. On Endpoint, these interrupts are only available on 16 pins at any given time, the pin number must be unique, over all of the available ports. For example: PA1 and PB1 cannot both be used as interrupts at the same time. However, PA1 and PB2, or even PA1 and PA2, can be used simultaneously."
  },
  "endpoint/tutorials/graphics.html": {
    "href": "endpoint/tutorials/graphics.html",
    "title": "Graphics",
    "keywords": "Graphics The GHIElectronics.Endpoint.Devices.Display NuGet package includes the backbone for all graphics needs. It uses the SkiaSharp Graphics library, their API can be found here. Once a display has been initialized and configured it is ready to start adding graphics using SkiaSharp. SkiaSharp elements are added to the SKCanvas then flushed to the screen. SkiaSharp Canvas The follow code initialize the SkiaSharp canvas, inside Canvas is where the SkiaSharp content is placed. SKBitmap bitmap = new SKBitmap(screenWidth, screenHeight, SKImageInfo.PlatformColorType, SKAlphaType.Premul); bitmap.Erase(SKColors.Transparent); // Initialize the SkiaSharp Canvas using (var screen = new SKCanvas(bitmap)){ /////////////////////////////////////////// // Place SkiaSharp Graphics content here // /////////////////////////////////////////// // Flush to screen var data = bitmap.Copy(SKColorType.Rgb565).Bytes; displayController.Flush(data); Thread.Sleep(1); } Note SkiaSharp elements are displayed in hierarchical order with each item being stacked on top of the previous item. Drawing Text The example below displays text on the screen using SkiaSharp built in SKFont There a several different attributes that can be set using the SkiaSharp API. // Draw text using (SKPaint text = new SKPaint()){ text.Color = SKColors.Blue; //Uses built-in color value //text.Color = SKColor.Parse(\"#FF0977aa\"); //Uses Hex value string for Color text.IsAntialias = true; text.StrokeWidth = 2; text.Style = SKPaintStyle.Fill; text.TextSize = 12; SKFont sKFont = new SKFont(); sKFont.Size = 22; SKTextBlob textBlob = SKTextBlob.Create(\"Hello Endpoint\", sKFont); screen.DrawText(textBlob, 50, 120, text); } Using TrueType Fonts Any TrueType font can be used, it just needs to be added as a resource. To add a font change the extension from .tft to .bin. This will save the font in resources as a byte array, the format SkiaSharp needs to display. byte[] fontfile = Resources.ArialBlack; Stream stream = new MemoryStream(fontfile); using (SKPaint text = new SKPaint()) using (SKTypeface tf = SKTypeface.FromStream(stream)){ text.Color = SKColors.Red; text.IsAntialias = true; text.StrokeWidth = 2; text.Style = SKPaintStyle.Fill; SKFont font = new SKFont(); font.Size = 90; font.Typeface = tf; SKTextBlob textBlob = SKTextBlob.Create(\"Hello Endpoint\", font); screen.DrawText(textBlob, 160, 155, text); } Drawing Draw Lines When drawing lines many variables are available from color, thickness, stoke, end cap effects, to shading. float[] intervals = [10, 20, 10, 20, 5, 40,];//sets the dash intervals using (SKPaint line = new SKPaint()){ line.Color = SKColors.Red; line.IsAntialias = true; line.StrokeWidth = 20; line.Style = SKPaintStyle.Stroke; //Rounds the ends of the line line.StrokeCap = SKStrokeCap.Round; //Creates dashes in line based on intervals array line.PathEffect = SKPathEffect.CreateDash(intervals, 25); // Create linear gradient from upper-left to lower-right line.Shader = SKShader.CreateLinearGradient( new SKPoint(0, 0), new SKPoint(screenWidth, screenHeight), new SKColor[] { SKColors.Red, SKColors.Blue }, new float[] { 0, 1 }, SKShaderTileMode.Repeat); screen.DrawLine(0, 0, 400, 200, line); } Drawing Images The example below displays an image on the screen using resources. Tip Images need to be converted and saved as .bin files to generate a byte array // Draw image from resource var img = logo; var info = new SKImageInfo(300, 200); var sk_img = SKBitmap.Decode(img, info); screen.DrawBitmap(sk_img, 0, 0);"
  },
  "endpoint/tutorials/i2c.html": {
    "href": "endpoint/tutorials/i2c.html",
    "title": "I2C",
    "keywords": "I2C I2C (pronounced eye-squared-sea, or eye-two-sea) was originally developed by Phillips as a protocol for synchronous serial communication between integrated circuits. It has a master and one or more slaves sharing the same data bus. Instead of selecting the slaves by using a dedicated chip select signal like SPI, I2C uses an addressing mechanism to communicate with the selected device. This addressing method saves one I/O pin per slave. Before data is transferred, the master transmits the 7-bit address of the slave device it wants to communicate with. It also sends one bit indicating whether it wants to send data to the slave or receive data from the slave. When a slave sees its address on the bus, it will acknowledge its presence. At this point, the master can send or receive data. The master will start data transfers with a \"start condition\" before sending an address or data. The master ends the data transfer with a \"stop condition.\" The two wires for I2C communication are called the SDA and SCL lines. SDA stands for Serial Data, and SCL is Serial Clock. Endpoint uses the standard .NET API for I2C (System.Device.I2c) but first we need to Initialize the pin for I2C. EPM815.I2c.Intialize(EPM815.I2c.I2c6); This method also allows the user to set clock speed, which 400KHz by default. EPM815.I2c.Intialize(EPM815.I2c.I2c6,100_000); I2C is a standard .NET IoT feature. This is a partial demo showing the use of I2C. EPM815.I2c.Intialize(EPM815.I2c.I2c6); var i2cConnectionSetting = new I2cConnectionSettings(EPM815.I2c.I2c6, 0x1C); var i2cDev = I2cDevice.Create(i2cConnectionSetting); WriteToRegister(0x2A, 1); i2cDev.Write(new byte[] { 1, 2 }); //Write something i2cDev.WriteRead(...); //This is good for reading register"
  },
  "endpoint/tutorials/in-field-update.html": {
    "href": "endpoint/tutorials/in-field-update.html",
    "title": "In-Field Update",
    "keywords": "In-Field Update It is possible to update the internal flash from an image found on SD or USB memory. This allows a device to be updated in-field. var usbhost = new UsbHostController(); usbhost.OnConnectionChangedEvent += UsbThumbDriveConnected; usbhost.Enable(); var cnt = 0; while (UsbMountPath == string.Empty) { Console.WriteLine($\"Wait for source files {cnt++}\"); Thread.Sleep(1000); } var update = new UpdateController(UpdateController.Mode.ProgrameMMC, EPM815.Gpio.Pin.PF0, UsbMountPath); var result = update.Update(); Console.WriteLine(\"Result update: \" + result); string UsbMountPath = string.Empty; void UsbThumbDriveConnected(UsbHostController sender, DeviceConnectionEventArgs e) { Console.WriteLine(\"Detect changed Id: \" + e.DeviceId + \", name: \" + e.DeviceName + \", status:\" + e.DeviceStatus); if (e.Type == GHIElectronics.Endpoint.Devices.Usb.DeviceType.MassStorage && e.DeviceStatus == DeviceConnectionStatus.Connected) { UsbMountPath = GHIElectronics.Endpoint.FileSystem.Mount(e.DeviceName); Console.WriteLine(\"Mounted, path \" + UsbMountPath); } else if (e.Type == GHIElectronics.Endpoint.Devices.Usb.DeviceType.MassStorage) { GHIElectronics.Endpoint.FileSystem.Unmount(UsbMountPath); Console.WriteLine(\"Umounted\"); } }"
  },
  "endpoint/tutorials/intro.html": {
    "href": "endpoint/tutorials/intro.html",
    "title": "Endpoint Tutorials",
    "keywords": "Endpoint Tutorials This section contains Endpoint tutorials, mostly about hardware topics not covered in standard .NET docs. Use the sub menu on the left to navigate the long list of available tutorials."
  },
  "endpoint/tutorials/mjpeg-video.html": {
    "href": "endpoint/tutorials/mjpeg-video.html",
    "title": "MJPEG Video",
    "keywords": "MJPEG Video The MJPEG video format is simply a chain of JPG images that are stored in a single file. Since JPEG is already supported, a developer can present the individual JPEG files. This is an example of how it is done on SITCore (TinyCLR)."
  },
  "endpoint/tutorials/networking.html": {
    "href": "endpoint/tutorials/networking.html",
    "title": "Networking",
    "keywords": "Networking Thanks to .NET, Endpoint provides full networking support. It includes everything from a simple socket handling to full cloud support. Configuration Wi-Fi The network needs to be configured properly before it can be used. For example, Wi-Fi needs SSID and password. Wi-Fi is supported through USB Wi-Fi dongles containing the RTL8188 chipset. using GHIElectronics.Endpoint.Devices.Network; //... var networkType = NetworkInterfaceType.WiFi; var networkSetting = new WiFiNetworkInterfaceSettings { Ssid = \"Endpoint\", Password = \"xxxxxxx\", DhcpEnable = true, }; var network = new NetworkController(networkType, networkSetting); network.NetworkLinkConnectedChanged += (a, b) => { if (b.Connected) { Console.WriteLine(\"Connected\"); } else { Console.WriteLine(\"Disconnected\"); } }; network.NetworkAddressChanged += (a, b) => { Console.WriteLine(string.Format(\"Address: {0}\\n gateway: {1}\\n DNS: {2}\\n MAC: {3} \", b.Address, b.Gateway, b.Dns[0], b.MACAddress)); }; network.Enable(); USB Ethernet var networkType = NetworkInterfaceType.UsbEthernet; var networkSetting = new NetworkInterfaceSettings { Address = new IPAddress(new byte[] { xx, xx, xx, xx }), SubnetMask = new IPAddress(new byte[] { 255, 255, 255, 0 }), GatewayAddress = new IPAddress(new byte[] { xx, xx, xx, xx }), DnsAddresses = new IPAddress[] { new IPAddress(new byte[] { 75, 75, 75, 75 }) }, DhcpEnable = false, }; var network = new NetworkController(networkType, networkSetting); network.NetworkLinkConnectedChanged += (a, b) => { if (b.Connected) { Console.WriteLine(\"Connected\"); } else { Console.WriteLine(\"Disconnected\"); } }; network.NetworkAddressChanged += (a, b) => { Console.WriteLine(string.Format(\"Address: {0}\\n gateway: {1}\\n DNS: {2}\\n MAC: {3} \", b.Address, b.Gateway, b.Dns[0], b.MACAddress)); }; network.Enable(); MQTT MQTT, and other common protocols, are supported through one of the many available NuGet packages. DotNetty.Codecs.Mqtt is the one of the common ones for example."
  },
  "endpoint/tutorials/power-management.html": {
    "href": "endpoint/tutorials/power-management.html",
    "title": "Power Management",
    "keywords": "Power Management There are multiple ways to put a system in different power modes to save on power consumption. Endpoint currently only support complete shutdown. Both Real Time Clock and one of the wakeup pins can be used to wakeup the system from shutdown. using GHIElectronics.Endpoint.Native; using GHIElectronics.Endpoint.Devices.Rtc; var rtc = new RtcController(); var dt = DateTime.Now; rtc.Now = dt; Console.WriteLine(\"rtc = \" + rtc.Now); Console.WriteLine(\"system = \" + DateTime.Now); Power.EnableWakeup(DateTime.Now.AddSeconds(30), WakeupPin.PA0); Console.WriteLine(\"Wakeup = \" + DateTime.Now.AddSeconds(30).ToString()); Power.Shutdown(); Tip Shutdown is brings the system down completely. Any unsaved files will be lost."
  },
  "endpoint/tutorials/pwm.html": {
    "href": "endpoint/tutorials/pwm.html",
    "title": "PWM",
    "keywords": "PWM Pulse Width Modulation (PWM) is a very useful feature found on most microcontrollers. PWM is a method of generating a square wave signal of uniform frequency with variable duty cycle. PWM is often used to generate (simulate) analog voltages, generate sounds, and driving servo motors. The ratio of the pulse width to it's period is called the duty cycle. Through software, you can control both the PWM frequency and duty cycle. using System.Device.Pwm; using GHIElectronics.Endpoint.Core; EPM815.Pwm.Initialize(EPM815.Pwm.Pin.PF9); PwmChannel pwm = PwmChannel.Create(EPM815.Pwm.GetChipId(EPM815.Pwm.Pin.PF9), EPM815.Pwm.GetChannelId(EPM815.Pwm.Pin.PF9)); pwm.DutyCycle = 0.25; pwm.Frequency = 1000; pwm.Start(); Thread.Sleep(1000); pwm.Stop(); Timers PWM channels (pins) are grouped in specific timers. This means changing the frequency on a specific channel (pin) will cause the frequency to change on other channels that are found on the same timer. In .NET, these timers are referred to Chip ID. Endpoint method GetChipId is used to obtain the timer used on a specific pin. Similarly, GetChannel returns the channel number. This table will help in planning the usage of timers Pin Timer Channel PA8 TIM1 CH1 PE11 TIM1 CH2 PA10 TIM1 CH3 PA11 TIM1 CH4 PA15 TIM2 CH1 PB3 TIM2 CH2 PA3 TIM2 CH4 PC6 TIM3 CH1 PB5 TIM3 CH2 PB0 TIM3 CH3 PD12 TIM4 CH1 PB7 TIM4 CH2 PD14 TIM4 CH3 PD15 TIM4 CH4 PA0 TIM5 CH1 PH11 TIM5 CH2 PH12 TIM5 CH3 PI0 TIM5 CH4 PI5 TIM8 CH1 PI6 TIM8 CH2 PI7 TIM8 CH3 PI2 TIM8 CH4 PH6 TIM12 CH1 PH9 TIM12 CH2 PA6 TIM13 CH1 PF9 TIM14 CH1 PE5 TIM15 CH1 PE6 TIM15 CH2 PB8 TIM16 CH1 PB9 TIM17 CH1"
  },
  "endpoint/tutorials/real-time-clock.html": {
    "href": "endpoint/tutorials/real-time-clock.html",
    "title": "Real Time Clock",
    "keywords": "Real Time Clock The Real Time Clock (RTC) is a circuit that runs off a small battery or a super capacitor connected to VBAT. It needs its own crystal and keeps running even when the main system and its clocks are powered off. var rtc = new RtcController(); var time = new DateTime(2024, 1, 1, 10, 59, 50); rtc.Now = time; // Read some time later var rtc_time = rtc.Now; VBAT VBAT mode can be set in \"charger mode\" where it can charge an attached supercap. Important Make sure the RTC battery charge mode is correctly set. Charging a lithium coin cell may cause damage to the cell and could cause it to leak. var rtc = new RtcController(); rtc.EnableChargeMode(BatteryChargeMode.Fast); System Clock You can get the current system time using DateTime.Now. After boot, if valid rtc detected, system clock will be updated by rtc. To set system time if rtc is not used, use SetSystemTime. var rtc = new RtcController(); rtc.SetSystemTime(new DateTime(2024, 1, 30, 15, 00, 00));"
  },
  "endpoint/tutorials/signal-control.html": {
    "href": "endpoint/tutorials/signal-control.html",
    "title": "Signal Control",
    "keywords": "Signal Control DigitalSignal The DigitalSignal is used to handle digital signals! Unlike the other features on this page, DigitalSignal is accurate because it is hardware-backed and runs in a non-blocking manner. Being hardware backed, this feature only runs on two specific pins: EPM815.Gpio.Pin.PH10 (Timer5) and EPM815.Gpio.Pin.PA5 (Timer2) Tip Timers are also used with other features, such as PWM. Once a Timer is reserved for DigitalSignal, it is no longer available for other features. There are two uses for DigitalSignal, reading a signal (capture) and sending a signal (generate). The capture feature also support capturing a stream of durations (signal analyzer) or a pulse counter. Generate Using the Generate function allows the user to create a very accurate signal generator. Generate(uint[] data, uint offset, int count) data is the length of each pulse in ticks There is a limitation to the data being used: The data array length is limited to 64K elements. Also, adding individual elements together in the array can also not exceed 0xFFFFFFFF in total. Generate(uint[] data, uint offset, int count, uint multiplier, Edge edge) Allowed multiplier values range from 5 to 318,000 (318us). The signal generator start with a signal at edge level. It then toggles the signal every x time. The time is fetched from the array given, one by one. Note that by sending an even count of pulses, the signal will terminate with a !edge level as shown below. Starting a second write will cause the signal to first go low, which may not be desired, as it causes an extra pulse on the next Generate. This pulse has a variable width. Making sure that the data Length is always an odd number will assure that the signal will terminate at a low-level. Calling Generate will return immediately (non-blocking) allowing the system to do other tasks while the signal is being generated in the background. When the signal is generated completely, an event is fired. To aid in signal handling, the event provides the final resting level of the signal. OnGenerateFinished => OnGenerateFinished; dsig.OnGenerateFinished += (a, b, c) => { if (b == GpioPinValue.High) Console.WriteLine(\"Write done, end state high\"); else Console.WriteLine(\"Write done, end state low\"); }; Capture The Capture feature returns an array of timestamps of individual durations. The returned values are in nanoseconds. Tip Digital Signal is limited to the timer max value, which comes to be about 17.89 seconds. The waitForEdge helps by only starting the timer when there is an active pulse. var digitalSignal = new DigitalSignalController(EPM815.Gpio.Pin.PA5); bool waitForEdge = false;// Start capturing as soon as Capture is called // Subscribe event when done capturing digitalSignal.CaptureFinished += DigitalSignal_OnCaptureFinished; // Subscribe error digitalSignal.ErrorReceived += (a,b) => { Console.WriteLine(\"Error detected: \" + error.ToString()); }; // start capture 100 samples, timeout is 15seconds digitalSignal.Capture(100, EPM815.Gpio.Edge.Rising | EPM815.Gpio.Edge.Falling, waitForEdge, TimeSpan.FromSeconds(15)); // Wait for finish capture // do other work Thread.Sleep(Timeout.Infinite); // The event private static void Digital_OnCaptureFinished(DigitalSignal sender, double[] buffer, uint count, uint initialState, bool aborted) { if (count == 0) { Console.WriteLine(\"no data was captured!\"); return; } for (int i = 0; i < count; i++) { Console.WriteLine(\"Sample [\" + i +\"]: \"+ buffer[i]+\" ns\"); } } Note The first captured pulse will likely have an inaccurate (shorter) value due to system prep-time. ReadPulse ReadPulse can be used to measure frequency and other analyses that require measuring time duration for specific pulse count. var digitalSignal = new DigitalSignalController(EPM815.Gpio.Pin.PH10); bool waitForEdge = true;// wait for first pulse before starting the measurement // Subscribe event when done reading digitalSignal.OnReadPulseFinished += DigitalSignal_ReadPulseFinished; // Subscribe error digitalSignal.ErrorReceived += (a,b) => { Console.WriteLine(\"Error detected: \" + error.ToString()); }; // Start reading 1000 pulses digitalSignal.ReadPulse(1000, EPM815.Gpio.Edge.Rising, waitForEdge); // do other work... Thread.Sleep(Timeout.Infinite); // the event void Digital_OnReadPulseFinished(DigitalSignal sender, TimeSpan duration, uint count, uint pinValue, bool aborted) { var ticks = duration.Ticks; var microsecond = ((double)duration.Ticks) / 10; var millisecond = ((double)duration.Ticks) / 10000; var freq = (count / microsecond) * 1000000; Console.WriteLine(\"GpioPinValue = \" + ((pinValue == 1) ? \"High\" : \"Low\")); Console.WriteLine(\"PulseCount = \" + count); Console.WriteLine(\"Duration ticks = \" + ticks); Console.WriteLine(\"Duration microsecond = \" + microsecond); Console.WriteLine(\"Duration millisecond = \" + millisecond); Console.WriteLine(\"freq = \" + freq / 1000.0 + \" KHz\"); } Abort An event is fired when any DigitalSignal operation is completed. In some cases, it may be desired to terminate the operation early, using Abort. When aborted, an event is still triggered, which will contain whatever data/pulses was collected from the trigger to the time Abort was called. var digitalSignal = new DigitalSignal(EPM815.Gpio.Pin.PH10); var waitForEdge = false; digitalSignal.OnReadPulseFinished += Digital_OnReadPulseFinished while (true) { if (digitalSignal.CanReadPulse) { digitalSignal.ReadPulse(1000, EPM815.Gpio.Edge.Rising, waitForEdge); Thread.Sleep(1000); digitalSignal.Abort(); Console.WriteLine(\"Aborted\"); } } void Digital_OnReadPulseFinished(DigitalSignal sender, TimeSpan duration, uint count, uint pinValue, bool aborted) { if (count > 0) { var microsecond = ((double)duration.Ticks) / 10; var freq = (count / microsecond) * 1000000; Console.WriteLine(\"freq = \" + freq / 1000.0 + \" KHz\"); } else { Console.WriteLine(\"No clock found.\"); } } Tip In the sample code above you can use PWM to provide the pulse needed to verify the code. Keep in mind that both PWM and DigitalSignal share resources, so a different Timer controller must be used."
  },
  "endpoint/tutorials/spi.html": {
    "href": "endpoint/tutorials/spi.html",
    "title": "SPI",
    "keywords": "SPI SPI uses three or four wires for transferring data. A SPI bus consists of a single master and one or more slaves. The master will send the clock signal to the slaves over the SCK (Serial Clock) pin. It will also send data over MOSI (Master Out Slave In) pin, while reading incoming data on the MISO (Master In Slave Out) pin. The SCK line is used to determine how fast the data is moved. If you know electronics, this is simply a shift register. The master selects which slave it will swap the data with using the SSEL (Slave SeLect) pin, sometimes called CS (Chip Select). In its simplest terms, the master will swap data between itself and the slave. You cannot write data without reading data at the same time. However, often you want to write data and don't care about the incoming data. To do this you can use the Write method. Keep in mind that the Write method is discarding whatever data the slave is sending back. Tip Note that an Endpoint device is always the SPI master, not the slave. Tip Some SPI devices (slaves) can have more than one select pin, like the VS1053 MP3 decoder chip that uses one select pin for data and the other for commands. Both share the three data transfer pins (SCK, MOSI, MISO). First, the desired appropriate pins needs to be set to use the SPI function EPM815.Spi.Initialize(EPM815.Spi.Spi4); and then SPI is a standard .NET IoT feature. // Map pins to use SPI EPM815.Spi.Initialize(EPM815.Spi.Spi4); // Get settings ready var setting = new SpiConnectionSettings(EPM815.Spi.Spi4) { ClockFrequency = 4_000_000, Mode = SpiMode.Mode0, ChipSelectLine = 0 }; // Create the SPI device var spiDev = SpiDevice.Create(setting); // read and write SPI var writebuff = new byte[2]; var readbuff = new byte[10]; spiDev.TransferFullDuplex(writebuff, readbuff);"
  },
  "endpoint/tutorials/touch-screen.html": {
    "href": "endpoint/tutorials/touch-screen.html",
    "title": "Touch Screen",
    "keywords": "Touch Screen Introduction Displays may optionally include a touch sensitive screen to detect user touch input. Endpoint supports capacitive touch. Capacitive Touch Capacitive touch screens are used on most modern devices, including phones. They are very accurate and capable of detecting multiple simultaneous touches. A special capacitive controller chip must be used to read the touch panel. This chip is usually mounted right on the flat cable going to the touch panel. These chips are usually I2C or SPI, with I2C being more common. The capacitive displays used in our development options use a touch controller from FocalTech. We provide the GHIElectronics.Endpoint.Drivers.FocalTech.FT5xx6 NuGet package to interact with capacitive touch screens. The constructor simply needs to know which I2C bus and reset pin are being used. The event fires giving the exact position using display pixels as units -- there is no need for scaling or calibration. The driver source code is found on the Endpoint Drivers repo. This simple example will draw the touch x and y coordinates on the screen. using System.Device.Gpio; using System.Device.Gpio.Drivers; using SkiaSharp; using GHIElectronics.Endpoint.Core; using GHIElectronics.Endpoint.Devices.Display; using GHIElectronics.Endpoint.Drivers.FocalTech.FT5xx6; //Initialize Screen var screenWidth = 480; var screenHeight = 272; var backlightPort = EPM815.Gpio.Pin.PD14 / 16; var backlightPin = EPM815.Gpio.Pin.PD14 % 16; var backlightDriver = new LibGpiodDriver((int)backlightPort); var backlightController = new GpioController(PinNumberingScheme.Logical, backlightDriver); backlightController.OpenPin(backlightPin); backlightController.SetPinMode(backlightPin, PinMode.Output); backlightController.Write(backlightPin, PinValue.High); var configuration = new FBDisplay.ParallelConfiguration(){ Clock = 10000, Width = 480, Hsync_start = 480 + 2, Hsync_end = 480 + 2 + 41, Htotal = 480 + 2 + 41 + 2, Height = 272, Vsync_start = 272 + 2, Vsync_end = 272 + 2 + 10, Vtotal = 272 + 2 + 10 + 2, }; var fbDisplay = new FBDisplay(configuration); var displayController = new DisplayController(fbDisplay); //Initialize Touch var touchX = 0; var touchY = 0; var TouchResetPin = EPM815.Gpio.Pin.PF2 % 16; var TouchResetPort = EPM815.Gpio.Pin.PF2 / 16; var TouchController = new GpioController(PinNumberingScheme.Logical, new LibGpiodDriver(TouchResetPort)); TouchController.OpenPin(TouchResetPin); TouchController.Write(TouchResetPin, PinValue.Low); Thread.Sleep(100); TouchController.Write(TouchResetPin, PinValue.High); EPM815.I2c.Initialize(EPM815.I2c.I2c5); var touch = new FT5xx6Controller(EPM815.I2c.I2c5, EPM815.Gpio.Pin.PB11); touch.TouchUp += Touch_TouchUp; //Initialize Graphics SKBitmap bitmap = new SKBitmap(screenWidth, screenHeight, SKImageInfo.PlatformColorType, SKAlphaType.Premul); bitmap.Erase(SKColors.Transparent); while (true){ using (var screen = new SKCanvas(bitmap)){ //Create Black Screen screen.DrawColor(SKColors.Black); screen.Clear(SKColors.Black); // Draw X using (SKPaint text = new SKPaint()){ text.Color = SKColors.White; text.IsAntialias = true; text.StrokeWidth = 2; text.Style = SKPaintStyle.Fill; SKFont sKFont = new SKFont(); sKFont.Size = 60; SKTextBlob textBlob = SKTextBlob.Create(\"Touch X =\" + touchX.ToString(), sKFont); screen.DrawText(textBlob, 60, 125, text); } // Draw Y using (SKPaint text = new SKPaint()){ text.Color = SKColors.White; text.IsAntialias = true; text.StrokeWidth = 2; text.Style = SKPaintStyle.Fill; SKFont sKFont = new SKFont(); sKFont.Size = 60; SKTextBlob textBlob = SKTextBlob.Create(\"Touch Y =\" + touchY.ToString(), sKFont); screen.DrawText(textBlob, 60, 175, text); } // Flush to screen var data = bitmap.Copy(SKColorType.Rgb565).Bytes; displayController.Flush(data); Thread.Sleep(1); } } void Touch_TouchUp(FT5xx6Controller sender, FT5xx6Controller.TouchEventArgs e){ touchX = e.X; touchY = e.Y; return; }"
  },
  "endpoint/tutorials/uart.html": {
    "href": "endpoint/tutorials/uart.html",
    "title": "UART",
    "keywords": "UART UART is supported through the standard SerialPort class in System.IO.Ports but first we need to Initialize the serial port. EPM815.SerialPort.Initialize(EPM815.SerialPort.Uart3); After initializing the port, create a buffer to read the data into and configure a new SerialPort and Open it. static byte[] buffer = new byte[64]; var serial = new SerialPort{ PortName = EPM815.SerialPort.Uart3, BaudRate = 9600, DataBits = 8, Parity = Parity.None, StopBits = StopBits.One, }; serial.Open(); Once configured, the device is ready to write & read the serial data. while(true){ //Check for data if(serial.BytesToRead > 0){ var data = serial.Read(buffer,0,serial.BytesToRead) Console.Writeline(Encoding.UTF8.GetString(buffer,0,data)); } Thread.Sleep(20); }"
  },
  "endpoint/tutorials/ui.html": {
    "href": "endpoint/tutorials/ui.html",
    "title": "User Interface",
    "keywords": "User Interface You can use the GHIElectronics.Endpoint.UI library to create user interfaces for your application. The UI library is inspired by Windows Presentation Foundation on the desktop. Application Management The UI library requires internal management that is handled by the application class. The following code provides a good starting point. Tip Needed NuGets: GHIElectronics.Endpoint.Drawing, GHIElectronics.Endpoint.UI using GHIElectronics.Endpoint.UI; namespace UserInterfaceExample { class Program : Application { public Program(int width, int height) : base(width, height) { } static void Main(string[] args) { // Initialize Display InitDisplay(); // Initialize Touch InitializeTouch(); var app = new Program(display); app.Run(Program.CreateWindow(display)); } private static Window CreateWindow(int width, int height) { var window = new Window { Height = height, Width = width }; window.Background = new LinearGradientBrush(Colors.Blue, Colors.Teal, 0, 0, window.Width, window.Height); //window.Background = null; return window; } static void InitDisplay() { var backlightPort = EPM815.Gpio.Pin.PD14 / 16; var backlightPin = EPM815.Gpio.Pin.PD14 % 16; var gpioDriver = new LibGpiodDriver(backlightPort); var gpioController = new GpioController(PinNumberingScheme.Logical, gpioDriver); gpioController.OpenPin(backlightPin, PinMode.Output); gpioController.Write(backlightPin, PinValue.High); // low is on var configuration = new FBDisplay.Configuration() { Clock = 10000, Width = 480, Hsync_start = 480 + 2, Hsync_end = 480 + 2 + 41, Htotal = 480 + 2 + 41 + 2, Height = 272, Vsync_start = 272 + 2, Vsync_end = 272 + 2 + 10, Vtotal = 272 + 2 + 10 + 2, }; var setting = $\"{configuration.Clock},\"; setting += $\"{configuration.Width},{configuration.Hsync_start},{configuration.Hsync_end},{configuration.Htotal},\"; setting += $\"{configuration.Height},{configuration.Vsync_start},{configuration.Vsync_end},{configuration.Vtotal},\"; setting += $\"{configuration.Num_modes},{configuration.Dpi_width},{configuration.Dpi_height},{configuration.Bus_flags},{configuration.Bus_format},{configuration.Connector_type},{configuration.Bpc}\"; Console.WriteLine(setting); var fbDisplay = new FBDisplay(configuration); displayController = new DisplayController(fbDisplay); } public static void InitializeTouch() { var resetPin = EPM815.Gpio.Pin.PF2 % 16; var resetPort = EPM815.Gpio.Pin.PF2 / 16; var gpioController = new GpioController(PinNumberingScheme.Logical, new LibGpiodDriver(resetPort)); gpioController.OpenPin(resetPin); gpioController.Write(resetPin, PinValue.Low); Thread.Sleep(100); gpioController.Write(resetPin, PinValue.High); // On dev //EPM815.I2c.Initialize(EPM815.I2c.I2c6); //var touch = new FT5xx6Controller(EPM815.I2c.I2c6, EPM815.Gpio.Pin.PF12); // On Domino EPM815.I2c.Initialize(EPM815.I2c.I2c5); var touch = new FT5xx6Controller(EPM815.I2c.I2c5, EPM815.Gpio.Pin.PB11); touch.TouchDown += (a, b) => { //Console.WriteLine(\"Touch down \" + b.X + \", \" + b.Y); Program.MainApp.InputProvider.RaiseTouch(b.X, b.Y, GHIElectronics.Endpoint.UI.Input.TouchMessages.Down, System.DateTime.Now); }; touch.TouchUp += (a, b) => { //Console.WriteLine(\"Touch up \" + b.X + \", \" + b.Y); Program.MainApp.InputProvider.RaiseTouch(b.X, b.Y, GHIElectronics.Endpoint.UI.Input.TouchMessages.Up, System.DateTime.Now); }; //Thread.Sleep(-1); } } } Windows While you can have multiple windows in your UI application, it is mandatory to have at least one window. Elements A window is not very useful without some elements (controls). There are many available standard elements, and you can make your own custom elements as well. All elements descend from the UIElement class. Explore the GHIElectronics.Endpoint.UI.Controls namespace to see what's available. For the sake of simplifying the rest of this tutorial, we've added the private static UIElement Elements() method that creates and returns the elements. This is then assigned to the child of our window. You will need to add window.Child = Elements() right before returning from CreateWindow. private static UIElement Elements() { var txt = new TextBox { Font = new Font(14), Text = \"Hello World!\", HorizontalAlignment = HorizontalAlignment.Center, VerticalAlignment = VerticalAlignment.Center }; return txt; } TextBox The TextBox allows for both single line and multiple line text input. var textBox = new TextBox() { Text = \"This is TextBox\", Font = new Font(14), Width = 120, Height = 25, HorizontalAlignment = HorizontalAlignment.Center, VerticalAlignment = VerticalAlignment.Center, }; Panel A Window can carry only a single Child, that is a single element. This is not a concern because the single element can be a container, like a Panel, which holds multiple elements. You can even have panels within panels with each having its own elements. This example will introduce shapes found in the GHIElectronics.Endpoint.UI.Shapes namespace. It also shows an example of the TextBox element. We will also set margins for a better look. private static UIElement Elements() { var panel = new Panel(); var txt1 = new TextBox() { HorizontalAlignment = HorizontalAlignment.Left, VerticalAlignment = VerticalAlignment.Top, }; txt1.Font = new Font(14); txt1.SetMargin(20); txt1.Text = \"Hello World!\"; var txt2 = new Text(new Font(14), \"Endpoint is Great!\") { ForeColor = Colors.White, HorizontalAlignment = HorizontalAlignment.Right, }; txt2.SetMargin(20); var rect = new Rectangle(200, 10) { Fill = new SolidColorBrush(Colors.Green), HorizontalAlignment = HorizontalAlignment.Center, }; panel.Children.Add(txt1); panel.Children.Add(txt2); panel.Children.Add(rect); return panel; } StackPanel There are also two types of elements that descend from panels, Canvas and StackPanel. The Canvas control allows elements to be added anywhere. StackPanels, on the other hand, place elements in order. We will modify the previous example to use a vertical StackPanel. The elements will stack and be arranged to the right and the left. Note that setting vertical alignment will be ignored as the vertical StackPanel overrides how elements are stacked. private static UIElement Elements() { var panel = new StackPanel(Orientation.Vertical); var txt1 = new TextBox() { HorizontalAlignment = HorizontalAlignment.Left, VerticalAlignment = VerticalAlignment.Top, }; txt1.Font = new Font(14); txt1.SetMargin(20); txt1.Text = \"Hello World!\"; var txt2 = new Text(new Font(14), \"Endpoint is Great!\") { ForeColor = Colors.White, HorizontalAlignment = HorizontalAlignment.Right, }; txt2.SetMargin(20); var rect = new Rectangle(200, 10) { Fill = new SolidColorBrush(Colors.Green), HorizontalAlignment = HorizontalAlignment.Center, }; panel.Children.Add(txt1); panel.Children.Add(txt2); panel.Children.Add(rect); return panel; } Canvas The Canvas element provides pixel level control over the placement of its child controls. The Width and Height properties of Canvas are requested dimensions, but the actual size depends on the size of the parent element. The ActualWidth and ActualHeight properties can be used to determine the actual size of the Canvas. Controls within a Canvas are positioned relative to the four edges of the Canvas. private static UIElement Elements() { var canvas = new Canvas(); var txt = new Text(new Font(14), \"Endpoint is Great!\") { ForeColor = Colors.White, }; var rect = new Rectangle(150, 30) { Fill = new SolidColorBrush(Colors.Green), HorizontalAlignment = HorizontalAlignment.Center, }; Canvas.SetLeft(rect, 20); Canvas.SetBottom(rect, 20); canvas.Children.Add(rect); Canvas.SetLeft(txt, 30); Canvas.SetBottom(txt, 25); canvas.Children.Add(txt); return canvas; } Border This element defines a border inside another element. The position of child elements is constrained to the area inside the border. In this example the border thickness is set to 10, but if the children do not fill the area within the border, the border's thickness will automatically increase. Uncomment the two alignment lines to see an undesired effect of how borders work. private static UIElement Elements() { var border = new Border(); border.SetBorderThickness(10); border.BorderBrush = new SolidColorBrush(Colors.Red) var txt = new TextBox() { //HorizontalAlignment = HorizontalAlignment.Center, //VerticalAlignment= VerticalAlignment.Center, }; txt.Font = new Font(14); txt.Text = \"Endpoint is Great!\"; border.Child = txt; return border; } The fix is to add a container and then the container will have a border. In this example, the parent of the border is the canvas instead of the window. private static UIElement Elements() { var canvas = new Canvas(); var border = new Border(); border.SetBorderThickness(10); border.BorderBrush = new SolidColorBrush(Colors.Red); Canvas.SetLeft(border, 20); Canvas.SetTop(border, 20); var txt = new TextBox(); txt.Font = new Font(14); txt.Text = \"Endpoint is Great!\"; border.Child = txt; canvas.Children.Add(border); return canvas; } Button Buttons are simple controls that accept user input in the form of a click, which in embedded devices is usually a finger tap on a touch screen. The button needs a child, typically text, which describes the button's function. Buttons have a Click event to respond to user input. private static UIElement Elements() { var txt = new Text(new Font(14), \"Push me!\") { VerticalAlignment = VerticalAlignment.Center, HorizontalAlignment = HorizontalAlignment.Center, }; var button = new Button() { Child = txt, Width = 100, Height = 40, }; button.Click += Button_Click; return button; } private static void Button_Click(object sender, RoutedEventArgs e) { // Add button click event code here... } TextFlow TextFlow is a more powerful version of TextBlock that supports more advanced text formatting, and works well with large blocks of text. private static UIElement Elements() { var textFlow = new TextFlow(); textFlow.TextRuns.Add(\"Hello \", font, Colors.Red); textFlow.TextRuns.Add(\"World!\", font, Colors.Purple); textFlow.TextRuns.Add(TextRun.EndOfLine); textFlow.TextRuns.Add(\"Endpoint is Great!\", font, Colors.Yellow); return textFlow; } ListBox This element provides a list of options for users to select from. private static UIElement Elements() { var listBox = new ListBox(); listBox.Items.Add(new Text(font, \"Item 1\")); listBox.Items.Add(new Text(font, \"Item 2\")); listBox.Items.Add(new Text(font, \"Item 3\")); listBox.Items.Add(new Text(font, \"Item 4\")); return listBox; } It is also possible to add a separator between items, simply by using a rectangle. This item will be set to be not selectable. private static UIElement Elements() { var rect = new Rectangle() { Height = 1, Width=30, Stroke = new Pen(Colors.Black), }; var separator = new ListBoxItem() { Child = rect, IsSelectable = false, }; separator.SetMargin(2); var listBox = new ListBox(); listBox.Items.Add(new Text(font, \"Item 1\")); listBox.Items.Add(new Text(font, \"Item 2\")); listBox.Items.Add(separator); listBox.Items.Add(new Text(font, \"Item 3\")); listBox.Items.Add(new Text(font, \"Item 4\")); return listBox; } ScrollViewer The scroll viewer allows for viewing content that is larger than the viewing area. User input is used to shift the content within the viewing area. // Create a scrollviewer var scrollViewer = new ScrollViewer { Background = new SolidColorBrush(Colors.Gray), // scroll line by line with 10 pixels per line ScrollingStyle = ScrollingStyle.LineByLine, LineWidth = 10, LineHeight = 10 }; Register Touch event, items in scrollViewer will go up or down every time touched. scrollViewer.TouchUp += ScrollViewer_TouchUp; private void ScrollViewer_TouchUp(object sender, GHIElectronics.Endpoint.UI.Input.TouchEventArgs e) { var s = (ScrollViewer)sender; s.LineDown(); } MessageBox var font = \"user font\"; //new Font(14) var messageBox = new MessageBox(font); messageBox.Show(\"Is this messageBox?\", \"MessageBox caption\", MessageBox.MessageBoxButtons.YesNo); messageBox.ButtonClick += (a, b) => { Debug.WriteLine(b.DialogResult.ToString()); }; Slider var slider = new Slider(30, 150); slider.Direction = Orientation.Vertical; slider.OnValueChanged += (a, b) => Debug.WriteLine(\"new value = \" + b.Value); DataGrid var gridWidth = 400; var rowCount = 5; var columnWidth = 60; var rowHeight = 60; var font = \"user font\"; var dataGrid = new DataGrid(gridWidth, rowHeight, rowCount, font); var colum1 = new DataGridColumn(\"Column 1\", columnWidth); var colum2 = new DataGridColumn(\"Column 2\", columnWidth); var colum3 = new DataGridColumn(\"Column 3\", columnWidth); var item123 = new DataGridItem(new string[] { \"item 1\", \"item 2\", \"item 3\" }); var item456 = new DataGridItem(new string[] { \"item 4\", \"item 5\", \"item 6\" }); // Add column dataGrid.AddColumn(colum1); dataGrid.AddColumn(colum2); dataGrid.AddColumn(colum3); // Add Item dataGrid.AddItem(item123); dataGrid.AddItem(item456); // Touch Event dataGrid.TapCellEvent += (a, b) => { Debug.WriteLine(b.ToString()); }; Chart var chartData = new ArrayList(); var random = new Random(); for (var i = 0; i < 10; i++) { chartData.Add(new DataItem() { Value = random.Next(100), Name = $\"N{i}\" }); } var chart = new Chart(400, 200) { Font = 'your font', // need font DivisionAxisX = 1, DivisionAxisY = 10, RadiusPoint = 10, ChartTitle = \"Endpoint Chart\", Items = chartData, Mode = ChartMode.RectangleMode }; The Dispatcher The User Interface libraries rely on a dispatcher to handle system events and update invalidated elements. All elements are changed and updated from within the dispatcher. In this example, we will show the time on the screen. The time will be in a text box that is updated every second using a Timer. Since timers run in their own thread, a dispatcher invoke is needed. static void Counter(object o) { Application.Current.Dispatcher.Invoke(TimeSpan.FromMilliseconds(1), _ => { Text txt = (Text)o; txt.TextContent = DateTime.Now.ToString(); txt.Invalidate(); return null; }, null); } private static UIElement Elements() { var txt = new Text(font, \"Hello World!\") { ForeColor = Colors.White, VerticalAlignment = VerticalAlignment.Center, HorizontalAlignment = HorizontalAlignment.Center, }; Timer timer = new Timer(Counter, txt, 2000, 1000); return txt; } You can also use the dispatcher timer directly: private static UIElement Elements() { var txt = new Text(font, \"Hello World!\") { ForeColor = Colors.White, VerticalAlignment = VerticalAlignment.Center, HorizontalAlignment = HorizontalAlignment.Center, }; var timer = new DispatcherTimer(); timer.Tag = txt; timer.Tick += Counter; timer.Interval = new TimeSpan(0, 0, 1); timer.Start(); return txt; } private static void Counter(object sender, EventArgs e) { var txt = (Text)((DispatcherTimer)sender).Tag; txt.TextContent = DateTime.Now.ToString(); txt.Invalidate(); } User Input A user can feed input to the graphical interface through touch or button input. Touch input app.InputProvider.RaiseTouch(x, y, touchState, DateTime.UtcNow); app.InputProvider.RaiseButton(btn, btnState, DateTime.UtcNow); The touch tutorial has further details. Button input User can map gpio pin to button left, right, back, home or select. Below is how to use left, right on MessageBox, assuming that Left is Yes, Right is No. //Declare gpio pin cs var buttonLeft = gpioController.OpenPin(SC20100.GpioPin.PE3); var buttonRight = gpioController.OpenPin(SC20100.GpioPin.PB7); buttonLeft.SetDriveMode(GpioPinDriveMode.InputPullUp); buttonRight.SetDriveMode(GpioPinDriveMode.InputPullUp); buttonLeft.DebounceTimeout = TimeSpan.FromMilliseconds(50); buttonRight.DebounceTimeout = TimeSpan.FromMilliseconds(50); buttonLeft.ValueChangedEdge = GpioPinEdge.RisingEdge; buttonRight.ValueChangedEdge = GpioPinEdge.RisingEdge; // Map to Input event buttonLeft.ValueChanged += (a, b) => { Program.MainApp.InputProvider.RaiseButton(GHIElectronics.Endpoint.UI.Input.HardwareButton.Left, true, DateTime.UtcNow); }; buttonRight.ValueChanged += (a, b) => { Program.MainApp.InputProvider.RaiseButton(GHIElectronics.Endpoint.UI.Input.HardwareButton.Right, true, DateTime.UtcNow); }; // Usage: void TestMessageBox(int counter) { var messageBox = new MessageBox(this.font12); // assuming font12 load from resource. Example: font12 = Resources.GetFont(Resources.FontResources.droid_reg12); this.mainStackPanel.Children.Add(messageBox); // messagebox to parent Element, here is this.mainStackPanel: example mainStackPanel = new StackPanel(Orientation.Vertical); messageBox.AddHandler(Buttons.ButtonUpEvent, new RoutedEventHandler(ProcessMessageboxButtons), true); messageBox.Show(\"Counter \" + counter.ToString() + \". Are you sure?\", \"Confirm\", MessageBox.MessageBoxButtons.YesNo); Buttons.Focus(messageBox); // focus event to messagebox // Use touch if touch is available. messageBox.ButtonClick += (a, b) => { if (b.DialogResult == MessageBox.DialogResult.Yes) { Debug.WriteLine(\"Press yes\"); } }; // Process gpio button events void ProcessMessageboxButtons(object sender, RoutedEventArgs e) { var buttonSource = (GHIElectronics.Endpoint.UI.Input.ButtonEventArgs)e; switch (buttonSource.Button) { case GHIElectronics.Endpoint.UI.Input.HardwareButton.Left: Debug.WriteLine(\"Button left - \"Yes\" pressed\"); break; case GHIElectronics.Endpoint.UI.Input.HardwareButton.Right: Debug.WriteLine(\"Button Right - \"No\" pressed\"); break; case GHIElectronics.Endpoint.UI.Input.HardwareButton.Select: Debug.WriteLine(\"Button Select pressed\"); break; } messageBox.Close(); // close messagebox } this.mainStackPanel.Invalidate(); // parent Invalidate } Avalonia UI Creating beautiful and functional User Interfaces is much easier on a hardware device when developers can use existing .NET APIs. Avalonia UI is an open-source UI framework for building stunning desktop, mobile, web, and embedded applications using a .NET single codebase. Their API can be found here. Endpoint takes advantage of Avalonia UI's cross-platform WPF. The GHIElectronics.Endpoint.Drivers.Avalonia.Input combined with the standard Avalonia NuGet package includes everything you need. Included on the Endpoint Samples Repo is a simple working example to get started with. Virtual Keyboard To help create a seamless UI experience on embedded devices we've created a virtual keyboard driver. This virtual keyboard is built into the Avalonia driver and can also be used stand-alone in any project. Implementation is simple. var keyboard = new VirtualKeyboard(displayController); touch.TouchUp += (a, b) =>{ keyboard.UpdateKey(b.X, b.Y); }; keyboard.Show(); The Endpoint Samples Repo contains the full virtual keyboard example."
  },
  "endpoint/tutorials/usb.html": {
    "href": "endpoint/tutorials/usb.html",
    "title": "USB",
    "keywords": "USB Both, USB Host and USB Device (Client) are utilized in any Endpoint device. USB Device An Endpoint device presents its USB Device as a virtual network interface. This interface is used to configure, program, and debug applications remotely. No user effort is needed to use this interface USB Host There are multiple way to benefit from USB Host to cover different needs. using GHIElectronics.Endpoint.Devices.UsbHost; //... var usbhost = new UsbHostController(); usbhost.OnConnectionChangedEvent += Usbhost_OnConnectionChangedEvent; usbhostController.Enable(); void Usbhost_OnConnectionChangedEvent(UsbHostController sender, DeviceConnectionEventArgs e) { Console.WriteLine(\"Detect changed Id: \" + e.DeviceId + \", name: \" + e.DeviceName + \", status:\" + e.DeviceStatus); } Mass Storage This allows users to access files on USB memory devices. Once a MassStorage device is inserted and detected, it can then be mounted, returning the device path needed to access files. var usbhost = new UsbHostController(); string usbmountedPath = string.Empty; usbhost.OnConnectionChangedEvent += Usbhost_OnConnectionChangedEvent; usbhostController.Enable(); void Usbhost_OnConnectionChangedEvent(UsbHostController sender, DeviceConnectionEventArgs e) { Console.WriteLine(\"Detect changed Id: \" + e.DeviceId + \", name: \" + e.DeviceName + \", status:\" + e.DeviceStatus); if (e.Type == GHIElectronics.Endpoint.Devices.Usb.DeviceType.MassStorage && e.DeviceStatus == DeviceConnectionStatus.Connected) { usbmountedPath = GHIElectronics.Endpoint.FileSystem.Mount(e.DeviceName); Console.WriteLine(\"Mounted, path \" + usbmountedPath); } else if (e.Type == GHIElectronics.Endpoint.Devices.Usb.DeviceType.MassStorage) { GHIElectronics.Endpoint.FileSystem.Unmount(usbmountedPath); Console.WriteLine(\"Unmounted\"); } } Files can now be accessed normally. string path = usbmountedPath + \"/DataFile.txt\"; using (FileStream fs = File.Create(path)) { //... } HID Human Interface Devices, such as a Keyboards and Mice, are automatically mounted by the system. using var hid = new HidInput(); hid.OnButtonPress += (e) => { Console.WriteLine($\"Code:{e.Code} State:{e.State}\"); }; hid.OnMouseMove += (e) => { Console.WriteLine($\"Axis:{e.Axis} Amount:{e.Amount}\"); }; hid.OnDisconnected += () => { Console.WriteLine(\"Device HID disconnected!\"); }; Camera The USB Camera library provides a stream of images. Note that only cameras with UVC (USB Video Class) standard are supported. usbhostController.OnConnectionChangedEvent += (a, b) => { var arg = b; if (arg.DeviceStatus == DeviceConnectionStatus.Connected) { Console.WriteLine(\"id: \" + arg.DeviceId); Console.WriteLine(\"name: \" + arg.DeviceName); Console.WriteLine(\"type: \" + arg.Type); if (arg.Type == GHIElectronics.Endpoint.Devices.Usb.DeviceType.Webcam && arg.DeviceName.IndexOf(\"video0\") > 0) { webcam = new Webcam(arg.DeviceName); var setting = new CameraConfiguration() { Width = 480, Height = 272, ImageFormat = Format.Rgb565, }; webcam.Setting = setting; webcam.VideoStreamStart(); webcam.FrameReceivedEvent += (a, b) => { displayController.Flush(b, 0, b.Length, webcam.Width, webcam.Height); }; } } else { if (webcam != null) { if (webcam.IsVideoStreaming) { webcam.VideoStreamStop(); } webcam.Dispose(); webcam = null; } } };"
  },
  "endpoint/tutorials/watchdog-timer.html": {
    "href": "endpoint/tutorials/watchdog-timer.html",
    "title": "Watchdog",
    "keywords": "Watchdog A watchdog timer is used to reset the system if the system fails or locks up. It's recommend to run Watchdog inside a thread in the application. Max timeout is 32 seconds. var watchdog = new WatchdogController(); watchdog.Start(10); // 10 second var cnt = 0; while (true) { Console.WriteLine(\"cnt: \" + cnt++); Thread.Sleep(1000); watchdog.Reset(); }"
  },
  "hardware/automotive.html": {
    "href": "hardware/automotive.html",
    "title": "CANxtra",
    "keywords": "CANxtra CANxtra is a hand-held programmable OBD-II tool that includes CAN, LIN and other vehicle buses. Resources below are provided for reference only. Please contact us for all of your custom automotive needs. Resources Brochure Schematic"
  },
  "hardware/breakout/fez-cerb40.html": {
    "href": "hardware/breakout/fez-cerb40.html",
    "title": "FEZ Cerb40",
    "keywords": "FEZ Cerb40 DIP40 form factor board. Not really a Gadgeteer board but it is very small! Schematic FEZ Cerb40 II Same as the FEZ Cerb40 with an added regulator chip. Schematic"
  },
  "hardware/breakout/fez-cobra.html": {
    "href": "hardware/breakout/fez-cobra.html",
    "title": "FEZ Cobra",
    "keywords": "FEZ Cobra Resources Schematic Software For information about programming the FEZ Cobra, please visit our EMX page."
  },
  "hardware/breakout/fez-mini.html": {
    "href": "hardware/breakout/fez-mini.html",
    "title": "FEZ Mini",
    "keywords": "FEZ Mini Resources Schematic Software For information on programming the FEZ Mini, please go to the USBizi page."
  },
  "hardware/breakout/fez-rhino.html": {
    "href": "hardware/breakout/fez-rhino.html",
    "title": "FEZ Rhino",
    "keywords": "FEZ Rhino Resources Schematic Software For information about programming the FEZ Rhino, please visit our USBizi page."
  },
  "hardware/breakout/g120-hdr.html": {
    "href": "hardware/breakout/g120-hdr.html",
    "title": "G120HDR Modules",
    "keywords": "G120HDR Modules The G120HDR Module is a through-hole version of the G120 Module G120HDR G120HDR Rev2 Resources Schematic"
  },
  "hardware/breakout/g120-th.html": {
    "href": "hardware/breakout/g120-th.html",
    "title": "G120 TH Module",
    "keywords": "G120 TH Module A through-hole version of the G120. Resources Schematic Software For information on programming the G120 TH Module, please go to the G120 page."
  },
  "hardware/breakout/g30-th.html": {
    "href": "hardware/breakout/g30-th.html",
    "title": "G30 TH Module",
    "keywords": "G30 TH Module A through-hole version of G30. Resources Schematic Software For information on programming the G30 TH Module, please go to the G30 page."
  },
  "hardware/breakout/g400-th.html": {
    "href": "hardware/breakout/g400-th.html",
    "title": "G400 TH Module",
    "keywords": "G400 TH Module A through-hole version of G400. Resources Schematic Software For information on programming the G400 TH Module please refer to the G400D page."
  },
  "hardware/breakout/g80-th.html": {
    "href": "hardware/breakout/g80-th.html",
    "title": "G80 TH Module",
    "keywords": "G80 TH Module A through-hole version of the G80. Resources Schematics Software For information on programming the G80 TH Module, please go to the G80 page."
  },
  "hardware/breakout/intro.html": {
    "href": "hardware/breakout/intro.html",
    "title": "Breakout",
    "keywords": "Breakout We offer breakout boards for all of our SoMs to speed the path to programming and product development. All of these boards offer through hole connections which accept standard 0.10 inch headers. Some boards also offer surface mount edge connections which are ideal for short production runs."
  },
  "hardware/duino/fez-cerbuino-bee.html": {
    "href": "hardware/duino/fez-cerbuino-bee.html",
    "title": "FEZ Cerbuino Bee",
    "keywords": "FEZ Cerbuino Bee An Arduino-pinout compatible single board computer with Gadgeteer sockets. Resources Schematic Software For information on programming the FEZ Cerbuino Bee, please go to the FEZ Cerberus page."
  },
  "hardware/duino/fez-cerbuino-net.html": {
    "href": "hardware/duino/fez-cerbuino-net.html",
    "title": "FEZ Cerbuino Net",
    "keywords": "FEZ Cerbuino Net An Arduino-pinout compatible single board computer with Gadgeteer sockets. Resources Schematic Software For information on programming the FEZ Cerbuino Net, please go to the FEZ Cerberus page."
  },
  "hardware/duino/fez-cobra-iii.html": {
    "href": "hardware/duino/fez-cobra-iii.html",
    "title": "FEZ Cobra III",
    "keywords": "FEZ Cobra III An Arduino-pinout compatible single board computer. Resources Schematic Software For information on programming the FEZ Cerbuino Bee, please go to the G120 page."
  },
  "hardware/duino/fez-domino.html": {
    "href": "hardware/duino/fez-domino.html",
    "title": "FEZ Domino",
    "keywords": "FEZ Domino Resources Schematic Software For information on programming the FEZ Domino, please go to the USBizi page."
  },
  "hardware/duino/fez-lemur.html": {
    "href": "hardware/duino/fez-lemur.html",
    "title": "FEZ Lemur",
    "keywords": "FEZ Lemur A Arduino-pinout compatible single board computer. Resources Schematic Software For information on programming the FEZ Lemur, please go to the G30 page."
  },
  "hardware/duino/fez-panda-ii.html": {
    "href": "hardware/duino/fez-panda-ii.html",
    "title": "FEZ Panda II",
    "keywords": "FEZ Panda II An Arduino-pinout compatible single board computer. Resources Schematic Software For information on programming the FEZ Panda II, please go to the USBizi page."
  },
  "hardware/duino/fez-panda-iii.html": {
    "href": "hardware/duino/fez-panda-iii.html",
    "title": "FEZ Panda III",
    "keywords": "FEZ Panda III An Arduino-pinout compatible single board computer. Resources Schematic Software For information on programming the FEZ Panda II, please go to the G80 page."
  },
  "hardware/duino/fez-panda.html": {
    "href": "hardware/duino/fez-panda.html",
    "title": "FEZ Panda",
    "keywords": "FEZ Panda An Arduino-pinout compatible board. Resources Schematic Software For information on programming the FEZ Panda, please go to the USBizi page."
  },
  "hardware/duino/fez-t18.html": {
    "href": "hardware/duino/fez-t18.html",
    "title": "FEZ T18",
    "keywords": "FEZ T18 Note FEZ T18 only works with TinyCLR OS 1.0 -- it will not run TinyCLR 2.0. An Arduino-pinout compatible single board computer Spec Value Processor STMicroelectronics ST32F401RET6 Speed 84 MHz Internal RAM 96 KByte Internal Flash 512 KByte Dimensions 70.6 x 56.0 x 14.5 mm Resources Schematic Software FEZ T18 is only supported by TinyCLR OS 1.0 and will not run TinyCLR OS 2.0. Link to Download compatible TinyCLR OS 1.0 Files Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com."
  },
  "hardware/duino/intro.html": {
    "href": "hardware/duino/intro.html",
    "title": "Duino Intro",
    "keywords": "Duino Intro Our Duino boards offer Arduino pinout compatible sockets that will accept standard Arduino expansion boards or \"shields.\" They run TinyCLR and can be programmed in C# or Visual Basic using the Microsoft Visual Studio development environment."
  },
  "hardware/filesystem/intro.html": {
    "href": "hardware/filesystem/intro.html",
    "title": "File System",
    "keywords": "File System This page has the technical details and manuals for the File System products. ALFAT Evaluation Kit This kit offers everything needed to evaluate F40 (ALFAT) and the different ALFAT OEM boards. As F40 and F20 share the same command set, this kit can also be used for understanding the F20 commands. The kit includes: ALFAT OEM board ALFAT SDR board ALFAT EVAL carrier board Storage devices and USB cable Part Number AFEVL-FS-524 ALFAT Eval Kit Schematic File System User Manual Software Bundle UART/SPI Command Implementation F40 (ALFAT) Chipset F40, originally called ALFAT, is the flagship file system chipset. Part Number ALF2X-SC-512 Datasheet User Manual Firmware v1.0.8 Firmware v2.0.0 ALFAT OEM Board F40 chipset with SD and dual-USB connectors. The PHY needed for USB 2.0 480 MHz speeds is available on one of the USB ports. Part Number ALFAT-OM-337 ALFAT-OEM Schematic ALFAT SD F40 chipset with SD connector. Part Number ALFAT-SD-338 ALFAT-SD Schematic ALFAT USB F40 chipset with USB connector. Part Number ALFAT-USB-428 ALFAT-USB Schematic ALFAT SDR This board wires the F40 in SD-reader mode. Part Number AFSDR-FS-523 ALFAT-SDR Schematic F20 Chipset This low-cost chipset is compatible with F40 but with a limited feature set. Part Number F20SC-SC-558 Datasheet User Manual Firmware v1.0.3 F20 uSD Board This boards combines F20 with a micro SD card connector on a very tiny circuit. Part Number F20FS-546 F20-uSD Schematic uALFAT Chipset User Manual Firmware v3.13 USBwiz Chipset User Manual Firmware v2.29 Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com."
  },
  "hardware/gadgeteer/fez-cerberus.html": {
    "href": "hardware/gadgeteer/fez-cerberus.html",
    "title": "FEZ Cerberus",
    "keywords": "FEZ Cerberus FEZ Cerberus is a .NET Gadgeteer product that utilizes .NET Micro Framework (NETMF). The core of the FEZ Cerberus is the G30 System on Chip (SoC). FEZ Cerberus is the mother of the Cerb Family! To use with NETMF/Gadgeteer, follow these setup instructions. Resources Schematic FEZ Game-O A programmable game console based on the FEZ Cerberus that was funded with a successful kickstarter campaign. The FEZ Game-O combine a 320 x 240 color display, 3D accelerometer and audio circuitry within an attractive, ergonomic enclosure. Schematic"
  },
  "hardware/gadgeteer/fez-cerbot.html": {
    "href": "hardware/gadgeteer/fez-cerbot.html",
    "title": "FEZ Cerbot",
    "keywords": "FEZ Cerbot A robot with reflective sensors and tons of LEDs. Gadgeteer sockets are used as an easy way to add features. Resources Schematic Software For information on programming the FEZ Cerbot, please go to the FEZ Cerberus page."
  },
  "hardware/gadgeteer/fez-cobra-ii.html": {
    "href": "hardware/gadgeteer/fez-cobra-ii.html",
    "title": "FEZ Cobra II Eco and WiFi",
    "keywords": "FEZ Cobra II Eco and WiFi FEZ Cobra II is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Cobra II is the G120 System on Module (SoM). Follow the instructions on the G120 page to learn how to use FEZ Cobra with NETMF and TinyCLR OS. Resources Eco and WiFi Schematic Net Schematic Cobra II Extender schematic Tip To activate bootloader v2, press and hold the LDR0 button while resetting the board."
  },
  "hardware/gadgeteer/fez-hydra.html": {
    "href": "hardware/gadgeteer/fez-hydra.html",
    "title": "FEZ Hydra",
    "keywords": "FEZ Hydra FEZ Hydra is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). To use with NETMF/Gadgeteer, follow these setup instructions. Resources Schematic"
  },
  "hardware/gadgeteer/fez-raptor.html": {
    "href": "hardware/gadgeteer/fez-raptor.html",
    "title": "FEZ Raptor",
    "keywords": "FEZ Raptor FEZ Raptor is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Raptor is the G400S System on Module (SoM). Follow the instructions on the G400S page to learn how to use FEZ Raptor with NETMF and TinyCLR OS. Resources Schematic Tip To activate bootloader v2, press and hold the LDR0 button while resetting the board."
  },
  "hardware/gadgeteer/fez-reaper.html": {
    "href": "hardware/gadgeteer/fez-reaper.html",
    "title": "FEZ Reaper",
    "keywords": "FEZ Reaper FEZ Reaper is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Reaper is the G80 System on Chip (SoC). Follow the instructions on the G80 page to learn how to use FEZ Raptor with NETMF and TinyCLR OS. Resources Schematic Tip To activate bootloader v2, press and hold both LDR0 and LDR1 buttons down while resetting the board."
  },
  "hardware/gadgeteer/fez-spider-ii.html": {
    "href": "hardware/gadgeteer/fez-spider-ii.html",
    "title": "FEZ Spider II",
    "keywords": "FEZ Spider II FEZ Spider II is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Spider II is the G120E System on Module (SoM). To use with NETMF/Gadgeteer, follow these setup instructions. Resources Schematic Using TinyCLR OS Follow the instructions on the G120 page to learn how to use FEZ Spider II TinyCLR OS. The instructions are the same as G120. LDR0 and LDR1 signals are available on switches #1 and #2. The schematic above has all details."
  },
  "hardware/gadgeteer/fez-spider.html": {
    "href": "hardware/gadgeteer/fez-spider.html",
    "title": "FEZ Spider",
    "keywords": "FEZ Spider FEZ Spider is a .NET Gadgeteer product that utilizes .NET Micro Frameworks (NETMF). The core of FEZ Spider is the EMX System on Module (SoM). To use with NETMF/Gadgeteer, follow these setup instructions. Resources Schematic"
  },
  "hardware/gadgeteer/intro.html": {
    "href": "hardware/gadgeteer/intro.html",
    "title": ".NET Gadgeteer Intro",
    "keywords": ".NET Gadgeteer Intro .NET Gadgeteer is a discontinued technology that was initiated by Microsoft Research and taken to production by GHI Electronics in the year 2011. .NET Gadgeteer had a great few year run, where it was loved for its plug-and-play mainboard and modules. Tip We will refer to .NET Gadgeteer as Gadgeteer throughout the rest of the documentation. The core of .NET Gadgeteer is .NET Micro Framework (NETMF). Like Gadgeteer, NETMF is no longer evolved by Microsoft and left for the community. Learn more about NETMF Sadly, and after 5 years of building modules and mainboards, GHI Electronics had to announce the EOL for Gadgeteer; however, most of the Gadgeteer hardware can still be used with TinyCLR OS. External resources: Microsoft's .NET Gadgeteer website (down) http://www.gadgeteer.com/ Microsoft's NETMF website (outdated) http://www.netmf.com/ Most of the Gadgeteer ecosystem is open-source: Microsoft's .NET Gadgeteer Core GHI Electronics' Software sources and Hardware design files Socket Map The magic of Gadgeteer is in its socket map Socket Pin1 Pin2 Pin3 Pin4 Pin5 Pin6 Pin7 Pin8 Pin9 Pin10 A +3.3V +5V AIN (G!) AIN (G) AIN GPIO [UN] [UN] [UN] GND B +3.3V +5V LCD B0 LCD B1 LCD B2 LCD B3 LCD B4 LCD ENABLE LCD CLK GND C +3.3V +5V GPIO! CAN TD (G) CAN RD (G) GPIO [UN] [UN] [UN] GND D +3.3V +5V GPIO! D- D+ GPIO GPIO [UN] [UN] GND E +3.3V +5V [UN] LED1 (OPT) LED2 (OPT) TX D- TX D+ RX D- RX D+ GND F +3.3V +5V GPIO! DAT0 DAT1 CMD DAT2 DAT3 CLK GND G +3.3V +5V LCD G0 LCD G1 LCD G2 LCD G3 LCD G4 LCD G5 LCD BACKLIGHT GND H +3.3V +5V GPIO! D- D+ [UN] [UN] [UN] [UN] GND I +3.3V +5V GPIO! [UN] [UN] GPIO [UN] SDA SCL GND K +3.3V +5V GPIO! TX (G) RX (G) RTS CTS [UN] [UN] GND O +3.3V +5V GPIO! GPIO AOUT [UN] [UN] [UN] [UN] GND P +3.3V +5V GPIO! [UN] [UN] GPIO PWM (G) PWM (G) PWM GND R +3.3V +5V LCD R0 LCD R1 LCD R2 LCD R3 LCD R4 LCD VSYNC LCD HSYNC GND S +3.3V +5V GPIO! GPIO GPIO CS MOSI MISO SCK GND T +3.3V +5V [UN] YU XL YD XR [UN] [UN] GND U +3.3V +5V GPIO! TX (G) RX (G) GPIO [UN] [UN] [UN] GND X +3.3V +5V GPIO! GPIO GPIO [UN] [UN] [UN] [UN] GND Y +3.3V +5V GPIO! GPIO GPIO GPIO GPIO GPIO GPIO GND Z +3.3V +5V [MS] [MS] [MS] [MS] [MS] [MS] [MS] GND * +3.3V +5V GPIO! GPIO GPIO [MS] [MS] [MS] [MS] GND Symbol Description AIN Analog input pin. GPIO A general-purpose digital input/output pin, operating at 3.3 volts. (G) In addition to another functionality, a pin that is also usable as a GPIO. [UN] Modules must not connect to this pin if using this socket type. Mainboards can support multiple socket types on one socket, as long as individual pin functionalities overlap in a compatible manner, so that a pin from one socket type can overlap with a [UN] pin of another. ! Interrupt-capable and software pull-up capable GPIO (the pull-up is switchable and in the range of 10,000 to 100,000 ohms). +3.3V Connection to the +3.3 V power net. +5V Connection to the +5 V power net. GND Connection the power ground net. Using .NET Gadgeteer To use .NET Gadgeteer's legacy software, install: Visual Studio 20013 (community edition is also supported) Unzip and install netmfvs2013.vsix and MicroFramewrokSDK.msi from here Microsoft's Gadgeteer Core GHI Electronics' NETMF SDK. The latest is recommended. The Gadgeteer for Beginners guide is a good starting point. Tip You can only use Visual Studio 2013, not a newer edition, unless you are using your Gadgeteer hardware with TinyCLR OS. With TinyCLR OS Most of the .NET Gadgeteer devices are still usable today, and with the latest technologies, thanks to efforts by GHI Electronics and the community. It all started in this video! This means you can still use all your beloved .NET Gadgeteer gear with TinyCLR OS. The first step needed to use TinyCLR OS is to load the GHI Electronics Bootloader v2 onto your mainboard, then use that to load the TinyCLR OS firmware. Each mainboard product page includes the needed instructions. Once those are loaded, you can start blinking the debug LED, detailed in the next section. Blinking the LED Tip If you have never used TinyCLR OS before, start here This example will blink the debug LED. You only need to add a power module to your mainboard. using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var led = GpioController.GetDefault().OpenPin(FEZSpider.GpioPin.DebugLed); led.SetDriveMode(GpioPinDriveMode.Output); while(true) { led.Write(GpioPinValue.High); Thread.Sleep(200); led.Write(GpioPinValue.Low); Thread.Sleep(200); } } } Tip The complete pin mapping is made available through GHIElectronics.TinyCLR.Pins. You should not need to use any schematics. Replace FEZSpider with your mainboard's name. Adding Gadgeteer Modules You are now ready to start adding modules."
  },
  "hardware/gadgeteer/modules.html": {
    "href": "hardware/gadgeteer/modules.html",
    "title": ".NET Gadgeteer Modules",
    "keywords": ".NET Gadgeteer Modules This page lists all .NET Gadgeteer modules. All sources are found on the NETMF and Gadgeteer repo Accel G248 The Accel G248 measures acceleration though I2C bus. Schematic Barometer Measures pressure. Schematic Bluetooth Schematic Breadboard X1 An easy breadboard option. Simply access the socket directly to wire whatever your heart desires! Schematic Breakout Simply a breakout of all signals. Schematic Breakout TB10 Simply a breakout of all signals, on a terminal block. Schematic Button The Button module is very simple, with a button connected to pin 3 and an LED connected to pin4. Schematic Button S7 7 buttons on a single module, with LEDs that light up with button presses! Use the same code example provided for the Button Module. Buttons map: Left: Pin Right: Pin 8 Up: Pin 6 Down: Pin 7 Enter: Pin 3 Back: Pin 4 Forward: Pin 9 Schematic CAN DW Schematic Camera Schematic Cellular Radio Gadgteer driver Schematic Character Display This is a standard and very common HD44780 display. Schematic ColorSense A color sensor that uses software I2C, not yet supported in TinyCLR OS. Schematic Compass Schematic Current ACS712 This is a current sensor that uses ACS712, which simply outputs an analog voltage. Schematic Display CP7 The configurations for the display: // these are the wrong values! Width = 800, Height = 480, PixelClockRate = 24 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 16, HorizontalBackPorch = 46, HorizontalSyncPulseWidth = 1, HorizontalSyncPolarity = true, VerticalFrontPorch = 7, VerticalBackPorch = 23, VerticalSyncPulseWidth = 1, VerticalSyncPolarity = true, Schematic Display N18 This is an SPI display that can work on any system with SPI bus, even small ones without TFT display support. Schematic Display N7 The configurations for the display: Width = 800, Height = 480, PixelClockRate = 24 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 16, HorizontalBackPorch = 46, HorizontalSyncPulseWidth = 1, HorizontalSyncPolarity = true, VerticalFrontPorch = 7, VerticalBackPorch = 23, VerticalSyncPulseWidth = 1, VerticalSyncPolarity = true, Schematic Display NHVN This allows the use of several displays offered by http://newhavendisplay.com/ Supported displays: NHD-4.3-480272EF-ATXL# NHD-4.3-480272EF-ATXL#-CTP NHD-4.3-480272EF-ATXL#-T NHD-7.0-800480EF-ATXL# NHD-7.0-800480EF-ATXL#-CTP NHD-7.0-800480EF-ATXV# NHD-7.0-800480EF-ATXV#-CTP The configurations for all 4.3\" display: Width = 480, Height = 272, PixelClockRate = 20 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, The configurations for all 7\" display: Width = 800, Height = 480, PixelClockRate = 20 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 88, HorizontalBackPorch = 40, HorizontalSyncPulseWidth = 48, HorizontalSyncPolarity = false, VerticalFrontPorch = 13, VerticalBackPorch = 32, VerticalSyncPulseWidth = 3, VerticalSyncPolarity = false, As for the capacitive touch controller, use this old NETMF driver code as a reference: public class FT5306Controller { private InterruptPort touchInterrupt; private I2CDevice i2cBus; private I2CDevice.I2CTransaction[] transactions; private byte[] addressBuffer; private byte[] touchDataBuffer; private byte[] touchCountBuffer; public delegate void TouchEventHandler(FT5306Controller sender, TouchEventArgs e); public event TouchEventHandler TouchDown; public event TouchEventHandler TouchUp; public event TouchEventHandler TouchMove; public FT5306Controller(Cpu.Pin interruptPin) { this.transactions = new I2CDevice.I2CTransaction[2]; this.addressBuffer = new byte[1]; this.touchDataBuffer = new byte[4]; this.touchCountBuffer = new byte[1]; this.i2cBus = new I2CDevice(new I2CDevice.Configuration(0x38, 400)); this.touchInterrupt = new InterruptPort(interruptPin, false, Port.ResistorMode.Disabled, Port.InterruptMode.InterruptEdgeBoth); this.touchInterrupt.OnInterrupt += (a, b, c) => this.OnTouchEvent(); } private void OnTouchEvent() { var points = this.ReadData(2, this.touchCountBuffer)[0]; for (var i = 0; i < points; i++) { var data = this.ReadData(i * 6 + 3, this.touchDataBuffer); var flag = (data[0] & 0xC0) >> 6; var x = ((data[0] & 0x0F) << 8) | data[1]; var y = ((data[2] & 0x0F) << 8) | data[3]; var handler = flag == 0 ? this.TouchDown : flag == 1 ? this.TouchUp : flag == 2 ? this.TouchMove : null; if (handler != null) handler(this, new TouchEventArgs { X = x, Y = y }); } } private byte[] ReadData(int address, byte[] resultBuffer) { this.addressBuffer[0] = (byte)address; this.transactions[0] = I2CDevice.CreateWriteTransaction(this.addressBuffer); this.transactions[1] = I2CDevice.CreateReadTransaction(resultBuffer); this.i2cBus.Execute(this.transactions, 500); return resultBuffer; } public class TouchEventArgs : EventArgs { public int X { get; internal set; } public int Y { get; internal set; } } } Schematic Display T35 The configurations for the display: Width = 320, Height = 240, PixelClockRate = 15 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 51, HorizontalBackPorch = 27, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 16, VerticalBackPorch = 8, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Schematic Display T43 The configurations for the display: Width = 480, Height = 272, PixelClockRate = 20 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Schematic Display TE35 The configurations for the display: Width = 320, Height = 240, PixelClockRate = 15 * 1000 * 1000, PixelPolarity = false, OutputEnablePolarity = true, OutputEnableIsFixed = true, HorizontalFrontPorch = 51, HorizontalBackPorch = 29, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 16, VerticalBackPorch = 3, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, Schematic Distance US3 A very common ultrasonic sensor that works by sending a pulse on the trig Pin4 and measuring the response time on echo Pin3. Schematic Ethernet ENC28 Schematic Ethernet J11D Schematic Extender Schematic FEZtive Schematic Flash Schematic GPS Schematic GasSense This module can host several different air sensors, like Alcohol and CO2. The sensor has an internal heater on pin 4 that needs to be enabled and then it is a simple analog read on pin 3. Schematic Gyro Schematic HD44780 See the Character Display Module Schematic HubAP5 No hub support is currently planned. Schematic IO60P16 Schematic IR Receiver Schematic Joystick The Joystick module has two analog inputs for X (pin 4) and Y (pin 5) position. Pressing the knob also works like a button (pin 3). Schematic Keypad KP16 Schematic LED 7C An LED that can be set to one of 7 colors, 8 if you count off! Schematic LED 7R This is a ring of 6 LEDs and a 7th center LED. Reference the LED 7C module for using pins. Center LED: pin 9 LEDs going clockwise starting from LEDs D1 to D6 on the board D1, D2, D3, D4, D5, D6 are pins 3 to 8 respectively. Schematic LED Strip A strip of 7 LEDs, connected to pins 3 through 9. Reference the LED 7C module for using pins. Schematic Light Sense Simply using analog on pin 3. Use the same code as the potentiometer. Schematic Load Each one of the 7 GPIO pins are connected to a transistor to handle a load, like a motor. Schematic MaxO Shift registers used to take serial SPI data and put on parallel pins, perfect for driving tons of LEDs! Schematic MicroSD Card Schematic Moisture This is a simple analog input measuring the direct resistance (moisture) on pin 3. An enable pin needs to be activated on pin 6. Schematic Motor Driver The Motor Driver Module uses L298 H-bridge that can drive two motors up to 4A. Pin 6: Motor A Direction (GPIO) Pin 7: Motor A Speed (PWM) Pin 8: Motor B Direction (GPIO) Pin 9: Motor B Speed (PWM) Schematic Multicolor LED Schematic Music The Music Module uses the popular VS1053 decoder chip that decodes MP3, WMA, OGG, MIDI and WAV files. Schematic Null Modem No driver is needed. OBD II OneWire X1 A breakout with a terminal block for easily connecting OneWire devices, specifically the common temperature probes. Schematic PIR Motion detection. Simply pin 3 changes its state when it detects motion. Schematic Parallel CNC Schematic Potentiometer The Potentiometer module is simply a variable resistor connected to pin3. Rotating its knob will result in an analog value changing from min to max. Schematic Pulse Count Schematic Pulse InOut Schematic Pulse Oximeter Schematic RFID Reader Schematic RS232 Simply a serial port. Schematic RS485 Simply a serial port. Schematic Radio FM1 Schematic Reflector R3 Schematic Relay ISOx16 An array of 16 relays. Operate similar to the MaxO module. Schematic Relay X1 Simply set pin 3 high to activate the relay. Schematic Rotary H1 Schematic SD Card Schematic S-Plus Schematic Serial Camera Stepper L6470 Schematic TempHumidity Schematic Thermocouple Schematic Touch C8 Schematic Touch L12 Schematic Tunes The Tunes Module is a tiny speaker that is connected to pin 9. Use PWM to generate sounds Schematic UC Battery 4xAA No driver is needed. Schematic USB Client DP No driver is needed. Schematic USB Client SP No driver is needed. Schematic USB Host Schematic USB Serial Simply, a serial port. Schematic USB Serial SP Simply, a serial port. Schematic VideoOut Schematic WiFi RN171 Schematic WiFi RS21 Schematic XBee Adapter Simply, a serial port. From there a driver like https://xbee.codeplex.com/ will help. Schematic"
  },
  "hardware/gadgeteering.html": {
    "href": "hardware/gadgeteering.html",
    "title": "Gadgeteering",
    "keywords": "Gadgeteering Gadgeteering was meant to extend Gadgeteer beyond NETMF. We are making our hardware and software available for reference only. All material is found at this github repository Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com."
  },
  "hardware/imaging.html": {
    "href": "hardware/imaging.html",
    "title": "Imaging",
    "keywords": "Imaging ALCAM-OEM is a small yet powerful imaging hardware. It could capture stills and videos to SD card and able to fetch images using serial commands. It started in a successful Kickstarter campaign Resources Examples ALCAM Explorer User Manual We have worked on similar custom commercial designs with imaging needs but decided to proceed with a one-size-fits-all. Please contact us to discuss your imaging needs. Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com."
  },
  "hardware/intro.html": {
    "href": "hardware/intro.html",
    "title": "Hardware",
    "keywords": "Hardware Endpoint Full .NET 8 ready hardware. Load, run, and debug from VS or VSCode. Learn More... SITCore Secure IoT SoCs, SoMs and Dev Boards that run C# with full debugging over USB. Learn More... Legacy Support for discontinued products. Learn More... Legal License, Disclaimer, Security. More... You can also visit our main website at main website and our community forum."
  },
  "hardware/legacy/intro.html": {
    "href": "hardware/legacy/intro.html",
    "title": "Legacy Products Introduction",
    "keywords": "Legacy Products Introduction This section covers GHI Electronics legacy products. While we take pride in helping our customers maximize the lifetime of their products, these products are not recommended for new designs and are no longer covered by our free support. Check out our Longevity Promise to find out more about GHI Electronics' product life cycle. NETMF Modules Learn more... Older SoMs Learn more... Universal Modules Learn more... Gadgeteer Learn more... Duino Learn more... Breakout Learn more... File System Learn more... Automotive Learn more... Gadgeteering Learn more... Imaging Learn more... Raspberry PI Hats Learn more... mBuino Learn more... Tip Our community forum is a great place to get help from our engineers and from thousands of community members: Producing Legacy Products GHI Electronic's products are all engineered and manufactured in-house. While some of our older products are deemed legacy and not recommended for new designs, we can still produce them, however a minimum order may be required. You can also visit our main website at main website and our community forum."
  },
  "hardware/legacy/som.html": {
    "href": "hardware/legacy/som.html",
    "title": "Legacy System on Modules",
    "keywords": "Legacy System on Modules With the rapid advance of technology it can be hard to stay current. We take pride in our support of past products while we work hard to provide our customers with the best new technology. Check out our Longevity Promise to find out more about GHI Electronics' product life cycle. Legacy product should not be used for new designs; however, many of our older products can still be produced (minimum order may be required)."
  },
  "hardware/legal.html": {
    "href": "hardware/legal.html",
    "title": "Legal",
    "keywords": "Legal License This product with its accompanying firmware is licensed royalty-free for commercial and noncommercial use. Using the provided firmware on any non-official product requires additional licensing. Unless stated otherwise in the sources, the provided documentation/schematics/libraries/sources are not to be used in any manner outside of implementing and using this GHI Electronics product in your design. Disclaimer IN NO EVENT SHALL GHI ELECTRONICS, LLC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS PRODUCT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. GHI ELECTRONICS LINE OF PRODUCTS ARE NOT DESIGNED FOR LIFE SUPPORT APPLICATIONS. SPECIFICATIONS, PRICE AND AVAILABILITY ARE SUBJECT TO CHANGE WITHOUT ANY NOTICE. Security WE DO OUR BEST TO PROVIDE SECURE PRODUCTS THAT PROTECT YOUR INTELLECTUAL PROPERTY (CODE) AND ARE DIFFICULT TO EXPLOIT. HOWEVER, NO PRODUCT IS COMPLETELY SECURE. THERE ARE DISHONEST AND POSSIBLY ILLEGAL METHODS THAT CAN BE USED TO CIRCUMVENT OUR CODE PROTECTION AND SECURITY FEATURES. GHI ELECTRONICS, LLC SHALL IN NO EVENT BE HELD LIABLE IN ANY WAY FOR THE EXPLOITATION OF SECURITY VULNERABILITIES OR ANY USE OR MISUSE OF OUR PRODUCTS RESULTING IN THE LOSS OR THEFT OF CODE OR OTHER INTELLECTUAL PROPERTY. Product Longevity GHI ELECTRONICS, LLC IS PRIMARILY INVOLVED IN PROVIDING ELECTRONIC COMPONENTS, MODULES, AND ACCOMPANYING SOFTWARE THAT ARE USED BY OUR CUSTOMERS TO CREATE NEW AND INNOVATIVE PRODUCTS. IN SUPPORT OF OUR CUSTOMERS, WE DO OUR BEST TO DESIGN AND MANUFACTURE PRODUCTS WITH THE LONGEST LIFE CYCLE POSSIBLE. HOWEVER, OUR PRODUCT AVAILABILITY IS DEPENDENT UPON THE AVAILABILITY OF THE ELECTRONIC COMPONENTS FROM WHICH OUR PRODUCTS ARE BUILT. GHI ELECTRONICS, LLC WILL IN NO WAY BE HELD LIABLE FOR LOSSES OF ANY KIND, INCURRED BY OUR CUSTOMERS OR OTHERS, WHETHER MONETARY OR OTHERWISE, AS A RESULT OF GHI ELECTRONICS' PRODUCT SHORTAGES, DELAYS IN AVAILABILITY, OR DISCONTINUATION."
  },
  "hardware/mbuino.html": {
    "href": "hardware/mbuino.html",
    "title": "mBuino",
    "keywords": "mBuino The mBuino is a tiny keychain circuit. It is GHI Electronics contribution to the mbed community. Learn more here Schematic Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com."
  },
  "hardware/netmf/chipworkx.html": {
    "href": "hardware/netmf/chipworkx.html",
    "title": "ChipworkX",
    "keywords": "ChipworkX ChipworkX is a NETMF (.NET Micro Framework) System on Module. To use with NETMF, follow these setup instructions. Requires the NETMF 4.1 SDK. Resources User Manual"
  },
  "hardware/netmf/embedded-master.html": {
    "href": "hardware/netmf/embedded-master.html",
    "title": "Embedded Master",
    "keywords": "Embedded Master Embedded Master is a NETMF (.NET Micro Framework) System on Module. To use with NETMF, follow these setup instructions. Requires the NETMF 4.1 SDK. Resources User Manual"
  },
  "hardware/netmf/emx.html": {
    "href": "hardware/netmf/emx.html",
    "title": "EMX System on Module",
    "keywords": "EMX System on Module EMX is a NETMF (.NET Micro Framework) System on Module. To use with NETMF, follow the setup instructions. Resources User Manual EMX Dev Sys The development system used for evaluating the EMX SoM. Schematic"
  },
  "hardware/netmf/g120.html": {
    "href": "hardware/netmf/g120.html",
    "title": "G120 / G120E",
    "keywords": "G120 / G120E Overview The G120 and G120E SoMs are powerful, low-cost, System on Modules part of the GHI Electronics Surface Mount Compute Modules (SCM) line. These modules can be programmed in .NET C# and Visual Basic using .NET Micro Framework. Tip Not recommended for new designs, consider SITCore System on Chip. Ordering Part Number G120 SoM: G120B-SM-373 G120E SoM: G120E-SM-532 G120E Dev Board: G120D-SM-533 G120 vs G120E G120 G120E Processor NXP LPC1788FET180 NXP LPC1788FET208 Package 91 pin surface-mount module (SMT) 120 MHz Dimensions 38.1 x 26.7 x 3.5 mm 45.8 x 39.4 x 4.4 mm RTC External 32,768 Hz crystal Included GPIO 72 80 SPI 3 2 Ethernet ENC28J60 over SPI ENC28J60 over SPI and/or Built-in base 100 Ethernet PHY Specifications Spec Value Processor NXP LPC1788FET Speed 120 MHz Internal RAM 96 KByte (SRAM) Internal Flash 512 KByte External RAM 16 MByte (DRAM) External Flash 4 MByte (SPI) Dimensions (G120) 38.1 x 26.7 x 3.5 mm Dimensions (G120E) 45.8 x 39.4 x 4.4 mm Temperature Range -40 C to +85 C Note: Resources are shared between your application and the operating system. Features .NET Micro Framework RoHS Lead Free 120 MHz ARM Cortex-M3 NXP LPC1788 6 MBytes available RAM 2.3 MBytes available flash Embedded LCD controller 72 to 80 GPIO 43 interrupt capable GPIO 2 to 3 SPI 1 I2C 5 UART 2 CAN 12 PWM 8 12-bit analog input 1 10-bit analog output 4-bit SD/MMC memory card interface Low power modes RTC Watchdog Threading USB host USB client SQLite database TCP/IP with SSL Full .NET socket interface Ethernet WiFi PPP Graphics Images Fonts Controls File System Full .NET file interface SD cards USB drives Native extensions Runtime Loadable Procedures Device register access Signal controls Generation Capture Pulse measurement G120 Pinout Many signals on the G120 are multiplexed to offer multiple functions on a single pin. Developers can decide on the pin functionality to be used through the provided libraries. Any pin with no name, function, or note must be left unconnected. G120E Pinout Footprints We recommend no traces or vias under the module. Dimensions are in inches. G120 Recommended Footprint G120E Recommended Footprint Device Startup The G120 is held in reset when the reset pin is low. Releasing it will begin the system startup process. It is pulled high internally on the G120E and left floating on the G120. There are four different components of the device firmware: GHI Electronics Bootloader: initializes the system, updates TinyBooter when needed, and executes TinyBooter. TinyBooter: executes NETMF, updates NETMF when needed, and updates the system configuration. NETMF: loads, debugs, and executes the managed application. Managed application: the program developed by the customer. Which components get executed on startup can be control by manipulating the LDR0 and LDR1 pins. LDR0 and LDR1 are pulled high on startup. LDRO LDR1 Effect Ignored High Execute the managed application High Low Wait in TinyBooter Low Low Wait in GHI Electronics Bootloader Additionally, the communications interface between the host PC and the G120 is selected on startup through the MODE pin, which is pulled high on startup MODE G120 G120E High USB UART1 Low UART1 USB The above discussed functions of LDR0, LDR1, and MODE are only during startup. After startup, they return to the default GPIO state and are available to use as GPIO in the user application. .NET Micro Framework (NETMF) The NETMF software on G120 is mature and complete. For more information on NETMF you can go to the NETMF Introduction page. The NETMF Getting Started page covers NETMF from setup of the host computer to program deployment on both an emulator and target device. Loading the Firmware Activate the bootloader, hold the LDR0 signal low while resetting the board. Open FEZ Config tool and follow the instructions. You can also update the firmware manually. See GHI Electronics Bootloader page. Start Coding Now that you have installed the bootloader and firmware on the G120, you can setup your host computer and start programming. Go to the NETMF Getting Started page for instructions. Datasheet This documentation page replaced the legacy datasheet PDF but it is here for reference. CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a G120 driving the SN65HVD230 CAN driver chip. See the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 33.333K 1 12 2 120 1 False 86.7% 0.33% 2145M 83.333K 1 13 2 45 1 False 87.5% 0.31% 845M 125K 1 13 2 30 1 False 87.5% 0.31% 545M 250K 1 13 2 15 1 False 87.5% 0.31% 245M 500K 1 12 2 8 1 False 86.7% 0.33% 92M 1M 1 12 2 4 1 False 86.7% 0.33% 18M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested tensure reliability.* Design Considerations Required Pins Exposing the following pins is required in every design to enable device programming, updates, and recovery: LDR0 LDR1 Reset Desired debug interface(s) MODE if required to select a debug interface Power Supply A typical clean power source, suited for digital circuitry, is needed to power the G120. Voltages should be within at least 10% of the needed voltage. Decoupling capacitors of 0.1 F are needed near every power pin. Additionally, a large capacitor, typically 47 F, should be near the G120 if the power supply is more than few inches away. Crystals The G120 and G120E include the needed system crystal and its associated circuitry. The G120E additionally includes the RTC crystal and its associated circuitry. However, the G120 does not. It requires an external 32,768 Hz crystal and circuitry for the RTC to function. Please see the processors documentation for advanced information. Interrupt Pins Only pins on ports 0 and 2 support interrupts. Reset The G120E includes an internal pull-up resistor on the reset pin. The G120 does not, so an external 15 k pull-up resistor is required for correct operation. SPI Channels SPI2 is shared internally with the flash memory on the G120. Use of a chip select with devices on this channel is required or the G120 will not function properly. The use of another SPI channel is recommended. Ethernet The built in Ethernet available on the G120E includes all needed Ethernet circuitry internally. However, an appropriate magnet and connector, like the J0011D or similar, are required. Oven Reflow The G120 is not sealed for moisture. Baking the module before reflow is recommended and required in a humid environment. The process of reflow can damage the G120 if the temperature is too high or exposure is too long. The lead-free reflow profiles used by GHI Electronics are shown below. The profiles are based on AIM SAC 305 solder (3% silver, 0.5% copper). The thermal mass of the assembled board and the sensitivity of the components on it affect the total dwell time. Differences in the two profiles are where they reach their respective peak temperatures as well as the time above liquids (TAL). The shorter profile applies to smaller assemblies, whereas the longer profile applies to larger assemblies such as back-planes or high-density boards. The process window is described by the shaded area. These profiles are only starting-points and general guidance. The particulars of an oven and the assembly will determine the final process. G120 Development Board The G120E Dev Board is an excellent starting point and reference design for anyone interested in evaluating and developing with the G120/G120E. Schematic You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com."
  },
  "hardware/netmf/g30.html": {
    "href": "hardware/netmf/g30.html",
    "title": "G30",
    "keywords": "G30 Overview The G30 SoC is a low-cost System on Chip part of the GHI Electronics SurfaceMount Compute Modules (SCM) line. This modules can be programmed in .NET C# and Visual Basic using .NET Micro Framework. Tip Not recommended for new designs, consider SITCore System on Chip. Ordering Part Number G30 SoC: 30SOC-SC-539 G30 Dev Board: G30DB-SM-555 Specifications Spec Value Processor STM ST32F401RET6 Speed 84 MHz Internal RAM 96 KByte (SRAM) Internal Flash 512 KByte Package LQFP64 10 x 10 mm Temperature Range -40C to +85C Note: Resources are shared between your application and the operating system. Features .NET Micro Framework RoHS Lead Free 84 MHz ARM Cortex-M4 STM32F401RET6 68 KBytes available RAM 128 KBytes available flash 49 GPIO 16 interrupt capable GPIO 2 SPI 1 I2C 2 UART 15 PWM 16 12-bit analog input 4-bit SD/MMC memory card interface Low power modes LQFP64 10 x 10 mm RTC Watchdog Threading USB client File System Full .NET file interface SD cards Native extensions Device register access Signal controls Generation Capture Pulse measurement G30 Pinout Many signals on the G30 are multiplexed to offer multiple functions on a single pin. Developers can decide on the pin functionality to be used through the provided libraries. Any pin with no name, function, or note must be left unconnected. Footprint The chip is standard LQFP64 10x10mm. See the ST32F401RET6 datasheet for exact footprint. Device Startup The G30 is held in reset when the reset pin is low. Releasing it will begin the system startup process. There are three different components of the device firmware: GHI Electronics Bootloader: initializes the system, updates NETMF firmware when needed, and executes NETMF. NETMF Firmware: loads, debugs, and executes the managed application. Managed application: the program developed by the customer. Which components get executed on startup can be control by manipulating the LDR0 pin. It is pulled high on startup. When low, the device waits in the GHI Electronics Bootloader. Otherwise, the managed application is executed. LDR1 is reserved for future use. Additionally, the communications interface between the host PC and the G30 is selected on startup through the MODE pin, which is pulled high on startup. The USB interface is selected when MODE is high and UART1 is selected when MODE is low. The above discussed functions of LDR0, LDR1, and MODE are only during startup. After startup, they return to the default GPIO state and are available to use as GPIO in the user application. .NET Micro Framework NETMF provides a way to program the G30 in C# or Visual Basic from the Microsoft Visual Studio integrated development environment. To get started you must first install the NETMFfirmware (instructions below) and then go to the NETMF Getting Started page for instructions. Loading the Firmware Activate the bootloader, hold the LDR0 signal low while resetting the board. Open FEZ Config tool and follow the instructions. You can also update the firmware manually. See GHI Electronics Bootloader page. Start Coding Now that you have installed the firmware on the G30, you can setup your host computer and start programming. Go to the NETMF Getting Started page for instructions. Datasheet This documentation page replaced the legacy datasheet PDF but it is here for reference. Design Considerations Required Pins Exposing the following pins is required in every design to enable device programming, updates, and recovery: LDR0 LDR1 Reset Desired debug interface(s) MODE if required to select a debug interface Power Supply A typical clean power source, suited for digital circuitry, is needed to power the G30. Voltages should be within at least 10% of the needed voltage. Decoupling capacitors of 0.1 F are needed near every power pin. Additionally, a large capacitor, typically 47 F, should be near the G30 if the power supply is more than few inches away. Crystals The G30 requires an external 12 MHz crystal and associated circuitry to function. For the RTC to function, a 32,768 Hz crystal and circuitry are required. Please see the processors documentation for advanced information. Interrupt Pins Interrupts are only available on 16 pins at any given time. Of those 16 pins, the pin number must be unique. For example: PA1 and PB1 cannot both be used as interrupts at the same time, but PA1 and PB2 can. Reset The reset pin is not pulled in any direction. Designs must be sure to use an appropriate pull-up resistor. G30 Development Board The G30 Dev Board is an excellent starting point and reference design for anyone interested in evaluating and developing with the G30. Schematic You can also visit our main website at main website and our community forum."
  },
  "hardware/netmf/g400d.html": {
    "href": "hardware/netmf/g400d.html",
    "title": "G400D",
    "keywords": "G400D Overview The G400D System on Module (SoM) is a 400 MHz ARM9. It is made just for running .NET Micro Framework. Tip Not recommended for new designs, consider SITCore System on Chip. Ordering Part Number G400D SoM: G400D-SM-400 Specifications Spec Value Processor Atmel AT91SAM9X35 ARM 926 Speed 400 MHz Internal RAM 32 KByte (SRAM) Internal Flash 0 KByte External RAM 128 MByte (DDR2 SDRAM) External Flash 4 MByte (SPI) Dimensions 67.7 x 31.9 x 5.0 mm Note: Resources are shared between your application and the operating system. Peripherals This table lists the available peripherals. The \"overall\" column shows the available pins if the design did not follow the UCM standard. Peripheral UCM Standard Overall UART 1 5 (including HS) UART HS 1 1 I2C 1 1 SPI 1 1 CAN 1 2 SDIO 1 1 ADC 8 8 PWM 4 4 GPIO 12 70 IRQ 4 70 USB Client Supported Supported USB Host 1 2 LCD Supported (16bpp) Supported (16bpp) Ethernet PHY Supported Supported WiFi Not supported Not supported DCMI Not supported Not supported VBAT Supported Supported JTAG Full JTAG Full JTAG Development Options The UCM development options can greatly simplify the process of building a product or prototype using the UC5550. Options include a development board and displays which can get you programming in minutes. .NET Micro Framework (NETMF) The NETMF software on G400 is mature and complete. For more information on NETMF you can go to the NETMF Introduction page. The NETMF Getting Started page covers NETMF from setup of the host computer to program deployment on both an emulator and target device. Bootloader v1 is needed for G400 to work with NETMF. It is available in the NETMF SDK. Loading Bootloader Download the G400 bootloader file and load onto the dataflash using the Microchip (Atmel) SAM-BA tool and the following instructions. To set the chip in SAM-BA mode, hold down the dedicated button on your board (SYS A on UCM Dev and Breakout boards) while the system powers up (or during reset). If there is no such button, connect G400D pin SPI1_MISO to ground. Keep the button pressed (pin grounded) for three seconds after power up or reset, then release the pin. The device manager will show a COM port similar to \"Bossa Program Port\" or \"GPS Detect\". If it is not already installed, download and install the SAM-BA tool from Microchip. The latest version we have tested is 2.18 for Windows. (The tool may not show correctly. Try to make the window larger to see all hidden buttons!) Open the SAM-BA program then select the COM port for your device in the connection box and your board type below it (at91sam9x35-ek for G400), then click connect. Near the middle of the window, go to the DataFlash AT45DB/DCB tab. Under Scripts, select Enable Dataflash (SPI0 CS0) then click the Execute button. Under Scripts, select Erase All then click Execute. This will take some time to complete. It seems that if SAM-BA loses focus during the erase procedure it can seem to lock up. We recommend that once you click the Execute button you leave the computer alone until the erase procedure is completed. Under Scripts, select Send Boot File, click execute, then browse to and select the bootloader for the device. Once the transfer finishes, go to File > Quit and then reset the board. Make sure to properly quit the program or connection errors may result on subsequent uses. Now reset the board. Congratulations, your board is now running the loaded program! Loading the Firmware Activate the bootloader, hold the LDR0 signal (SYS B) low while resetting the board. Open the FEZ Config tool and follow the instructions. You can also update the firmware manually. Download the firmware and learn how to use the GHI Electronics Bootloader manually. Start Coding Now that you have installed the bootloader and firmware, you can setup your host computer and start programming. Go to the NETMF Getting Started page for instructions. Datasheet This documentation page replaced the legacy datasheet PDF but it is here for reference. G400D Pinout Many signals on the G400D are multiplexed to offer multiple functions on a single pin. Developers can decide on the pin functionality to be used through the provided libraries. Any pin with no name, function, or note must be left unconnected. UCM Pinout SO-DIMM Pin UCM Standard Function Name 1 AGND GND 2 Ethernet TX- ETH PHY TX- 3 Module Specific 1 4 Ethernet TX+ ETH PHY TX+ 5 Analog VREF- GND 6 Ethernet RX- ETH PHY RX- 7 Reserved 8 Ethernet RX+ ETH PHY RX+ 9 Reserved 10 Indicator A ETH PHY LED SPEED 11 Indicator B ETH PHY LED LINK 12 Reserved 13 GND GND 14 DCMI D0 15 DCMI D1 16 DCMI D2 17 DCMI D3 18 DCMI D4 19 DCMI D5 20 Analog 3.3V 3.3V 21 DCMI D6 22 DCMI D7 23 DCMI VSYNC 24 DCMI HSYNC 25 DCMI PIXCLK 26 DCMI XCLK 27 GND GND 28 PWM E 29 PWM F 30 PWM G 31 PWM H 32 Analog VREF+ 3.3V 33 Reserved 34 5V 35 Module Specific 4 PB3 36 Module Specific 5 PB4 (DNP) 37 Module Specific 6 PB5 38 Module Specific 7 PB6 39 Module Specific 8 PB7 40 GND GND 41 GND GND 42 LCD 24bpp R0 43 LCD 24bpp R1 44 LCD 24bpp R2 45 LCD 24bpp G0 46 3.3V 3.3V 47 LCD 24bpp G1 48 LCD 24bpp B0 49 LCD 24bpp B1 50 LCD 24bpp B2 51 GND GND 52 Module Specific 9 PB1 53 Reserved 54 Reserved 55 Reserved 56 5V 57 IRQ A PD18 58 IRQ B PD17 59 IRQ C PD16 60 3.3V 3.3V 61 IRQ D PD15 62 GPIO A PD14 63 GPIO B PD13 64 GPIO C PD12 65 GND GND 66 GPIO D PD11 67 GPIO E PD10 68 GPIO F PD9 69 GPIO G PD8 70 5V 71 Reserved 72 3.3V 3.3V 73 I2C B SDA 74 I2C B SCL 75 UART C TX 76 UART C RX 77 UART D TX 78 UART D RX 79 GND GND 80 Reserved 81 Reserved 82 Reserved 83 Reserved 84 Reserved 85 Reserved 86 5V 87 USB Device ID 88 3.3V 3.3V 89 UART B TX 90 UART B RX 91 ADC A PB8, ADC9 92 GPIO H PD2 93 SPI B MISO 94 SPI B MOSI 95 GND GND 96 SPI B SCK 97 ADC B PB11, ADC0 98 CAN A TD PA5, UART3 TX, CAN2 TX 99 CAN A RD PA6, UART3 RX, CAN2 RX 100 CAN B TD 101 CAN B RD 102 UART HS A TX PA0, UART2 TX 103 UART HS A RX PA1, UART2 RX 104 ADC C PB12, ADC1 105 PWM A PC18, PWM0 106 3.3V 3.3V 107 SYS A SPI1 MISO 108 Module Specific 2 SPI1 MOSI 109 Module Specific 3 SPI1 SCK 110 ADC D PB17, ADC6 111 SYS C PA4, LDR1 112 PWM B PC19, PWM1 113 GND GND 114 ADC E PB16, ADC5 115 I2C A SDA PA30, I2C SDA 116 I2C A SCL PA31, I2C SCL 117 UART A RX PA9, UART1 RX, CAN1 RX 118 UART A TX PA10, UART1 TX, CAN1 TX 119 GPIO I PC24 120 UART HS A RTS PA2, UART2 RTS 121 UART HS A CTS PA3, UART2 CTS 122 GPIO J PD7 123 SD Card D0 PA15, SD D0 124 3.3V 3.3V 125 SD Card CMD PA16, SD CMD 126 SD Card CLK PA17, SD CLK 127 SD Card D1 PA18, SD D1 128 SD Card D2 PA19, SD D2 129 SD Card D3 PA20, SD D3 130 PWM C PC21, PWM3 131 GND GND 132 GPIO K PC26 133 PWM D PC20, PWM2 134 SYS B PA24, LDR0 135 SYS D PA25, MODE 136 GPIO L PA26 137 Module Specific 10 PA27 138 UART HS B RTS 139 UART HS B CTS 140 UART HS B TX PC16, UART6 TX 141 UART HS B RX PC17, UART6 RX 142 3.3V 3.3V 143 LCD VSYNC PC27, LCD VSYNC 144 LCD HSYNC PC28, LCD HSYNC 145 LCD CLK PC30, LCD CLK 146 LCD DE PC29, LCD DE 147 Module Specific 11 PD3 148 SD Card CD PD4 149 Module Specific 12 PD5 150 Reserved 151 GND GND 152 LCD B3 PC0, LCD B3 153 LCD B4 PC1, LCD B4 154 LCD B5 PC2, LCD B5 155 LCD B6 PC3, LCD B6 156 LCD B7 PC4, LCD B7 157 ADC F PB13, ADC2 158 ADC G PB14, ADC3 159 ADC H PB15, ADC4 160 3.3V 3.3V 161 LCD G2 PC5, LCD G2 162 LCD G3 PC6, LCD G3 163 LCD G4 PC7, LCD G4 164 LCD G5 PC8, LCD G5, UART5 TX 165 LCD G6 PC9, LCD G6, UART5 RX 166 Module Specific 13 PD1 167 Indicator C PA8, UART4 RX 168 LCD R7 PC15, LCD R7 169 GND GND 170 LCD G7 PC10, LCD G7 171 LCD R3 PC11, LCD R3 172 LCD R4 PC12, LCD R4 173 LCD R5 PC13, LCD R5 174 LCD R6 PC14, LCD R6 175 SPI A SCK PA23, SPI2 SCK 176 SPI A MISO PA21, SPI2 MISO 177 Module Specific 14 WKUP 178 SPI A MOSI PA22, SPI2 MOSI 179 Module Specific 15 SHDN 180 3.3V 3.3V 181 Module Specific 16 PWR EN 182 Module Specific 17 USB H2+ 183 VBAT VBAT 184 Module Specific 18 USB H2- 185 GND GND 186 GND GND 187 RESET RESET 188 USB Host D+ USB H1+ 189 JTAG RTCK RTCK 190 USB Host D- USB H1- 191 JTAG TDO TDO 192 3.3V 3.3V 193 JTAG NTRST NTRST 194 USB Device D+ USB D+ 195 JTAG TDI TDI 196 USB Device D- USB D- 197 JTAG TCK (SWCLK) TCK 198 GND GND 199 JTAG TMS (SWDIO) TMS 200 Indicator D PA7, UART4 TX CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a G400 driving the SN65HVD230 CAN driver chip. See the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 83.333K 7 4 1 99 0 False 87.5% 0.31% 845M 125K 7 1 1 81 0 False 84.6% 0.38% 499M 250K 7 1 1 40 0 False 84.6% 0.38% 222M 500K 7 7 1 13 1 False 89.5% 0.41% 92M 1M 7 7 1 6 1 False 89.5% 0.41% 19M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested to ensure reliability. G400 Development Board This is no longer in production, replaced by the Development Options Schematic Want to quickly build your prototype? Check out the UCM Development Options. You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com."
  },
  "hardware/netmf/g400s.html": {
    "href": "hardware/netmf/g400s.html",
    "title": "G400S",
    "keywords": "G400S Overview The G400S System on Module (SoM) is the surface mount version of the G400D. The G400D can be programmed in .NET C# and Visual Basic using .NET Micro Framework. Tip Not recommended for new designs, consider SITCore System on Chip. Ordering Part Number G400S SoM: G400S-SM-480 Specifications Spec Value Processor Atmel AT91SAM9X35 ARM 926 Speed 400 MHz Internal RAM 32 KByte (SRAM) Internal Flash 0 KByte External RAM 128 MByte (DDR2 SDRAM) External Flash 4 MByte (SPI) Dimensions 48.3 x 33.1 x 4.6 mm Temperature Range -40 C to +85 C Note: Not all memory will be available for your application. Peripherals Note: Many peripherals share I/O pins. Not all peripherals will be available to your application. .NET Micro Framework RoHS Lead Free 400 MHz ARM 9 Atmel SAM9X35 64 MBytes available RAM 1.4 MBytes available flash Embedded LCD controller 89 interrupt capable GPIO 2 SPI 1 I2C 6 UART 2 CAN 4 PWM 12 10-bit analog output 4-bit SD/MMC memory card interface Low power modes RTC Watchdog Threading USB host USB client SQLite database TCP/IP with SSL Full .NET socket interface Ethernet PPP Graphics Images Fonts Controls File System Full .NET file interface SD cards USB drives Native extensions Runtime Loadable Procedures Device register access Signal controls Generation Capture Pulse measurement G400S Pinout Many signals on the G400 are multiplexed to offer multiple functions on a single pin. Developers can decide on the pin functionality to be used through the provided libraries. Any pin with no name, function, or note must be left unconnected. Footprint G400S Recommended Footprint Device Startup The G400 is held in reset when the reset pin is low. Releasing it will begin the system startup process. It is pulled high internally There are four different components of the device firmware: GHI Electronics Bootloader: initializes the system, updates TinyBooter when needed, and executes TinyBooter. TinyBooter: executes NETMF, updates NETMF when needed, and updates the system configuration. NETMF: loads, debugs, and executes the managed application. Managed application: the program developed by the customer. Which components get executed on startup can be control by manipulating the LDR0 and LDR1 pins. LDR0 and LDR1 are pulled high on startup. LDRO LDR1 Effect Ignored High Execute the managed application High Low Wait in TinyBooter Low Low Wait in GHI Electronics Bootloader Additionally, the communications interface between the host PC and the G400 is selected on startup through the MODE pin, which is pulled high on startup. The USB interface is selected when MODE is high and UART1 is selected when MODE is low. The above discussed functions of LDR0, LDR1, and MODE are only during startup. After startup, they return to the default GPIO state and are available to use as GPIO in the user application. .NET Micro Framework (NETMF) The NETMF software on G400 is mature and complete. For more information on NETMF you can go to the NETMF Introduction page. The NETMF Getting Started page covers NETMF from setup of the host computer to program deployment on both an emulator and target device. Bootloader v1 is needed for G400 to work with NETMF. It is available in the NETMF SDK. Loading Bootloader Download the G400 bootloader file and load onto the dataflash using the Microchip (Atmel) SAM-BA tool and the following instructions. To set the chip in SAM-BA mode, hold down the dedicated button on your board (SYS A on UCM Dev and Breakout boards) while the system powers up (or during reset). If there is no such button, connect G400S pin SPI1_MISO to ground. Keep the button pressed (pin grounded) for three seconds after power up or reset, then release the pin. The device manager will show a COM port similar to \"Bossa Program Port\" or \"GPS Detect\". If it is not already installed, download and install the SAM-BA tool from Microchip. The latest version we have tested is 2.18 for Windows. (The tool may not show correctly. Try to make the window larger to see all hidden buttons!) Open the SAM-BA program then select the COM port for your device in the connection box and your board type below it (at91sam9x35-ek for G400), then click connect. Near the middle of the window, go to the DataFlash AT45DB/DCB tab. Under Scripts, select Enable Dataflash (SPI0 CS0) then click the Execute button. Under Scripts, select Erase All then click Execute. This will take some time to complete. It seems that if SAM-BA loses focus during the erase procedure it can seem to lock up. We recommend that once you click the Execute button you leave the computer alone until the erase procedure is completed. Under Scripts, select Send Boot File, click execute, then browse to and select the bootloader for the device. Once the transfer finishes, go to File > Quit and then reset the board. Make sure to properly quit the program or connection errors may result on subsequent uses. Now reset the board. Congratulations, your board is now running the loaded program! Loading the Firmware Activate the bootloader, hold the LDR0 signal low while resetting the board. Open FEZ Config tool and follow the instructions. You can also update the firmware manually. See GHI Electronics Bootloader page. Start Coding Now that you have installed the bootloader and firmware, you can setup your host computer and start programming. Go to the NETMF Getting Started page for instructions. Datasheet This documentation page replaced the legacy datasheet PDF but it is here for reference. CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a G400 driving the SN65HVD230 CAN driver chip. See the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 83.333K 7 4 1 99 0 False 87.5% 0.31% 845M 125K 7 1 1 81 0 False 84.6% 0.38% 499M 250K 7 1 1 40 0 False 84.6% 0.38% 222M 500K 7 7 1 13 1 False 89.5% 0.41% 92M 1M 7 7 1 6 1 False 89.5% 0.41% 19M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested to ensure reliability. Design Considerations Required Pins Exposing the following pins is required in every design to enable device programming, updates, and recovery: LDR0 LDR1 Reset Desired debug interface(s) MODE if required to select a debug interface SPI1 MISO to update TinyBooter in SDK 2015 R1 and earlier and to install the GHI Electronics Bootloader once for SDK 2016 R1 and later Power Supply A typical clean power source, suited for digital circuitry, is needed to power the G400. Voltages should be within at least 10% of the needed voltage. Decoupling capacitors of 0.1 F are needed near every power pin. Additionally, a large capacitor, typically 47 F, should be near the G400 if the power supply is more than few inches away. Additionally, the G400 requires additional voltages beyond the typical 3.3 V to function properly. See the pinout table for details. Crystals The G400 includes the needed system and RTC crystals and their associated circuitry. SPI Channels SPI1 is shared internally with the flash memory on the G400. Use of a chip select with devices on this channel is required or the G400 will not function properly. The use of another SPI channel is recommended. Ethernet The built in Ethernet available on the G400D includes all needed Ethernet circuitry internally. However, an appropriate magnet and connector, like the J0011D or similar, are required. Soldering the G400S The G400S is designed to be easily machine-placed or hand-soldered. Static sensitive precautions should be taken when handling the module. Oven Reflow The G400S is not sealed for moisture. Baking the module before reflow is recommended and required in a humid environment. The process of reflow can damage the G400 if the temperature is too high or exposure is too long. The lead-free reflow profiles used by GHI Electronics are shown below. The profiles are based on AIM SAC 305 solder (3% silver, 0.5% copper). The thermal mass of the assembled board and the sensitivity of the components on it affect the total dwell time. Differences in the two profiles are where they reach their respective peak temperatures as well as the time above liquids (TAL). The shorter profile applies to smaller assemblies, whereas the longer profile applies to larger assemblies such as back-planes or high-density boards. The process window is described by the shaded area. These profiles are only starting-points and general guidance. The particulars of an oven and the assembly will determine the final process. You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com."
  },
  "hardware/netmf/g80.html": {
    "href": "hardware/netmf/g80.html",
    "title": "G80",
    "keywords": "G80 Overview The G80 SoC is a low-cost System on Chip part of the GHI Electronics SurfaceMount Compute Modules (SCM) line. This modules can be programmed in .NET C# and Visual Basic using .NET Micro Framework. Tip Not recommended for new designs, consider SITCore System on Chip. Ordering Part Number G80 SoC: G80SC-SM-501 G80 Dev Board: G80DB-SM-483 Specifications Spec Value Processor STM32F427VGT6 Speed 180 MHz Internal RAM 256 KByte (SRAM) Internal Flash 1 MByte Package LQFP100 14 x 14 mm Temperature Range -40C to +85C Note: Resources are shared between your application and the operating system. Features .NET Micro Framework RoHS Lead Free 180 MHz ARM Cortex-M4 STM32F427VGT6 156 KBytes available RAM 256 KBytes available flash 78 GPIO 16 interrupt capable GPIO 2 SPI 1 I2C 4 UART 2 CAN 26 PWM 16 12-bit analog input 4-bit SD/MMC memory card interface Low power modes LQFP6100 14 x 14 mm RTC Watchdog Threading USB host USB client TCP/IP with SSL Full .NET socket interface Ethernet PPP Graphics Images Fonts Controls File System Full .NET file interface SD cards USB drives Native extensions Runtime Loadable Procedures Device register access Signal controls Generation Capture Pulse measurement G80 Pinout Many signals on the G80 are multiplexed to offer multiple functions on a single pin. Developers can decide on the pin functionality to be used through the provided libraries. Any pin with no name, function, or note must be left unconnected. Footprint The chip is standard LQFP100 14x14mm. See the STM32F427VGT6 datasheet for exact footprint. Device Startup The G80 is held in reset when the reset pin is low. Releasing it will begin the system startup process. There are three different components of the device firmware: GHI Electronics Bootloader: initializes the system, updates NETMF firmware when needed, and executes NETMF. NETMF Firmware: loads, debugs, and executes the managed application. Managed application: the program developed by the customer. Which components get executed on startup can be control by manipulating the LDR0 pin. It is pulled high on startup. When low, the device waits in the GHI Electronics Bootloader. Otherwise, the managed application is executed. LDR1 is reserved for future use. Additionally, the communications interface between the host PC and the G80 is selected on startup through the MODE pin, which is pulled high on startup. The USB interface is selected when MODE is high and UART1 is selected when MODE is low. The above discussed functions of LDR0, LDR1, and MODE are only during startup. After startup, they return to the default GPIO state and are available to use as GPIO in the user application .NET Micro Framework NETMF provides a way to program the G80 in C# or Visual Basic from the Microsoft Visual Studio integrated development environment. To get started you must first install the firmware on the G80 (instructions below) and then go to the NETMF Getting Started page for instructions. Loading the Firmware Activate the bootloader, hold the LDR0 signal low while resetting the board. Open the FEZ Config tool and follow the instructions. You can also update the firmware manually. See GHI Electronics Bootloader manually. Start Coding Now that you have installed the firmware on the G80, you can setup your host computer and start programming. Go to the NETMF Getting Started page for instructions. Datasheet This documentation page replaced the legacy datasheet PDF but it is here for reference. CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a G80 driving the TJA1050T CAN driver chip. See the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 33.333K 1 12 2 90 1 False 86.7% 0.33% 2145M 83.333K 1 12 2 36 1 False 86.7% 0.33% 825M 125K 1 12 2 24 1 False 86.7% 0.33% 531M 250K 1 12 2 12 1 False 86.7% 0.33% 238M 500K 1 12 2 6 1 False 86.7% 0.33% 91M 1M 1 12 2 3 1 False 86.7% 0.33% 18M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested to ensure reliability. Design Considerations Required Pins Exposing the following pins is required in every design to enable device programming, updates, and recovery: LDR0 LDR1 Reset Desired debug interface(s) MODE if required to select a debug interface Power Supply A typical clean power source, suited for digital circuitry, is needed to power the G80. Voltages should be within at least 10% of the needed voltage. Decoupling capacitors of 0.1 F are needed near every power pin. Additionally, a large capacitor, typically 47 F, should be near the G80 if the power supply is more than few inches away. Crystals The G80 requires an external 12 MHz crystal and associated circuitry to function. For the RTC to function, a 32,768 Hz crystal and circuitry are required. Please see the processors documentation for advanced information. Interrupt Pins Interrupts are only available on 16 pins at any given time. Of those 16 pins, the pin number must be unique. For example: PA1 and PB1 cannot both be used as interrupts at the same time, but PA1 and PB2 can. Reset The reset pin is not pulled in any direction. Designs must be sure to use an appropriate pull-up resistor. G80 Development Board The G80 Dev Board is an excellent starting point and reference design for anyone interested in evaluating and developing with the G80. Schematics You can also visit our main website at main website and our community forum."
  },
  "hardware/netmf/intro.html": {
    "href": "hardware/netmf/intro.html",
    "title": "NETMF Modules",
    "keywords": "NETMF Modules These products have matured. They are in full production; however, NETMF software has been replaced by TinyCLR OS 2.0 software and SITCore Modules. Please consider switching ASAP. G30 Learn more... G80 Learn more... G120 / G120E Learn more... G400S Learn more... Upgrading Learn more... You can also visit our main website at main website and our community forum."
  },
  "hardware/netmf/upgrade.html": {
    "href": "hardware/netmf/upgrade.html",
    "title": "Upgrading",
    "keywords": "Upgrading To complement our ten year Longevity Promise, we provide products that are drop in replacements for most of the mature SoMs and chipsets. We strive to keep customers products viable as long as possible with no or minimal changes to hardware. Speed Comparison This table shows the time needed to calculate PI to several digits. Processor Speed OS SC20xxx 1.75 seconds TinyCLR 2.1 G400 3.3 seconds NETMF 4.3 G80 7.6 seconds NETMF 4.3 G30 18 seconds NETMF 4.3 SC13xxx 21 seconds TinyCLR 2.1 G120 29 seconds NETMF 4.3 EMX 74 seconds NETMF 4.3 G30 to SITCore There is currently no LQFP64 package options for SITCore. The recommended replacement is SC13048Q chipset. G80 to SITCore The SITCore SC20100S is LQFP100 with near identical pinout and compatibility with the G80, however it is not a drop-in replacement and some small changes are necessary. The table below provides a pinout comparison. SC20100S to G80 Pinout Map G120 to SITCore The SCM20260N is a drop in replacement for the G120 with the following differences. The following pads/pins on the SCM20260N do not support hardware PWM: Pad 3/pin PK7, pad 23/pin PC10, pad 24/pin PC9, pad 25/pin PC12, pad 26/pin PC8, pad 28/pin PD2, pad 85/pin PI12, and pad 90/pin PI13. SCM20260N pad 80 (PK6/LCD B7) and pad 88 (PJ6/LCD R7) do not have UART TX and RX as found on G120 pads 80 and 88. As this is an LCD pin, this will rarely be an issue. Pad 15 on the SCM20260N (PI2/SPI2 MISO/TIM8 CH4 + PD3/USART2 CTS through a 330 ohm resistor) provides USART CTS connected through a 330 ohm resistor to maintain compatibility with Pad 15 on the G120 (P0.17/UART2 CTS/SPI1 MISO). Serial mode deploying and debugging defaults to UART5 on the SCM20260E versus UART1 on the G120. This is only a concern if serial mode deploying/debugging is needed. G120 IO pins default to pull-ups where on SITCore they are high impedance. SCM20260N to G120 Pinout Map G120E to SITCore The SCM20260E is a drop in replacement for the G120E except for a few differences. To enable serial deployment and debugging, the MOD pin on the SCM20260E is active low, while on the G120E the MODE pin is active high. A minor change will be needed to correct the MOD level and select the desired debugging interface. Serial mode deploying and debugging defaults to UART5 on the SCM20260E versus UART1 on the G120E. This is only a concern if serial mode deploying/debugging is needed. SCM20260E pad 57 (PD3/UART2 CTS) does not have PWM as on G120E pad 57 (P3.18/UART2 CTS/PWM2). SCM20260E pad T5 (PJ6/LCD R7) does not have UART RX as on G120E pad T5 (P2.9/LCD R4/UART5 RX). As this is an LCD pin, this will rarely be an issue. SCM20260E pad T16 (PJ6/LCD R7) does not have UART TX as on G120E pad T16 (P1.29/LCD B4/UART5 TX). As this is an LCD pin, this will rarely be an issue. SD Power pin is not available. Instead, there is regular GPIO pin. G120E IO pins default to pull-ups where on SITCore they are high impedance. SCM20260E to G120E Pinout Map G400S to SITCore There is no drop-in replacement for the G400S. The recommended replacement is the SCM20260E, which has considerably more horsepower and available resources. G400D to SITCore Our SCM20260D is a drop in replacement for the G400D, with just a couple of differences that will rarely be an issue. SCM20260D pins 164 and 165 do not provide UART TX and RX as on the G400D. As these are LCD pins, this will rarely be an issue. There is no second USB host controller on the SITCore SCM20260D pins 182 and 184 as there is on the G400D. SCM20260D to G400D Pinout Map UC2550 and UC5500 to SITCore The recommended replacement, the SCM20260D, is close, but not completely compatible with the UC2550 and UC5550. Some PCB changes will be needed."
  },
  "hardware/netmf/usbizi.html": {
    "href": "hardware/netmf/usbizi.html",
    "title": "USBizi",
    "keywords": "USBizi USBizi was the first single chip .NET Micro Framework (NETMF) on the market. It was available in 100pin and 144pin LQFP packages. We are no longer selling this chipset but we are making all bootloader binaries available for free, including for commercial use. To use with NETMF, follow these setup instructions. Requires the NETMF 4.1 SDK. Resources User Manual USBizi DevSys The original development board for USBizi. Schematic"
  },
  "hardware/raspberrypi-hats.html": {
    "href": "hardware/raspberrypi-hats.html",
    "title": "Raspberry Pi Hats",
    "keywords": "Raspberry Pi Hats Several HATs were made for the RPI. The software was focused on the use of Win10. This GitHub repo includes the software for all HATs. FEZ HAT Schematic FEZ ProtoPi Schematic FEZ Utility Schematic FEZ Cream This HAT was part of the Gadgeteering efforts. Schematic Visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com."
  },
  "hardware/sitcore/dev.html": {
    "href": "hardware/sitcore/dev.html",
    "title": "SITCore Dev Boards",
    "keywords": "SITCore Dev Boards We offer three development boards making it possible to start programming applications within minutes without designing or building new hardware. These boards are not only suitable for prototypes, but for short production runs as well. SITCore SC13048Q Dev Board The SC13048Q Dev Board includes an SC13048Q soldered to the board and a built in 1.8 inch color serial display. It has a 10 pin socket header for connecting peripherals. Peripheral connectors include mikroBus connector, external power, CAN, USB host and client and RTC backup supercap. It also has a buzzer, LEDs, a reset button, and user programmable boot buttons. To start development using the SC13048Q Dev Board, just connect the board's USB Client port to a host computer using a USB-C cable. Go to the Getting Started page in the TinyCLR section of the documentation page for further instructions. The board can be powered through either the USB client connectors or the barrel jack. Always use the barrel jack for power when using the display. USB does not provide sufficient power needed for displays. SC13048Q Dev Board Schematic SC13048Q Dev Board 3D STEP File Note All boards with a barrel power jack accept a 5.5 x 2.1 mm power plug. The pin is positive, the sleeve is negative. Note SC13048 Dev board uses linear voltage regulators that run hotter with higher input voltages. Generally we recommend an input voltage of 6 to 12 volts, but if your project draws a lot of current, use a lower voltage to keep the regulator cooler. SITCore SC20100S Dev Board The SC20100S Dev Board includes an SC20100S soldered to the board and a built in 1.8 inch color serial display. It has a 40 pin socket headers for connecting peripherals. Peripheral connectors include two mikroBus connectors, external power, CAN, USB host and client, RTC supercap and an SD card slot. It also has a buzzer, LEDs, a reset button, and user programmable boot buttons. To start development using the SC20100S Dev Board, just connect the board's USB Client port to a host computer using a USB-C cable. Go to the Getting Started page in the TinyCLR section of the documentation page for further instructions. The board can be powered through either the USB client connectors or the barrel jack. Always use the barrel jack for power when using displays, especially the larger ones. USB does not provide sufficient power needed for displays. SC20100S Dev Board Schematic SC20100S Dev Board 3D STEP File Note All boards with a barrel power jack accept a 5.5 x 2.1 mm power plug. The pin is positive, the sleeve is negative. SITCore SCM20260D Dev Board The SCM20260D Dev Board is the fastest and easiest way to start developing with the SCM20260D. This board includes an SCM20260D DIMM module and a 4.3 inch capacitive touch display. It provides standard connectors for input/output, and two 40 pin socket headers for connecting peripherals and a display. Peripheral connectors include two mikroBus connectors, external power, Ethernet, CAN, USB host and client, RTC supercap, DCMI interface and an SD card slot. It also has a buzzer, LEDs, a reset button, and user programmable boot buttons. To start development using the SCM20260D Dev Board, just install the module on the board, plug in the display (if needed), and connect the board's USB Client port to a host computer using a USB-C cable. Go to the Getting Started page in the TinyCLR section of the documentation page for further instructions. The board can be powered through either the USB client connectors or the barrel jack. Always use the barrel jack for power when using displays, especially the larger ones. USB does not provide sufficient power needed for displays. SCM20260D Dev Board Schematic SCM20260D Dev Board 3D STEP File Note All boards with a barrel power jack accept a 5.5 x 2.1 mm power plug. The pin is positive, the sleeve is negative. SC20260 Dev Display Options One of the headers on the SCM20260 Dev board includes all necessary parallel display signals. It also includes I2C and a couple of GPIOs allowing for support of capacitive touch panels. Out-of-the-box, the SCM20260 Dev board includes a 4.3\" display with capacitive touch. A 7\" display is also available. UD435 Display Adaptor This display is included with the SCM20260D Dev board. Display Module: ER-TFT043-3 Touch Panel: ER-TPC043-2 4.3\" Display Module Schematic This display module has a 4.3\" 480x272 TFT display with a capacitive touch screen. It plugs directly into the SCM20260D Dev Board and uses I2C1 for capacitive touch and PJ14 for the touch interrupt. The backlight is controllable through PA15. The TinyCLR Samples repo has usage examples. You can learn more in the Graphics and Display sections of the TinyCLR tutorials. See below for the display configuration values: Property Value Width 480 Height 272 DataFormat RGB56 Pixel Clock Rate 8_000_000 <= x <= 24_000_000 //MHz Pixel Polarity low DataEnable Is Fixed false DataEnable Polarity low Horizontal Back Porch 46 Horizontal Front Porch 16 Horizontal Sync Polarity low Horizontal Sync Pulse Width 1 Vertical Back Porch 23 Vertical Front Porch 7 Vertical Sync Polarity low Vertical Sync Pulse Width 1 UD700 Display Adaptor This display is a special order option. Contact Us. Display Module: ER-TFT070A2-4 Touch Panel: ER-TPC07-4 7\" Display Module Schematic This display module has a 7\" 800x480 TFT display with a capacitive touch screen. It plugs directly into the SCM20260D Dev Board and uses I2C1 for capacitive touch and PJ14 for the touch interrupt. The backlight is controllable through PA15. The TinyCLR Samples repo has usage examples. You can learn more in the Graphics and Display sections of the TinyCLR tutorials. See below for the display configuration values: Property Value Width 800 Height 480 DataFormat RGB565 Pixel Clock Rate 8_000_000 <= x <= 24_000_000 //MHz Pixel Polarity false DataEnable Is Fixed false DataEnable Polarity low Horizontal Back Porch 46 Horizontal Front Porch 16 Horizontal Sync Polarity false Horizontal Sync Pulse Width 1 Vertical Back Porch 23 Vertical Front Porch 7 Vertical Sync Polarity false Vertical Sync Pulse Width 1 HDMI Adaptor This optional HDMI adaptor can be used instead of the display to provide an HDMI option. The board utilizes TI's TFP410 HDMI transmitter chip. A NuGet driver library is provided as well. The driver automatically sets all the configuration internally. var hdmi = new TFP410Controller(i2cController, Resolution.HD720p, DisplayOrientation.Degrees0, resetPin); displayController.SetConfiguration(hdmi.Configuration); SITCore HDMI Adaptor Schematic SC20260 Dev Camera Options The SC20260 SoC and its related SoMs include a parallel Digital Camera Interface. The Dev Board exposes the camera signals on a dedicated header. While any compatible display can be connected, the pinout matches the popular OV9655 breakout board, available from many sources around the web and shown below: It is important to note that some of these breakout boards ship with voltage regulators that don't seem to work properly, while others work well. Please understand that these are just our observations -- we cannot guarantee the functionality or quality of any third party products. Here are images of OV9655 modules where one works and the other doesn't. The good modules have regulators labeled \"3DB8N\" and \"3Cb2b:\" . The bad modules have voltage regulators labeled \"2EB2S\" and \"3AB2I:\" Demo Program The SITCore SCM20260D Dev Board ships with a demonstration program that can be found on our TinyCLR-Samples GitHub repository. USB-C Functionality All SITCore single board computers use a USB-C connector for application deployment and debugging. While USB-C has many advantages, we've also noticed some flaws. Every USB-A to USB-C cable tested worked as expected. Testing USB-C to USB-C cables gave interesting and unexpected results. Most USB-C hubs also do not work when using USB-C to USB-C cables. If you are having problems deploying or debugging, try connecting the board directly to your computer with a USB-A to USB-C cable. You can visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com."
  },
  "hardware/sitcore/getting-started.html": {
    "href": "hardware/sitcore/getting-started.html",
    "title": "Getting Started",
    "keywords": "Getting Started SITCore product family runs TinyCLR OS. See TinyCLR OS Getting Started page and the TinyCLR Tutorials for details."
  },
  "hardware/sitcore/intro.html": {
    "href": "hardware/sitcore/intro.html",
    "title": "SITCore",
    "keywords": "SITCore The SITCore line of products provides an easy way to create secure IoT and embedded devices that are programmable in C# using Visual Studio, thanks to TinyCLR OS. Designed with security as a top priority, your intellectual property is protected through device code protection, secure encrypted in-field and OTA update, and secure booting. Getting Started Get started quickly with SITCore and TinyCLR OS. Learn More... System on Chip Secure IoT chips that run C# and support debugging over USB. Learn More... System on Modules Available as a surface mount module and a 200 pin SO-DIMM module. Learn More... Development Boards Get started quickly with one of our development boards -- you'll be programming in minutes! Learn More... Single Board Computers Our single board computers provide the lowest barrier of entry to the world of TinyCLR OS Learn More... The SITCore product family is empowered by TinyCLR OS, which lets you program your devices in C# or Visual Basic using Microsoft's Visual Studio -- and the development tools are free! Learn more.... You can also visit our main website at main website and our community forum."
  },
  "hardware/sitcore/sbc.html": {
    "href": "hardware/sitcore/sbc.html",
    "title": "Single Board Computers",
    "keywords": "Single Board Computers We offer multiple single board computers to provide the lowest possible barrier to entering the world of TinyCLR OS. Most of these boards have WiFi and they all support the complete TinyCLR feature set. These boards are great for trying out TinyCLR OS, building prototypes, or incorporating into products. Specifications and Peripherals FEZ Flea FEZ Pico FEZ Feather FEZ Stick FEZ Bit Fez Duino Fez Portal Core SC13048Q SC13048Q SC20100S SC20100S SC20100S SC20100S SC20260N External SDRAM X X X X X X 32 MByte External Flash X X X X X 16 MByte 16 MByte Display X X X X 1.8\" 160x128 X 4.3\" 480x272 Cap. Touch Click Connectors X X X 2 X X 1 WiFi X X Yes X Yes Yes Yes Micro SD X X X X Yes Yes Yes User LED Yes Yes Yes Yes Yes Yes Yes Buzzer X X X X Yes X Yes Accelerometer X X X X Yes X X User Buttons X X Yes Yes Yes Yes Yes USB Client Yes Yes Yes Yes Yes Yes Yes USB Host Connector X X X Yes X Yes Yes LiPo Charger X X Yes X X X X Power Barrel X X X X X Yes X GPIO 11 26 31 33 19 38 45 SPI 1 2 2 2 1 2 3 I2C 2 1 1 2 1 2 1 UART 3 (1 w/ HS) 3 (1 w/ HS) 5 (1 w/ HS) 2 (0 w/ HS) 3 (0 w/ HS) 5 (2 w/ HS) 6 (1 w/ HS) CAN X 1 1 1 1 1 2 PWM 4 7 8 6 8 12 17 ADC 6 6 6 3 8 11 10 DAC 2 2 1 X 1 2 2 SD/SDIP/MMC X X 1 1 1 1 1 Note: As many pins share peripherals, not all peripherals will be available. Power Consumption The 'Running' power consumption totals include all other on board components, such as WiFi & Display. FEZ Flea/Pico Power 80MHz 40MHz Running 12.6mA 7.5mA Idle 6.2mA 4.2mA Sleep 1.4mA 1.4mA Shutdown 23uA 23uA FEZ Duino/Stick/Feather Power 480MHz 240MHz Running 205mA 110mA Idle 170mA 97mA Sleep 6.5mA 6.5mA Shutdown 40uA 40uA Tip Enabling WiFi (when available) adds up to 300mA. Battery charging on FEZ Feather adds up to 500mA. FEZ Bit Power 480MHz 240MHz Running 232mA 140mA Idle 190mA 127mA Sleep 8.5mA 8.5mA Shutdown 90uA 90uA Tip Display backlight is included when Running and in Idle, but off in Sleep and Shutdown. Tip Enabling WiFi adds up to 300mA. FEZ Portal Power 480MHz 240MHz Running 375mA 345mA Idle 270mA 255mA Sleep 17mA 17mA Shutdown 9.7mA 9.7mA Tip Display backlight is included when Running and in Idle, but off in Sleep and Shutdown. Tip Enabling WiFi adds up to 300mA. See the Power Management tutorial USB-C Functionality All SITCore single board computers use a USB-C connector for application deployment and debugging. While USB-C has many advantages, we've also noticed some flaws. Every USB-A to USB-C cable tested worked as expected. Testing USB-C to USB-C cables gave interesting and unexpected results. Most USB-C hubs also do not work when using USB-C to USB-C cables. If you are having problems deploying or debugging, try connecting the board directly to your computer with a USB-A to USB-C cable. FEZ Flea The FEZ Flea is the most cost effective way to dive into TinyCLR OS. With it's Seeeduino Xiao form factor it can be used with many existing accessories on the market. The board also has castellated and through-hole pins. Making it ideal for using as a SoM or on a breadboard. FEZ Flea Schematic FEZ Flea STEP file FEZ Flea Peripheral Pin User LED PA8 Button LDR = PC13 FEZ Pico The FEZ Pico uses the Raspberry Pi Pico form factor allowing it drop into existing Pico accessories. The FEZ Pico adds JST connector compatible with Sparkfun Qwiic modules and Adafruit STEMMA modules. This allows for easy expandability. FEZ Pico Schematic FEZ Pico STEP file FEZ Pico Peripheral Pin User LED PA8 Button LDR = PC13 FEZ Feather The Adafruit Feather form factor boards are made to be stackable and have built-in support for 3.7V LiPo batteries with a charging circuit. The FEZ Feather provides both through hole pads and castellated edges making it both breadboard friendly and easy to build into products. Caution Lithium Polymoer(Li-Po) batteries are significantly more volatile than other rechargable batteries. Make sure you have an understanding of how to properly charge and use them before connecting to the FEZ Feather. Never attempt to charge a damaged or swollen battery. Never leave battery charging unattended. Improper use could result in fire. Warning Be very careful to ensure the correct polarity of LiPo batteries before connecting them to the FEZ Feather. Reverse polarity will damage the charging circuit, and not all batteries are wired correctly. GHI Electronics is not responsible for, and will not warranty, damage caused by incorrectly connected batteries. Make sure the battery polarity is correct as shown below (red wire to plus, black to minus): Caution The 3.3v regulator may run hot, especially when WiFi is in use. You can add 3.3V regulator externally to eliminate this heat issue, and this is needed if adding any external components that draw more than 10mA. FEZ Feather Schematic FEZ Feather 3D STEP File FEZ Feather Peripheral Pins User LED PE11 WiFi SPI = SPI3 IRQ = PB12 CS = PD15 EN = PA8 RST = PB13 Buttons LDR = PE3 APP = PB7 FEZ Stick The FEZ Stick is a cost effective way to easily get started with TinyCLR OS. While providing an inexpensive way for the uninitiated to try TinyCLR OS, we've provided castellated edges as well as through hole pads to make it breadboard friendly and easy to embed into products. Also, there's actually space for two click modules, making this a very versatile board at a very affordable price! Note FEZ Stick REV. B pin PB13 MISO is mislabeled on the silk screen and should read PE13 MISO Caution The onboard 3.3v regulator is only capable of running external components of an additional 50mA. If more current is necessary, then add an additional external 3.3V regulator. FEZ Stick Schematic FEZ Stick 3D STEP File FEZ Stick Peripheral Pins User LED PE11 Buttons LDR = PE3 APP = PB7 FEZ Bit The FEZ Bit, while seemingly more of a \"maker\" board, provides a convenient way to easily use the multitude of inexpensive Micro:bit accessories that have flooded the market. As the number of Micro:bit accessories continues to grow, this board will be valued as a way to use these accessories to quickly assemble prototypes and test new product concepts. Caution The 3.3v regulator may run hot, especially when WiFi is in use. You can add 3.3V regulator externally to eliminate this heat issue, and this is needed if adding any external components that draw more than 10mA. FEZ Bit Schematic FEZ Bit 3D STEP File FEZ Bit Peripheral Pins User LED PE11 Buzzer PB1 Accelerometer I2C = I2C1 SPI Display SPI = SPI4 BL = PA15 CS = PD10 RS = PC4 RST = PE15 WiFi SPI = SPI3 IRQ = PB12 CS = PD15 EN = PA8 RST = PB13 Buttons LDR = PE3 APP = PB7 UP = PE4 DOWN = PA1 A = PE5 B = PE6 Edge Connector P0 = PC6 (PC2 Analog) P1 = PC7 (PA3 Analog) P2 = PA0 P3 = PB0 P4 = PA4 P5 = PD13 P6 = PD12 P7 = PD11 P8 = PE8 P9 = PC3 P10 = PC0 P11 = PD1 P12 = PD0 P13 = PA5 P14 = PA6 P15 = PA7 P16 = PE7 P19 = PB8 P20 = PB9 Note All boards with a barrel power jack accept a 5.5 x 2.1 mm power plug. The pin is positive, the sleeve is negative. While these boards accept a wide voltage range, they use linear voltage regulators that run hotter with higher input voltages. Generally we recommend an input voltage of 6 to 12 volts, but if your project draws a lot of current, use a lower voltage to keep the regulator cooler. A one amp power supply should provide enough current for most needs. FEZ Duino The FEZ Duino provides female headers that make use of the popular Arduino pinout. Once again, we are trying to make it as easy and inexpensive as possible to build prototypes and try out new concepts by taking advantage of an existing accessory ecosystem. FEZ Duino Schematic FEZ Duino 3D STEP File FEZ Duino Peripheral Pins User LED PE11 WiFi SPI = SPI3 IRQ = PB12 CS = PD15 EN = PA8 RST = PB13 Buttons LDR = PE3 APP = PB7 Warning FEZ Duino REV. A & B, The cap used on barrel jack is 6.3v but the input voltage can be as high as 12v. Use the barrel jack at your own risk or replace cap with a higher voltage. This only effects the power barrel jack. Everything else functions as expected if using USB for power. FEZ Portal Already one of our most popular SITCore single board computers, The FEZ Portal is a 4.3\" 480x272 display with capacitive touch that is programmable in C#. As the display and controller are one unit, it's even easier to make a product with touch as you only have to mount a single board that's only slightly larger than the display. Display uses part# ER-TFT043-3 available at buydisplay.com Note I2C address on touch screen controller is 0x38. Use software I2C if a device has same address need to be connected. FEZ Portal Schematic FEZ Portal 3D STEP File FEZ Portal Peripheral Pins User LED PB0 Buzzer PB1 Display BL = PA15 Touch I2C = I2C1 Touch I2C Address = 0x38 Touch IRQ = PG9 WiFi SPI = SPI3 IRQ = PF10 CS = PA6 EN = PA8 RST = PC3 Buttons LDR = PE3 APP = PB7"
  },
  "hardware/sitcore/soc.html": {
    "href": "hardware/sitcore/soc.html",
    "title": "SITCore System on Chip",
    "keywords": "SITCore System on Chip Overview The SITCore SoCs provide a low cost way to add .NET computing power to any embedded product. Available as either a 48 pin QFN, a 100 pin LQFP or a 265 ball BGA, the SITCore SoCs let you design IoT products that are secure, easily integrated with the cloud, and can be easily manage and updated from the cloud for deployments of one to a million or more. SC20xxx Features Low power modes including three independently controllable power domains RTC Watchdog Threading TCP/IP with SSL Full .NET socket interface Ethernet PPP Graphics Images Fonts Controls File System Full .NET file interface SD cards USB drives Native extensions Runtime Loadable Procedures Device register access Signal controls Generation Capture Pulse measurement SC13xxx Features All core OS features, like threading and memory management, are fully supported. Security is still an important part of the offer, with secure assemblies and secure storage. A subset of the crypto libraries is also included. All pin level features are supported, like PWM, ADC and the Signal Generators. SPI, UART, CAN, and I2C are also supported. Full USB Client support, with WebUSB and WinUSB. There are some missing features that are not typically needed on micro-sized devices, but you still have options. Graphics: No native support but BasicGraphics library provides an alternative. In fact, the development board includes a color TFT SPI display. File System: No native file system support but ManagedFileSystem library is a full FAT implementation that supports file/directory access on SD cards over SPI bus. Networking: SC20 is still the proper way to access networks securely. However, Wiznet W5500 Ethernet chipset and ESP32 WiFi module can be used as an alternative. Specifications Spec SC13048Q SC20100S/B SC20260B Core ARM Cortex-M4 32 bit ARM Cortex-M7 32 bit ARM Cortex-M7 32 bit Speed 80 MHz 480 MHz 480 MHz Math Co-processor Single-precision Double-precision Double-precision Internal RAM 160K 1 MByte 1 MByte User RAM 128K 512K 512K + 32MB optional external Internal Flash 512K 2 MByte 2 MByte User Flash 220K + 8MB optional external 640K + 8MB optional external 640K + 8MB optional external Instruction Cache None 16 KByte 16 KByte Data Cache None 16 KByte 16 KByte Package 48-QFN 7 x 7 mm S/ LQFP100 14 x 14 mm 265-TFBGA 14 x 14 mm B/ 100-TFBGA 8 x 8 mm Temperature Range -40C to +85C -40C to +85C -40C to +85C Note Resources are shared between your application and the operating system.* Peripherals Peripheral SC13048Q SC20100S/B SC20260B GPIO 37 74 163 SPI 2 3 3 I2C 2 2 3 UART 4 (2 with handshaking) 8 (4 with handshaking) 8 (4 with handshaking) CAN 1 2 2 PWM 10 16 29 ADC 10 12 21 DAC 1 2 2 SD/SDIP/MMC 0 1 1 Quad SPI 1 1 1 USB Host 0 1 1 USB Client 1 1 1 Ethernet 0 1 1 LCD TFT 0 0 1 Graphics BasicGraphics via SPI Full Graphics via SPI 16BPP TFT Camera 0 0 1 Note As many pins share peripherals, not all peripherals will be available.* SC20xxx Power Consumption 480MHz 240MHz Running 205mA 110mA Idle 170mA 97mA Sleep 6.5mA 6.5mA Shutdown 40uA 40uA SC13xxx Power Consumption 80MHz 40MHz Running 12.6mA 7.5mA Idle 6.2mA 4.2mA Sleep 1.4mA 1.4mA Shutdown 23uA 23uA See the Power Management tutorial Operational Voltage Levels Voltage Range SC13xxx 1.71V ~ 3.6V SC20xxx 1.62V ~ 3.6V Note Keep in mind that modules (SOM) may have other components that needs higher voltage, like QSPI and SDRAM. Those need to be accounted for. Using Interrupts (IRQs) The microcontrollers we use in our SITCore line of products do not support concurrent interrupts with the same pin number, even if the pins are on different ports (the port is denoted by the second letter of the GPIO pin name -- PA1 is pin 1 on port A). Therefore, interrupts are available on only 16 pins at any given time. For example, pins PA1 and PB1 cannot be used as interrupt pins at the same time, but PA1 and PB2 can. PA1 and PA2 can also be used with interrupts simultaneously. Pinouts GPIO pins are rated is 20mA per pin, 140mA total on all pins, and 5 volt tolerant. SC13048Q Pinout SC20100S/B Pinout SC20260B Pinout Device Startup The SITCore is held in reset while the RESET pin is low. Releasing RESET will begin the system startup process. There are three different components of the device firmware: GHI Electronics Bootloader: initializes the system, updates TinyCLR when needed, and executes TinyCLR. TinyCLR: used to load, debug, and execute the managed application. Managed application: the program developed by you or your software developer. Which components get executed on startup is controlled by manipulating the LDR pin. It is pulled high on startup during normal program execution. When low, the device waits in the GHI Electronics Bootloader. Otherwise, the managed application is executed. The APP pin is used to stop the managed application from running. Additionally, the communications interface between the host PC and the SITCore is selected on startup through the MOD pin, which is pulled high on startup. The USB interface is selected when MOD is high and UART1 is selected when MOD is low. The above discussed functions of the LDR, APP, and MOD pins are only available during startup. After startup, the pins return to the default GPIO state and are available as a GPIO (or peripheral pin) in your application. Check out the Special Pins page for more information. TinyCLR OS TinyCLR OS provides a way to program the SITCore in C# from the Microsoft Visual Studio integrated development environment. To get started you must first install the firmware on the SITCore (instructions below) and then go to the TinyCLR Getting Started page for instructions. Loading the Firmware Activate the bootloader, hold the LDR signal low while resetting the board. Open TinyCLR Config tool. Select the correct COM port and 'Connect' to the device. If you are not seeing it then the device is not in the loader mode. Download the firmware. Select the downloaded firmware in TinyCLR Config and click 'Update Firmware'. You can also update the firmware manually. Download the firmware and learn how to use the GHI Electronics Bootloader manually Start Coding Now that you have installed the bootloader and firmware on the SITCore, you can setup your host computer and start programming. Go to the TinyCLR Getting Started page for instructions. Design Considerations Footprints This is the recommended footprint for the SC13048Q: This is the recommended footprint for the SC20100S: This is the recommended footprint for the SC20100B: This is the recommended footprint and PCB design rules for the SC20260B: Required Pins Exposing the following pins is required in every design to enable device programming, updates, and recovery: RESET LDR APP MOD (required to select a the debug interface) Desired debug interface(s) (see below) For information on these and other important pins, please refer to the Special Pins page. Debug Interface All SITCore products provide two debug and deployment interfaces: USB and serial. Whether USB or serial debugging is selected is determined by the state of the MOD pin during startup and reset. If the MOD pin is held high during startup, the USB debug interface will be selected. If the MOD pin is held low during startup, the serial debug interface will be selected. When in serial mode, all SITCore products use UART1 except SC20260B chipset/boards use UART5. Power Supply A clean power source, suitable for digital circuitry, is needed to power SITCore SoCs. Voltages should be regulated to within 10% or better of the specified voltage. Decoupling capacitors of 0.1 uF are needed near every power pin. Additionally, a large capacitor, typically 47 uF, should be placed near the SoC if the power supply is more than few inches away. Analog Considerations It is a good idea to provide a separate filtered supply line for the Vdda, and Vref+ pins. Additionally, on the 260 pin devices, you may want to provide a separate filtered ground connection for the Vssa and Vref- pins. While this is not needed for ADC operation, it does help to ensure more accurate ADC readings by reducing analog supply noise. Crystals There is a lot to consider when selecting a crystal -- especially the RTC crystal. Please consult AN2867 from STMicroelectronics. Main Crystal Most 8 MHz quartz crystals and ceramic resonators from various manufacturer will work with SITCore SoCs. The table below will tell you what to look for based on the crystal's maximum equivalent series resistance (ESR), shunt capacitance (C0), and load capacitance (CL). Keeping the total capacitance of C0 + CL well below the recommended maximum will provide more of a safety margin for stable and reliable oscillator operation. The SITCore SC13048 SoC main clock can also operate using an internal oscillators, with no need for any crystals, even when using USB. If an application requires better accuracy, like when running CAN for example, an external oscillator can be added. Max crystal ESR (ohms) Recommended max total of C0 and CL (pF) 40 49 50 44 60 40 70 37 80 35 100 31 200 22 300 18 RTC Crystal It can be difficult to select the right RTC crystals, that is due to the RTC oscillator running on an extremely low power. The table below should help. For reliable operation, the total capacitance of C0 (crystal shunt capacitance) and CL (crystal load capacitance) must be less than the recommended max total of C0 and CL. The SITCore SC13048 SoC built in RTC can also operate using an internal oscillator when a 32.768Khz crystals is not present, however adding an external crystal gives better RTC accuracy. Max crystal ESR (kilohms) Recommended max total of C0 and CL (pF) 30 9.9 40 8.5 50 7.6 60 7.0 70 6.5 80 6.0 90 5.7 100 5.4 When laying out your board, it is best to keep the crystal as close as possible to the SoC. The oscillator circuit should also be surrounded by a grounded guard ring or ground plane on the same layer to reduce noise. RTC Power The VBAT pin is optionally used to power up the RTC when the system main power is turned off. Also, SITCore chipsets and modules include a built in charging circuit internally, that can be enabled to charge an external supercap. See the RTC tutorial for further details. QuadSPI External Flash SITCore supports 16 MByte external QuadSPI flash chips. The options are in the table below. Manufacture Part Number Winbond Electronics W25Q128JVSIM Winbond Electronics W25Q128JVSIQ Reset SITCore processors have a permanent internal pull up resistor that is connected to the RESET (NRST) pin. No external pull up resistor is needed. Oven Reflow Profile SITCore SoCs are not sealed for moisture. Baking SoCs before reflow is recommended and required in a humid environment. The process of reflow can damage the SoC if the temperature is too high or exposure is too long. The lead-free reflow profiles used by GHI Electronics are shown below. The profiles are based on AIM SAC 305 solder (3% silver, 0.5% copper). The thermal mass of the assembled board and the sensitivity of the components on it affect the total dwell time. Differences in the two profiles are where they reach their respective peak temperatures as well as the time above liquids (TAL). The shorter profile applies to smaller assemblies, whereas the longer profile applies to larger assemblies such as back-planes or high-density boards. The process window is described by the shaded area. These profiles are only starting-points and general guidance. The particulars of the oven and the assembly will determine the final process. SITCore Dev Boards The SITCore development boards are ready to get any project started as quickly and easily as possible. Click here for details."
  },
  "hardware/sitcore/som.html": {
    "href": "hardware/sitcore/som.html",
    "title": "SITCore System on Modules",
    "keywords": "SITCore System on Modules Overview The SITCore SoMs provide a low cost way to add .NET computing power to any embedded product. They are available in a 200 pin SO-DIMM format or as surface mount modules. The SITCore SoMs let you design IoT products that are secure, easily integrated with the cloud, and can be easily managed and updated from the cloud for deployments of one to a million or more. The surface mount versions are great for harsh or high vibration environments. Features Low power modes including three independently controllable power domains RTC Watchdog Threading TCP/IP with SSL Full .NET socket interface Ethernet PPP Graphics Images Fonts Controls File System Full .NET file interface SD cards USB drives Signal controls Generation Capture Pulse measurement Specifications Spec All SITCore SoMs Processor Type ARM Cortex-M7 32 Bit Speed 480 MHz Internal RAM 1 MByte Internal Flash 2 MByte Instruction Cache 16 KByte Data Cache 16 KByte Temperature Range -40C to +85C Note: Resources are shared between your application and the operating system. Peripherals Peripheral SCM20100E SCM20260N SCM20260E SCM20260D External SDRAM None 32 MByte 32 MByte 32 MByte External Flash None 16 MByte 16 MByte 16 MByte GPIO 43 79 85 108 SPI 2 3 3 3 I2C 1 1 3 3 UART 4 (2 w/ H.S.) 7 (4 w/ H.S.) 8 (4 w/ H.S.) 8 (4 w/ H.S.) CAN 1 2 2 2 PWM 12 22 23 28 ADC 6 16 15 20 DAC 2 2 1 2 SD/SDIP/MMC 1 1 1 1 USB Host 1 1 1 1 USB Client 1 1 1 1 Ethernet 1 0 1 1 LCD TFT 0 1 1 1 Camera 0 1 1 1 Note: As many pins share peripherals, not all peripherals will be available. Power Consumption SCM20260D/E 480MHz 240MHz w/ Ethernet Running 205mA 110mA +90mA Idle 170mA 97mA +90mA Sleep 6.5mA 6.5mA +18mA Shutdown 40uA 40uA +18mA SCM20260N 480MHz 240MHz Running 205mA 110mA Idle 170mA 97mA Sleep 6.5mA 6.5mA Shutdown 1.4mA 1.4mA SCM20100E 480MHz 240MHz w/ Ethernet Running 205mA 110mA +90mA Idle 170mA 97mA +90mA Sleep 6.5mA 6.5mA +18mA Shutdown 40uA 40uA +18mA See the Power Management tutorial Using Interrupts (IRQs) The microcontrollers we use in our SITCore line of products do not support concurrent interrupts with the same pin number, even if the pins are on different ports (the port is denoted by the second letter of the GPIO pin name -- PA1 is pin 1 on port A). Therefore, interrupts are available on only 16 pins at any given time. For example, pins PA1 and PB1 cannot be used as interrupt pins at the same time, but PA1 and PB2 can. PA1 and PA2 can also be used with interrupts simultaneously. Module Pinouts SCM20100E Pinout SCM20260N Pinout SCM20260E Pinout SCM20260D Pinout Schematics SCM20100E Schematic SCM20260N Schematic SCM20260E Schematic SCM20260D Schematic 3D STEP files SCM20100E STEP File SCM20260N STEP File SCM20260E STEP File SCM20260D STEP File Getting Started As the SITCore modules are based on the SITCore chipset, please refer to the SITCore SoC page for information on device startup, loading TinyCLR OS firmware, and writing and deploying your application. Design Considerations Footprints We recommend no traces or vias under the module. Dimensions are in inches. SCM20100E Recommended Footprint SCM20260N Recommended Footprint SCM20260E Recommended Footprint SCM20260D SO-DIMM Socket The SCM20260D uses the same 200 pin SO-DIMM socket that was originally made for DDR2 memory modules. You can make a custom SO-DIMM SITCore circuit board by adding the appropriate SO-DIMM socket to your circuit board. Tip Make sure to expose the required pins in your design. Specific pins are needed for device programming, updates, recovery, and WiFi firmware updates. See the Special Pins page and the device specifications for details. SO-DIMM stands for Small Outline Dual Inline Memory Module. There are two different 200 pin SO-DIMM sockets, those made for DDR memory and those made for DDR2 memory. They are identical except for the orientation notch which is in a slightly different position. These sockets are not interchangeable. There is also a 204 pin SO-DIMM socket for DDR3 memory with the notch positioned closer to the center of the module. Note Our UCMs are only compatible with DDR2 type 200 pin SO-DIMM sockets. Here is a link to the manufacturer's web page for the connector we use on our boards: EMBOSS ASSY DDR2 SODIMM SOCKET 200P 5.2H Required Pins Exposing the following pins is required in every design to enable device programming, updates, and recovery: RESET LDR APP MOD (if required to select a debug interface) Desired debug interface(s) For information on these and other important pins, please refer to the Special Pins page. Power Supply A clean power source, suitable for digital circuitry, is needed to power SITCore SoMs. Voltages should be regulated to within 10% or better of the specified voltage. Additionally, a large capacitor, typically 47 uF, should be placed near the SoM if the power supply is more than few inches away. Analog Considerations Where these pins are provided, using a separate filtered supply for Analog 3.3V and Analog VREF+ may help to improve ADC accuracy by reducing analog supply noise. For the same reason, you may want to provide a separate and clean analog ground for the Analog GND and Analog VREF-, if these pads are provided on the SoM you are using. Oven Reflow Profile SITCore SoMs are not sealed for moisture. Baking modules before reflow is recommended and required in a humid environment. The process of reflow can damage the SoM if the temperature is too high or exposure is too long. The lead-free reflow profiles used by GHI Electronics are shown below. The profiles are based on AIM SAC 305 solder (3% silver, 0.5% copper). The thermal mass of the assembled board and the sensitivity of the components on it affect the total dwell time. Differences in the two profiles are where they reach their respective peak temperatures as well as the time above liquids (TAL). The shorter profile applies to smaller assemblies, whereas the longer profile applies to larger assemblies such as back-planes or high-density boards. The process window is described by the shaded area. These profiles are only starting-points and general guidance. The particulars of the oven and the assembly will determine the final process. SITCore Dev Boards We offer SITCore development boards to get you started as quickly and easily as possible. These boards allow you to start programming in minutes, and are suitable for both prototypes and production. Click here for details."
  },
  "hardware/ucm/development-options.html": {
    "href": "hardware/ucm/development-options.html",
    "title": "UCM Development Options",
    "keywords": "UCM Development Options These options are provided to speed the development of your product and make it possible to start programming your application within minutes without designing or building new hardware. You may also use these products as quick drop-in options into your design as well. Code Samples For some examples of using the development options in TinyCLR, take a look at the TinyCLR Samples repo. You may also find the TinyCLR tutorials useful. UCM Dev Board Ordering Part Number: UCD-DEV-E Schematic The UCM Dev Board is the fastest and easiest way to start using our Universal Compute Modules. This board provides a socket for the UCM, standard connectors for input/output, and three 40 pin socket headers for connecting peripherals and a display. Peripheral connectors include external power, Ethernet, CAN, USB host and client, RTC backup battery, DCMI interface and an SD card slot. It also has a buzzer, LEDs, a reset button, and user programmable boot buttons. To start development using the UCM Dev Board, just plug a UCM into the socket on the board and connect the board's USB Client port to a host computer using a micro USB. Go to the documentation page for the particular UCM you are using for instructions. For power, the board can be powered through either USB connectors or the barrel jack. Always use the barrel jack for power when using displays, especially the larger ones. USB does not provide sufficient power needed for displays. Tip The barrel jack is pin positive, sleeve negative, 2.1mm. It is capable of anywhere 7V to 30V. 1A of power should be enough for most needs. UCM Breakout Board Ordering Part Number: UCD-BKT-C Schematic The UCM Breakout Board provides a socket for UCMs, and both through hole and surface mount edge connections for soldering the Breakout Board to your own circuit board. You can solder pin headers to the Breakout Board and use traditional breadboarding techniques to build your prototype as well. This board makes it easier to use UCMs in prototypes or products without the need to solder the fine pitch 200 pin SO-DIMM socket. For added convenience, it also includes USB Client connector, a reset button, four user programmable boot buttons, and a micro SD card slot. Please note that this is a Breakout Board and it does not have any power supplies. You will need to add 3.3V or 5V as needed to power up your modules. However, the power from USB is available on one of the pins (5V USB) so it is possible to wire a 3.3V regulator. Tip There are 2 LEDs by the USB connector, for 3.3V and 5V. They are useful to check that you have supplied the necessary power. A simple board can be designed and hand soldered to host the Breakout Board. You can turn an idea into a product prototype in days! This example board example (in green) is made to be the exact same size as the 4.3\" universal display board. It can be designed with the display connector conveniently located in the right place. To start using the breakout board, plug one of the UCMs into the socket on the board and wire in 3.3V (you may also need 5V) and plug in USB into your PC. Go to the documentation page for the particular UCM you are using for instructions. Universal Displays Available displays work directly with the options above, just make sure you are using a SoM supporting the needed peripherals. The Universal Displays can be connected directly or wired though a 40-pin IDE extension ribbon cable, similar to the old-style IDE hard drive cable extender, with a Male connector on one end and a Female connector on the other. To connect a display with the Dev Board, simply plug it on top. The display can be larger than the board but it will still use the same connector (HDR C). When using the Breakout Board you need to add a female header. Make sure the header is placed on the back of the Breakout Board. Note how the Breakout Board, and potentially your host board, hide behind the display. This is a good advantage when mounting the display inside a product. Adding a ribbon cable allows for further flexibility on where and how far the display is mounted. The length of the cable is determined by clock frequency used with the display. If the image on the display is not stable, lower the clock or shorten the cable. In our testing, our display have worked perfectly with 10\" cable. UCD-D43-A Ordering Part Number: UCD-D43-A Display Module: ER-TFT043-3 Touch Panel: ER-TPC043-2 Schematic This display module has a 4.3\" 480x272 TFT display with capacitive touch screen. The display needs a UCM with TFT display support and needs I2C for the capacitive touch. The backlight is controllable through GPIO A. The capacitive touch controller is connected I2C A with the interrupt pin on GPIO B. The TinyCLR Samples repo has usage examples. Learn more about the graphics support. See below for the display configuration values: Property Value Width 480 Height 272 DataFormat RGB565 Pixel Clock Rate 8 MHz <= x <= 16MHz Pixel Polarity low DataEnable Is Fixed false DataEnable Polarity low Horizontal Back Porch 46 Horizontal Front Porch 16 Horizontal Sync Polarity low Horizontal Sync Pulse Width 1 Vertical Back Porch 23 Vertical Front Porch 7 Vertical Sync Polarity low Vertical Sync Pulse Width 1 UCD-D70-A Ordering Part Number: UCD-D70-A Display Module: ER-TFT070-4 Touch Panel: ER-TPC070-6 Schematic This display module has a 7\" 800x480 TFT display with capacitive touch screen. The display needs a UCM with TFT display support and needs I2C for the capacitive touch. The backlight is controllable through GPIO A. The capacitive touch controller is connected I2C A with the interrupt pin on GPIO B. The display is exactly the same size as the Dev Board. They can be nicely mounted back to back with stand offs. A ribbon cable will be needed for the display signals. The TinyCLR Samples repo has usage examples. Learn more about the graphics support. See below for the display configuration values: Property Value Width 800 Height 480 DataFormat RGB565 Pixel Clock Rate 23 MHz <= x <= 46MHz Pixel Polarity low Data Enable Is Fixed false Data Enable Polarity low Horizontal Back Porch 46 Horizontal Front Porch 16 Horizontal Sync Polarity low Horizontal Sync Pulse Width 1 Vertical Back Porch 23 Vertical Front Porch 7 Vertical Sync Polarity low Vertical Sync Pulse Width 1 Custom Boards The \"Display Interface\" utilized on development options include TFT parallel 16bit/24bit bus, I2C bus, SPI, bus and 2 GPIOs. It is possible to design a custom display to utilize the UCM mainboards, or design a mainboard to utilize the available displays. Additionally, the designs of the development options can be used as a reference to start a UCMbased design. GHI Electronics' engineering/manufacturing is available for such designs. You can also visit our main website at main website and our community forum."
  },
  "hardware/ucm/intro.html": {
    "href": "hardware/ucm/intro.html",
    "title": "Universal Compute Modules",
    "keywords": "Universal Compute Modules Important Continuing with our longevity policy, these modules are available for purchase; however, due to discontinued components by STMicroelectronics, they are no longer recommended. Consider upgrading Universal Compute Modules are based on a 200 pin SO-DIMM form factor. All models follow a standard pin out making it easy to change modules to fit the needs of your product. A variety of tools and software options are available. Check the individual product documentation for details. UCM Standard Description, peripherals and pinouts of the standard. Learn more... UC2550 ARM Cortex-M4 based UCM with optional Wi-Fi. Learn more... UC5500 ARM Cortex-M7 based UCM with optional Wi-Fi. Learn more... G400D Based on a 400 MHz Atmel ARM 926. Learn more... UCM Development Options Development boards, breakout boards, displays. Learn more... You can also visit our main website at main website and our community forum."
  },
  "hardware/ucm/standard.html": {
    "href": "hardware/ucm/standard.html",
    "title": "The UCM Standard",
    "keywords": "The UCM Standard The UCM Standard defines a consistent hardware and software interface for the most widely used microcontroller peripherals. Universal Compute Modules are based on the 200 pin SO-DIMM form factor. They adhere to a standard pinout across models making it easy to change modules to adapt to the needs of your product. When designing a product, consider following thee UCM standard pinout. This will make your design compatible with any of the UCM modules. Software also becomes more portable with the UCM standard. For example, our TinyCLR OS provides a library to automatically map the UCM standard names to the underlying system so that your program can use the UCM standard names only, making changing to a different module very easy. The SO-DIMM Socket All of our UCMs use the same 200 pin SO-DIMM socket that was originally made for DDR2 memory modules. The fastest way to get started with UCMs is by using the optional boards and displays described on the UCM Development Options page. You can also incorporate any of our UCMs into your own custom design by adding the appropriate SO-DIMM socket to your circuit board. Tip Make sure to expose the required pins in your design. Specific pins are needed for device programming, updates, recovery, and WiFi firmware updates. See device specifications for details. SO-DIMM stands for Small Outline Dual Inline Memory Module. There are two different 200 pin SO-DIMM sockets, those made for DDR memory and those made for DDR2 memory. They are identical except for the orientation notch which is in a slightly different position. These sockets are not interchangeable. There is also a 204 pin SO-DIMM socket for DDR3 memory with the notch positioned closer to the center of the module. Note Our UCMs are only compatible with DDR2 type 200 pin SO-DIMM sockets. Here is a link to the manufacturer's web page for the connector we use on our boards: EMBOSS ASSY DDR2 SODIMM SOCKET 200P 5.2H Peripherals Peripheral Up to Max UART (Universal Asynchronous Receiver/Transmitter) 4 UART HS (Handshaking) 2 I2C (Inter-Integrated Circuit) 2 SPI (Serial Peripheral Interface) 2 CAN (Controller Area Network) 2 SDIO (SD Card) 1 ADC (Analog to Digital Converter) 8 PWM (Pulse Width Modulation) 8 GPIO (General Purpose Input/Output) 12 IRQ (Interrupt Request Capable GPIO) 4 USB Client 1 USB Host 1 LCD (TFT Controller - 16bpp or 24bpp) 1 Ethernet PHY (Ethernet Physical Layer) 1 DCMI (Digital Camera Interface) 1 VBAT (Battery Backup for RTC) 1 JTAG (Debug Serial Port) 1 *Available peripherals vary by model Note that the system defines 12 GPIOs that are free from any other functions but most other peripheral pins also support GPIO, giving the user several more GPIO pin options -- keep in mind the standard does not guarantee this though. Tip The TinyCLR tutorials are a good resource on using these peripherals. UART (Universal Asynchronous Receiver Transmitter) UART is used to implement moderate speed full duplex asynchronous serial communication. It is usually used for peer to peer communication between only two devices. It can transfer data using only one wire for each direction if both devices share a common ground. UART HS (Handshaking) UART with handshaking is a configuration which allows the host and client to negotiate data transfer via Ready to Send (RTS) and Clear to Send (CTS) signals (two additional wires) to prevent missed data. I2C (Inter-Integrated Circuit) I2C is a multi-master, multi-slave, packet switched, half duplex serial communication bus typically used for attaching peripheral ICs to processors and microcontrollers in short-distance, intra-board communication. It uses two wires and has a slower maximum speed than SPI. SPI (Serial Peripheral Interface) SPI is a synchronous serial communication interface used for short distance communication. It uses a master-slave protocol. When using TinyCLR, the processor running TinyCLR is always configured as the master. SPI needs at least three wires and usually needs an additional line (chip select) for each slave. It can communicate much faster than either UART or I2C. CAN (Controller Area Network) A robust bus standard that originated in the automotive field and works very well in high noise environments. It allows microcontrollers and devices to communicate with each other in applications without a host computer. It is a message-based multi-master protocol and generally uses only two wires. Speed is up to one megabit per second but limited by bus length. SDIO (SD Card) SDIO (Secure Digital Input Output) is an interface used for reading from and writing to SD cards. ADC (Analog to Digital Converter) ADCs are used to measure an analog voltage level by converting it to a digital value. PWM (Pulse Width Modulation) PWM is a method of generating a square wave signal of uniform frequency with variable duty cycle. PWM is often used to generate analog voltages, but has many other uses such as generating digital pulses for driving servo motors or driving infrared LEDs for communication. GPIO (General Purpose Input/Output) GPIOs are the digital I/O pins that allow the user to interface with basic devices such as buttons (input) or LEDs (output). GPIOs are very versatile and can also be used to perform more advanced communication and control duties. IRQ (Interrupt Request Capable GPIO) IRQ capable GPIO pins can be programmed to interrupt a program when the input to the pin changes. For example, an IRQ could be used by a WiFi module to tell the processor that the WiFi module is receiving data. The processor would then stop what it is doing to get the data from the WiFi module. USB Client Used to communicate with a USB host. Often used to program and debug embedded devices. USB Host Used to communicate with one or more USB clients. Typically used to communicate with various devices such as a mouse, keyboard, camera, etc. LCD (TFT Controller - 16bpp or 24bpp) An interface providing communication with a TFT LCD (thin-film-transistor liquid-crystal display). The number of data lines connected determines the number of bits per pixel (bpp), which determines the number of colors that can be displayed. Ethernet PHY Ethernet PHY is the Ethernet physical (hardware) layer. It provides the Tx and Rx signals for the Ethernet connector. DCMI (Digital Camera Interface) A standard interface for compatible digital cameras. VBAT (Battery Backup for RTC) VBAT is used to provide battery voltage to a microcontroller's real time clock. It allows the microcontroller to keep the correct time when the main power to the controller is disconnected (the device is turned off). JTAG JTAG is a serial interface which allows communication between the processor and a host computer. It is built into the microcontroller and provides a means of software debugging including the ability to stop program execution, single step through program instructions, and read and write to memory and processor registers. Pin Assignments SO-DIMM Pin Universal Compute Standard 1 AGND 2 Ethernet TX- 3 Module Specific 1 4 Ethernet TX+ 5 Analog VREF- 6 Ethernet RX- 7 Reserved 8 Ethernet RX+ 9 Reserved 10 Indicator A 11 Indicator B 12 Reserved 13 GND 14 DCMI D0 15 DCMI D1 16 DCMI D2 17 DCMI D3 18 DCMI D4 19 DCMI D5 20 Analog 3.3V 21 DCMI D6 22 DCMI D7 23 DCMI VSYNC 24 DCMI HSYNC 25 DCMI PIXCLK 26 DCMI XCLK 27 GND 28 PWM E 29 PWM F 30 PWM G 31 PWM H 32 Analog VREF+ 33 Reserved 34 5V 35 Module Specific 4 36 Module Specific 5 37 Module Specific 6 38 Module Specific 7 39 Module Specific 8 40 GND 41 GND 42 LCD 24bpp R0 43 LCD 24bpp R1 44 LCD 24bpp R2 45 LCD 24bpp G0 46 3.3V 47 LCD 24bpp G1 48 LCD 24bpp B0 49 LCD 24bpp B1 50 LCD 24bpp B2 51 GND 52 Module Specific 9 53 Reserved 54 Reserved 55 Reserved 56 5V 57 IRQ A 58 IRQ B 59 IRQ C 60 3.3V 61 IRQ D 62 GPIO A 63 GPIO B 64 GPIO C 65 GND 66 GPIO D 67 GPIO E 68 GPIO F 69 GPIO G 70 5V 71 Reserved 72 3.3V 73 I2C B SDA 74 I2C B SCL 75 UART C TX 76 UART C RX 77 UART D TX 78 UART D RX 79 GND 80 Reserved 81 Reserved 82 Reserved 83 Reserved 84 Reserved 85 Reserved 86 5V 87 USB Device ID 88 3.3V 89 UART B TX 90 UART B RX 91 ADC A 92 GPIO H 93 SPI B MISO 94 SPI B MOSI 95 GND 96 SPI B SCK 97 ADC B 98 CAN A TD 99 CAN A RD 100 CAN B TD 101 CAN B RD 102 UART HS A TX 103 UART HS A RX 104 ADC C 105 PWM A 106 3.3V 107 SYS A 108 Module Specific 2 109 Module Specific 3 110 ADC D 111 SYS C 112 PWM B 113 GND 114 ADC E 115 I2C A SDA 116 I2C A SCL 117 UART A RX 118 UART A TX 119 GPIO I 120 UART HS A RTS 121 UART HS A CTS 122 GPIO J 123 SD Card D0 124 3.3V 125 SD Card CMD 126 SD Card CLK 127 SD Card D1 128 SD Card D2 129 SD Card D3 130 PWM C 131 GND 132 GPIO K 133 PWM D 134 SYS B 135 SYS D 136 GPIO L 137 Module Specific 10 138 UART HS B RTS 139 UART HS B CTS 140 UART HS B TX 141 UART HS B RX 142 3.3V 143 LCD VSYNC 144 LCD HSYNC 145 LCD CLK 146 LCD DE 147 Module Specific 11 148 SD Card CD 149 Module Specific 12 150 Reserved 151 GND 152 LCD B3 153 LCD B4 154 LCD B5 155 LCD B6 156 LCD B7 157 ADC F 158 ADC G 159 ADC H 160 3.3V 161 LCD G2 162 LCD G3 163 LCD G4 164 LCD G5 165 LCD G6 166 Module Specific 13 167 Indicator C 168 LCD R7 169 GND 170 LCD G7 171 LCD R3 172 LCD R4 173 LCD R5 174 LCD R6 175 SPI A SCK 176 SPI A MISO 177 Module Specific 14 178 SPI A MOSI 179 Module Specific 15 180 3.3V 181 Module Specific 16 182 Module Specific 17 183 VBAT 184 Module Specific 18 185 GND 186 GND 187 RESET 188 USB Host D+ 189 JTAG RTCK 190 USB Host D- 191 JTAG TDO 192 3.3V 193 JTAG NTRST 194 USB Device D+ 195 JTAG TDI 196 USB Device D- 197 JTAG TCK (SWCLK) 198 GND 199 JTAG TMS (SWDIO) 200 Indicator D Want to quickly build your prototype? Check out the UCM Development Options. You can also visit our main website at main website and our community forum."
  },
  "hardware/ucm/uc2550.html": {
    "href": "hardware/ucm/uc2550.html",
    "title": "UC2550",
    "keywords": "UC2550 Overview The efficiency of our UC2550 makes it ideal for low power applications. It is also our lowest cost UCM and offers a large complement of peripherals. Ordering Part Number Model Number WiFi External QSPI Flash UC2550-13NNN no optional UC2550-13NNW yes optional Specifications Specs Value Processor STM STM32F413 32-bit ARM Cortex-M4 Speed 100 MHz Internal RAM 320 KByte (SRAM) Internal Flash 1 MByte External RAM 0 KByte External Flash Up to 4 MByte (QSPI) Dimensions 67.7 x 31.7 x 3.2 mm Note: Not all memory will be available for your application. Peripherals This table lists the available peripherals. The \"overall\" column shows the available pins if the design did not follow the UCM standard. Peripheral UCM Standard Overall UART 4 9 (including HS) UART HS 2 2 I2C 2 2 SPI 2 3 CAN 2 2 SDIO 1 1 ADC 8 15 PWM 8 27 GPIO 10 67 IRQ 4 67 USB Client Supported Supported USB Host Not supported Not supported LCD Not supported Not supported Ethernet PHY Not supported Not supported WiFi Supported Supported Camera Not supported Not supported VBAT Supported Supported JTAG SWD SWD Development Options The UCM development options can greatly simplify the process of building a product or prototype using the UC2550. Options include a development board and displays which can get you programming in minutes. Tip We are assuming you are using the UCM Development Board for all instructions provided. .NET Micro Framework NETMF provides a way to program the G30 in C# or Visual Basic from the Microsoft Visual Studio integrated development environment. To get started you must first install the NETMFfirmware (instructions below) and then go to the NETMF Getting Started page for instructions. Loading Bootloader v2 Download the UC2550 bootloader here. Connect your device to the USB client port. Put the board in DFU mode: Hold the SYS A pin low and press/release the reset button. Wait for a second then release SYS A. Windows Device Manager will now show \"STM Device in DFU Mode\" under the 'Universal Serial Bus controller' TAB. This is a DFU file, upload it like you would any other DFU file. See STMicroelectronics documentation for details. Loading the Firmware Activate the bootloader, hold the LDR0 signal low while resetting the board. Open FEZ Config tool and follow the instructions. Start Coding Now that you have installed the bootloader and firmware on the UC2550, you can setup your host computer and start programming. Go to the NETMF Getting Started page for instructions. Schematic The schematic for the UC2550 can be found here. Customization We also offer customized, non-stock versions of our SoMs. Many options are available, such as various sizes of external QSPI flash. Please contact us for details. We will always do our best to provide you with a module to fit your exact needs. Pin Assignments SO-DIMM Pin Universal Compute Standard Function Name 1 AGND AGND 2 Ethernet TX- 3 Module Specific 1 (WiFi PIN14) WiFi Power LED 4 Ethernet TX+ 5 Analog VREF- Analog VREF- 6 Ethernet RX- 7 Reserved 8 Ethernet RX+ 9 Reserved 10 Indicator A (WiFi PIN15) WiFi Link Up LED 11 Indicator B (WiFi PIN5) WiFi Running (Blink) LED 12 Reserved 13 GND GND 14 DCMI D0 15 DCMI D1 16 DCMI D2 17 DCMI D3 18 DCMI D4 19 DCMI D5 20 Analog 3.3V Analog 3.3V 21 DCMI D6 22 DCMI D7 23 DCMI VSYNC 24 DCMI HSYNC 25 DCMI PIXCLK 26 DCMI XCLK 27 GND GND 28 PWM E PE5, TIM9 CH1 29 PWM F PE6, TIM9 CH2 30 PWM G PB14, TIM12 CH1 31 PWM H PB15, TIM12 CH2 32 Analog VREF+ Analog VREF+ 33 Reserved 34 5V 35 Module Specific 4 (WiFi PIN13) 36 Module Specific 5 (WiFi PIN16) 37 Module Specific 6 (WiFi PIN22) 38 Module Specific 7 39 Module Specific 8 40 GND GND 41 GND GND 42 LCD 24bpp R0 43 LCD 24bpp R1 44 LCD 24bpp R2 45 LCD 24bpp G0 46 3.3V 3.3V 47 LCD 24bpp G1 48 LCD 24bpp B0 49 LCD 24bpp B1 50 LCD 24bpp B2 51 GND GND 52 Module Specific 9 53 I2S SCK 54 I2S WD 55 I2S WS 56 5V 57 IRQ A PC0, ADC10 58 IRQ B PC1, ADC11 59 IRQ C PC2, ADC12 60 3.3V 3.3V 61 IRQ D PC3, ADC13 62 GPIO A PC4, ADC14 63 GPIO B PC5, ADC15 64 GPIO C PA15, TIM2 CH1 65 GND GND 66 GPIO D PB0, ADC8, TIM3 CH3 67 GPIO E PB7, TIM4 CH2 68 GPIO F PD7 69 GPIO G PD10 70 5V 71 Reserved 72 3.3V 3.3V 73 I2C B SDA PB8, I2C3 SDA, TIM10 CH1 74 I2C B SCL PA8, I2C3 SCL, MCO1 75 UART C TX PE1, UART8 TX 76 UART C RX PE0, UART8 RX 77 UART D TX PD15, USART9 TX, TIM4 CH4 78 UART D RX PD14, USART9 RX, TIM4 CH3 79 GND GND 80 Reserved 81 Reserved 82 Reserved 83 Reserved 84 Reserved 85 Reserved 86 5V 87 USB Device ID 88 3.3V 3.3V 89 UART B TX PE8, USART7 TX 90 UART B RX PE7, USART7 RX 91 ADC A PA0, ADC0, TIM5 CH1 92 GPIO H PE10 93 SPI B MISO (WiFi PIN6) PE13, SPI5 MISO, TIM1 CH3 94 SPI B MOSI (WiFi PIN8) PE14, SPI5 MOSI, TIM1 CH4 95 GND GND 96 SPI B SCK (WiFi PIN10) PE12, SPI5 SCK 97 ADC B PA1, ADC1, TIM5 CH2 98 CAN A TD PD1, CAN1 TX, UART4 TX 99 CAN A RD PD0, CAN1 RX, UART4 RX 100 CAN B TD PB13, CAN2 TX, UART5 TX 101 CAN B RD PB12, CAN2 RX, UART5 RX 102 UART HS A TX PD5, USART2 TX 103 UART HS A RX PD6, USART2 RX 104 ADC C PA2, ADC2, TIM5 CH3 105 PWM A PE9, TIM1 CH1 106 3.3V 3.3V 107 SYS A BOOT0 108 Module Specific 2 (WiFi PIN2) 109 Module Specific 3 (WiFi PIN4) 110 ADC D PA3, ADC3, TIM5 CH4 111 SYS C PE3, LDR1 112 PWM B PE11, TIM1 CH2 113 GND GND 114 ADC E PA4, ADC4, DAC1 115 I2C A SDA PB9, I2C2 SDA, TIM10 CH1 116 I2C A SCL PB10, I2C2 SCL, TIM2 CH3 117 UART A RX PA10, USART1 RX 118 UART A TX PA9, USART1 TX 119 GPIO I PD14, UART9 RX, TIM4 CH3 120 UART HS A RTS PD4, USART2 RTS 121 UART HS A CTS PD3, USART2 CTS 122 GPIO J PD15, UART9 RX, TIM4 CH4 123 SD Card D0 PC8, SD D0, TIM8 CH3 124 3.3V 3.3V 125 SD Card CMD PD2, SD CMD 126 SD Card CLK PC12, SD CLK, SPI3 MOSI 127 SD Card D1 PC9, SD D1, TIM8 CH4 128 SD Card D2 PC10, SD D2, SPI3 SCK 129 SD Card D3 PC11, SD D3, SPI3 MISO 130 PWM C PC6, TIM3 CH1, USART6 TX 131 GND GND 132 GPIO K 133 PWM D PC7, TIM3 CH2, USART6 RX 134 SYS B PB2, LDR0 135 SYS D PE4, MODE 136 GPIO L 137 Module Specific 10 138 UART HS B RTS PD12, USART3 RTS 139 UART HS B CTS PD11, USART3 CTS 140 UART HS B TX PD8, USART3 TX 141 UART HS B RX PD9, USART3 RX 142 3.3V 3.3V 143 LCD VSYNC 144 LCD HSYNC 145 LCD CLK 146 LCD DE 147 Module Specific 11 148 SD Card CD PC13 149 Module Specific 12 150 Reserved 151 GND GND 152 LCD B3 153 LCD B4 154 LCD B5 155 LCD B6 156 LCD B7 157 ADC F PA5, ADC5, DAC2 158 ADC G PA6, ADC6 159 ADC H PA7, ADC7 160 3.3V 3.3V 161 LCD G2 162 LCD G3 163 LCD G4 164 LCD G5 165 LCD G6 166 Module Specific 13 167 Indicator C 168 LCD R7 169 GND GND 170 LCD G7 171 LCD R3 172 LCD R4 173 LCD R5 174 LCD R6 175 SPI A SCK PB3, SPI1 SCK, TIM2 CH2 176 SPI A MISO PB4, SPI1 MISO 177 Module Specific 14 178 SPI A MOSI PB5, SPI1 MOSI 179 Module Specific 15 180 3.3V 3.3V 181 Module Specific 16 182 Module Specific 17 183 VBAT VBAT 184 Module Specific 18 185 GND GND 186 GND GND 187 RESET RESET 188 USB Host D+ 189 JTAG RTCK 190 USB Host D- 191 JTAG TDO 192 3.3V 3.3V 193 JTAG NTRST 194 USB Device D+ PA12, USB D+ 195 JTAG TDI 196 USB Device D- PA11, USB D- 197 JTAG TCK (SWCLK) PA14, JTCK, SWCLK 198 GND GND 199 JTAG TMS (SWDIO) PA13, JTMS, SWDIO 200 Indicator D CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a UC2550 driving the SN65HVD230 CAN driver chip. See the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 33.333K 1 13 2 90 1 False 87.5% 0.31% 2195M 83.333K 1 13 2 36 1 False 87.5% 0.31% 845M 125K 1 13 2 24 1 False 87.5% 0.31% 545M 250K 1 13 2 12 1 False 87.5% 0.31% 245M 500K 1 13 2 6 1 False 87.5% 0.31% 95M 1M 1 13 2 3 1 False 87.5% 0.31% 20M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested to ensure reliability. Want to quickly build your prototype? Check out the UCM Development Options. You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com."
  },
  "hardware/ucm/uc5550.html": {
    "href": "hardware/ucm/uc5550.html",
    "title": "UC5550",
    "keywords": "UC5550 Overview The UC5550 System on Module has the processor and memory needed to run the most intense embedded applications, thanks to its 216 MHz Cortex-M7 and 32 MByte of RAM. Its built in native parallel TFT display makes it an ideal option for applications that require professional display support. Ordering Part Number Model Number WiFi Ethernet PHY External SDRAM External QSPI Flash UC5550-67HFN no no 32 MByte 4 MByte UC5550-67HFW yes no 32 MByte 4 MByte UC5550-67HFE no yes 32 MByte 4 MByte Specifications Spec UC5550 Processor ST STM32F767 32-bit ARM Cortex-M7 Speed 216 MHz Internal RAM 512 KByte (SRAM) Internal Flash 2 MByte External RAM 32 MByte (SDRAM) External Flash 4 MByte (QSPI) Dimensions 67.7 x 31.7 x 4.5 mm Note: Resources are shared between your application and the operating system. Peripherals This table lists the available peripherals. The \"overall\" column shows the available pins if the design did not follow the UCM standard. Peripheral UCM Standard Overall UART 4 5 (including HS) UART HS 1 2 I2C 1 2 SPI 2 3 CAN 2 2 SDIO 1 1 ADC 8 9 PWM 8 20 GPIO 12 103 IRQ 4 103 USB Client Supported Supported USB Host Supported Supported LCD Supported (16bpp & 24bpp) Supported (16bpp & 24bpp) Ethernet PHY Supported Supported WiFi Supported Supported Camera Supported Supported VBAT Supported Supported JTAG SWD SWD Tip The NETMF tutorials is a good resource on using these peripherals. Development Options The UCM development options can greatly simplify the process of building a product or prototype using the UC5550. Options include a development board and displays which can get you programming in minutes. Tip We are assuming you are using the UCM Development Board for all instructions provided. Loading Bootloader v2 Download the UC5550 bootloader here. Connect your device to the USB client port. Put the board in DFU mode: Hold the SYS A pin low and press/release the reset button. Wait for a second then release SYS A. Windows Device Manager will now show \"STM Device in DFU Mode\" under the 'Universal Serial Bus controller' TAB. This is a DFU file, upload it like you would any other DFU file. See STMicroelectronics documentation for details. Loading the Firmware Activate the bootloader, hold the LDR0 signal low while resetting the board. Open FEZ Config tool and follow the instructions. Start Coding Now that you have installed the bootloader and firmware on the UC5550, you can setup your host computer and start programming. Go to the NETMF Getting Started page for instructions. Schematic The schematic for the UC5550 can be found here. Customization We also offer customized, non-stock versions of our SoMs. Many options are available, such as various sizes of external QSPI flash. Please contact us for details. We will always do our best to provide you with a module to fit your exact needs. Pin Assignments SO-DIMM Pin Universal Compute Standard Function Name 1 AGND AGND 2 Ethernet TX- ETH PHY TX- 3 Module Specific 1 (WiFi PIN14) WiFi Power LED 4 Ethernet TX+ ETH PHY TX+ 5 Analog VREF- Analog VREF- 6 Ethernet RX- ETH PHY RX- 7 Reserved 8 Ethernet RX+ ETH PHY RX+ 9 Reserved PH7, DCMI GP 10 Indicator A ETH PHY LED SPEED 11 Indicator B ETH PHY LED LINK 12 Reserved 13 GND GND 14 DCMI D0 PH9, DCMI D0 15 DCMI D1 PH10, DCMI D1 16 DCMI D2 PG10, DCMI D2 17 DCMI D3 PH12, DCMI D3 18 DCMI D4 PE4, DCMI D4 19 DCMI D5 PI4, DCMI D5 20 Analog 3.3V Analog 3.3V 21 DCMI D6 PE5, DCMI D6 22 DCMI D7 PE6, DCMI D7 23 DCMI VSYNC PG9, DCMI VSYNC 24 DCMI HSYNC PH8, DCMI HSYNC 25 DCMI PIXCLK PA6, DCMI PIXCLK 26 DCMI XCLK PA8, DCMI XCLK, MCO1 27 GND GND 28 PWM E PI6, TIM8 CH2 29 PWM F PI7, TIM8 CH3 30 PWM G PI2, TIM8 CH4 31 PWM H PA3, TIM9 CH2, ADC3 32 Analog VREF+ Analog VREF+ 33 Reserved 34 5V 35 Module Specific 4 (WiFi PIN13) 36 Module Specific 5 (WiFi PIN16) 37 Module Specific 6 (WiFi PIN22) 38 Module Specific 7 39 Module Specific 8 40 GND GND 41 GND GND 42 LCD 24bpp R0 PI15, LCD R0 43 LCD 24bpp R1 PJ0, LCD R1 44 LCD 24bpp R2 PJ1, LCD R2 45 LCD 24bpp G0 PJ7, LCD G0 46 3.3V 3.3V 47 LCD 24bpp G1 PJ8, LCD G1 48 LCD 24bpp B0 PJ12, LCD B0 49 LCD 24bpp B1 PJ13, LCD B1 50 LCD 24bpp B2 PJ14, LCD B2 51 GND GND 52 Module Specific 9 53 Reserved 54 Reserved 55 Reserved 56 5V 57 IRQ A PI8 58 IRQ B PI11 59 IRQ C PH14 60 3.3V 3.3V 61 IRQ D PH15 62 GPIO A PD7 63 GPIO B PE3 64 GPIO C PG3 65 GND GND 66 GPIO D PG6 67 GPIO E PG7 68 GPIO F PH4 69 GPIO G PI0 70 5V 71 Reserved 72 3.3V 3.3V 73 I2C B SDA 74 I2C B SCL 75 UART C TX PF7, UART7 TX 76 UART C RX PF6, UART7 RX 77 UART D TX (WiFi PIN9) PB10, USART3 TX, TIM2 CH3, I2C2 SCL 78 UART D RX (WiFi PIN7) PB11, USART3 RX, TIM2 CH4, I2C2 SDA 79 GND GND 80 Reserved 81 Reserved 82 Reserved 83 Reserved 84 Reserved 85 Reserved 86 5V 87 USB Device ID 88 3.3V 3.3V 89 UART B TX PC6, USART6 TX, TIM3 CH1 90 UART B RX PC7, USART6 RX, TIM3 CH2 91 ADC A PA0, ADC0, TIM5 CH1 92 GPIO H PA1, ETH RMII REF CLK 93 SPI B MISO (WiFi PIN6) PF8, SPI5 MISO, TIM13 CH1, UART7 RTS 94 SPI B MOSI (WiFi PIN8) PF9, SPI5 MOSI, TIM14 CH1, UART7 CTS 95 GND GND 96 SPI B SCK (WiFi PIN10) PH6, SPI5 SCK, TIM12 CH1 97 ADC B PA4, ADC4, DAC1 98 CAN A TD PH13, CAN1 TX 99 CAN A RD PI9, CAN1 RX 100 CAN B TD PB13, CAN2 TX 101 CAN B RD PB12, CAN2 RX 102 UART HS A TX PD5, USART2 TX 103 UART HS A RX PD6, USART2 RX 104 ADC C PA5, ADC5, DAC2 105 PWM A PA15, TIM2 CH1 106 3.3V 3.3V 107 SYS A BOOT0 108 Module Specific 2 (WiFi PIN2) 109 Module Specific 3 (WiFi PIN4) 110 ADC D PB0, ADC8, TIM3 CH3 111 SYS C PI1, LDR1 112 PWM B PB7, TIM4 CH2 113 GND GND 114 ADC E PB1, ADC9, TIM3 CH4 115 I2C A SDA PB9, I2C1 SDA, TIM4 CH4 116 I2C A SCL PB8, I2C1 SCL, TIM4 CH3 117 UART A RX PA10, USART1 RX 118 UART A TX PA9, USART1 TX 119 GPIO I PA2, ETH MDIO 120 UART HS A RTS PD4, USART2 RTS 121 UART HS A CTS PD3, USART2 CTS 122 GPIO J PA7, ETH RMII CRS DV 123 SD Card D0 PC8, SD D0 124 3.3V 3.3V 125 SD Card CMD PD2, SD CMD 126 SD Card CLK PC12, SD CLK, SPI3 MOSI 127 SD Card D1 PC9, SD D1 128 SD Card D2 PC10, SD D2, SPI3 SCK 129 SD Card D3 PC11, SD D3, SPI3 MISO 130 PWM C PH11, TIM5 CH2 131 GND GND 132 GPIO K PC4, ETH RMII RXD0 133 PWM D PI5, TIM8 CH1 134 SYS B PB2, LDR0 135 SYS D PI3, MODE 136 GPIO L PC5, ETH RMII RXD1 137 Module Specific 10 (ETH PHY OSCILLATOR PIN1) OE OFF# 138 UART HS B RTS 139 UART HS B CTS 140 UART HS B TX 141 UART HS B RX 142 3.3V 3.3V 143 LCD VSYNC PI13, LCD VSYNC 144 LCD HSYNC PI12, LCD HSYNC 145 LCD CLK PI14, LCD CLK 146 LCD DE PK7, LCD DE 147 Module Specific 11 148 SD Card CD PC13 149 Module Specific 12 150 Reserved 151 GND GND 152 LCD B3 PJ15, LCD B3 153 LCD B4 PK3, LCD B4 154 LCD B5 PK4, LCD B5 155 LCD B6 PK5, LCD B6 156 LCD B7 PK6, LCD B7 157 ADC F PC0, ADC10 158 ADC G PC2, ADC12 159 ADC H PC3, ADC13 160 3.3V 3.3V 161 LCD G2 PJ9, LCD G2 162 LCD G3 PJ10, LCD G3 163 LCD G4 PJ11, LCD G4 164 LCD G5 PK0, LCD G5 165 LCD G6 PK1, LCD G6 166 Module Specific 13 167 Indicator C (WiFi PIN15) WiFi Link Up LED 168 LCD R7 PJ6, LCD R7 169 GND GND 170 LCD G7 PK2, LCD G7 171 LCD R3 PJ2, LCD R3 172 LCD R4 PJ3, LCD R4 173 LCD R5 PJ4, LCD R5 174 LCD R6 PJ5, LCD R6 175 SPI A SCK PB3, SPI1 SCK 176 SPI A MISO PB4, SPI1 MISO 177 Module Specific 14 178 SPI A MOSI PB5, SPI1 MOSI 179 Module Specific 15 180 3.3V 3.3V 181 Module Specific 16 182 Module Specific 17 183 VBAT VBAT 184 Module Specific 18 185 GND GND 186 GND GND 187 RESET RESET 188 USB Host D+ PB15, USBH D+ 189 JTAG RTCK 190 USB Host D- PB14, USBH D- 191 JTAG TDO 192 3.3V 3.3V 193 JTAG NTRST 194 USB Device D+ PA12, USB D+ 195 JTAG TDI 196 USB Device D- PA11, USB D- 197 JTAG TCK (SWCLK) PA14, JTCK, SWCLK 198 GND GND 199 JTAG TMS (SWDIO) PA13, JTMS, SWDIO 200 Indicator D (WiFi PIN5) WiFi Running (Blink) LED CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a UC5550 driving the SN65HVD230 CAN transceiver chip. See the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 33.333K 1 12 2 108 1 False 86.7% 0.33% 2145M 83.333K 1 15 2 36 1 False 88.9% 0.28% 879M 125K 1 13 2 27 1 False 87.5% 0.31% 545M 250K 1 15 2 12 1 False 88.9% 0.28% 257M 500K 1 15 2 6 1 False 88.9% 0.28% 101M 1M 1 15 2 3 1 False 88.9% 0.28% 23M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested to ensure reliability. Want to quickly build your prototype? Check out the UCM Development Options. You can also visit our main website at www.ghielectronics.com and our community forums at forums.ghielectronics.com."
  },
  "index.html": {
    "href": "index.html",
    "title": "GHI Electronics Documentation",
    "keywords": "GHI Electronics Documentation Here you will find GHI Electronics product documentation. For more information visit the main website. You can also visit our community forum. Endpoint - .NET 8 on Hardware Endpoint is FULL .NET 8 for circuits! Load and run applications on embedded hardware. Learn More... SITCore - Secure C# Hardware SITCore family of Secure C# Chips and Modules for creating secure IoT devices. Learn More... TinyCLR OS - the heart of SITCore TinyCLR OS is the operating system for embedded devices, powering the SITCore product family. Develop software in Microsoft Visual Studio, and debug over USB. Learn More..."
  },
  "software/due/downloads.html": {
    "href": "software/due/downloads.html",
    "title": "Due Script Downloads",
    "keywords": "Due Script Downloads Firmware SC007 (BrainPad Edge) Date Revision Firmware Mar 1, 2023 1.0 Due Script SC007 R1 SC13 (BrainPad Pulse) Date Revision Firmware Mar 1, 2023 1.0 Due-SC13 R1 Library .NET Date Revision Package Mar 1, 2023 1.0 Due-NET Nuget R1 Python Date Revision Firmware Mar 1, 2023 1.0 Due-Python R1"
  },
  "software/due/intro.html": {
    "href": "software/due/intro.html",
    "title": "Due Scripting Language",
    "keywords": "Due Scripting Language It can be accessed from any modern OS and any language/system that have access to serial ports. See the downloads page for currently supported languages. Why Due? Due stands for Dynamic, Universal, and Extensible. A user-friendly scripting language that allows for internal real-time processing. Dynamic There are 2 modes to code or command a Due device, Immediate or Record modes. In Immediate mode, commands are executed immediately. In Record mode, commands are stored in flash and executed with the run command. Learn more about modes on the language page. Universal Due doesn't care if you use Python or C#, because the Due commands are sent over serial port. It can also be scripted using a terminal editor with simple BASIC like commands included in the API. Extensibility Due devices when used with other languages extend the language. Call any Due recorded function from any external source using serial commands. On-line editor You can program any Due device using a simple terminal editor like TerraTerm. This is nimble for quick testing but can be cumbersome with large programs. An on-line editor will soon be released to make coding and debugging programs very easy. Streams Send data in chunks directly to the device. This is useful when working with screens or other device which require batches of data."
  },
  "software/due/language.html": {
    "href": "software/due/language.html",
    "title": "Due - Language",
    "keywords": "Due - Language Immediate & Record Modes Immediate mode, commands are executed immediately. In Record mode, commands are stored in flash and executed with the run command. Immediate Mode A user will know they are in this mode when their cursor prompt is the > character. All statements are executed as soon as entered. > print(\"Hello World\") Note Immediate Mode is the default mode when device is first connected. Record Mode To enter into Record mode, the user enters the $ character. The character prompt will change to the $ sign until Record mode is exited using the > character. All statements entered are stored directly in flash but not executed until run is entered. Statement Description $ Sets the device in record mode > Exits record mode and returns to direct mode The following statements control the program recorded in flash, but can be used in both Immediate or Record modes. When used in Record mode these special statements execute, but are not added to the program in flash. Statement Description run Executes the program stored in flash new Erases the program stored in flash list Returns all the code in your program > $ $ println (x) $ println (y) $ > > x=1:y=2 > run 1 2 >list println(x) println(y) >new Comments The # character is used to identify a comment. Comments are ignored by the program, text added to help developers understand the code. # This is a comment x=10 print (x) # This is also a comment Variables Due can hold up to 26 variables one for letters a-z. The only data type used in Due is integers. All variables created are global in nature. Single Line Commands Code can be concatenated together in a single line with each command joined by a : When coding in Immediate mode multi-line statements need to be coded as a single line command. When using Record mode multi-line statements can be used. x=10:print(x):x=15:print(x) Looping & Conditional Statements Statement Description for/to/step/next Incremental looping if/else/end Conditional execution of the code For-Loop used in Immediate mode for i=1 to 1000 step 10: println(i):next If-Else statement used in Record mode $ $new $if x=1 $println(\"one\") $else $println(\"not one\") $end $> >x = 1 >run one >x = 2 >run not one Functions Functions in Due are implements in a simple form. They do not take arguments and do not return values. However, the built in library functions do take arguments and return values, learn more about the library functions. User functions resides in nonvolatile memory using recording mode. They can then be \"run\" or called from immediate mode. Note While these are called functions, they are actually just labels. A user function is created by using the @ symbol in front of the name of the function you'd like to create. These names are limited to 6 characters. Once you've created a \"function\" any preceding commands entered go inside that function. Function are typically end with a return. $@Mine $add code here $return The function can then be called by its name with (). Note how this can be done externally from any system with access to Due interface, like Python. >Mine() A goto can also be used to call a function but in this case the function is treated as a label and a return should not be expected. $@Loop $add code here $goto loop Tip Due variables are global and any changes inside functions will affect variable values outside those functions. Extending Due User \"functions\" stored in flash, can be called externally. This allows a function to be called from ANY outside source or program. This will enter recording mode and then records a function $ @Count for x=0 to a println(x) next return The above \"function\" can now be called from inside Immediate mode as an example. Make sure to switch to immediate mode! >a=5 >Count()"
  },
  "software/due/library.html": {
    "href": "software/due/library.html",
    "title": "Due - Library",
    "keywords": "Due - Library These library functions are available on all Due-supported hardware, for user defined functions, see language page Tip Code samples are using upper and lower case to make things look clearer. Due is not case sensitive and Print(\"Due\") is exactly the same as print(\"Due\") Streams Some functionality require speed when sending/retrieving data to/from a device. For example, when sending the entire LCD display. A stream command initiates the request, in this case LcdStream(). Once this command is received and accepted by the device, it will respond with the & symbol. Now, the PC can send the entire data, exactly to the required byte count. This required count, to follow the stream command, is documented with each stream command individual. System Functions Echo(enable) enable: 0 = Enable echo , 1 = Disable echo Version - Returns the current firmware version of Due Print(text) - Prints the value of the argument to the console on the same line text: String or variable PrintLn(text) - Prints the value of the argument to the console then moves to the next line text: String or variable GetTicks() - read system current ticks in microseconds Wait(duration) - holds program from running duration: duration = milliseconds Reset(loader) - Resets the board loader: 0 = system reset, 1 = reset and stay in loader mode Digital These functions provide access to digital pins. Digital Write DWrite(pin, state) - Sets a pins digital output pin: pin number state: 1 = high or 0 = low for x = 1 to 10 DWrite(0,1) Wait(200) DWrite(0,0) Wait(200) next Digital Read DRead(pin, pull) - Read a digital pin output pin: 0-9 pull: Sets the internal pull resistors to -> 0=none, 1=up, 2=down Returns: 1 = high or 0 = low x = DRead(2,1) if x = 0 Print(\"low\") else Print(\"high\") end Analog These functions provide access to analog pins. Analog Write AWrite(pin, dutyCycle) - Writes to pin using PWM pin: pin number dutyCycle: 0 to 1000 Note Frequency is fixed to 50hz. @loop for i=0 to 1000 step 100 AWrite(0,i) Wait(100) next for i=1000 to 0 step -100 AWrite(0,i) Wait(100) next goto loop Analog Read ARead(pin) - Read an analog output pin: pin number Returns: The analog value of the pin @loop for i=0 to 100 x=ARead(0) PrintLn(x) Wait(100) next goto loop Neopixel Neopixel is fixed to pin number 1 NeoClear() - Clears all LEDs (in memory). Needs NeoShow() to see the affect NeoSet(index, red, green, blue) - Sets a specific LED to a color. Needs NeoShow() to see affect index: The LED index where 0 is first one and supporting up to 256 LEDs red, green, blue: Color levels, 0 to 255 NeoShow(count) - count: The count of LEDs to update and show This example assumes we have 8 LEDs and will set 8 LEDs to red, increasing the color intensity from 0 to 80. Then it waits one second before it sets the first LED to bright purple! NeoClear() for x = 0 to 8 NeoSet(x,x*10,0,0) next NeoShow(8) Wait(1000) NeoSet(0,200,0,200) NeoShow(8) NeoStream(count) - Streams data directly to LEDs.Needs NeoShow() to see affect count: The count of LEDs to \"stream\" Stream size: It is \"count\" multiplied by 3, due to the fact that each LED needs 3 bytes for colors, ordered in GRB format. Frequency Frequency is fixed to pin 0 Freq(frequency, duration, dutyCycle) - provides an accurate hardware generated PWM signal frequency: frequency duration: 0 to forever dutyCycle: 0 to 1000 Note Freq() is a non-blocking function, calling Freq() a second time before the duration of the first call is over will end the function despite the duration of first calls argument. @Loop for x=1 to 1000 Freq(x,500,500) Wait(200) next for x=1000 to 1 step -1 Freq(x,500,500) Wait(200) next goto Loop Infrared IR decoder is fixed to pin 2 IrEnable(enable) - enables pin for IR signal capture enable: 1 = enable, 0 = disable IrRead() - reads the value from the IR enabled pin Return: Tracks the past 16 key presses and returns them. -1 if none. Button Return Value power 0 up 1 lightbulb 2 left arrow 4 sound 5 right arrow 6 backward 8 down 9 forward 2 + 12 0 13 - 14 1 16 2 17 3 18 4 19 5 20 6 21 7 22 8 23 9 24 IrEnable(1) @Loop x=IrRead() if x >=0: Println(x):end Wait(1000) goto Loop SPI SpiByte(byte) - sends a byte byte: - value 0 to 255 Return: Read byte value code sample SpiSteam(writeCount, readCount, cs) - Streams data directly to the SPI device writeCount: The number of bytes to write readCount: The number of bytes to read cs: set to -1 if not needed Stream size: The stream starts with PC sending \"writeCount\" of bytes and then the PC must read the \"readCount\". If either count is zero then that step can be skipped. code sample Spi4Bpp(count) - Streams and converts data from 4BPP to 16BPP count: The count of bytes to be written. Stream size: The \"count\". This special function converts 4BPP incoming data to 16BPP on-the-fly. This is added to speed up the use of SPI color displays, namely ones using ST7735 found on the very common 1.8\" SPI color displays. This allows for faster updates, since each byte sent is 2 pixels. Palette(index, colorValue) - Sets the desired color for a palette. index: Index number of color colorValue: A standard HEX value of the RGB color. This function goes hand-in-hand with Spi4Bpp() function to set the colors that are to be used. Default colors: Index Color Value Color 0 0x000000 Black 1 0xFFFFFF White 2 0xFF0000 Red 3 0x32CD32 Lime 4 0x0000FF Blue 5 0xFFFF00 Yellow 6 0x00FFFF Cyan 7 0xFF00FF Magenta 8 0xC0C0C0 Silver 9 0x808080 Gray 10 0x800000 Maroon 11 0xBAB86C Olive 12 0x00FF00 Green 13 0xA020F0 Purple 14 0x008080 Teal 15 0x000080 Navy I2C I2cBytes(address, writeCount, readCount) - Reads and/or writes up to 4 bytes to/from I2C bus. Data is transfered to and from variables A, B, C, D writeCount: The number of bytes to write readCount: The number of bytes to write code sample I2cStream(address, writeCount, readCount) - address: address of the I2C device writeCount: readCount: Stream size: The stream starts with PC sending \"writeCount\" of bytes and then the PC must read the \"readCount\". If either count is zero then that step can be skipped. code sample Note On SC13 devices only: The I2C pins are different on BrainPad Pulse vs FEZ boards. PB15 is used to determine how I2C should work. Pay attention to the state of PB15 on power up, Pulse has it pulled up through 10k resistor. UART UartInit(baudRate) - Sets the baud rate UART baudRate: Any commonly used standard baud rate UartRead() - Read UART data Returns: A byte read from UART UartWrite(data) - Write UART data data: Data byte to send on UART UartCount() - Count Returns: How many bytes have been buffered and ready to be read code sample Touch TouchRead(pin) - Initializes the pin for touch pin: pin number @Loop a=TouchRead(0):b=TouchRead(1):c=TouchRead(2) if a>0:Println(\"pin 0\"):end if b>0:Println(\"pin 1\"):end if c>0:Println(\"pin 2\"):end wait(100) goto Loop Servo Motor ServoSet(pin, degree) - Sets servo motor connected to pin to a specific position pin: pin number degree: 0 to 180 Tip Many servo motors need 5V to work. @Loop ServoSet(0,0) Wait(1000) ServoSet(0,180) Wait(1000) goto Loop Distance Sensor ReadDistance(trigger, echo) - uses ultrasonic sonic sensor to read distance. trigger: The pin number that is connected to trigger (pulse) signal echo: The pin number that is connected to echo signal Returns: Distance in centimeters Tip most sensors need 5V to work. @Loop x = Distance(0,1) if x>0 PrintLn(x) end Wait(100) goto Loop Buttons BtnEnable(pin, enable) - sets up a button to be used pin: pin number, 'a', or 'b' enable: 1 = enable, 0 = disabled BtnDown(pin) Returns a value when button is pressed pin: pin number, 'a', or 'b' Returns: 1 if button was pressed and continues to return 1 until the button is released Note 'a' is ASCII a or 97, 'b' is ASCII b or 98 Tip Will always return zero if not enabled BtnEnable('a',1) @Loop x=BtnDown('a') if x=1 Println(\"Button A\") end goto Loop Device Specific These functions are added to support the built in display & buzzer found on the BrainPad Pulse Sounds Sound(frequency, duration, volume) frequency: sound frequency in Hz duration: in milliseconds. 0 is always on volume: 0 to 100 Note Sound() uses Freq() which is a non-blocking function. Calling Sound() could end the duration of the previous Sound() despite the set duration inside the argument. See Freq() section for more details. Sound(256,1000,50) LCD LcdShow() Sends the display buffer to the LCD. LcdClear(color) Clears the entire screen to black or white color: 0 = black, 1 = white LcdClear(0) LcdShow() Draw Line LcdLine(color, x1,y1,x2,y2) color: 0 = black, 1 = white x1: Starting x point y1: Starting y point x1: Ending x point y1: Ending y point LcdClear(0) LcdLine(1,0,0,128,64) LcdShow() Set Pixel LcdPixel(color, x, y) color: 0 = black, 1 = white x: x pixel value y: y pixel value LcdClear(0) LcdPixel(1,64,32) LcdShow() Draw Circle LcdCircle(color, x,y,radius) color: 0 = black, 1 = white x: x position of circle's center y: y position of circle's center radius: radius of the circle LcdClear(0) LcdCircle(1,64,32,31) LcdShow() Draw Rectangle LcdRect(color, x1, y1, x2, y2) color: 0 = black, 1 = white x1: Starting x point y1: Starting y point x1: Ending x point y1: Ending y point LcdClear(0) LcdRect(1,10,10,118,54) LcdShow() Draw Scaled Text LcdTextS(\"text\", color, x, y, scaleWidth, scaleHeight) text: String message in double quotes. Using variables is not supported color: 0 = black, 1 = white x: x position y: x position scaleWidth: Width scale multiplier scaleHeight: Width scale multiplier LcdClear(0) LcdText(\"Hello\",1,0,0,2,2) LcdShow() Tip Scale is multiplier for the pixel in width and height to make the font larger Draw Text LcdText(\"text\", color, x, y) Works exactly the same as LcdText() minus scaling. LcdClear(0) LcdText(\"Hello World\",1,10,10) LcdShow() LCD Stream Stream is used to send the entire LCD update. LcdStream() Stream Size: The size screen size divided by 8, 128x64/8=1K. The data is organized as 8bit columns going left to right and then wrapping around to the next row. Example code to set a pixel at 10x10 int x=10; int y=10; buffer[(y >> 3) * 128 + x] |= (byte)(1 << (y & 7));"
  },
  "software/due/samples.html": {
    "href": "software/due/samples.html",
    "title": "Due Samples",
    "keywords": "Due Samples Coming soon..."
  },
  "software/micropython/debugging.html": {
    "href": "software/micropython/debugging.html",
    "title": "Debugging",
    "keywords": "Debugging While MicroPython does not have the full debugging experience found with Visual Studio and TinyCLR OS, the built in REPL provides some interesting uses. Thanks to the MicroPython's built-in compiler and runtime engine. There are 2 very important hot-keys that are always handy, ctrl+C to exit from a looping program and going back to REPL and ctrl+D to soft reset the OS. Assuming there is a robot with I2C-controlled headlight and we need to write a driver for those headlights. The first step would be to create a file in the virtual drive that show up when connecting the MicroPython running board. We can now open the file and add the drivers. from machine import Pin, SoftI2C i2c4 = SoftI2C(scl=Pin(\"PB11\"), sda=Pin(\"PB10\")) buf4= bytearray(4) buf4[0]=0x01 def set(r,g,b): buf4[1]=r buf4[2]=g buf4[3]=b i2c4.writeto(0x01, buf4) set(100,100,0) When saving the file, we need to make sure to observe the activity LED to make sure the file is done saving, which takes few seconds. The REPL interface can now be used to import the driver we have just created, import headlights. Looking at the driver example, it creates a set function and then it calls it with colors 100,100,0 for RGB (Yellow). Tip import only works once on any module. Calling it a second time has no effect. We now can set the headlight colors, purple for example headlights.set(100,0,100). Another option now is to include a flashing lights loop on power up, using main.py file. We will modify main.py contents: import headlights import time while True: headlights.set(100,0,0) time.sleep(0.2) headlights.set(0,0,100) time.sleep(0.2) Do not reset the board manually, instead use ctrl+D to soft reset. The LEDs will flash red and blue, like a police car! To exit the loop and reuse REPL, use ctrl+C. And then turn the headlights off headlights.set(0,0,0). The system does not need import headlights as this was done earlier when main.py was loaded."
  },
  "software/micropython/downloads.html": {
    "href": "software/micropython/downloads.html",
    "title": "Downloads",
    "keywords": "Downloads Software status legend: Status Meaning Production (RTW) Ready to be used commercially (ready to wear). Release Candidate (RC) Could become a production release if proven solid. Preview Preview of the next release, not quite ready for production use. Firmwares SITCore SC13xxx File Date Status Core MD5 SC13xxx v0.2.3 2021-09-21 Preview v1.15-21 FF90737B4D0441389F57771C519BE7D3 SC13xxx v0.2.1 2021-06-10 Preview v1.15-21 8BDCFED1E1065E4791379D3EF0F59D7B SC13xxx v0.2.0 2021-05-27 Preview v1.15-21 D955CAED3261E44CE385B678987F94BF SC13xxx v0.1.0 2021-04-30 Preview v1.15-21 A5FABF3250B796C5AC9C112FB7F30AA0 Tera Term TeraTerm serial terminal is available free from https://ttssh2.osdn.jp/index.html.en but also available here for convenience. File Date Status Core MD5 TeraTerm v4.105 2019-12-07 RTW v4.105 DD0FFA0F6DF6179AE1383368DCB6C08E Roadmap MicroPython port to some of GHI Electronics devices is available to enhance the developer's productivity. While the main focus is still on TinyCLR OS, the adoption rate will determine how much resources will go into evolving MicroPython."
  },
  "software/micropython/editors.html": {
    "href": "software/micropython/editors.html",
    "title": "Editors",
    "keywords": "Editors While it is possible to simply use MicvroPython on SITCore with zero installation, adding an editor would make for a better user experience. There are many available options but this page will highlight https://www.thonny.org/ #Thonny This an a lean Python editor that is easy to install and use. It works for full Python development but it is as useful for MicroPython. We first need to visit https://www.thonny.org/ and download the version compatible with the OS being used. In our example here, we are using Windows. The editor is now ready to edit and run full Python programs. To use Thonny with SITCore, we first need to plug in the SITCore device, such as FEZ Flea, and load it with MicroPython firmware as detailed in Getting Started. Then from the top menu Run->Select Interpreter... We need the MicroPython (generic) option and on the 'Port' drop down we need to select the REPL COM port. We will add a new file with the following code and save it. from machine import Pin led=Pin(\"PA8\",Pin.OUT_PP) led.high() Tip PA8 on SITCore SC13048 is activity LED and found on all boards. This LED can be used by the user as well. We can now click the run icon or hit F5. This will send the script to the device and the LED will come on. The shell window is the REPL interface, showing any error messages. It is also useful for entering code. led.low() will turn the LED off. We will test an infinite loop. from machine import Pin import time led=Pin(\"PA8\",Pin.OUT_PP) while True: led.low() time.sleep(0.3) led.high() time.sleep(0.3) To stop the running program, we can use ctrl+C (stop) or ctrl+D (soft reset). Or we can click the stop icon."
  },
  "software/micropython/getting-started.html": {
    "href": "software/micropython/getting-started.html",
    "title": "Getting Started",
    "keywords": "Getting Started This page explains how to load and use MicroPython on the GHI Electronics supported devices. The Terminal Software Tera Term is the recommended terminal software but any other software should work. Tera Term is free and widely used. Download Tera Term from the downloads page or directly or search the web for downloads. Unzip the downloaded file and run ttermpro.exe. The software will look like the image below. Go ahead and click cancel on this page. The next step is to put the device in Loader mode. This is accomplished by setting LDR pin low during reset or power up. On devices that have LDR button, just hold the LDR button down and continue to hold it down while reseting the board and then release the LDR button. This step will bring the device into loader mode, which will load a new virtual serial port. On windows, the Device Manager will look something like the image below. Go back to Tera Term and, from the top menu, select File->New connection.... A new window will pop-up with serial ports updated with the COM port we have introduced in previous step. Select that new port and click OK. Hit the enter key and the device should respond with Invalid Command. Try to hit v followed by enter and the device will respond with the boot loader versions number. The device is now ready for the MicroPython firmware. The MicroPyhon Firmware Download the firmware from the Downloads page. Tip MicroPython is not available on all products. Back to Tera Term, press U followed by enter. The device will respond with Are you sure (Y/N)? Now press 'Y' followed by enter.' The device will now will be sending CCCCCCC..... indicating that it is ready for the MicroPython file. From top menu, File->Transfer->XMODEM->Send.... This is an important, commonly missed step, you MUST select the 1K checkbox! Select the downloaded MicroPython file (glb file type) from earlier step. Progress window will show the update status. When upload has completed, reset the board. If the firmware was loaded successfully, the PC will see a virtual memory driver, just like a USB memory drive. The drive will contain multiple files, one of them is main.py, which is what MicroPyhton automatically runs on power up. The device will also bring up a vistual COM port, just like the one used in loader mode but this COM is for the REPL interface. Activity LED PA8 pin is a special pin that is used by the system to indicate status. For example, the pin goes high when saving to the internal storage. The Python script can safely use PA8 but anytime the system needs to indicate something it will override the pin and then release it back to the script. REPL Read Evaluate Print Loop is a very quick way to command and control a MicroPython-running device. First find out the correct COM port and then start a new Tera Term connection to that port, just like we did with the boot loader. Once connected, the device will respond with something like: MicroPython v1.15-21-g4dc8024-dirty on 2021-04-30; GHI Electronics SITCore v0.1.0 with SC13048 >>> The device can now accept Python code! Try print(x) and the device will respond with an error about x. Now try x=10 and then print(x). >>> x=10 >>> print(x) 10 >>> This is example code to turn on activate an LED on pin PA8 from machine import Pin led=Pin(\"PA8\",Pin.OUT_PP) led.high() It is also possible to add a loop through REPL. Once a loop statement is entered (ending with :) the REPL will automatically indent the following line. To end the indentation and execute the block, press backspace or del, then enter. >>> for i in range(10): ... print(i) ... 0 1 2 3 4 5 6 7 8 9 >>> Tip For a quick help on a any module, use the help function, like use help(machine). main.py This special file gets executed in power up. Open the file, from the device's virtual driver, and modify its content to a blink LED. Change the pin number to the LED on the device being used. from machine import Pin import time led=Pin(\"PA8\",Pin.OUT_PP) while True led.high(); time.sleep(0.5) led.low(); time.sleep(0.5) Save main.py and wait for the activity LED/pin to go low, then reset the board. The led should be blinking. Use ctrl+C on the terminal to stop the program and go back to REPL. Next Steps Now that the device is running MicroPython, we can start learning about debugging tricks. And then the tutorials is a good next step."
  },
  "software/micropython/intro.html": {
    "href": "software/micropython/intro.html",
    "title": "MicroPython",
    "keywords": "MicroPython MicroPython brings the Python scripting language to small microcontrollers. While TinyCLR OS with .NET C# and full debugging is the recommended path for building secure and modern devices there are instances where using MicroPython can be useful. The MicroPython project is found at http://www.micropython.org/. GHI Electronics makes a ready-to-use MicroPython build for some of its products. Some areas where MicroPython shines: No complex software tools to setup. MicroPython is all-self-contained. Any serial terminal is enough to command/control/update the device. REPL allows for writing pure code on the device directly, where the device itself would compile and interpret. Python is a powerful scripting language that is relatively-easy to learn. Develop on any operating system as long as there is a terminal software! Reasons to use TinyCLR OS over MicroPython: True secure hardware with many security services. Solid and complete networking support. Full fledged debugging experience. Works with world-class Microsoft Visual Studio. NuGet cloud hosted libraries. C# is C's big sister, which is the global language for coding, especially on small devices. The GHI Electronics fork of MicroPython is found here. Getting Started Deploy your first MicroPython program. Learn more... Tutorials Learn MicroPython embedded programming. Learn more... Downloads Necessary Downloads. Learn more... Release Notes Find the latest changes to MicroPython. Learn more..."
  },
  "software/micropython/release-notes.html": {
    "href": "software/micropython/release-notes.html",
    "title": "Release Notes",
    "keywords": "Release Notes v0.2.3 Released 2021-09-21 Changes Add necessary libraries to support BrainPad. Known Issues No PWM. Use timer instead. v0.2.0 Released 2021-05-27 Changes Added SSD1306 driver. Added Neopixel WS2812 driver. Add distance sensor HCSC04 driver Fixed I2C(2), I2C(4). Known Issues No PWM. Use timer instead. v0.1.0 Released 2021-04-30 Changes Initialize. Known Issues None."
  },
  "software/micropython/tutorials/analog-in.html": {
    "href": "software/micropython/tutorials/analog-in.html",
    "title": "Analog In",
    "keywords": "Analog In Unlike digital input pins, which can only read high or low, analog pins can read a range of voltage levels. Microcontrollers based on 3.3V can typically read voltages anywhere between zero and 3.3V. Analog inputs connect internally to an Analog to Digital Converter (ADC) that converts the analog voltage level on the pin to a digital value. import machine adc = machine.ADC(machine.Pin('PA5')) adc.read_u16()"
  },
  "software/micropython/tutorials/displays.html": {
    "href": "software/micropython/tutorials/displays.html",
    "title": "Displays",
    "keywords": "Displays See the Graphics tutorial on details on how to draw using the display drivers below. SSD1306 Drivers for this commonly available display are built in. Pull in the drivers using from displays pull ssd1306. from machine import I2C import ssd1306 # using default address 0x3C i2c = I2C(1) display = ssd1306.SSD1306_I2C(128, 64, i2c) display.text('Hello, World!', 0, 0, 1) display.show() The display driver also includes other helper methods. display.poweroff() # power off the display, pixels persist in memory display.poweron() # power on the display, pixels redrawn display.contrast(0) # dim display.contrast(255) # bright display.invert(1) # display inverted display.invert(0) # display normal display.rotate(True) # rotate 180 degrees display.rotate(False) # rotate 0 degrees display.show() # write the contents of the FrameBuffer to display memory"
  },
  "software/micropython/tutorials/gpio.html": {
    "href": "software/micropython/tutorials/gpio.html",
    "title": "GPIO",
    "keywords": "GPIO Microcontrollers include pins that can be controlled through software. They can be logical inputs or outputs, hence the name \"general purpose input/output\". The Pin class is uses to access GPIOs, located in the machine library. from machine import Pin Digital Outputs A digital output pin can be set to either high or low. High means that there is approx. 3.3V on the output pin. When the pin is set to low, it's voltage will be very close to zero. led=Pin(\"PA8\",Pin.OUT_PP) led.high() Digital Inputs Digital inputs sense the state of a pin based on its voltage. Minimum voltage on most pins is 0 volts; a negative voltage may damage the pin or the processor. Most processors run on 3.3V, the highest voltage a pin should see is 3.3V. However, some processors that are powered by 3.3V are 5V tolerant -- they can withstand up to 5V on their inputs. SITCore is 5V tolerant. Warning 5V tolerant doesn't mean the processor can be powered by 5V, only that the input pins can tolerate 5V. Unconnected input pins are called \"floating.\" A resistor can be added to pull the pin high or low. Modern processors include internal pull-up and pull-down resistors that are controlled by software. The code sample below uses an internal pull-up resistor to set the button high. When the button is pressed the GpioPinValue goes low. button = Pin(\"PB7\", Pin.IN, Pin.PULL_UP) button.value() Digital Input Interrupts Instead of polling a pin to determine it state, a function can be called when a pin is changed. def ButtonHandler(p) print(\"Pressed\", p) button = Pin(\"PB7\", Pin.IN, Pin.PULL_UP) button.irq(trigger=Pin.IRQ_FALLING, handler=ButtonHandler) Whenever the button is pressed (Falling Edge), the print will show \"Button\" flowed by the pin that caused the event. In this case it will show: Button Pin(Pin.cpu.B7, mode=Pin.IN, pull=Pin.PULL_UP) For further clarification, try print(button) and observe the output Pin(Pin.cpu.B7, mode=Pin.IN, pull=Pin.PULL_UP)."
  },
  "software/micropython/tutorials/graphics.html": {
    "href": "software/micropython/tutorials/graphics.html",
    "title": "Graphics",
    "keywords": "Graphics The built in Display support includes a graphics library. the flowing methods draw to a frame buffer. Calling display.show() will send the frame buffer to the screen. display.fill(0) # fill entire screen with color=0 display.pixel(0, 10) # get pixel at x=0, y=10 display.pixel(0, 10, 1) # set pixel at x=0, y=10 to color=1 display.hline(0, 8, 4, 1) # draw horizontal line x=0, y=8, width=4, color=1 display.vline(0, 8, 4, 1) # draw vertical line x=0, y=8, height=4, color=1 display.line(0, 0, 127, 63, 1) # draw a line from 0,0 to 127,63 display.rect(10, 10, 107, 43, 1) # draw a rectangle outline 10,10 to 107,43, color=1 display.fill_rect(10, 10, 107, 43, 1) # draw a solid rectangle 10,10 to 107,43, color=1 display.text('Hello World', 0, 0, 1) # draw some text at x=0, y=0, color=1 display.scroll(20, 0) # scroll 20 pixels to the right It is also possible to create other frame buffers, which are then rendered on top the display's frame buffer.' import framebuf fbuf = framebuf.FrameBuffer(bytearray(8 * 8 * 1), 8, 8, framebuf.MONO_VLSB) fbuf.line(0, 0, 7, 7, 1) display.blit(fbuf, 10, 10, 0) # draw on top at x=10, y=10, key=0 display.show()"
  },
  "software/micropython/tutorials/i2c.html": {
    "href": "software/micropython/tutorials/i2c.html",
    "title": "",
    "keywords": "#I2C I2C is a common 2 wire bus where a master talk to a slave using the slave's address. The available implementation is for I2C Master only, allowing the chip to talk to I2C slaves, such as displays and accelerometers. Hardware I2C MicroPython implementation on SITCore internally uses Software I2C but compatibility is provides the hardware class. from machine import I2C, Pin i2c = I2C(1, freq=100000) # Uses I2C1 i2c.scan() # show what slaves are available i2c.readfrom(0x3a, 4) # read 4 bytes from slave device with address 0x3a i2c.writeto(0x3a, '12') # write '12' to slave device with address 0x3a buf = bytearray(10) # create a buffer with 10 bytes i2c.writeto(0x3a, buf) # write the given buffer to the slave Note i2c.scan() returns addresses 0x8 to 0x77 only. Software I2C Software I2C can work with any pin. from machine import Pin, SoftI2C i2c = SoftI2C(scl=Pin(\"PB8\"), sda=Pin(\"PB9\"))"
  },
  "software/micropython/tutorials/intro.html": {
    "href": "software/micropython/tutorials/intro.html",
    "title": "MicroPython Tutorials",
    "keywords": "MicroPython Tutorials Here you will find programming tutorials and code examples for our MicroPython port. We try to keep the documents as hardware generic as possible, but changes may be required to get the sample code to run on your target device. Use the sub menu on the left to navigate the long list of available tutorials."
  },
  "software/micropython/tutorials/pwm.html": {
    "href": "software/micropython/tutorials/pwm.html",
    "title": "PWM",
    "keywords": "PWM Pulse Width Modulation is used to generate frequencies on a pin, or to control the level of power given to a pin. Current implementation prides PWM through Timer. This example will sweep through frequency: from machine import Pin, Timer import time p = Pin('PA5') # PA5 has TIM2, CH1 tim = Timer(2, freq=4000) ch = tim.channel(1, Timer.PWM, pin=p) ch.pulse_width_percent(50) for f in range(500, 1800): tim.freq(f) time.sleep(0.01) This example will brighten up an LED, from 1% to 100%, by changing the duty cycle: from machine import Pin, Timer import time p = Pin('PA5') # PA5 has TIM2, CH1 tim = Timer(2, freq=4000) ch = tim.channel(1, Timer.PWM, pin=p) ch.pulse_width_percent(50) for d in range(100, 0.1): ch.pulse_width_percent(d) time.sleep(0.01)"
  },
  "software/micropython/tutorials/rtc.html": {
    "href": "software/micropython/tutorials/rtc.html",
    "title": "RTC",
    "keywords": "RTC Real Time Clock is an internal clock that runs off a a separate battery even when the system is off. from machine import RTC rtc = RTC() rtc.init() rtc.datetime((2021, 8, 23, 1, 12, 48, 0, 0)) # set a specific date and time while True: rtc.datetime() time.sleep(1)"
  },
  "software/micropython/tutorials/sounds.html": {
    "href": "software/micropython/tutorials/sounds.html",
    "title": "",
    "keywords": "#Sounds Tunes and simple sounds can be generated by connecting a buzzer PWM. Typically, duty-cycle is fixed 50% and the frequency is changed to desired tones. For playing MP3 and music, a decode chip, like the ones from VLSI can be used through SPI."
  },
  "software/micropython/tutorials/spi.html": {
    "href": "software/micropython/tutorials/spi.html",
    "title": "SPI",
    "keywords": "SPI SPI uses transfers data serially, from a master to one or more slaves. Data is clocked out on the CLK pin. With every clock, a bit is sent out of the master into the slave MOSI (Master Out Slave In). The MISO sends data in the opposite direction. When there are multiple salves, the CS (Chip Select) pin is used to identify the addressed salve. Hardware SPI from machine import SPI spi = SPI(1, SPI.MASTER, baudrate=600000, polarity=1, phase=0) spi.init(baudrate=200000) # set the baudrate spi.read(10) # read 10 bytes on MISO spi.read(10, 0xff) # read 10 bytes while outputting 0xff on MOSI buf = bytearray(50) # create a buffer spi.readinto(buf) # read into the given buffer (reads 50 bytes in this case) spi.readinto(buf, 0xff) # read into the given buffer and output 0xff on MOSI spi.write(b'12345') # write 5 bytes on MOSI buf = bytearray(4) # create a buffer spi.write_readinto(b'1234', buf) # write to MOSI and read from MISO into the buffer spi.write_readinto(buf, buf) # write buf to MOSI and read MISO back into buf Software SPI Software SPI is slower than hardware but can work with any pins. from machine import Pin, SoftSPI spi = SoftSPI(baudrate=100000, polarity=1, phase=0, sck=Pin(\"PB3\"), mosi=Pin(\"PB5\"), miso=Pin(\"PB4\"))"
  },
  "software/micropython/tutorials/time.html": {
    "href": "software/micropython/tutorials/time.html",
    "title": "Time",
    "keywords": "Time The time module include several helpers. import time. Sleep To pause execution for a specific time, use sleep, which takes the sleep time in seconds. This examples sleeps for two and half a seconds: import time print(\"Hello\") time.sleep(2.5) print(\"there!\") If ms sleep is desired, use sleep_ms instead. Here is a one second delay: import time print(\"Hello\") time.sleep_ms(1000) print(\"there!\") Up Time The time.time() returns the seconds count since the system reset."
  },
  "software/micropython/tutorials/uart.html": {
    "href": "software/micropython/tutorials/uart.html",
    "title": "",
    "keywords": "#UART UART uses 2 pins for full-duplex data transfer between 2 devices, where TX (transmit) on one side goes to RX (receive) on the other device. from machine import UART uart = UART(1, baudrate=9600) uart.write('hello') uart.read(5) # read up to 5 bytes"
  },
  "software/netmf/bootloader.html": {
    "href": "software/netmf/bootloader.html",
    "title": "Bootloader",
    "keywords": "Bootloader The GHI Electronics Bootloader is used to update the firmware on our devices. It is the first program to run and unless the device specific LDR pins are set (see device documentation for details), it will execute the firmware on the device (if present). The bootloader communicates over a USB virtual serial port and a regular serial port. The interface used is controlled by a MODE pin. See your device specifications for details on interface configuration and selection and which version of the bootloader it runs. Tip If you are running Windows 7 or Windows 8, you must install drivers for the bootloader to appear in Windows. See \"USB Drivers\" in the downloads section below. Bootloader v1 The original loader runs on Embedded Master, EMX, G120, G120E, G400D, G400S and USBizi. All results are terminated with LF (\\n). Commands are executed as soon as they entered without waiting for a new-line. \"BL\" or \"Done.\" will be sent after each command. On startup, a banner is sent that is terminated by \"BL\". Once the banner is received, you are free to enter any of the case-sensitive single-character commands described below. V: returns the current version. E: erases all user sectors of the device (* is sent while erasing). R: runs the firmware if present. B: increases the baud rate in serial mode to 921,600. X: upload a file to the device using 1K XMODEM. Only send *.ghi files meant for your device. The firmware is automatically run after a successful upload. Tip The USB interface on Version 1.0 doesn't work on Windows 7 and newer operating systems. Use the serial interface instead. Bootloader v2 This loader runs on G30, G80, UC25, UC55 and FEZ T18. All commands and results are terminated with CR and LF (\\r\\n). \"OK.\" will be sent after each successful command. On startup, a banner is sent that is terminated by \"OK.\". Once the banner is received, you are free to enter any of the case-insensitive single-character commands described below. Most commands require confirmation. Send Y or y followed by a new-line to proceed or anything else to cancel. V: returns the current version. N: returns the current device type. E: erases all user sectors of the device. R: runs the firmware if present. B: increases the baud rate in serial mode to 921,600. X: upload a ghi file to the device using 1K XMODEM. Only send *.ghi files meant for your device. U: upload a glb file to the device using 1K XMODEM. Only send *.glb files meant for your device. Manually Loading the Firmware TinyCLR Config tool should be used to update the firmware. As a backup, use these instructions: Put your board in bootloader mode. Each product has a specific way to enter the boot loader. Open any terminal software, for example Tera Term. Select serial and pick the COM port associated with your board. (If unsure, check Device Manager) Press V and then enter. You will see back the boot loader version number (v2.x.x) Press U or X and then enter. Use X for firmware file type GHI and U for firmware file type GLB. Press Y to confirm then enter. You will now see CCCC... Go to File -> Transfer -> XMODEM -> Send. IMPORTANT: Make sure you check the 1K option. Select the firmware file. When the transfer is complete, reset your board. GLB File Format The glb files that are loaded onto devices have some additional metadata that help the bootloader function in addition to the raw data itself. The first 1,024 bytes of a glb file is the upload header. Starting from offset 0 are the below fields. The rest of the header is currently reserved. 32 bit signature number that is unique for each device. 32 bit unsigned address in flash that this image should be copied to. 32 bit unsigned length of the image to flash rounded to the nearest 1,024 bytes. 16 bit CRC-CCITT of the image. After the upload header is the actual image to flash. If its length is not divisible by 1,024 bytes, it is padded until it is. For images that are meant to be bootable, the address in the upload header should be set to the entry point defined for the specific device. Bootable images have an additional 1,024 byte header at the beginning of the image that is used to verify the image before booting it. The boot image is also padded to the nearest 1,024 bytes. Starting from offset 0 are the below fields. The rest of the header is currently reserved. 32 bit signature number that is unique for each device. 32 bit unsigned address in flash that is the entry point the bootloader will invoke. 32 bit unsigned length of the boot image rounded to the nearest 1,024 bytes. 16 bit CRC-CCITT of the boot image bounded by the specified address and length. Upgrading GHI Electronics Bootloader v1 to v2 Warning No longer supported! Some of our devices ship with v1 loader but require v2 loader to work with TinyCLR OS, such as G120. Download the bootloader file from the list below. Put your device in v1 mode (instructions are found on each product's documentation page). The PC will now detect a virtual serial (COM) device. If you need drivers, they are in the NETMF SDK. Open any terminal software, we recommend Tera Term. Select serial and pick the COM port associated with your board. Enter E and you will see back \"Erase all memory! Are you sure?\" now enter Y. (The bootloader is case sensitive) Enter X and you will see CCCC... showing on the terminal. Now go to File -> Transfer -> XMODEM -> Send. IMPORTANT: Make sure you check the 1K option. Select the bootloader file you have downloaded above. You will see File Transfer Finished Successfully. Change the configuration switches back to the off position and reset the board. You are now running GHI Electronics bootloader v2! Bootloader Downloads Most products already ship with bootloader already installed. But in case the loader needs to be reloaded, the individual product pages include instructions on how to load the bootloader. Here you can find the various bootloaders available for the various products. FEZCLR (used on FEZ and BrainPad Classic) File Date MD5 v2.0.4 2017-08-31 33F7FCAE266D07209C079CEA38AAB583 v2.0.3 2017-07-07 056919694D6A5F06546F9B721AE141CE UC2550 File Date MD5 v2.0.4 2018-04-05 692FA78A161BAA2AEF17E9F85A6AF141 UC5550 File Date MD5 v2.0.5 2018-09-28 9F4DB868E5501773CC52048D8085B8D6 v2.0.4 2018-04-05 594744A52EC07CEFE6212669D33A5FE1 G120 and G120E File Date MD5 v2.0.4 2017-08-31 7052D6FFB1890987DDCC4043895788D3 v2.0.2 2017-03-07 00ECD55A24607336863B1D61B91C3D86 G400S and G400D File Date MD5 v2.0.4 2017-09-13 BD46D86D41DCD42C4FC50D27AF02E5EE v2.0.2 2017-04-06 81D45A8F078AA8E633C824C7BB3279DC v2.0.1 2016-06-27 42CD50E4105939611ABF360475EBF4E5 v1.0 2015-08-24 842FF841610A5354F28D376B6BFFCBA7 USBizi File Date MD5 v1.0.7 144 2015-05-05 853557479D8797EAB650B98E3D333DCF v1.0.7 100 2015-05-05 34D17AA5CA4E13D5447C80AB8094D064 USB Drivers Only needed for Windows 7 and 8 since they do not automatically load drivers for the bootloader interface. File Date MD5 v1.0.0 x64 2018-12-27 74D66FC4236126A83CCCFE28D556F339 v1.0.0 x86 2018-12-27 8BDE68132452E22B14597C0972ABA8FD v0.6.0 x64 2017-08-31 AEDD7C00854BBF99AC3FDAB4976E1F33 v0.6.0 x86 2017-08-31 A0F487D32B882199F0A69E6CAA8DE4CB"
  },
  "software/netmf/downloads.html": {
    "href": "software/netmf/downloads.html",
    "title": "NETMF Downloads",
    "keywords": "NETMF Downloads General Resources .NET Micro Framework for Beginners (ebook PDF) Gadgeteer mainboards and moudle driver Source code NETMF Open Source Ports Microsoft Visual Studio The lastest version of Visual Studio that works with NETMF is VS2013. The Community Version can be downloaded from the following link: Microsoft Visual Studio 2013 Community Edition Microsoft .NETMF SDK Microsoft .NET Micro Framework 4.3 (QFE2) Microsoft .NET Gadgeteer Core Microsoft .NET Gadgeteer Core Download the archived zip file. It contains everything you will need. If you need to find a specific library, you can look at realeaseList.json file found in the release folder. Youll be able to see accurately the filenames you need for each file and its path under the releases directory. GHI Electronics Product NETMF SDKs Tip Release notes are found within the SDKs. Date NETMF Core Rev SDK Jun 27, 2016 4.3 QFE2 GHI Electronics NETMF SDK 2016 R1 GHI Electronics NETMF SDK 2016 R1 zip Aug 31, 2015 4.3 QFE2 GHI Electronics NETMF SDK 2015 R1 Oct 29, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R5 Oct 8, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R4 Sep 15, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R3 Jul 31, 2014 4.3 QFE1 NETMF and Gadgeteer Package 2014 R2 Jan 29, 2014 4.3 RTM NETMF and Gadgeteer Package 2014 R1 Oct 23, 2013 4.3 RTM NETMF and Gadgeteer Package 2013 R3 Aug 27, 2013 4.3 RTM NETMF and Gadgeteer Package 2013 R2 Apr 30, 2013 4.3 RTM NETMF and Gadgeteer Package 2013 R1 Update 1 Feb 14, 2013 4.2 QFE2 NETMF and Gadgeteer Package 2013 R1 Feb 17, 2012 4.1 RTM NETMF 4.1 SDK, for Embedded Master, USBizi and ChipworkX (Includes IoT book for FEZ Panda) Glide Glide is a graphics library that shipped with an on-line designer that is no longer available. GlideStudio is a community provided program to replace the discontinues official designer. This is a community-created non-supported download. Glide Designer"
  },
  "software/netmf/getting-started.html": {
    "href": "software/netmf/getting-started.html",
    "title": ".NET Micro Framework Getting Started",
    "keywords": ".NET Micro Framework Getting Started Installation Steps Install Visual Studio Community Edition Download and install Microsoft's Visual Studio 2013 Community Edition. Install Microsoft .NET Micro Framework Uninstall any currently installed NETMF SDKs. Download Microsoft .NET Micro Framework 4.3 (QFE2) and unzip the file. Open the file's folder and install MicroFrameworkSDK.MSI and netmfvs2013.vsix. Install Microsoft .NET Gadgeteer Core (for Gadgeteer users only) Download and install Microsoft .NET Gadgeteer Core. For more information on the future of Gadgeteer, please see this news post. Install GHI Electronic's NETMF SDK Download and install GHI Electronics NETMF SDK 2016 R1 from our NETMF Downloads page. When installing newer GHI Electronics NETMF SDKs, click the Advanced button on the opening dialog box and uncheck the boxes to install the FEZ CERB Family and G400/FEZ Hydra loader updaters (the first two options). If needed, these loaders can be installed separately as highlighted in the individual product pages. Older GHI Electronics NETMF SDKs are also available on the NETMF Downloads page. For the latest 2016 R1 SDK, we've also made a zip archive of the sub-installers available so that you can install just the pieces you need in a quicker fashion. Get Started with .NET Micro Framework for Beginners To help you get started we have a free e-book in .pdf format: .NET Micro Framework for Beginners The Emulator The NETMF SDK includes an emulator for running NETMF applications on the PC. For the first part of this project, the emulator will be used to run a very simple application; afterwards the same program is run on NETMF hardware. Create a New Project Open Visual Studio, select File > New Project. There should be a Micro Framework option in the left menu. Click on it and then select Console Application in the center panel. Note The pictures used in this tutorial may vary slightly with different versions of the development platform. Click the OK button to create a new project. The project has only one C# file, called Program.cs. C# source files are listed in the Solution Explorer window. If the Solution Explorer is not open, use the View > Solution Explorer menu to open it. Double click on Program.cs to open the file in the editor. using System; using Microsoft.SPOT; namespace MFConsoleApplication1 { public class Program { public static void Main() { Debug.Print( Resources.GetString(Resources.StringResources.String1)); } } } For simplicity change the code to match the listing below: Tip All example code should be copied directly from this page and pasted into the Visual Studio program editor. using Microsoft.SPOT; public class Program { public static void Main() { Debug.Print(\"Amazing!\"); } } Selecting Transport When compiling a NETMF Console Project, there are options in Video Studio that control where the program is loaded and run. Select the menu item for the project's properties: In the Properties window, on the left side tabs, select .NET Micro Framework and make sure that Transport: is set to Emulator. Console applications have their Debug.Print statements appear in Visual Studio's Output Window. The application in this example uses print statements. If the Output window is not visible, open it by selecting Output in the View menu. Executing Press F5 and Visual Studio will compile the program, load it into the emulator and run it. The emulator displays a hypothetical NETMF device, complete with buttons and a screen. Do not close it. After a few seconds, the program will stop and the Output window will have \"Amazing!\" printed (surrounded by other application information). Introduction to Debugging The following sections are a quick introduction to the power and ease of debugging NETMF applications. Start running the program by pressing F11 (instead of F5), this will \"step\" into the application instead of just running it. After deployment, the program starts to run and stops at the very first line of the code. This is indicated by the yellow arrow. Press F11 to step to the \"Debug.Print\" statement. Finally, after pressing F11 one more time, \"Amazing!\" is printed in the Output window. Press F5 to let the program run to completion. Breakpoints Setting breakpoints is simple! -- Click in the bar to the left of the line that prints \"Amazing!\" A red dot appears to mark the breakpoint location. Press F5 to run the software. When the application reaches the breakpoint the debugger will pause: F11 can be used to single step execution line by line. F5 can be used to let the program run. Running on Hardware Deploying and running NETMF applications on hardware is very simple. Just connect the hardware, change an option in Visual Studio, and all loading, running, debugging, etc. are done on the device. The complete procedure is described below. Warning When working with hardware, take care not to expose the hardware to static electricity as it can damage the device. Connect and Power-up Connect the NETMF hardware to the PC using a USB cable. This is done one of two ways. If the processor has an integral USB port and is colored red, plug a USB cable from the computer directly to the board. Processors without an integral USB port will use a Gadgeteer socket to connect the power/USB module to the board. For these boards connect the power module to a \"D\" labeled socket on the board, then connect the power/USB module to the computer. (These circuit boards are black). The first time a processor is connected to the computer, Windows will need to load a driver. Wait until the driver is fully loaded before proceeding. Updating Device Software Before using a NETMF device, the embedded software must match the version of the SDK being used. Instructions for updating the embedded software are found on the Firmware Update page. If necessary, update your firmware, and then return here to continue the tutorial. Skipping the above step is the most common problem faced by beginners. Tip Many USB hubs are poorly implemented in PCs. If Windows failed to recognize the NETMF device or had any connection problems, make sure the device is connected directly to the PC, not through a USB hub. If problems persist, try using a power transformer or powered USB hub to guarantee the device is getting sufficient power. Deploying to Hardware Once the board is connected, Visual Studio has a control to switch back and forth between the emulator and connected hardware. From the project properties, select USB for transport.. Make sure the setup looks similar to the image below: Pressing F5 sends the simple application to the hardware and runs it. Debugging works exactly the same as described above. Next Steps We are currently updating the NETMF documentation found in our NETMF Tutorials."
  },
  "software/netmf/intro.html": {
    "href": "software/netmf/intro.html",
    "title": ".NET Micro Framework",
    "keywords": ".NET Micro Framework .NET Micro Framework (NETMF) is a subset of the full Microsoft .NET Framework used to make Windows applications. NETMF initially started by Microsoft for use in SPOT watches and then later was open sourced. The latest version of Visual Studio working with our NETMF products is VS2013. Tip NETMF had a great run, but now it's time for something better. TinyCLR OS continues where NETMF left off, but with added features and increased security. Learn more about TinyCLR OS. General Resources .NET Micro Framework for Beginners (ebook PDF) Gadgeteer mainboards and module driver Source code Our .NET Micro Framework Discussion Forum Getting Started Deploy your first NETMF program. Learn more... Tutorials Learn NETMF embedded programming. Learn more... | Downloads Visual Studio and device downloads. Learn more..."
  },
  "software/netmf/tutorials/analog-in.html": {
    "href": "software/netmf/tutorials/analog-in.html",
    "title": "Analog Inputs",
    "keywords": "Analog Inputs Unlike digital input pins which can only read high or low, analog pins can read a range of voltage levels. Micro-controllers based on 3.3V can read voltages anywhere between zero and 3.3V. In contrast to digital input pins that are 5V tolerant; the maximum applied voltage for analog input must not exceed 3.3V (for higher voltages a voltage divider or an op-amp circuit can be used). Using a Light Sensor to Demonstrate Analog Input This example uses a light sensor. Its output voltage varies with light intensity -- the darker the light the higher the voltage output. The following code requires the Microsoft.SPOT.Hardware assembly. Consult the Developers' Guide or the product manual for specific channels. using System.Threading; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { AnalogInput lightSensor = new AnalogInput((Cpu.AnalogChannel)Cpu.AnalogChannel.ANALOG_7); double lightSensorReading = 0; while (true) { lightSensorReading = lightSensor.Read(); Debug.Print(lightSensorReading.ToString()); Thread.Sleep(500); } } }"
  },
  "software/netmf/tutorials/analog-out.html": {
    "href": "software/netmf/tutorials/analog-out.html",
    "title": "Analog Outputs",
    "keywords": "Analog Outputs An analog output sets the voltage on its pin anywhere between 0 and the supplied voltage (maximum voltage) which is typically 3.3 volts. The output voltage is only a signal, not meant to drive any loads. An op-amp or similar circuit can be added to drive loads, such as a speaker. The analog out on a micro has \"precision:\" the precision of a particular processor is in its manual or datasheet; consequentially, actual output values on the pin are an approximation. For example, a micro with an 8-bit (256 steps) analog out has a step precision of 3.3V/256. In NETMF, the voltage to be output is specified as a percentage called the \"level.\" So, on a processor with a maximum output of 3.3V, a level of 0.5 (50%) would output around 1.65V. NETMF has two properties for the AnalogOutput class: Scale and Offset. The final voltage on the output pin will be: Final voltage = maximum output * ( (level*Scale) + Offset)) Final voltages are clipped to fit in the range 0V to maximum pin voltage. Example The processor in this example has a maximum output of 3.3 volts. The 50% voltage (level == 0.5) by default would generate 1.65V. Because of Scale, the actual percent will be 10 (0.5 * 0.2), which results in an output voltage of about 0.33V (3.3V * 0.1). The following code requires the Microsoft.SPOT.Hardware assembly. using Microsoft.SPOT.Hardware; public class Program { public static void Main() { //Setup Analog on the first analog output channel AnalogOutput output = new AnalogOutput( Cpu.AnalogOutputChannel.ANALOG_OUTPUT_0); output.Scale = 0.2; output.Write(0.5); //output approx. 0.33V } }"
  },
  "software/netmf/tutorials/can.html": {
    "href": "software/netmf/tutorials/can.html",
    "title": "CAN",
    "keywords": "CAN Controller Area Network (CAN) is a very common interface in industrial and automotive control. CAN is very robust and works very well in noisy environments at high speeds. All error checking and recovery methods are done automatically on the hardware. TD (Transmit Data) and RD (Receive Date) are the only two pins needed. There is no master/slave relationship in CAN. All nodes are equal and can both transmit and receive. CAN includes a protocal which easily allows for a node to claim a slice of time for its use so that collisions do not occur. You must have at least two nodes on the bus, however, or CAN will not work. There are many kinds of physical layers, but the most commonly used is a high-speed-dual wire that uses a twisted pair for noise immunity. This transceiver can run at up to 1 Mbit/s and can transfer data on very long wires if a low bit rate is used. Data can be transferred between nodes on the bus where any node can transfer at any time and all other nodes are required to successfully receive the data. All nodes must have a predefined bit timing criteria. This is much more complicated than calculating a simple baud rate for UART. For this reason, many CAN bit rate calculators are available which you can find using a simple internet search. We provide a few precalculated speeds that you can use but you can create more precise custom timings if you wish. There is an informative CAN guide in our downloads. The above image shows two CAN nodes connected over a bus with the 120 ohm resistors required on these transceivers. Tip Make sure to check the datasheet from the tranceiver. Most CAN controllers will divide the frequency by 2 before actually using it. Getting Started The code below sends a message over the CAN bus and prints out every message it receives to the debug window. It requires the GHI.Hardware assembly be added to the resources in your Visual Studio project. using GHI.IO; using Microsoft.SPOT; using System.Threading; public class Program { public static void Main() { var can = new ControllerAreaNetwork(ControllerAreaNetwork.Channel.One, ControllerAreaNetwork.Speed.Kbps1000); can.ErrorReceived += can_ErrorReceived; can.MessageAvailable += can_MessageAvailable; can.Enabled = true; can.SendMessage(new ControllerAreaNetwork.Message() { Data = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 }, ArbitrationId = 0x12345678, Length = 8, IsRemoteTransmissionRequest = false, IsExtendedId = true }); Thread.Sleep(Timeout.Infinite); } private static void can_MessageAvailable(ControllerAreaNetwork sender, ControllerAreaNetwork.MessageAvailableEventArgs e) { var received = sender.ReadMessage(); var data = string.Empty; for (int i = 0; i < received.Length; i++) data += \"0x\" + received.Data[i].ToString(\"x2\") + \" \"; Debug.Print(\" CAN Message \"); Debug.Print(\"-----------------\"); Debug.Print(\" ID: \" + received.ArbitrationId.ToString()); Debug.Print(\" Time: \" + received.TimeStamp.ToString()); Debug.Print(\" RTR: \" + received.IsRemoteTransmissionRequest.ToString()); Debug.Print(\" EID: \" + received.IsExtendedId.ToString()); Debug.Print(\"Length: \" + received.Length.ToString()); Debug.Print(\" Data: \" + data); Debug.Print(\"\"); } private static void can_ErrorReceived(ControllerAreaNetwork sender, ControllerAreaNetwork.ErrorReceivedEventArgs e) { Debug.Print(\"Error on CAN: \" + e.Error.ToString()); } } CAN Bit Timing Settings The following CAN bit timing parameters were calculated for a SITCore driving the SN65HVD230 CAN transceiver chip. See the CAN Tutorial for more information. Baud Propagation Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 33.333K ? ? ? ? ? False 86.7% 0.33% 2145M 83.333K ? ? ? ? 1 False 88.9% 0.28% 879M 125K ? ? ? ? 1 False 87.5% 0.31% 545M 250K ? ? ? ? 1 False 88.9% 0.28% 257M 500K ? ? ? ? 1 False 88.9% 0.28% 101M 1M ? ? ? ? 1 False 88.9% 0.28% 23M Note: Maximum Oscillator Tolerance and Maximum Cable Length are theoretical maximums and must be tested to ensure reliability."
  },
  "software/netmf/tutorials/digital-inputs.html": {
    "href": "software/netmf/tutorials/digital-inputs.html",
    "title": "Digital Inputs",
    "keywords": "Digital Inputs Digital inputs sense if the state of its pin is high or low based on the voltage. Every pin has a maximum & minimum supported voltages. For example, the typical minimum voltage on most pins is 0 volts -- a negative voltage may damage the pin or the processor. Also, the maximum that can be supplied to most pins must be less than the processor power source voltage. Since most processors run on 3.3V, the highest voltage a pin should see is 3.3V; however, some processors that are powered by 3.3V are 5V tolerant and are capable of accepting up to 5V on their inputs. Check the product's or the processor's manual for the tolerance level. Warning 5V-tolerant doesn't mean the processor can be powered by 5V. Only the input pins can tolerate 5V. InputPort An InputPort object is used to handle digital input pins. Most pins on the processor can be input or output. Unconnected input pins are \"floating\". When a pin is an input and is not connected, it is open for any surrounding noise, which can make the pin high or low. To take care of this issue, modern processors include internal weak pull-down or pull-up resistors, that are usually controlled by software. Enabling the pull-up resistor will pull the pin high. Note that the pull-up resistor doesn't make a pin high but it pulls it high. If nothing is connected then the pin is high by default. External resistors can be added as well. In this example, a button is connected between ground and the input pin. We will also enable the pull-up resistor. This means that the pin will be high (pull-up) when button is not pressed and low (connected to ground) when the button is pressed. We will read the status of the button and pass its state to the LED. Note that the pin is high when the button is not pressed (pulled-high) and it is low when the button is pressed. This means the LED will turn off when the button is pressed. The following code requires the Microsoft.SPOT.Hardware assembly. Consult the device schematics or manuals for the proper pin numbers. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { OutputPort LED; InputPort Button; LED = new OutputPort(Cpu.Pin.GPIO_Pin1, true); Button = new InputPort(Cpu.Pin.GPIO_Pin2, false, Port.ResistorMode.PullUp); while (true) { LED.Write(Button.Read()); Thread.Sleep(10); } } } Interrupt Port In the previous example, the program just looped, and looped, and looped -- each time checking the status of the pin attached to the button. The pin is checked maybe a million times before/after the button is pressed! Interrupt ports allows us to set a method that will be executed when the button is pressed (when pin is low for example). We can set the interrupt to fire (call the method) on many state changes on the pin: when a pin is low or maybe when it is high. The most common use is the \"on change.\" The change from low to high or high to low creates a signal edge. The rising edge occurs when the signal rises from low to high. The falling edge happen when the signal falls from high to low. For a more in-depth understanding of the difference between the \"change\" interrupt versus a \"level\" interrupt, use wikipedia -- the two articles of relevance are found by searching for \"Interrupt Port\" and \"edge level transition.\" In the example below, we are using the low edge to detect a button press. \"IntButton_OnInterrupt\" will automatically run when button is pressed. The following code requires the Microsoft.SPOT.Hardware assembly. Consult the device schematic or manual for pin numbers. using Microsoft.SPOT; using Microsoft.SPOT.Hardware; using System; using System.Threading; public class Program { public static void Main() { InterruptPort IntButton = new InterruptPort(Cpu.Pin.GPIO_Pin1, false, Port.ResistorMode.PullUp, Port.InterruptMode.InterruptEdgeLow); IntButton.OnInterrupt += new NativeEventHandler(IntButton_OnInterrupt); // Other code can be added here // ... // We are just going to sleep in this example! Thread.Sleep(Timeout.Infinite); } static void IntButton_OnInterrupt(uint port, uint state, DateTime time) { Debug.Print(\"Button Pressed\"); } } When creating the new InterruptPort object, the second argument indicates whether the glitch filter is enabled (true) or disabled (false). This is typically needed when using the interrupt feature to debounce the button. Not enabling this feature may cause the button to trigger more than one event, even though the button is pressed once. Tip In the event handler, like the one above : ...OnInterrupt(uint port, uint state..., the state argument is the state of the Pin after the edge transition. I.e. on a low to high edge, state will be high (true); likewise for high to low transitions. Tristate Port If we want a pin to be an input and output, what can we do? A pin can never be in and out simultaneously but we can make it output to set something and then make it input to read a response back. One way is to \"Dispose\" of the pin. We make an output port, use it and then dispose it; then we can make the pin input and read it. NETMF supports a better option called a Tristate port. Tristate means three states -- input, output low and output high. One minor issue about tristate pins is that if a pin is set to output and then you set it to output again an exception will occur. One common work-around for this is to check the direction of the pin before changing it. The direction of the pin is in its property \"Active\" where false means input and true is output. The code below requires the Microsoft.SPOT.Hardware assembly. Tip Due to internal design, TristatePorts will only work with interrupt capable digital pins. Warning Be careful not to have the pin connected to a switch then set the pin to output. using System.Threading; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; public class Program { static void MakePinOutput(TristatePort port) { if (port.Active == false) port.Active = true; } static void MakePinInput(TristatePort port) { if (port.Active == true) port.Active = false; } public static void Main() { TristatePort TriPin = new TristatePort(Cpu.Pin.GPIO_Pin6, false, false, Port.ResistorMode.PullUp); MakePinOutput(TriPin); TriPin.Write(true); Debug.Print(\"Write to output pin completed.\"); Debug.Print(\"Changing to input pin\"); MakePinInput(TriPin); Debug.Print(\"The input pin state is: \" + TriPin.Read().ToString()); Thread.Sleep(Timeout.Infinite); } }"
  },
  "software/netmf/tutorials/digital-outputs.html": {
    "href": "software/netmf/tutorials/digital-outputs.html",
    "title": "Digital Outputs",
    "keywords": "Digital Outputs A digital output pin can be set to either high or low. There are different ways of describing these two states. High can also be called \"true\" or \"one;\" low can be called \"false\" or \"zero\". If the processor is powered off of 3.3 V, then the state high means that there is 3.3 V on the output pin. It is not going to be exactly 3.3 V but very close. When the pin is set to low then it is voltage is very close to zero volts. Warning Never connect two output pins together. If they are connected and one is high and the other is low, the entire processor can be damaged. The digital pins on micro-controllers are very weak. They can not be used to drive devices that require a lot of power. Tip All the examples shown below require the Microsoft.SPOT.Hardware assembly. Consult the device schematics or manual for specific pin numbers. Light Up an LED This example turns a LED on. The initial state of the pin (true or false) must be specified when creating the OutputPort. This example makes the pin true which will cause the LED to be on by default. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { OutputPort LED; LED = new OutputPort(Cpu.Pin.GPIO_Pin1, true); Thread.Sleep(Timeout.Infinite); } } Blink an LED To blink an LED, the pin is toggled between high and low. Due to the high speed of the microcontroller (it can flash the LED millions of times per second) a delay needs to be added between ON and OFF to see the blinking. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { OutputPort LED; LED = new OutputPort(Cpu.Pin.GPIO_Pin1, true); while (true) { LED.Write(!LED.Read()); Thread.Sleep(200); } } }"
  },
  "software/netmf/tutorials/files.html": {
    "href": "software/netmf/tutorials/files.html",
    "title": "Files",
    "keywords": "Files The file system features in NETMF are very similar to full .NET. There are no limits on file counts or sizes other than the limits of the FAT file system itself. NETMF supports FAT16 and FAT32. With a few minor changes, NETMF file system access can be tested from within the Microsoft NETMF emulator. Changes include removing any of the GHI Electronics library dependencies. Unlike full .NET, NETMF does require mounting of media. NETMF also handles media names differently than full .NET. Media name differences are easily handled by accessing the root directory name at runtime and then using that name. Consequently, most online examples of how to use .NET to access files on PCs can be used with NETMF. In NETMF, other than differences for specific physical characteristics, usage of SD/MMC cards and USB memory devices are identical to .NET. This document splits it's examples into two sets. One for SD/MMC Card file system access and the other for USB Mass Storage. The core file operations (open, read, write, etc.) are identical between the two. Warning The file system does a lot of data buffering internally to speed up file access time and to increase the life of flash media. When you write data to a file, it is often saved somewhere in internal buffers rather than being written immediately to the media. To make sure the data is stored on the media, you need to flush the data. Flushing (or closing) a file is the only way to guarantee that the data you are trying to write is on the actual media. In addition to the file data there is other information, such as directory information, that may not be written to the media when the file is flushed. For example, if you delete a file and remove the card from the system, the file is probably not actually erased because the directory structure was not flushed. Under current versions of .NET Micro Framework, there can be a variable time delay before the buffers are actually written to the media when using the FileStream's Flush method. This delay can reportedly be as long as a minute (see: https://netmf.codeplex.com/workitem/2149). To guarantee that the file buffers and the meta-data are written to the media you need to flush the volume: VolumeInfo.GetVolumes()[0].FlushAll() -or- Microsoft.SPOT.IO.VolumeInfo(\"\\SD\").FlushAll(). Ideally, you would unmount the media before it is removed from the system. This may not be always possible -- FlushAll will guarantee your data is saved Tip The SD/MMC Card examples shown below require the GHI.Hardware, Microsoft.SPOT.IO, and System.IO assemblies. Some Microsoft documentation class descriptions, such as for Directory, place the library code in the mscorlib assembly; however, it is found in the System.IO assembly. SD Card: Show Files in Root Directory This example assumes the card is already inserted; it lists all files available in the root directory. using System.IO; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; using Microsoft.SPOT.IO; using GHI.IO; using GHI.IO.Storage; class Program { public static void Main() { // ... // assume SD card is inserted // Create a new storage device // NETMF only allows one SD card // to be supported at a time. SDCard sd_card = new SDCard(); // this is a non-blocking call // it fires the RemovableMedia.Insert event after // the mount is finished. sd_card.Mount(); // for some cases, a simple sleep might suffice // This example just waits on the event before proceeding // (After first time firing of the event, you may want // to disable the handler or re-assign it bool fs_ready = false; RemovableMedia.Insert += (a, b) => { fs_ready = true; }; while (! fs_ready) { System.Threading.Thread.Sleep(50); } // Assume one storage device is available, access it through // NETMF and display the available files and folders: Debug.Print(\"Getting files and folders:\"); if (VolumeInfo.GetVolumes()[0].IsFormatted) { string rootDirectory = VolumeInfo.GetVolumes()[0].RootDirectory; string[] files = Directory.GetFiles(rootDirectory); string[] folders = Directory.GetDirectories(rootDirectory); Debug.Print(\"Files available on \" + rootDirectory + \":\"); for (int i = 0; i < files.Length; i++) Debug.Print(files[i]); Debug.Print(\"Folders available on \" + rootDirectory + \":\"); for (int i = 0; i < folders.Length; i++) Debug.Print(folders[i]); } else { Debug.Print(\"Storage is not formatted. \" + \"Format on PC with FAT32/FAT16 first!\"); } // Unmount when done sd_card.Unmount(); } } SD Card: Writing Files There is more than one way to open files. I will only cover FileStream objects. This example will open a file and write a string to it. Since FileStream will only take byte arrays, we need to convert our string to a byte array. using System.Threading; using System.Text; using Microsoft.SPOT; using System.IO; using Microsoft.SPOT.IO; using GHI.IO.Storage; public class Program { static void Main() { // if necessary, check that SD is present here... SDCard sd_card = new SDCard(); sd_card.Mount(); bool fs_ready = false; RemovableMedia.Insert += (a, b) => { fs_ready = true; }; while (! fs_ready ) { System.Threading.Thread.Sleep(1); } // Assume only one storage device is available // and that the media is formatted string rootDirectory = VolumeInfo.GetVolumes()[0].RootDirectory; FileStream FileHandle = new FileStream(rootDirectory + @\"\\hello.txt\", FileMode.Create); byte[] data = Encoding.UTF8.GetBytes(\"This string will go in the file!\"); FileHandle.Write(data, 0, data.Length); FileHandle.Close(); sd_card.Unmount(); } } SD Card: Reading a File Take the SD Card used in the last example, put it in a PC and you will see the file. For this example, we use the same SD Card written to by the last example. The file is opened and read to verify its contents. using System.Threading; using System.Text; using Microsoft.SPOT; using System.IO; using Microsoft.SPOT.IO; using GHI.IO.Storage; public class Program { static void Main() { // ... If desired, check if SD is inserted // SD Card is inserted // Create a new storage device SDCard sd_card = new SDCard(); // Mount the file system sd_card.Mount(); bool fs_ready = false; RemovableMedia.Insert += (a, b) => { fs_ready = true; }; while (!fs_ready) { System.Threading.Thread.Sleep(1); } // Assume one storage device is available, // access it through NETMF string rootDirectory = VolumeInfo.GetVolumes()[0].RootDirectory; FileStream FileHandle = new FileStream(rootDirectory + @\"\\hello.txt\", FileMode.Open, FileAccess.Read); byte[] data = new byte[100]; int read_count = FileHandle.Read(data, 0, data.Length); FileHandle.Close(); Debug.Print(\"The size of data read is: \" + read_count.ToString()); Debug.Print(\"Data from file:\"); Debug.Print(new string(Encoding.UTF8.GetChars(data), 0, read_count)); sd_card.Unmount(); } } ##SD Card: Media Detection The previous examples assumed that the card was already inserted and mostly ignored whether that media was formatted (contained a file system). The following example shows an application without such assumptions; additionally, it demonstrates the Format method. Together, InsertEventHandler, EjectEventHandler, and IsSDCardPresent are used to respond to physical card activities, which in turn are used to control mounting (Mount, Unmount) of the card. Once the card is mounted, the file-system can be used. using System; using System.IO; using System.Threading; using Microsoft.SPOT; using Microsoft.SPOT.IO; using GHI.IO.Storage; public class Program { // evt is used to avoid the possibility that accesses to the // mounted file system do not occur until mount() // is fully done. private static AutoResetEvent evt = new AutoResetEvent(false); //Make sure to set the pin to your sd card detect pin. private static InputPort sdCardDetect = new InputPort(Cpu.Pin.GPIO_NONE, false, Port.ResistorMode.Disabled); public static void Main() { RemovableMedia.Insert += new InsertEventHandler(RemovableMedia_Insert); RemovableMedia.Eject += new EjectEventHandler(RemovableMedia_Eject); // Start auto mounting thread new Thread(SDMountThread).Start(); evt.WaitOne(); // yield here until mounting and initializing is finished // Your program goes here // ... } // This event is fired by unmount; not neccesarily by physical ejection of media static void RemovableMedia_Eject(object sender, MediaEventArgs e) { Debug.Print(\"SD card unmounted, eject event fired\"); // as desired signal other thread(s) in application // that unmount occurred } static void RemovableMedia_Insert(object sender, MediaEventArgs e) { Debug.Print(\"Insert event fired; SD card mount is finished.\"); // insert code here for anything the program wants to do immediately // after mounting occurs... if (e.Volume.IsFormatted) { Debug.Print(\"Available folders:\"); string[] strs = Directory.GetDirectories(e.Volume.RootDirectory); for (int i = 0; i < strs.Length; i++) Debug.Print(strs[i]); Debug.Print(\"Available files:\"); strs = Directory.GetFiles(e.Volume.RootDirectory); for (int i = 0; i < strs.Length; i++) Debug.Print(strs[i]); } else { Debug.Print(\"SD card is not formatted. Formatting...\"); // VolumeInfo is the class that contains volume information for a specific // media. // .GetVolumes()[0] aquires the first volume on the device. Change the // index for different volumes. // .Format(\"FAT\", 0); Selects the \"FAT\" file system as the format type. VolumeInfo.GetVolumes()[0].Format(\"FAT\", 0); } evt.Set(); // proceed with other processing } public static void SDMountThread() { SDCard SD = null; const int POLL_TIME = 500; // check every 500 millisecond bool sdExists; while (true) { try { // If SD card was removed while mounting, it may throw exceptions. sdExists = sdCardDetect.Read(); // make sure it is fully inserted and stable if (sdExists) { Thread.Sleep(50); sdExists = sdCardDetect.Read(); } if (sdExists && SD == null) { SD = new SDCard(); SD.Mount(); } else if (!sdExists && SD != null) { SD.Unmount(); SD.Dispose(); SD = null; } } catch { if (SD != null) { SD.Dispose(); SD = null; } } Thread.Sleep(POLL_TIME); } } } USB Mass Storage Devices USB mass storage devices, such as memory sticks and card readers are supported by GHI's NETMF devices. If you compare the following example with those above for SD Cards, you will see how easy it is to program for one, the other, or both with virtually identical code. using System; using System.Threading; using System.IO; using Microsoft.SPOT; using System.Text; using Microsoft.SPOT.IO; using GHI.Usb; using GHI.Usb.Host; using GHI.IO.Storage; public class Program { // evt is used to avoid the possibility that accesses to the // mounted file system do not occur until mount() // is fully done. private static AutoResetEvent evt = new AutoResetEvent(false); private static MassStorage usb_storage; private static string rootDirectory; public static void Main() { RemovableMedia.Insert += new InsertEventHandler(RemovableMedia_Insert); RemovableMedia.Eject += new EjectEventHandler(RemovableMedia_Eject); // Unlike SD Card detection, the USB Host Controller sends an // event when a Mass Storage device is plugged-in. Controller.MassStorageConnected += (sender, massStorage) => { usb_storage = massStorage; usb_storage.Mount(); // fires the insert event when finished }; Controller.Start(); evt.WaitOne(); // yield here until mounting and initializing is finished byte[] data; // write using (var FileHandle = new FileStream(rootDirectory + @\"\\hello.txt\", FileMode.Create)) { data = Encoding.UTF8.GetBytes(\"This string will go in the file!\"); FileHandle.Write(data, 0, data.Length); } // read int read_count; using (var FileHandle = new FileStream(rootDirectory + @\"\\hello.txt\", FileMode.Open, FileAccess.Read)) { data = new byte[100]; read_count = FileHandle.Read(data, 0, data.Length); } Debug.Print(\"The size of data we read is: \" + read_count.ToString()); Debug.Print(\"Data from file:\"); Debug.Print(new string(Encoding.UTF8.GetChars(data), 0, read_count)); usb_storage.Unmount(); } // This event is fired by unmount static void RemovableMedia_Eject(object sender, MediaEventArgs e) { Debug.Print(\"USB unmounted, eject event fired\"); } static void RemovableMedia_Insert(object sender, MediaEventArgs e) { Debug.Print(\"Insert event fired; USB Storage mount is finished.\"); if (e.Volume.IsFormatted) { rootDirectory = e.Volume.RootDirectory; Debug.Print(\"Available folders:\"); string[] strs = Directory.GetDirectories(e.Volume.RootDirectory); for (int i = 0; i < strs.Length; i++) Debug.Print(strs[i]); Debug.Print(\"Available files:\"); strs = Directory.GetFiles(e.Volume.RootDirectory); for (int i = 0; i < strs.Length; i++) Debug.Print(strs[i]); } else { Debug.Print(\"Media is not formatted. Formatting...\"); e.Volume.Format(\"FAT\", 0); rootDirectory = e.Volume.RootDirectory; } evt.Set(); // proceed with other processing } } Warning Media formatted as FAT12 will not work. This shouldn't be an issue since FAT12 is no longer in use."
  },
  "software/netmf/tutorials/firmware-update.html": {
    "href": "software/netmf/tutorials/firmware-update.html",
    "title": "Firmware Update",
    "keywords": "Firmware Update Note If you need to update the loader, it should always be done before updating the firmware. See your device's developers' guide or manual for more detail on updating the loader. Connect your device to your PC. Launch FEZ Config and click on Check device for update button. This will show the version numbers on the PC and what is loaded on the device. Note Fez Config is installed when you install the NETMF SDK. To proceed with updating TinyCLR, click on the Firmware Updater button on the left and follow the instructions. After FEZ Config selects the firmware and the default configuration files, click Next. Click OK to proceed when the dialog appears asking if you are having issues. As the update occurs, the steps and progress are shown. When it is finished, the module is ready to be flashed with NETMF applications."
  },
  "software/netmf/tutorials/graphics.html": {
    "href": "software/netmf/tutorials/graphics.html",
    "title": "Graphics",
    "keywords": "Graphics Introduction NETMF provides excellent support for graphics through the Bitmap class (that we also supplement with our Glide library). It can draw various shapes, text, and images from BMPs, JPGs, and GIFs -- which can be obtained from the file system, network, or resources. When drawing on a bitmap, everything is rendered on an in-memory object that can be quite large depending on your screen size. To transfer a bitmap object from memory to the screen, we need to call Flush on the bitmap object. Flush will only work if the size of the bitmap is exactly the size of the screen. If it is any other size, no image will be displayed. Non-Native Support Some smaller devices do not have a built in LCD controller. As a result, they can only use displays through a different type of bus, often SPI. Depending on your exact display, you may need to call a display specific function in its driver to draw on the scree. However, some SPI displays do support the Flush method on bitmaps, so be sure to consult your display documentation. Display Configuration In order to use a display, you must configure it. You can select the display type from FEZ Config on the LCD Configuration tab or you can execute the below code (make sure to select your actual display). After you set the configuration, the device must reboot for it to take effect. The Save method returns whether or not a reboot is needed. If you are using a display that is not present under GHIDisplay, you will need to configure the properties on the Display object instead of calling the Populate method. using GHI.Processor; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { Display.Populate(Display.GHIDisplay.DisplayCP7); if (Display.Save()) PowerState.RebootDevice(false); //Display is now configured. } } Drawing The following example draws a line and an ellipse on the screen. The assemblies Microsoft.SPOT.Graphics and Microsoft.SPOT.TinyCore are required. using Microsoft.SPOT; using Microsoft.SPOT.Presentation; using Microsoft.SPOT.Presentation.Media; public class Program { public static void Main() { Bitmap lcd = new Bitmap(SystemMetrics.ScreenWidth, SystemMetrics.ScreenHeight); lcd.DrawLine(Colors.Green, 1, 20, 20, 40, 40); lcd.DrawEllipse(Colors.Blue, 5, 5, 5, 5); lcd.Flush(); } } Text The following code shows how to display text using NETMF. Since resources depend on your project's default namespace, make sure that you change the namespace in this example to match your namespace. If you do not currently have a font resource in your project, NETMF ships with two default fonts that you can add as a resource found in C:\\Program Files (x86)\\Microsoft .NET Micro Framework\\v4.3\\Fonts. You can find the NinaB font that we use below in that folder. using Microsoft.SPOT; using Microsoft.SPOT.Presentation; using Microsoft.SPOT.Presentation.Media; namespace your_namespace { public class Program { public static void Main() { Font font = Resources.GetFont(Resources.FontResources.NinaB); Bitmap lcd = new Bitmap(SystemMetrics.ScreenWidth, SystemMetrics.ScreenHeight); lcd.DrawText(\"Hello, World!\", font, Colors.White, 0, 0); lcd.Flush(); } } } Adding new fonts to your application is very easy. TTL fonts can be converted to the simple font format used in NETMF using the TinyFont tool SPI Displays If you are using a G80 or Cerb based device and a SPI display, you can configure the device so that when you call Flush on a bitmap, it is automatically sent to the display. If the ControlPin is provided, the draw window will automatically be set, the data byte will be sent, and the ControlPin will be set high for you when you call Flush. The display will also be initialized on the first call to Flush. Additionally, the backlight pin will automatically be set high if provided on the first call to Flush. Lastly, if ResetPin is provided, it will be toggled before initialization. If your device does not have enough memory to create a bitmap for the entire screen, you can create a smaller one and only draw to a subset of the display. You can set the draw window on the display to match that new size and pick which position it is drawn at. Doing this multiple times allows you to draw the entire screen by moving the draw window around and redrawing the bitmap. The below example shows how to do this on the FEZ Cerberus and requires the GHI.Hardware, Microsoft.SPOT.Graphics, and Microsoft.SPOT.Hardware assemblies. Make sure you properly set any pins other configuration below for your actual device bearing in mind the above considerations. If you are not using the DisplayN18, you must configure the display before first use and set the draw window before you call Flush every time. using GHI.Pins; using GHI.Processor; using GHI.Utilities; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; using Microsoft.SPOT.Presentation.Media; public class Program { public static void Main() { Display.Width = 128; Display.Height = 160; Display.Type = Display.DisplayType.Spi; Display.CurrentRotation = Display.Rotation.Normal; Display.BitmapFormat = Bitmaps.Format.Bpp16BgrLe; Display.SpiModule = FEZCerberus.Socket5.SpiModule; Display.ChipSelectPin = FEZCerberus.Socket5.Pin6; Display.ResetPin = FEZCerberus.Socket5.Pin3; Display.BacklightPin = FEZCerberus.Socket5.Pin4; Display.ControlPin = FEZCerberus.Socket5.Pin5; Display.Save(); var bmp = new Bitmap(Display.Width, Display.Height); bmp.DrawEllipse(Colors.Red, 5, 5, 5, 5); bmp.DrawEllipse(Colors.Green, 15, 5, 5, 5); bmp.DrawEllipse(Colors.Blue, 25, 5, 5, 5); } } Gadgeteer When using Gadgeteer display modules, the SimpleGraphics interface is provided for you. It provides an API that is a bit easier to use than regular NETMF bitmaps. It is available as the SimpleGraphics property on every display. The below example shows how to display an ellipse, line, and some text. Make sure that you change the namespace to match yours. Gadgeteer programs automatically add the NinaB font to your project so you do not need to worry about adding it yourself. using GT = Gadgeteer; namespace your_namespace { public partial class Program { void ProgramStarted() { this.displayCP7.SimpleGraphics.DisplayEllipse(GT.Color.Red, 1, GT.Color.Red, 5, 5, 5, 5); this.displayCP7.SimpleGraphics.DisplayLine(GT.Color.Blue, 1, 20, 20, 40, 40); this.displayCP7.SimpleGraphics.DisplayText(\"Hello, World!\", Resources.GetFont(Resources.FontResources.NinaB), GT.Color.Green, 60, 60); } } }"
  },
  "software/netmf/tutorials/i2c.html": {
    "href": "software/netmf/tutorials/i2c.html",
    "title": "I2C",
    "keywords": "I2C I2C (pronounced eye-squared-sea, or eye-two-sea) was originally developed by Phillips to allow multiple chipsets to communicate on a 2-wire bus in home consumer devices. It has a master and one or more slaves sharing the same data bus. Instead of selecting the slaves using a digital pin like SPI (consuming an additional I/O pin), I2C uses an addressing mechanism to communicate to the selected device. Before data is transferred, the master sends out a 7-bit address address of the slave device it wants to communicate with. It also sends one bit indicating whether it wants to send data to the device or receive data from the device. When a slave sees its address on the bus, it will acknowledge its presence. At this point, the master can send or receive data. The master will start data transfers with a \"start\" condition before it sends any address or data and then end it with \"stop\" condition. The I2C uses two wires to communicate between the I2C Master and the I2C device. These two wires are known as the SDA and SCL lines. SDA stands for Serial Data, and SCL is Serial Clock. The I2C NETMF driver is based on transactions. If we want to read from a register on a sensor, we would first need to send it the register number we wish to read from, and then we need to read the register. Those are two transactions; a write followed by a read. Addressing One very important point about I2C is that I2C devices have a 7-bit address, but 8-bits are sent on the wire in the \"control byte\" when communicating with the I2C bus. The 8th bit tells the device whether the operation will be a read operation (the 8th bit is a 1) or a write operation (the 8th bit is a 0). When discussing I2C you should always make sure you are clear about the 7-bit address that your device uses, rather than stating your 8-bit read or write address. Software I2C When using I2C, it is highly recommended that you use the built-in hardware support for I2C. In some cases though it may be necessary to have another I2C bus or it is necessary to use specific pins that are not I2C pins. In this case, I2C can be handled completely in software, though performance will be lower. The GHI Electronics libraries include a software I2C implementation in the GHI.Hardware assembly (GHI.IO.SoftwareI2CBus). An I2C Example This example will read the value of the register on an I2C device with the 7-bit address of 0x38. As discussed above, you first have to write the register number you want to read, two in this case, and then read the value back. using Microsoft.SPOT; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { //create I2C object //note that the netmf i2cdevice configuration requires a 7-bit address! It set the 8th R/W bit automatically. I2CDevice.Configuration con = new I2CDevice.Configuration(0x38, 400); I2CDevice MyI2C = new I2CDevice(con); // Create transactions // We need 2 in this example, we are reading from the device // First transaction is writing the \"read command\" // Second transaction is reading the data I2CDevice.I2CTransaction[] xActions = new I2CDevice.I2CTransaction[2]; // create write buffer (we need one byte) byte[] RegisterNum = new byte[1] { 2 }; xActions[0] = I2CDevice.CreateWriteTransaction(RegisterNum); // create read buffer to read the register byte[] RegisterValue = new byte[1]; xActions[1] = I2CDevice.CreateReadTransaction(RegisterValue); // Now we access the I2C bus using a timeout of one second // if the execute command returns zero, the transaction failed (this // is a good check to make sure that you are communicating with the device correctly // and dont have a wiring issue or other problem with the I2C device) if (MyI2C.Execute(xActions, 1000) == 0) { Debug.Print(\"Failed to perform I2C transaction\"); } else { Debug.Print(\"Register value: \" + RegisterValue[0].ToString()); } } } Multiple Devices The I2C object on NETMF is a representation of the \"bus\" and not the \"device\" so you can't construct multiple I2C objects. To access multiple I2C devices you need to have multiple configurations and then when accessing device \"A\" we need to use configuration \"A\" and when accessing device \"B\" we need to use configuration \"B\". using Microsoft.SPOT; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { //create I2C Device object representing both devices on our bus I2CDevice.Configuration conDeviceA = new I2CDevice.Configuration(0x38, 400); I2CDevice.Configuration conDeviceB = new I2CDevice.Configuration(0x48, 400); //create I2C Bus object using one of the devices on the bus I2CDevice MyI2C = new I2CDevice(conDeviceA); // Note you could have chosen to create the bus using the conDeviceB parameter, which ever you choose it will be the \"selected\" device on the bus to start with. Here's how you would do that: // I2CDevice MyI2C = new I2CDevice(conDeviceB); //create transactions (we need 2 in this example) I2CDevice.I2CTransaction[] xActions = new I2CDevice.I2CTransaction[2]; // create write buffer (we need one byte) byte[] RegisterNum = new byte[1] { 2 }; xActions[0] = I2CDevice.CreateWriteTransaction(RegisterNum); // create read buffer to read the register byte[] RegisterValue = new byte[1]; xActions[1] = I2CDevice.CreateReadTransaction(RegisterValue); // Explicitly set the I2C bus to access device A by setting the I2C Config to the Device A's config. MyI2C.Config = conDeviceA; if (MyI2C.Execute(xActions, 1000) == 0) { Debug.Print(\"Failed to perform I2C transaction\"); } else { Debug.Print(\"Register value: \" + RegisterValue[0].ToString()); } // Explicitly set the I2C bus to access device B by setting the I2C Config to the Device B's config. MyI2C.Config = conDeviceB; if (MyI2C.Execute(xActions, 1000) == 0) { Debug.Print(\"Failed to perform I2C transaction\"); } else { Debug.Print(\"Register value: \" + RegisterValue[0].ToString()); } } }"
  },
  "software/netmf/tutorials/in-field-update.html": {
    "href": "software/netmf/tutorials/in-field-update.html",
    "title": "In-Field Update",
    "keywords": "In-Field Update One of GHI Electronics's additions to NETMF includes the In-Field Update (IFU) class allowing devices to be updated in the field. Updates can be obtained over the network or via USB memory, an SD card, or even through a serial port. File encryption and integrity checking can be implemented if desired. Once the data is available, it is passed on to IFU and then stored internally in RAM. Once all of the data is received and loaded by the developer, a single call will wipe the flash and write the new files. Only the regions that are being updated are erased. Warning The final stage will erase the flash and write the new data. This can take some time depending on the board. Losing power during this process will cause the update to fail and require the device to be updated manually. Extracting an Existing Application Creating a hex file to flash to your deployed board is easy. For example, if you have a board in the field (mall kiosk, traffic signal, etc) that is difficult to access, just deploy the new version of your program to another board of the same type. Then open MFDeploy, select USB, and select Target > Application Deployment > Create Application Deployment as shown below. Tip If you would like the next version of your application to have the same update ability, be sure to include the update code in it as well. Now select the name of the file that you would like to use and where to save it. Once this is done, you can place this file on an SD card and insert it into your device, or you can send it to you device over a network. The next section will demonstrate how to load the files and perform the update. Getting Started The following example shows you how to load data into IFU and then flash the device. It requires the GHI.Hardware assembly and assumes that you have already mounted an SD card. Since firmware files can large and often cannot be held in entirely in memory we only load portions of the file at a time. using GHI.Processor; using System.IO; public class Program { public const int BLOCK_SIZE = 65536; public static void FlashFirmware() { // Reserve the memory needed to buffer the update. // A lot of RAM is needed so it is recommended to do this at the program start. InFieldUpdate.Initialize(InFieldUpdate.Types.Firmware | InFieldUpdate.Types.Configuration); // Start loading the new firmware on the RAM reserved in last step. // Nothing is written to FLASH in this stage. Power loss and failures are okay. // Simply abort this stage any way you like! // Files can come from storage, from network, from serial bus or any other way. LoadFile(\"\\\\SD\\\\Config.hex\", InFieldUpdate.Types.Configuration); LoadFile(\"\\\\SD\\\\Firmware.hex\", InFieldUpdate.Types.Firmware); LoadFile(\"\\\\SD\\\\Firmware2.hex\", InFieldUpdate.Types.Firmware); //Only if your device has two firmware files. // This method will copy The new firmware from RAM to FLASH. // This function will not return but will reset the system when done. // Power loss before this function resets the system will result in corrupted firmware. // A manual update will be needed if this method fails (due to power loss for example). InFieldUpdate.FlashAndReset(); } public static void LoadFile(string filename, InFieldUpdate.Types type) { using (var stream = new FileStream(filename, FileMode.Open)) { var data = new byte[BLOCK_SIZE]; for (int i = 0; i < stream.Length / BLOCK_SIZE; i++) { stream.Read(data, 0, BLOCK_SIZE); InFieldUpdate.Load(type, data, BLOCK_SIZE); } stream.Read(data, 0, (int)stream.Length % BLOCK_SIZE); InFieldUpdate.Load(type, data, (int)stream.Length % BLOCK_SIZE); } } }"
  },
  "software/netmf/tutorials/intro.html": {
    "href": "software/netmf/tutorials/intro.html",
    "title": ".NET Micro Framework Tutorials",
    "keywords": ".NET Micro Framework Tutorials Topics Analog Inputs Analog Outputs CAN Digital Inputs Digital Outputs Files Firmware Update Graphics I2C In-Field Update Networking PWM Pulse Feedback Real Time Clock (RTC) Register Access RLP Signal Capture Signal Generator SPI SQLite Timers Touch UART USB Client USB Host Watchdog XML XTEA What is .NET Micro Framework? If you are new to NETMF you might want to take a look at our free e-book .NET Micro Framework for Beginners"
  },
  "software/netmf/tutorials/networking.html": {
    "href": "software/netmf/tutorials/networking.html",
    "title": "Networking",
    "keywords": "Networking Introduction Networks are an essential part of our everyday lives. Almost every home is connected to a network (the Internet) and most businesses can't function without an internal network (LAN or WiFi) that is connected to an external network (the Internet). All these networks have a standard for communication: TCP/IP. There are actually a few protocols that handle different tasks in the network: DNS, DHCP, IP, ICMP, TCP, UDP, PPP, and others. In code, you create what is called a socket. A socket allows communication between your computer and one or more other endpoints (usually remote computers). Sockets can be TCP, UDP, and others. Socket support in NETMF is very similar to the full .NET Framework. Tip When working with networking, you may sometimes receive socket exceptions that look like \"10054\". NETMF uses the same error codes as WinSock on the desktop, so a quick search can tell you what that code means. For example,10054 means connection reset. Getting started with WiFi Since GHI Electronics's devices can provide multiple network interfaces (only one can be used at a time, however), you must initialize the interface you wish to use. To do so, you must create the interface object, open it, configure any network settings, and, in the case of WiFi, join a network. In the below example, you can see that we are using DHCP and dynamic DNS. This allows a lot of the configuration to be done automatically, depending on your network setup. (Static IP and static DNS also work.) Once you join a network and have been issued a valid IP Address, the network is ready to use. Make sure you enter your network key in the proper format. WPA/WPA2 keys are the literal string value while WEP keys are the hex digits without the leading 0x. The following code requires the GHI.Networking, Microsoft.SPOT.Hardware, and Microsoft.SPOT.Net assemblies. Make sure that you update the pins in the constructor to match your hardware setup. using GHI.Networking; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; using Microsoft.SPOT.Net.NetworkInformation; using System; using System.Net; using System.Threading; public class Program { private static WiFiRS9110 netif; public static void Main() { NetworkChange.NetworkAvailabilityChanged += NetworkChange_NetworkAvailabilityChanged; NetworkChange.NetworkAddressChanged += NetworkChange_NetworkAddressChanged; netif = new WiFiRS9110(SPI.SPI_module.SPI1, Cpu.Pin.GPIO_Pin1, Cpu.Pin.GPIO_Pin2, Cpu.Pin.GPIO_Pin3); netif.Open(); netif.EnableDhcp(); netif.EnableDynamicDns(); netif.Join(\"SSID\", \"Password\"); while (netif.IPAddress == \"0.0.0.0\") { Debug.Print(\"Waiting for DHCP\"); Thread.Sleep(250); } //The network is now ready to use. } private static void NetworkChange_NetworkAddressChanged(object sender, Microsoft.SPOT.EventArgs e) { Debug.Print(\"Network address changed\"); } private static void NetworkChange_NetworkAvailabilityChanged(object sender, NetworkAvailabilityEventArgs e) { Debug.Print(\"Network availability: \" + e.IsAvailable.ToString()); } } Wired Ethernet If you want to use a physical Ethernet connection, you can use our SPI based ENC28 or the built in Ethernet adapter. Initializing the network is similar to WiFi in either case, except you do not join a network as seen below. netif = new EthernetENC28J60(SPI.SPI_module.SPI1, Cpu.Pin.GPIO_Pin1, Cpu.Pin.GPIO_Pin2, Cpu.Pin.GPIO_Pin3); netif.Open(); netif.EnableDhcp(); netif.EnableDynamicDns(); while (netif.IPAddress == \"0.0.0.0\") { Debug.Print(\"Waiting for DHCP\"); Thread.Sleep(250); } //The network is now ready to use. netif = new EthernetBuiltIn(); netif.Open(); netif.EnableDhcp(); netif.EnableDynamicDns(); while (netif.IPAddress == \"0.0.0.0\") { Debug.Print(\"Waiting for DHCP\"); Thread.Sleep(250); } //The network is now ready to use. HTTP communication Once you configure a network interface, you probably want to start communicating over the network. One of the easiest ways to do this is through HTTP. After you have received an IP Address (as shown above), you can create an HTTP request to a URL and then receive its response. What you do with that data is up to you. Make sure the result buffer is larger enough to hold the response or process the data as you read it. byte[] result = new byte[65536]; int read = 0; using (var req = HttpWebRequest.Create(\"url to query\") as HttpWebRequest) { using (var res = req.GetResponse() as HttpWebResponse) { using (var stream = res.GetResponseStream()) { do { read = stream.Read(result, 0, result.Length); Thread.Sleep(20); } while (read != 0); } } } //The result array now contains the data received from the remote server. mIP For those who want greater control over the networking stack, there is the mIP C# library available at http://mip.codeplex.com/ It is a full networking stack allowing you to modify it to suit your needs, something not easily done with the built in stack. PPP You can use the provided PPP class to communicate with serial PPP devices such as cellular or regular modems that provide access to the internet. After you configure your device over a serial port (potentially using AT commands that differ for every device), you pass that port and any authentication parameters to our PPP class and then, once the PPP connection is established with the device, you can use the regular NETMF networking functionality to access the internet or your network. The below example shows the basic initialization, AT commands, and PPP commands needed to access the network using a SIM908 cellular modem. You must provide your own SIM card and correctly set the APN and COM port based on your setup. The code requires the GHI.Networking, Microsoft.SPOT.SerialPort, and Microsoft.SPOT.Net assemblies. Different AT commands will be needed for different modems. using GHI.Networking; using Microsoft.SPOT.Net.NetworkInformation; using System.IO.Ports; using System.Text; using System.Threading; public class Program { private static AutoResetEvent evt; private static void Main() { evt = new AutoResetEvent(false); NetworkChange.NetworkAvailabilityChanged += NetworkChange_NetworkAvailabilityChanged; using (var port = new SerialPort(\"YOUR UART PORT\", 115200, Parity.None, 8, StopBits.One)) { port.Open(); port.DiscardInBuffer(); port.DiscardOutBuffer(); SendATCommand(port, \"AT+CGDCONT=2,\\\"IP\\\",\\\"YOUR APN\\\"\"); SendATCommand(port, \"ATDT*99***2#\"); using (var netif = new PPPSerialModem(port)) { netif.Open(); netif.Connect(PPPSerialModem.AuthenticationType.Pap, \"\", \"\"); evt.WaitOne(); //The network is now ready to use. } } } private static void NetworkChange_NetworkAvailabilityChanged(object sender, NetworkAvailabilityEventArgs e) { if (e.IsAvailable) evt.Set(); } private static void SendATCommand(SerialPort port, string command) { var sendBuffer = Encoding.UTF8.GetBytes(command + \"\\r\"); var readBuffer = new byte[256]; var read = 0; port.Write(sendBuffer, 0, sendBuffer.Length); while (true) { read += port.Read(readBuffer, read, readBuffer.Length - read); var response = new string(Encoding.UTF8.GetChars(readBuffer, 0, read)); if (response.IndexOf(\"OK\") != -1 || response.IndexOf(\"CONNECT\") != -1) break; } } } SSL SSL allows you to secure the communications between your device and a remote server. Currently only SSL2, SSL3, and TLS1.0 are supported. Your NETMF device must have the proper time set for SSL to function. Unlike your PC, NETMF devices do not maintain a database of root certificates which are used to verify a remote server is who it says it is. As a result, you must manually include the root certificate for the site you are connecting to in your project. One easy way to accomplish this is to go to the site in your browser, click the padlock icon near the address bar, view the certificate, and then go to the Certification Path tab, click the top most (the root) certificate entry, view it, then under Details, copy it to a file, making sure to use base 64 encoding. Add that file as a resource to your project. Unfortunately, this will not always work. Some sites present different certificates based on who it detects it asking for them. Additionally, some certificates may be cross signed where there is another root you must use. You can try to search online for the actual root certificate or use Wireshark or a similar program. To use Wireshark, capture the traffic from the device when you try to connect to the desired site. It should fail since you do not have the correct certificate. Early in the conversation, after the \"Server Hello\" packet, find a \"Certificate\" packet. Under the SSL > Handshake Protocol > Certificates, find the very last entry. Make sure it is its own issuer. If not, you must use the issuer as the root certificate. For example, when connecting to https://www.google.com/, the very last certificate is GeoTrust Global CA. In the browser, it is issued by itself. In Wireshark from our device however, it is actually issued by Equifax Secure Certificate Authority. Once you have added it to your project, you can use the below code to communicate with that site: just pass in the URL you want to download and the root certificate. It requires the Microsoft.SPOT.Native and System.Http assemblies. When connecting to different sites, make sure to repeat the same process and get their root certificate as well. You are also required to update the SSL seed using MFDeploy or FEZ Config any time you update the firmware. void DownloadOverSsl(string url, byte[] certificate) { using (var request = HttpWebRequest.Create(url) as HttpWebRequest) { request.HttpsAuthentCerts = new X509Certificate[] { new X509Certificate(certificate) }; request.KeepAlive = false; using (var response = request.GetResponse()) { using (var stream = response.GetResponseStream()) { var result = string.Empty; var buffer = new byte[4096]; var read = 0; stream.ReadTimeout = 5000; for (var left = response.ContentLength; left > 0; ) { Thread.Sleep(1000); try { read = stream.Read(buffer, 0, buffer.Length); } catch { continue; } left -= read; result += new string(Encoding.UTF8.GetChars(buffer, 0, read)); } Debug.Print(result); } } } } If you do not want to use the HTTP classes, you can use a raw socket. After you have called Connect on the desired socket, pass it to the constructor of SslStream found in System.Net.Security. You then have to call AuthenticateAsClient on it. The first parameter is the common name. Often that is the host portion of the URL, such as \"www.ghielectronics.com\", but it is not always. To find the common name of the site, look at the \"Issued To\" field on the certificate details window. The next parameter is null, followed by an X509Certificate array containing the root certificate. The last two parameters need to be SslVerification.CertificateRequired and SslProtocols.Default. Once that call completes, you can read and write to that stream. Calls to Read will not always succeed, especially if called in rapid succession. You should wait a bit between calls. Waits up to 1 second can be expected depending on your exact network characteristics. We recommend testing different lengths and calibrating the wait for your needs."
  },
  "software/netmf/tutorials/pulse-feedback.html": {
    "href": "software/netmf/tutorials/pulse-feedback.html",
    "title": "Pulse Feedback",
    "keywords": "Pulse Feedback Introduction The PulseFeedback class can be found in the GHI.Hardware assembly and can be used in three different modes. The first mode is EchoDuration. This mode sends a pulse of a given length and state over the provided pin. It then waits for an echo on the other specified pin and measures how long in microseconds that echo pulse was. The echo and pulse pin can be the same if required. The next mode is DurationUntilEcho. It is very similar to EchoDuration, though instead of sending a pulse and measuring the length of the resulting echo, it measures how long it takes until that echo is received. The below example illustrates sending a pulse of 10us and reading an echo on the same pin where both the pulse and echo are high. A constructor overload is available that allows you to specify a different echo pin and state. using GHI.IO; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; using System.Threading; public class Program { public static void Main() { var pulse = new PulseFeedback(PulseFeedback.Mode.EchoDuration, true, 10, Cpu.Pin.GPIO_NONE); while (true) { Debug.Print(pulse.Read().ToString()); Thread.Sleep(250); } } } Measuring Capacitance The final mode is DrainDuration. This mode is often used in capacitive touch. When calling Read, the pulse line will be held in the specified state for the specified length and then is set to an input. When a resistor and capacitor are connected to this pin and ground, the pin will fall to ground after a short period of time dependent on the capacitance on the pin. The below image shows a sample circuit. Do note that this mode can only be used with a single pin. The exact values of the capacitor and resistor will depend on your setup. Generally a resistor in the megaohm range and a capacitor in the low picofarads in acceptable. Pin Example This image shows an example pin capture for each of the modes. It is not drawn to scale. The area marked by the arrows is the time measured for each mode. Remember that the pulse and echo may be on separate pins. Timeouts A call to Read will block until the expected pin state has occurred or the timeout has expired. In the latter case, -1 will be returned. The ReadTimeout property controls this."
  },
  "software/netmf/tutorials/pwm.html": {
    "href": "software/netmf/tutorials/pwm.html",
    "title": "PWM",
    "keywords": "PWM PWM is used to control of the ratio of a pin's high and low state, the \"duty cycle.\" This can be done using software or using built-in PWM pins on the processor. PWM pins have the advantage over Software PWM because the toggling is independent of the CPU. Software PWM is performed using the SignalGenerator class. PWM objects are constructed with the period and duration of the pulse. The duration is how long the pin is high or active while the period is the time between one duration and the next. \"Duty Cycle\" is the ratio of the duration and the period -- as a convenience, a scale can be set. The scale is applied to the numbers assigned to the PWM's properties. A pin with duty cycle 0.5 will be high half the time and low the other half. Some common uses of PWM: control the intensity of lights and the speed of motors by changing the duty-cycle. generate audio tones by keeping the duty-cycle at 50% and changing the frequency. positioning of a servo by using a pulse with a specific duration or width. .NET Micro Framework PWM Channels In NETMF, the PWM pins are defined in the \"Cpu.PWMChannel\" enumeration. As the enumeration has a limited number of members, the number of PWM pins may exceed the members. Casting can be used for those extra PWMs. // Using the enumeration PWM MyServo = new PWM(Cpu.PWMChannel.PWM_3, 2175, 175, PWM.ScaleFactor.Microseconds, false); // Lots of PWMs on processor, use a cast to access an extra PWM PWM LED = new PWM((Cpu.PWMChannel)9, 10000, 0.10, false); > [!Tip] > The examples shown below require the Microsoft.SPOT.Hardware.PWM assembly; > [!Warning] > Some or all PWM pins share the same timers internally. This means the changing frequency on one pin will also effect the others. However, the duty cycle can be different on all pins. Users needing to determine which pins share the same timer have two options. Either use trial and error on all PWM pins or check the processor manual. ## Controlling LEDs Brightness This example starts the LED at 0% intensity then slowly steps up to full intensity, after which it reverts to 0% and starts over. ```cs using System.Threading; using Microsoft.SPOT.Hardware; public class Program { static PWM MyFader = new PWM(Cpu.PWMChannel.PWM_0, 10000, 0.1, false); public static void Main() { double i = 0.0; while (true) { MyFader.DutyCycle = i; /* DutyCycle is not dynamic so make a call to * Start() to refresh the object */ MyFader.Start(); if ((i += 0.1) >= 1.0) { i = 0.0; } Thread.Sleep(10); } } } Musical Tones Music notes have specific frequencies, for example C is about 261Hz. Plugging these numbers into an array and knowing the length of each tone is all that is needed to play some simple music. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { const int NOTE_C = 261; const int NOTE_D = 294; const int NOTE_E = 330; const int NOTE_F = 349; const int NOTE_G = 392; const int WHOLE_DURATION = 1000; const int EIGHTH = WHOLE_DURATION / 8; const int QUARTER = WHOLE_DURATION / 4; const int QUARTERDOT = WHOLE_DURATION / 3; const int HALF = WHOLE_DURATION / 2; const int WHOLE = WHOLE_DURATION; //make sure the two below arrays match in length. each duration element corresponds to //one note element. static int[] note = { NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_E, NOTE_D, NOTE_D, NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_D, NOTE_C, NOTE_C}; static int[] duration = { QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, HALF, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, WHOLE}; public static void Main() { PWM MyPWM = new PWM(Cpu.PWMChannel.PWM_3, 261, 0.50, false); while (true) { for (int i = 0; i < note.Length; i++) { MyPWM.Stop(); MyPWM.Frequency = note[i]; MyPWM.Start(); Thread.Sleep(duration[i]); } Thread.Sleep(100); } } } Servos For the servo in this example, if the pulse width is about 1.25ms then the servo is at 0 degrees. Increasing the pulse width to 1.50ms will move the servo to 90 degrees (neutral). A wider pulse of 1.75ms will move the servo to 180 degrees. Servos expect a pulse every 20ms to 30ms. It is important for the high pulse to be between 1.25ms and 1.75ms so that the servo's position is set properly. The code below will move the position of the servo to 180 degrees (using a pulse of 1.75ms). It uses a pause time between pulses of 20ms. So the period is 21.75ms and a duration of 1.75ms. Note the use of \"scale\". using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { PWM MyServo = new PWM(Cpu.PWMChannel.PWM_3, 2175, 1750, PWM.ScaleFactor.Microseconds, false); while (true) { // 0 degrees. 20ms period and 1.25ms high pulse MyServo.Duration = 1250; MyServo.Period = 20000; MyServo.Start(); Thread.Sleep(1000); // 90 degrees. 20ms period and 1.50ms high pulse MyServo.Duration = 1500; MyServo.Period = 20000; MyServo.Start(); Thread.Sleep(1000); // 180 degrees. 20ms period and 1.75ms high pulse MyServo.Duration = 1750; MyServo.Period = 20000; MyServo.Start(); Thread.Sleep(1000); } } }"
  },
  "software/netmf/tutorials/register-access.html": {
    "href": "software/netmf/tutorials/register-access.html",
    "title": "Register Access",
    "keywords": "Register Access Introduction To make the processor registers directly available to developers, We added the Register class. Register PCONP = new Register(0xE01FC0C4); // Enable timer2 and timer3 PCONP.SetBits((1 << 22) | (1 << 23)); Do you understand why 1 << 22 was used? It's easy to get the first bit (0x01), second bit (0x02) and so on but what about the higher bits such as 0x00400000? Which bit is this one? Instead of complicating things, let the compiler do the work for you. Simply use 1 << 22 for the 22nd bit. Pulse Counter NETMF doesn't have a way to count pulses. What if the processor supports it? Here is an example that sets timer 3 and P0.4 on the LPC2478 processor to count pulses. While this code will compile on any platform, it will only work on LPC2478. Other processors have different registers and different features. Tip You will need the LPC2478 datasheet and manuall to fully understand the example. using System; using System.Threading; using Microsoft.SPOT; using GHI.Processor; namespace MFConsoleApplication1 { public class Program { public static void Main() { Register PCONP = new Register(0xE01FC0C4); PCONP.SetBits(1 << 22);//enable timer2 // Select IO0 on EMX CAP2.0 Register PINSEL0 = new Register(0xE002C000); PINSEL0.SetBits((3 << 8));//set bits 8 and 9 // To enable timer/counter Register T2TCR = new Register(0xE0070004); T2TCR.Value = 1; // set prescale to 0 Register T2PR = new Register(0xE007000C); T2PR.Value = 0; Register T2CTCR = new Register(0xE0070070); T2CTCR.Value = (2 << 0 | 0 << 2);//count on falling edge and use CAPn.0 // should be 0 for a counter Register T2CCR = new Register(0xE0070028); T2CCR.ClearBits(0x07); // Don't do anything on match Register T2MCR = new Register(0xE0070014); T2MCR.Value = 0; // To reset the counter T2TCR.SetBits((1 << 1)); T2TCR.ClearBits((1 << 1)); // To read Register T2TC = new Register(0xE0070008); while (true) { uint count = T2TC.Value; Debug.Print(\"Total count: \" + count); Thread.Sleep(1000); } } } }"
  },
  "software/netmf/tutorials/rlp.html": {
    "href": "software/netmf/tutorials/rlp.html",
    "title": "Runtime Loadable Procedures",
    "keywords": "Runtime Loadable Procedures Introduction In .NET Micro Framework, C# is complied to an intermediate languages that is interpreted by the Common Language Runtime (CLR). The C# you write is not executed directly by processor. In a typical application, you will not see much difference in speed as many objects used in your application are implemented as native code internally and are not interpreted. When running processor intensive tasks, like cryptography algorithms or even as simple as calculating CRC, however, you will likely notice the interpreter overhead. GHI's Runtime Loadable Procedures (RLP) allow you to write and compile native code that you load onto the device and execute from the interpreted C#. Installing the compiler Since you are writing native code for an ARM device, you cannot easily use Visual Studio. Yagarto provides a helpful toolchain for compiling native code for ARM. Download and then install the following programs in order. Make sure the install paths do not have any spaces in them. Compiling will not function if they do. yagarto-bu-2.23.1_gcc-4.7.2-c-c++_nl-1.20.0_gdb-7.5.1_eabi_20121222.exe yagarto-tools-20121018-setup.exe You can verify the correct installation by running make --version and arm-none-eabi-gcc --version from a command prompt. Getting Started Download and extract the samples found here. The RLP.h file found in the Native directory is a header that defines our extensions and helpers that make it easier to write your native code. You will also see a folder for each supported platform. Within each platform, there are four files. makefile and LinkerScript.lds are basic scripts that we provide to get started with compiling your program. You will not normally need to edit them. Build.bat will actually compile your code for you and produce an elf and map file as output. NativeCode.c is an example file that shows you some basic functions. You can modify it and add your own functions. Every function you write that you want to be called from managed code must have the following signature: int YourFunc(void** args); When you invoke that function from the managed side, any arguments you pass will be found in that void** parameter. If you pass five arguments, then args will be an array of five void pointers. It is your job to then cast each of these pointers to their native equivalent. The following table shows the supported NETMF parameter types and their native equivalent: | C# Parameter | Native Parameter | | byte | unsigned char | | sbyte | char | | short | short | | ushort | unsigned short | | int | int | | uint | unsigned int | | long | long | | ulong | unsigned long | | float | float | | double | double | | bool | unsigned char | | Bitmap | unsigned short[] | Arrays of each of the above parameters (except bitmaps) are also supported. When passing a non-array parameter, it is by value. Any changes to these parameters on the native side are not seen on the managed side. Arrays, however, are passed by reference. Any change to the value of a member of an array is seen on the managed side. Make sure to not read or write past the end of the array. It is up to you to track its length, perhaps through a second parameter you pass. For example, imagine you have passed an integer, a byte array, its length, and a boolean down to the native side. You can retrieve those parameters using the following code: int YourFunc(void** args) { int arg1 = *(int*)(args[0]); //the integer unsigned char* arg2 = (unsigned char*)(args[1]); //the byte array int arg3 = *(int*)(args[2]); //the length of the byte array unsigned char arg4 = *(unsigned char*)(args[3]); //the boolean } When you pass a primitive value, you simple cast the void pointer to a pointer of the corresponding native type and dereference it. When the argument is an array, you again cast the void pointer to a pointer of the corresponding native type but you do not reference it. You can dereference that pointer as if it were an array. Again, make sure to not read beyond its length. Warning Make sure you do not store the pointer to a passed array parameter between function invocations. The array is managed by the CLR and the garbage collector may relocate it between invocations. If you want to pass data outside of the parameters to Invoke for performance reasons, you can allocate a buffer on the native side and return its address to managed code. From there, you can read and write to that buffer using Register and AddressSpace. Compiling Once you have written your code, in the folder that contains makefile, LinkerScript.lds, and NativeCode.c run the file Build.bat. You will see some compiler output and an elf and a map file will appear in the directory. Both files will be called [board name]RLP. The ELF file is the one that you will need to load into RLP from the managed code. To be able to invoke the native function from managed code, you must get the compiled ELF file into a byte array in the managed side. You can save the ELF file as a resource, to an SD card, or to the network and then read or download it. Warning If the native code you execute hangs or crashes, NETMF and the device will become unresponsive. It is recommended that you do not execute any RLP code as soon as the board boots because if it crashes you will have no way to redeploy a program requiring you to completely erase and reflash the board. Invoking Your Function The below code shows you how to load the byte array representing the ELF file into RLP and calling it natively. (It assumes you have added the ELF file as a resource to your C# project.) You pass the name of your native function into the FindFunction function and it will return an object that you can call Invoke() on and pass parameters. We will use the same four parameters as above, an integer, byte array, its length, and a boolean. This code requires the GHI.Hardware assembly. using GHI.Processor; using Microsoft.SPOT; public class Program { public static void Main() { byte[] elfBuffer = Resources.GetBytes(Resources.BinaryResources.ELFFile); //Make sure to load the ELF file you compiled into this array. var elfImage = new RuntimeLoadableProcedures.ElfImage(elfBuffer); var yourFunction = elfImage.FindFunction(\"YourFunc\"); var byteArray = new byte[] { 25, 5, 0 }; int anInteger = 5; var result = yourFunction.Invoke(anInteger, byteArray, byteArray.Length, true); Debug.Print(\"The function returned \" + result.ToString()); //Should be 5 Debug.Print(\"The third element of the byte array is \" + byteArray[2].ToString()); //Should be 30 } } Now imagine we defined the native function like this: int YourFunc(void** args) { int arg1 = *(int*)(args[0]); //the integer unsigned char* arg2 = (unsigned char*)(args[1]); //the byte array int arg3 = *(int*)(args[2]); //the length of the byte array unsigned char arg4 = *(unsigned char*)(args[3]); //the boolean if (arg4 != 0) arg2[2] = arg2[0] + arg2[1]; return arg1; } The first parameter, the integer, is returned from the function. You can access that value as the return value of the Invoke function in the managed side. The above C# example prints out that value. If the fourth parameter, the boolean, is not false (0 is false, otherwise it is true) we will add the first and second elements of the byte array and store the result in the third element. You will see the change to the array in the managed side. Events and Tasks Sometimes you might have a long running function that runs in RLP. Since RLP blocks the managed side, nothing else on the board will run for the duration of the that function call. Using RLP tasks, your native function can register a function to be called at some future point so that you can return to NETMF. As long as this callback function is short lived, the managed side will continue to execute. You can break your work up into smaller chunks that are worked on during each callback invocation. When you are done, you can trigger an event on the managed side. Make sure to re-register the callback so long as there is more work to do. The below example passes the first and only argument passed to RLP into the task and then fires that many events. It schedules itself to fire again in one second until the parameter is zero. RLP_Task task; void TaskCallback(void* arg) { unsigned int* count = (unsigned int*)arg; RLP->PostManagedEvent(*count); if (*count > 0) { *count -= 1; RLP->Task.ScheduleTimeOffset(&task, 1000000); } else { RLP->Task.Abort(&task); } } int StartTask(void** args) { RLP->Task.Initialize(&task, TaskCallback, args[0], RLP_FALSE); RLP->Task.Schedule(&task); return 1; } As before, we create and invoke the RLP function object but we also subscribe to the NativeEvent event and then print out the value received. Every time PostManagedEvent is called from the native side, this event will be fired with the data passed to it. In this example, it should be fired six times, printing out 5, 4, 3, 2, 1, and then 0. using GHI.Processor; using Microsoft.SPOT; using System.Threading; public class Program { public static void Main() { byte[] elfBuffer = Resources.GetBytes(Resources.BinaryResources.ELFFile); //Make sure to add an ELF file as a resource RuntimeLoadableProcedures.NativeEvent += RuntimeLoadableProcedures_NativeEvent; var elfImage = new RuntimeLoadableProcedures.ElfImage(elfBuffer); var startTask = elfImage.FindFunction(\"StartTask\"); startTask.Invoke(5); Thread.Sleep(Timeout.Infinite); } private static void RuntimeLoadableProcedures_NativeEvent(object sender, RuntimeLoadableProcedures.NativeEventEventArgs e) { Debug.Print(\"We've received \" + e.Data.ToString() + \" from the native side.\"); //Should be 5 to 0 } } Bitmaps You can also pass bitmaps to RLP. You will receive an unsigned short array in the argument list. Changes made to that array will be reflected in the bitmap back in C#. As with all arrays, make sure not to save it between invocations or read beyond its end. Its length is equal to bitmap.Width x bitmap.Height. Each entry in the array represents one pixel in RGB 565 format. You can access a pixel using the following code: void SetPixel(unsigned short* bmp, int x, int y, int bitmapWidth, unsigned short color) { bmp[y * bitmapWidth + x] = color; } Multiple Files If you load more than one ELF image at a time, you must be sure that all images after the first occupy a unique location in RAM. The header and linker scripts we provide place the ELF image at a certain default location. You must change that for the second file so that you do not overwrite the first file when you load the second. When compiling, you should see a map file created as one of the outputs. This file tells you exactly how big and where each function is located. You can use it to determine where your second image must start."
  },
  "software/netmf/tutorials/rtc.html": {
    "href": "software/netmf/tutorials/rtc.html",
    "title": "Real Time Clock",
    "keywords": "Real Time Clock Introduction Systems typically have a Real Time Clock (RTC) that uses a backup battery (VBAT) and a separate crystal to keep time running even if the system is not powered. Typical crystal value is 32.768Khz. Consult your product's documentation to see if it has a built in RTC. Note: NETMF has time services that you can use to get/set the system time such as DateTime.Now. When power is lost or the system is reset, the time is also reset. Those services do not need RTC. An application can set proper time by reading from the RTC (running from a separate always-on power) or from the internet through a time server. Not having RTC will not limit NETMF's time services beyond resetting the date and time to a preset value. Time measurement is still available. Time via NETMF This example sets the current time to a predefined value that is lost when power is lost. using System; using System.Threading; using Microsoft.SPOT; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { //Set the time to 07/25/2012 at 11:46:11 DateTime time = new DateTime(2012, 07, 25, 11, 46, 11); // lost after power cycle or reset: Utility.SetLocalTime(time); while (true) { Debug.Print(DateTime.Now.ToString()); Thread.Sleep(100); } } } Using GHI's extension for Real Time Clock To use the RTC hardware, we first need to check if the RTC hardware has the valid time or not. If RTC has a valid time then we can read from the RTC and use that to set the NETMF system time. If time is not valid, then you will need to set the RTC to the correct time. You can verify the validilty of the RTS several ways. One way is to use the built in battery ram (if available) to store some \"magic numbers\" that we check later to determine if the battery ram data is still valid. If they are then most likely the RTC is valid. You can also check the RTC against some known time. For example, if your program was written on 1/1/2014, you can check to see if the current RTC date is before that known date. If it is, then the time is incorrect. using System; using GHI.Processor; using Microsoft.SPOT; public class Program { public static void Main() { DateTime DT; try { DT = RealTimeClock.GetDateTime(); Debug.Print(\"Current Real-time Clock \" + DT.ToString()); } catch // If the time is not good due to powerloss or being a new system an exception will be thrown and a new time will need to be set { Debug.Print(\"The date was bad and caused a bad time\"); DT = new DateTime(2014, 1, 1, 1, 1, 1); // This will set a time for the Real-time Clock clock to 1:01:01 on 1/1/2014 RealTimeClock.SetDateTime(DT); //This will set the hardware Real-time Clock to what is in DT } if (DT.Year < 2011) { Debug.Print(\"Time is not resonable\"); } Debug.Print(\"Current Real-time Clock \" + RealTimeClock.GetDateTime().ToString()); DT = new DateTime(2014, 9, 15, 7, 30, 0); // This will set the clock to 9:30:00 on 9/15/2014 RealTimeClock.SetDateTime(DT); //This will set the hardware Real-time Clock to what is in DT Debug.Print(\"New Real-time Clock \" + RealTimeClock.GetDateTime().ToString()); } }"
  },
  "software/netmf/tutorials/signal-capture.html": {
    "href": "software/netmf/tutorials/signal-capture.html",
    "title": "Signal Capture",
    "keywords": "Signal Capture Introduction The SignalCapture class monitors a pin and records any changes (high-low or low-high transitions) of the pin into an array. It is a digital waveform recorder. Each array element is the number of microseconds between each signal change. SignalCapture is a GHI Electronics' extension to NETMF. It requires the GHI.Hardware assembly. using System.Threading; using Microsoft.SPOT.Hardware; using GHI.IO; public class Program { public static void Main() { uint[] signal = new uint[100]; SignalCapture pin = new SignalCapture(Cpu.Pin.GPIO_Pin1, Port.ResistorMode.Disabled); pin.Read(false, signal); // ... // process the \"signal\" } } Timeouts When calling read, it blocks until it has read as much data as the buffer can hold or you specify using the count parameter. If your signal is shorter than that, the call will never return. Make sure to request only what you plan to capture. Alternatively, you can use the ReadTimeout property to signal to the call to return after the number of milliseconds specified by the property regardless of how much data you captured."
  },
  "software/netmf/tutorials/signal-generator.html": {
    "href": "software/netmf/tutorials/signal-generator.html",
    "title": "Signal Generator",
    "keywords": "Signal Generator Introduction SignalGenerator is non-blocking digital waveform generator. SignalGenerator works by comparing an internal counter to an array of time values, one by one; when the value of the argument matches the counter, the output pin is changed. The values are in microseconds. SignalGenerator can also be used to generate PWM; unlike the PWM class, SignalGenerator can be used to generate PWM on any available output pins; however, it uses a processor time, the higher the frequency the more processing it uses. SignalGenerator can operate in two modes: non-blocking: runs in the background using system interrupts, and blocking: which does block (while it is running, it does not yield time to other code). This mode has higher accuracy (used, for example, to generate carrier frequencies for infrared signals). Blinking LED This example uses an array of toggle times to turn the LED on and off. The state of the the pin controlled by SignalGenerator will change after waiting for the durations specified in an array. Onces all the elements have been used; SignalGenerator will, optionally, start over at the beginning of the array. using Microsoft.SPOT.Hardware; using GHI.IO; public class Program { public static void Main() { uint[] time = new uint[] { 500 * 1000, 500 * 1000 }; SignalGenerator LED = new SignalGenerator(Cpu.Pin.GPIO_Pin1, false); // args: initial value, // array of times, // array start offset, // length of array, // repeat -- if true ==> repeat LED.Set(false, time, 0, 2, true);//start the waveform //... do more code here and the LED will continue to work. //... because the default running mode is non-blocking. } }"
  },
  "software/netmf/tutorials/spi.html": {
    "href": "software/netmf/tutorials/spi.html",
    "title": "SPI",
    "keywords": "SPI SPI uses three, sometimes four, wires for transferring data. The bus on SPI consists of one master and one or more slaves. The master will send clock to the salves along with data and will read back using the same clock. This clock is used to determine how fast the data is moved. If you know electronics, this is a shift register. So, the master will transmit a clock on a SCK (serial clock) pin and will simultaneously transmit the data on MOSI (Master Out Slave In) pin. The slave will read the clock on SCK pin and simultaneously read the data from MOSI pin. So far, this is a one way communication. While data is transmitted in one direction using MOSI another set of data is sent back on MISO (Master In Slave Out) pin. Other data sizes are possible but bytes are most common. NETMF supports 8-bit (byte) and 16-bit (short) data transfers. Because of this master/slave scheme, we can add multiple slaves on the same bus where the master selects which slave it will swap the data with. Note I am using the word swap because you can never send or receive but you always send and receive (swap) data. The master selects one of the slaves using SSEL (Slave Select) pin. This pin can be called CS (Chip Select) as well. In theory, the master can have unlimited slaves but it can only select one of them at any given time. The master will only need 3 wires (SCK, MISO, MOSI) to connect to all slaves on the bus but then it needs a separate SSEL pin for each one of the slaves. Some SPI devices (slaves) can have more than one select pin, like VS1053 MP3 decoder chip that uses one pin for data and one pin for commands but both share the 3 data transfer pins (SCK, MOSI, MISO). SPI needs more wires than other similar buses but it can transfer data very fast. A 50Mhz clock is possible on SPI, that is 50 million bits in one second. Note that NETMF devices are always SPI masters, not slaves. Before creating a SPI object, we would need a SPI configuration object. The configuration object is used to set the states of the SPI pins and some timing parameters. In most cases, you need the clock to be idle low (false) with clocking on rising edge (true) and with zero for select setup and hold time. The only thing you would need to set is the clock frequency. Some devices may accept high frequencies but others do not. Setting the clock to 1000Khz (1Mhz) should be okay for a starter Getting Started This example is sending/receiving 10 bytes of data on SPI channel 1. Note: NETMF start numbering SPI channels (module) from 1, but on processors the channels start from 0 typically. So, using SPI1 in code is actually using SPI0 on the processor. using System.Threading; using Microsoft.SPOT.Hardware; public class Program { public static void Main() { SPI.Configuration MyConfig = new SPI.Configuration(Cpu.Pin.GPIO_Pin1, false, 0, 0, false, true, 1000, SPI.SPI_module.SPI1); SPI MySPI = new SPI(MyConfig); byte[] tx_data = new byte[10]; byte[] rx_data = new byte[10]; MySPI.WriteRead(tx_data, rx_data); Thread.Sleep(100); } } Accessing Multiple Devices The SPI object on NETMF is a representation of the \"bus\" and not the \"device\", so you can't construct multiple SPI objects, unless it uses a different SPI bus. To access multiple SPI devices you need to have multiple configurations and then when accessing device \"A\" we need to use configuration \"A\" and when accessing device \"B\" we need to use configuration \"B\". using Microsoft.SPOT.Hardware; public class Program { public static void Main() { SPI.Configuration ConfigDeviceA = new SPI.Configuration(Cpu.Pin.GPIO_Pin1, false, 0, 0, false, true, 1000, SPI.SPI_module.SPI1); SPI.Configuration ConfigDeviceB = new SPI.Configuration(Cpu.Pin.GPIO_Pin4, false, 0, 0, false, true, 1000, SPI.SPI_module.SPI1); SPI MySPI = new SPI(ConfigDeviceA); byte[] tx_data = new byte[10]; byte[] rx_data = new byte[10]; // accessing device A MySPI.Config = ConfigDeviceA; MySPI.WriteRead(tx_data, rx_data); // accessing device B MySPI.Config = ConfigDeviceB; MySPI.WriteRead(tx_data, rx_data); } }"
  },
  "software/netmf/tutorials/sqlite.html": {
    "href": "software/netmf/tutorials/sqlite.html",
    "title": "SQLite Database",
    "keywords": "SQLite Database Introduction According to the SQLite homepage, \"SQLite is a software library that implements a self-contained, serverless, zero-configuration, transactional SQL database engine. SQLite is the most widely deployed SQL database engine in the world\". GHI Electronics provides a driver for SQLite so that you can have access to a SQL database that resides entirely in a simple file on a persistant storage device. The below code is a simple example where a database file is created in RAM (using SD cards and USB drives is possible as well). A table is created that is filled with some initial rows and then this data is read from the database. This data is then iterated over and printed out. ColumnOriginNames returns the names of each of the columns. using System; using System.Collections; using Microsoft.SPOT; using GHI.SQLite; public class Program { public static void Main() { // Create a database in memory, // file system is possible however! Database myDatabase = new GHI.SQLite.Database(); myDatabase.ExecuteNonQuery(\"CREATE Table Temperature\" + \" (Room TEXT, Time INTEGER, Value DOUBLE)\"); //add rows to table myDatabase.ExecuteNonQuery(\"INSERT INTO Temperature (Room, Time, Value)\" + \" VALUES ('Kitchen', 010000, 4423)\"); myDatabase.ExecuteNonQuery(\"INSERT INTO Temperature (Room, Time, Value)\" + \" VALUES ('Living Room', 053000, 9300)\"); myDatabase.ExecuteNonQuery(\"INSERT INTO Temperature (Room, Time, Value)\" + \" VALUES ('bed room', 060701, 7200)\"); // Process SQL query and save returned records in SQLiteDataTable ResultSet result = myDatabase.ExecuteQuery(\"SELECT * FROM Temperature\"); // Get a copy of columns orign names example String[] origin_names = result.ColumnNames; // Get a copy of table data example ArrayList tabledata = result.Data; String fields = \"Fields: \"; for (int i = 0; i < result.RowCount; i++) { fields += result.ColumnNames[i] + \" |\"; } Debug.Print(fields); object obj; String row = \"\"; for (int j = 0; j < result.RowCount; j++) { row = j.ToString() + \" \"; for (int i = 0; i < result.ColumnCount; i++) { obj = result[j, i]; if (obj == null) row += \"N/A\"; else row += obj.ToString(); row += \" |\"; } Debug.Print(row); } myDatabase.Dispose(); } } The details on SQLite All details on SQLite are found at the offcial SQLite website http://www.sqlite.org/"
  },
  "software/netmf/tutorials/timers.html": {
    "href": "software/netmf/tutorials/timers.html",
    "title": "Timers",
    "keywords": "Timers Introduction NETMF includes 2 timer classes, Timer and ExtendedTimes. Timer class is the same one included in full framework where ExtendedTimer is specific to NETMF with extra functionality. A timer example This example creates a timer that will run after five seconds and then it will keep firing every second. Note: the time parameters expect times in milliseconds. using System.Threading; using Microsoft.SPOT; public class Program { class OurClass { public int x; } static void RunMe(object o) { OurClass cls = (OurClass)o; Debug.Print(\"From timer!\"); Debug.Print(\"Value: \" + cls.x.ToString()); } public static void Main() { OurClass cls = new OurClass(); cls.x = 5; Timer MyTimer = new Timer(new TimerCallback(RunMe), cls, 5000, 1000); Debug.Print( \"The timer will fire in 5 seconds and then fire priodically every 1 second\"); Thread.Sleep(Timeout.Infinite); } }"
  },
  "software/netmf/tutorials/touch.html": {
    "href": "software/netmf/tutorials/touch.html",
    "title": "Touch",
    "keywords": "Touch Introduction NETMF devices have the ability to receive touch input from a touch screen. Getting Started The below code draws a blue circle wherever you touch on the display. Make sure that you have configured your display properly before running this example. It requires the Microsoft.SPOT.Graphics, Microsoft.SPOT.TinyCore, and Microsoft.SPOT.Touch assemblies. using Microsoft.SPOT; using Microsoft.SPOT.Input; using Microsoft.SPOT.Presentation; using Microsoft.SPOT.Presentation.Media; using Microsoft.SPOT.Touch; public class Program : Application { private Bitmap lcd; public static void Main() { Program app = new Program(); app.Run(); } public Program() { this.lcd = new Bitmap(SystemMetrics.ScreenWidth, SystemMetrics.ScreenHeight); Touch.Initialize(this); this.MainWindow = new Window(); this.MainWindow.TouchDown += MainWindow_TouchDown; this.MainWindow.TouchUp += MainWindow_TouchUp; this.MainWindow.TouchMove += MainWindow_TouchMove; } private void MainWindow_TouchMove(object sender, TouchEventArgs e) { Debug.Print(\"Touch move at (\" + e.Touches[0].X.ToString() + \", \" + e.Touches[0].Y.ToString() + \")\"); this.lcd.DrawEllipse(Colors.Blue, e.Touches[0].X, e.Touches[0].Y, 5, 5); this.lcd.Flush(); } private void MainWindow_TouchUp(object sender, TouchEventArgs e) { Debug.Print(\"Touch up at (\" + e.Touches[0].X.ToString() + \", \" + e.Touches[0].Y.ToString() + \")\"); } private void MainWindow_TouchDown(object sender, TouchEventArgs e) { Debug.Print(\"Touch down at (\" + e.Touches[0].X.ToString() + \", \" + e.Touches[0].Y.ToString() + \")\"); } } Touch In Gadgeteer Since Gadgeteer already creates an application instance, you cannot use the above example in a Gadgeteer program. You must instead use the pre-created application instance available under Application.Current. The below example shows you how to use touch in a Gadgeteer program. Tip In the below example we still use a Bitmap object to draw to the display. Usually in Gadgeteer programs you will want to use the SimpleGraphics interface on a display module. using Microsoft.SPOT; using Microsoft.SPOT.Input; using Microsoft.SPOT.Presentation; using Microsoft.SPOT.Presentation.Media; using Microsoft.SPOT.Touch; public partial class Program { private Bitmap lcd; void ProgramStarted() { this.lcd = new Bitmap(SystemMetrics.ScreenWidth, SystemMetrics.ScreenHeight); Touch.Initialize(Application.Current); this.display.WPFWindow.TouchDown += this.MainWindow_TouchDown; this.display.WPFWindow.TouchUp += this.MainWindow_TouchUp; this.display.WPFWindow.TouchMove += this.MainWindow_TouchMove; } private void MainWindow_TouchMove(object sender, TouchEventArgs e) { Debug.Print(\"Touch move at (\" + e.Touches[0].X.ToString() + \", \" + e.Touches[0].Y.ToString() + \")\"); this.lcd.DrawEllipse(Colors.Blue, e.Touches[0].X, e.Touches[0].Y, 5, 5); this.lcd.Flush(); } private void MainWindow_TouchUp(object sender, TouchEventArgs e) { Debug.Print(\"Touch up at (\" + e.Touches[0].X.ToString() + \", \" + e.Touches[0].Y.ToString() + \")\"); } private void MainWindow_TouchDown(object sender, TouchEventArgs e) { Debug.Print(\"Touch down at (\" + e.Touches[0].X.ToString() + \", \" + e.Touches[0].Y.ToString() + \")\"); } } Calibration If your screen does not report touches close to where they actually were, your screen may need to be calibrated. NETMF provides functionality that can do this for you. It will give you a list of coordinates to touch at based on the configured screen size and then you give it the coordinates returned when you touch that spot on the display. It usually asks for five points: the four corners and the center. The below example takes care of all of this calibration for you. It requires the Microsoft.SPOT.Native, Microsoft.SPOT.Graphics, Microsoft.SPOT.TinyCore, and Microsoft.SPOT.Touch assemblies. You begin calibration by touching the screen once. After that, touch where each of the five circles is displayed in turn. After you do that, it will show you the calibration data and show a circle wherever you touch. using Microsoft.SPOT; using Microsoft.SPOT.Input; using Microsoft.SPOT.Presentation; using Microsoft.SPOT.Presentation.Media; using Microsoft.SPOT.Touch; public class Program : Application { private Bitmap lcd; private bool started; private bool finished; private int currentCalibrationPoint; private int calibrationPoints; private short[] screenX; private short[] screenY; private short[] uncalibratedX; private short[] uncalibratedY; public static void Main() { new Program().Run(); } public Program() { this.lcd = new Bitmap(SystemMetrics.ScreenWidth, SystemMetrics.ScreenHeight); Touch.Initialize(this); this.MainWindow = new Window(); this.MainWindow.TouchUp += this.OnTouchUp; this.currentCalibrationPoint = 0; this.calibrationPoints = 0; this.started = false; this.finished = false; Touch.ActiveTouchPanel.GetCalibrationPointCount(ref this.calibrationPoints); this.screenX = new short[this.calibrationPoints]; this.screenY = new short[this.calibrationPoints]; this.uncalibratedX = new short[this.calibrationPoints]; this.uncalibratedY = new short[this.calibrationPoints]; for (int i = 0, x = 0, y = 0; i < this.calibrationPoints; i++) { Touch.ActiveTouchPanel.GetCalibrationPoint(i, ref x, ref y); this.screenX[i] = (short)x; this.screenY[i] = (short)y; } Touch.ActiveTouchPanel.StartCalibration(); } private void OnTouchUp(object sender, TouchEventArgs e) { if (this.started && !this.finished) { this.uncalibratedX[this.currentCalibrationPoint] = (short)e.Touches[0].X; this.uncalibratedY[this.currentCalibrationPoint] = (short)e.Touches[0].Y; if (++this.currentCalibrationPoint == this.calibrationPoints) { Touch.ActiveTouchPanel.SetCalibration(this.calibrationPoints, this.screenX, this.screenY, this.uncalibratedX, this.uncalibratedY); this.lcd.Clear(); var str = \"Screen X: [\"; for (int i = 0; i < this.calibrationPoints; i++) str += this.screenX[i].ToString() + (i + 1 != this.calibrationPoints ? \", \" : string.Empty); str += \"]\"; this.lcd.DrawText(str, Resources.GetFont(Resources.FontResources.NinaB), Colors.White, 0, 0); str = \"Screen Y: [\"; for (int i = 0; i < this.calibrationPoints; i++) str += this.screenY[i].ToString() + (i + 1 != this.calibrationPoints ? \", \" : string.Empty); str += \"]\"; this.lcd.DrawText(str, Resources.GetFont(Resources.FontResources.NinaB), Colors.White, 0, 15); str = \"Uncalibrated X: [\"; for (int i = 0; i < this.calibrationPoints; i++) str += this.uncalibratedX[i].ToString() + (i + 1 != this.calibrationPoints ? \", \" : string.Empty); str += \"]\"; this.lcd.DrawText(str, Resources.GetFont(Resources.FontResources.NinaB), Colors.White, 0, 30); str = \"Uncalibrated Y: [\"; for (int i = 0; i < this.calibrationPoints; i++) str += this.uncalibratedY[i].ToString() + (i + 1 != this.calibrationPoints ? \", \" : string.Empty); str += \"]\"; this.lcd.DrawText(str, Resources.GetFont(Resources.FontResources.NinaB), Colors.White, 0, 45); this.lcd.Flush(); this.finished = true; } else { this.DrawPoint(this.screenX[this.currentCalibrationPoint], this.screenY[this.currentCalibrationPoint]); } } else if (!this.started) { this.started = true; this.DrawPoint(this.screenX[0], this.screenY[0]); } else if (this.finished) { this.DrawPoint(e.Touches[0].X, e.Touches[0].Y); } } private void DrawPoint(int x, int y) { this.lcd.Clear(); this.lcd.DrawEllipse(Colors.Red, x, y, 6, 6); this.lcd.Flush(); } } After you calibrate your display, you can save the values in the four short arrays in the above program along with the number of calibration points. You can then pass these values at a later point, without running calibration again, to the below function. Touch.ActiveTouchPanel.SetCalibration(calibrationPoints, screenX, screenY, uncalibratedX, uncalibratedY);"
  },
  "software/netmf/tutorials/uart.html": {
    "href": "software/netmf/tutorials/uart.html",
    "title": "UART",
    "keywords": "UART UART transfers data between two pins TXD (transmit) and RXD (receive). Normally, the pins are on different processors. Data is sent from TXD, in a sequence, at a predefined speed. The receiver checks data on RXD. Usually systems want to send and receive as well, so there will be a TXD and RXD on one end with another set on the other end. The connection in between is crossed so TXD on one end goes to RXD on the other end and vice versa. UART Technical Details The \" baud rate\" is number of bits are transmitted per second; standard baud rates are 9600, 119200, 115200 and others. Direct connection between TXD/RXD pins use their high/low voltages for bits (\"TTL level,\" 0V to 3.3V). NETMF supports serial ports (UART) in the same way as the full .NET framework. Serial ports on PC's and on NETMF are called \"COM ports.\" Their names start with COM1 and go up (there is no COM0). Processors usually start with UART0 not UART1 (so, COM1 is UART0... etc.) Software UART Through GHI's SignalGenerator, a system can simulate a UART data. This is beneficial as any GPIO pin can be used to send the UART data. A good example is a serial character display. These typically do not require speed and not updated frequently. If all UARTs are being used, any GPIO can be used to simulate a UART transmission. RS232 Processor pins can be set at 0 for low or at the power level for high, 3.3V for example. This means connecting outputs on a micro to inputs on another is safe. These levels are called TTL. In our case here a TTL UART levels. To overcome distances, the very old standard RS232 defined the low state to be +12V. Sounds like it is backwards but this is how it is! This port is found on many systems and found on many PCs. It has been disappearing from PCs lately but this can be easily added using a USB to serial cable. We can't connect the RS232 levels to TTL levels directly. This is easily solved by adding a small circuitry that converts the RS232 levels to TTL, like the MAX232 chip. In other words, do not connect a PC's serial port to a micro directly. Use a level converter in between. Example using UART The following program sends a counter value 10 times per second. The data is sent at 115200 baud so make sure that the receiving end is setup the same way. This program sends the data on COM1 of your NETMF device. This COM number has nothing to do with COM number on your PC. For example, you may have a USB serial port on your PC that maps to COM8 and so you need to open COM8 on your PC, not COM1. The NETMF program will still use COM1 because it uses UART0 (COM1). The data sent can be shown on a terminal program, like Tera Term. Note how we ended the string with \"\\r\\n\". The \"\\r\" is code to tell the terminal to \"return\" back to the beginning of the line and \"\\n\" is to add \"new\" line. When data is received on UART, it is automatically queued a side so you wouldn't lose any data. Tip Using serial ports require the Microsoft.SPOT.Hardware.SerialPort. If your program uses the enums Parity or StopBits, the Microsoft.SPOT.Hardware assembly is needed. using System.IO.Ports; using System.Text; using System.Threading; public class Program { public static void Main() { SerialPort uart = new SerialPort(\"COM1\", 115200); int counter = 0; uart.Open(); while (true) { // create a string string counter_string = \"Count: \" + counter.ToString() + \"\\r\\n\"; // convert the string to bytes byte[] buffer = Encoding.UTF8.GetBytes(counter_string); // send the bytes on the serial port uart.Write(buffer, 0, buffer.Length); // increment the counter; counter++; //wait... Thread.Sleep(100); } } } Receiving Data This example will wait until a byte is received on the port and then print it telling you what was sent from the other end. using System.Threading; using System.IO.Ports; using System.Text; public class Program { public static void Main() { SerialPort uart = new SerialPort(\"COM1\", 115200); int read_count = 0; byte[] rx_byte = new byte[1]; uart.Open(); while (true) { // read one byte read_count = uart.Read(rx_byte, 0, 1); if (read_count > 0)// do we have data? { // create a string string counter_string = \"You typed: \" + rx_byte[0].ToString() + \"\\r\\n\"; // convert the string to bytes byte[] buffer = Encoding.UTF8.GetBytes(counter_string); // send the bytes on the serial port uart.Write(buffer, 0, buffer.Length); //wait... Thread.Sleep(10); } } } } Sending and Receiving This example is a loop-back. Connect a wire from TX to RX on your board and it will send data and make sure it is receiving it correctly. using System.IO.Ports; using System.Text; using System.Threading; using Microsoft.SPOT; public class Program { public static void Main() { SerialPort uart = new SerialPort(\"COM1\", 115200); int read_count = 0; byte[] tx_data; byte[] rx_data = new byte[10]; tx_data = Encoding.UTF8.GetBytes(\"FEZ\"); uart.ReadTimeout = 0; uart.Open(); while (true) { // flush all data uart.Flush(); // send some data uart.Write(tx_data, 0, tx_data.Length); // wait to make sure data is transmitted Thread.Sleep(100); // read the data read_count = uart.Read(rx_data, 0, rx_data.Length); if (read_count != 3) { // we sent 3 so we should have 3 back Debug.Print(\"Wrong size: \" + read_count.ToString()); } else { // the count is correct so check the values // I am doing this the easy way so the code is more clear if (tx_data[0] == rx_data[0]) { if (tx_data[1] == rx_data[1]) { if (tx_data[2] == rx_data[2]) { Debug.Print(\"Perfect data!\"); } } } } Thread.Sleep(100); } } } Tip For .NET Gadgeteer examples, see the Device to PC communications document."
  },
  "software/netmf/tutorials/usb-client.html": {
    "href": "software/netmf/tutorials/usb-client.html",
    "title": "USB Client",
    "keywords": "USB Client By default, all of GHI's NETMF devices use USB for deploying and debugging. You may optionally use the USB client (not the host) for something other than debugging. This is actually supported by NETMF and GHI Electronics adds more functionality making it even easier to use. Say you are making a device that that reads temperature and humidity and logs all of this data on an SD card. This device can be configured to set the time or give file names and you want this configuration to happen over USB, perhaps in the field. So when your device plugs into a USB port, you want it to show as a virtual serial port. This way, anyone can open a terminal software (like TeraTerm) to connect to your device and configure it. Using the USB client, there is no need to add the extra cost of additional RS232 serial ports or USB<->serial chipsets. The built-in USB client port can be configured to act as a CDC device, a virtual COM port. However, you still need to connect the PC to your device for debugging and deploying applications. Since the USB client port is used by your end application, you need to debug and deploy using a serial connection. You only need the serial interface in the development and deployment stage. ##Setting Up Debugging and deploying serially is specific to each device so you may want to consult your device's manual or Developers' Guide. Once the device is configured for the serial interface, remember to select the proper transport in Visual Studio. Tip The examples shown below require the Microsoft.SPOT.Hardware.Usb and GHI.Usb assemblies. Mouse The following example tells your device to act as a mouse and send random commands to your computer. You could use this to prank others and send their computer fake mouse commands or to have a second mouse for your own computer. using System; using System.Threading; using GHI.Usb; using GHI.Usb.Client; using Microsoft.SPOT; using Microsoft.SPOT.Hardware.UsbClient; public class Program { public static void Main() { // Start Mouse Mouse mouse = new Mouse(); Controller.ActiveDevice = mouse; // Move pointer in a swirl const int ANGLE_STEP_SIZE = 15; const int MIN_CIRCLE_DIAMETER = 50; const int MAX_CIRCLE_DIAMETER = 200; const int CIRCLE_DIAMETER_STEP_SIZE = 1; int diameter = MIN_CIRCLE_DIAMETER; int diameterIncrease = CIRCLE_DIAMETER_STEP_SIZE; int angle = 0; int factor; Random rnd = new Random(); int i = 0; while (true) { // we want to do it every sometime randomly i = rnd.Next(5000) + 5000;//between 5 and 10 seconds Debug.Print(\"Delaying for \" + i + \" ms\"); Thread.Sleep(i); i = rnd.Next(200) + 100;//do it for a short time Debug.Print(\"Looping \" + i + \" times!\"); while (i-- > 0) { // Check if connected to PC if (Controller.State == UsbController.PortState.Running) { // Note Mouse X, Y are reported as change in position // (relative position, not absolute) factor = diameter * ANGLE_STEP_SIZE * (int)System.Math.PI / 180 / 2; int dx = (-1 * factor * (int)Microsoft.SPOT.Math.Sin(angle) / 1000); int dy = (factor * (int)Microsoft.SPOT.Math.Cos(angle) / 1000); angle += ANGLE_STEP_SIZE; diameter += diameterIncrease; if (diameter >= MAX_CIRCLE_DIAMETER || diameter <= MIN_CIRCLE_DIAMETER ) diameterIncrease *= -1; // report mouse position mouse.SendRawData(dx, dy, 0,Buttons.None); } Thread.Sleep(10); } } } } Keyboard Emulating a keyboard is as very similar to emulating a mouse. The following example will create a USB Keyboard and send \"Hello world!\" to a computer every second. using System.Threading; using GHI.Usb; using GHI.Usb.Client; using Microsoft.SPOT; using Microsoft.SPOT.Hardware.UsbClient; public class Program { public static void Main() { // Start keyboard Keyboard kb = new Keyboard(); Controller.ActiveDevice = kb; Debug.Print(\"Waiting to connect to PC...\"); // Send \"Hello world!\" every second while (true) { // Check if connected to PC if ( Controller.State == UsbController.PortState.Running) { // We need shift down for capital \"H\" kb.Press(Key.LeftShift); kb.Stroke(Key.H); kb.Release(Key.LeftShift); // Now \"ello world\" kb.Stroke(Key.E); kb.Stroke(Key.L); kb.Stroke(Key.L); kb.Stroke(Key.O); kb.Stroke(Key.Space); kb.Stroke(Key.W); kb.Stroke(Key.O); kb.Stroke(Key.R); kb.Stroke(Key.L); kb.Stroke(Key.D); // The \"!\" kb.Press(Key.LeftShift); kb.Stroke(Key.D1); kb.Release(Key.LeftShift); // Send an enter key kb.Stroke(Key.Enter); } Thread.Sleep(1000); } } } CDC - Virtual Serial Port Serial ports are the most common interface, especially in the embedded system world. It is an ideal solution for devices to transfer data between computers and embedded devices NETMF products. To combine the popularity and usefulness of USB with the ease of serial, we have virtual USB devices. To Windows' applications or devices, a virtual serial port works just like a serial port but it is actually a USB port. To use CDC, you need the USB Drivers that come with the GHI Electronics NETMF and Gadgeteer SDK (2016 R1 and later). This will only work if you use the default constructor of the Cdc class. If you do not and you provide different Vendor and Product Ids, this driver will not work and you will need to create your own. You can use the one we provide in the SDK as a model, though it will not be signed. Note: CDC drivers usually handle one transaction in every frame. The max EP size on USB is 64 bytes and there 1000 frames per second on full-speed USB. This means that the maximum transfer rate in ideal conditions for CDC is 64KB/sec. The buffer size is limited so you must be make sure to read all data quickly because there is no overflow event. The following example will create a USB CDC and send \"Hello world!\" to computer every second. using System.Threading; using GHI.Usb; using GHI.Usb.Client; using Microsoft.SPOT; using Microsoft.SPOT.Hardware.UsbClient; public class Program { public static void Main() { // Start Cdc Cdc vsp = new Cdc(); Controller.ActiveDevice = vsp; // Send \"Hello world!\" to PC every second. (Append a new line too) byte[] bytes = System.Text.Encoding.UTF8.GetBytes(\"Hello world!\\r\\n\"); while (true) { // Check if connected to PC if (Controller.State != UsbController.PortState.Running) { Debug.Print(\"Waiting to connect to PC...\"); } else { vsp.Stream.Write(bytes, 0, bytes.Length); } Thread.Sleep(1000); } } } Mass Storage GHI's USB client supports Mass Storage Class (MSC). This allows access to connected media right from USB. For example, a data logger application that needs to save data to an SD card or USB memory. When the user is done collecting data, they can plug the USB data logger into the PC and now the PC can detect the device as a mass storage device. The user can then transfer the files using standard operating system controls. It may be helpful to think of the device as a memory card reader. We can even enhance our logger where the USB client interface can be CDC to configure the device and later dynamically switch to MSC to transfer files. Once very common question on GHI Electronics support is \"Why can't I access the media from my application while the media is also accessed externally (from windows)?\" Due to caching of file system data and/or the possibility of a write from one interface while the other is doing a read and/or a write, data on the media and/or data used by the interface will likely (and quickly) be corrupted. Note: you can easily switch back and forth between internal file system and USB MSC. This example code assumes an SD card is always plugged in. It enables MSC showing the device as a card reader. This code assumes that the USB port is NOT being used for debugging. In addition to the assemblies mentioned above in the Note, the following code requires the GHI.Hardware assembly. using System; using System.Threading; using GHI.Usb.Client; using GHI.Usb; using GHI.IO.Storage; public class Program { public static void Main() { // Start MS MassStorage ms = new MassStorage(); Controller.ActiveDevice = ms; // Assume SD card is connected SDCard sd; try { sd = new SDCard(); } catch { throw new Exception(\"SD card not detected\"); } ms.AttachLogicalUnit(sd,0, \" \", \" \"); // enable host access ms.EnableLogicalUnit(0); Thread.Sleep(Timeout.Infinite); } } HID and Custom Devices Windows and other operating systems have built in drivers for USB HID (Human Interface Devices). These drivers are ideal as they provide a simple way to transfer data between a computer and a device. HID's are usually mice and keyboards but they can also be simple data transfer devices. Although examples in codeshare may need changes for differences in SDK releases, this project provides a good example: http://www.ghielectronics.com/community/codeshare/entry/420 The GHI Electronics USB Client allows you to control the USB client in anyway you like. This feature requires advanced knowledge of USB. If you do not know what an EndPoint or a Pipe is then do not attempt to create custom devices. It is very important to have the device configured correctly the first time it is plugged into Windows since Windows stores a lot of information in its registry. If you change the configuration of your device after you had it plugged into Windows previously, Windows may not see the changes since it will be using the old configuration from its registry. Do not use USB Client Custom Devices unless you really have good reason to use them and you are knowledgeable in USB and Windows drivers."
  },
  "software/netmf/tutorials/usb-host.html": {
    "href": "software/netmf/tutorials/usb-host.html",
    "title": "USB Host",
    "keywords": "USB Host There is usually a lot of confusion between USB host and USB client. USB host is the system that connects to multiple USB clients. For example, the PC is a USB host and it can connect to multiple USB clients like mice, keyboards, and mass storage devices. Implementing a USB client is rather simple but implementing a host is far more complicated. USB host is an exclusive feature from GHI Electronics. With this feature, you can connect almost any USB device to GHI's NETMF products. This feature opens new possibilities for embedded systems. Your product can now connect to a standard USB keyboard and can also access files on a USB thumb drive. USB is a hot pluggable system which means any device can be connected or disconnected at any time. Events are generated when devices are connected or disconnected. The program that you write should subscribe to these events and handle them accordingly. With USB hub support, devices can be connected directly to the USB host port or the user may connect multiple USB devices through a USB hub. Getting Started When working with USB host, you interact with the Controller. You subscribe to the connected event for various devices and then start the controller. When a device connected, you receive an object representing that device as the event arguments. You can subscribe to the Disconnect event on that device to do any clean up you might need. The below code requires the GHI.Usb and GHI.Hardware assemblies and shows you briefly how to handle device connections and disconnections. using GHI.Usb.Host; using Microsoft.SPOT; using System.Threading; public class Program { public static void Main() { Controller.DeviceConnectFailed += Controller_DeviceConnectFailed; Controller.KeyboardConnected += Controller_KeyboardConnected; Controller.Start(); Thread.Sleep(Timeout.Infinite); } private static void Controller_DeviceConnectFailed(object sender, EventArgs e) { Debug.Print(\"Failed.\"); } private static void Controller_KeyboardConnected(object sender, Keyboard keyboard) { Debug.Print(\"Keyboard connected.\"); keyboard.Disconnected += keyboard_Disconnected; } private static void keyboard_Disconnected(BaseDevice sender, EventArgs e) { Debug.Print(\"Keyboard disconnected.\"); } } Mice, keyboards, and joysticks Once you receive a connect event and the associated object for a mouse, keyboard, or joystick, you can subscribe to various events on those objects to receive data from the device. The below code simply prints out when a button or key is pressed. using GHI.Usb.Host; using Microsoft.SPOT; using System.Threading; public class Program { public static void Main() { Controller.KeyboardConnected += Controller_KeyboardConnected; Controller.MouseConnected += Controller_MouseConnected; Controller.JoystickConnected += Controller_JoystickConnected; Controller.Start(); Thread.Sleep(Timeout.Infinite); } private static void Controller_KeyboardConnected(object sender, Keyboard keyboard) { Debug.Print(\"Keyboard connected.\"); keyboard.KeyUp += keyboard_KeyUp; keyboard.KeyDown += keyboard_KeyDown; } private static void Controller_MouseConnected(object sender, Mouse mouse) { Debug.Print(\"Mouse connected.\"); mouse.ButtonChanged += mouse_ButtonChanged; mouse.CursorMoved += mouse_CursorMoved; mouse.WheelMoved += mouse_WheelMoved; } private static void Controller_JoystickConnected(object sender, Joystick joystick) { Debug.Print(\"Joystick connected.\"); joystick.ButtonChanged += joystick_ButtonChanged; joystick.CursorMoved += joystick_CursorMoved; joystick.HatSwitchPressed += joystick_HatSwitchPressed; } private static void keyboard_KeyUp(Keyboard sender, Keyboard.KeyboardEventArgs e) { Debug.Print(\"Up: \" + e.Which.ToString()); } private static void keyboard_KeyDown(Keyboard sender, Keyboard.KeyboardEventArgs e) { Debug.Print(\"Down: \" + e.Which.ToString()); } private static void mouse_ButtonChanged(Mouse sender, Mouse.ButtonChangedEventArgs e) { Debug.Print(e.State.ToString() + \" \" + e.Which); } private static void mouse_CursorMoved(Mouse sender, Mouse.CursorMovedEventArgs e) { Debug.Print(e.Delta.ToString() + \" \" + e.NewPosition.ToString()); } private static void mouse_WheelMoved(Mouse sender, Mouse.WheelMovedEventArgs e) { Debug.Print(e.Delta.ToString() + \" \" + e.NewPosition.ToString()); } private static void joystick_ButtonChanged(Joystick sender, Joystick.ButtonChangedEventArgs e) { Debug.Print(e.State.ToString() + \" \" + e.Which); } private static void joystick_CursorMoved(Joystick sender, Joystick.CursorMovedEventArgs e) { Debug.Print(e.Delta.ToString() + \" \" + e.NewPosition.ToString() + \" \" + e.Which.ToString()); } private static void joystick_HatSwitchPressed(Joystick sender, Joystick.HatSwitchPressedEventArgs e) { Debug.Print(e.Direction.ToString()); } } Serial Serial (UART) communication is a very common interface. There are many companies that create chips that convert USB to serial. GHI Electronics currently supports chipsets from FTDI. Their FT232 is known to work, though others may as well. USB chipsets are made to be somewhat customized. A company can use an FTDI chip to make their product run on USB and they will change the strings in USB descriptors so that when you plug in their device to a PC you will see the company name and not FTDI. They can also change the USB VID/PID, vendor ID and product ID. Many of the interface products on the market use the FTDI chipset. A few other USB-Serial manufacturers, like Prolific, are included, but they are deprecated and not supported by us. The below example simply echoes any data received back out to the sender and prints it to the debug output. using GHI.Usb.Host; using Microsoft.SPOT; using System.Threading; public class Program { public static void Main() { Controller.UsbSerialConnected += Controller_UsbSerialConnected; Controller.Start(); Thread.Sleep(Timeout.Infinite); } private static void Controller_UsbSerialConnected(object sender, UsbSerial usbSerial) { Debug.Print(\"UsbSerial connected.\"); usbSerial.DataReceived += usbSerial_DataReceived; } private static void usbSerial_DataReceived(UsbSerial sender, UsbSerial.DataReceivedEventArgs e) { for (int i = 0; i < e.Data.Length; i++) Debug.Print(e.Data[i].ToString()); sender.Write(e.Data); } } ##Mass Storage When you connect a mass storage device, it can be accessed through the regular NETMF filesystem functions with the device root \"USB\". Once you mount the device, you need to wait for NETMF to fire the RemovableMedia.Insert event before you try accessing the filesystem. The below code simply opens or creates a file on the drive, writes \"Hello, World!\" to it, and then unmounts the device. It requires the Microsoft.SPOT.IO and System.IO assembly. using GHI.Usb.Host; using Microsoft.SPOT; using Microsoft.SPOT.IO; using System.IO; using System.Text; using System.Threading; public class Program { private static AutoResetEvent evt = new AutoResetEvent(false); public static void Main() { Controller.MassStorageConnected += Controller_MassStorageConnected; Controller.Start(); Thread.Sleep(Timeout.Infinite); } private static void Controller_MassStorageConnected(object sender, MassStorage massStorage) { RemovableMedia.Insert += RemovableMedia_Insert; massStorage.Mount(); evt.WaitOne(); using (var fs = new FileStream(\"\\\\USB\\\\Hello.txt\", FileMode.OpenOrCreate)) fs.Write(Encoding.UTF8.GetBytes(\"Hello, World!\"), 0, 13); massStorage.Unmount(); } private static void RemovableMedia_Insert(object sender, MediaEventArgs e) { Debug.Print(\"Inserted.\"); evt.Set(); } } Warning Under current versions of NETMF, the Flush method of FileStream will eventually write the buffers; unfortunately, there is a delay (sometimes up to a minute) from when Flush is called to when the data is actually flushed. See Files and Folders for more details. Webcams You can also connect a webcam and stream images from it. Webcams only support certain image formats and sizes so you need to query the formats supported and tell the camera to stream images using that format. We support cameras that support the YUV2 color format. The below code requires the Microsoft.SPOT.Graphics and Microsoft.SPOT.TinyCore assemblies. It looks for a format that has a size of 320x240 and starts to stream it. When a new image is available an event is raised and we draw the received image to the bitmap that represents our screen and then flush it. Make sure you have a display properly configured. using GHI.Usb.Host; using Microsoft.SPOT; using Microsoft.SPOT.Presentation; using System.Threading; public class Program { private static Bitmap lcd = new Bitmap(SystemMetrics.ScreenWidth, SystemMetrics.ScreenHeight); public static void Main() { Controller.WebcamConnected += Controller_WebcamConnected; Controller.Start(); Thread.Sleep(Timeout.Infinite); } private static void Controller_WebcamConnected(object sender, Webcam webcam) { webcam.ImageAvailable += webcam_ImageAvailable; foreach (Webcam.ImageFormat i in webcam.SupportedFormats) { if (i.Width == 320 && i.Height == 240) { webcam.StartStreaming(i); break; } } } private static void webcam_ImageAvailable(Webcam sender, EventArgs e) { sender.GetImage(lcd); lcd.Flush(); } } Unknown Devices If your device is not recognized by our libraries, the UnknownDeviceConnected event will be triggered. This event will give you the USB parameters of the device that you can use to \"force\" the creation of a specific type. This method is not guaranteed to work with every unknown device, however. The below code illustrates how to do this with a usb to serial device. using GHI.Usb.Host; using Microsoft.SPOT; using System.Threading; public class Program { private static UsbSerial serial; public static void Main() { Controller.UnknownDeviceConnected += Controller_UnknownDeviceConnected; Controller.Start(); Thread.Sleep(Timeout.Infinite); } private static void Controller_UnknownDeviceConnected(object sender, Controller.UnknownDeviceConnectedEventArgs e) { Debug.Print(\"Unknown device connected.\"); serial = new UsbSerial(e.Id, e.InterfaceIndex, e.VendorId, e.ProductId, e.PortNumber, BaseDevice.DeviceType.SerialProlific); serial.DataReceived += serial_DataReceived; } private static void serial_DataReceived(UsbSerial sender, UsbSerial.DataReceivedEventArgs e) { for (int i = 0; i < e.Data.Length; i++) Debug.Print(e.Data[i].ToString()); sender.Write(e.Data); } }"
  },
  "software/netmf/tutorials/watchdog.html": {
    "href": "software/netmf/tutorials/watchdog.html",
    "title": "Watchdog",
    "keywords": "Watchdog Introduction In the embedded system world, devices are usually always running and with no user interaction. So if something went wrong, it would be very beneficial if we have an automatic reset button. Watchdog is your reset button! Assume you are making a smart vending machine that reports its inventory over the network. If your code raises an exception that wasn't handled properly then your program will end. Program ended means the vending machine will no longer work. Someone will have to drive to the vending machine to reset it! The alternative is to use the watchdog. When watchdog is enabled, it is given a timeout where it will reset the system if the time reached without resetting the timeout. This is like saying \"reset the system in 5 seconds\" then the program goes on to do something. The program needs to come back and reset the time and say \"reset in 5 seconds\". If the program keeps doing this, the system will never reset. But if the program got stuck somewhere, the 5 seconds will end causing the system to reset. Tip GHI Electronics does not use the NETMF's built in services for watchdog, but uses its own. Use the GHI.Hardware assembly when using watchdog. Warning Do NOT set the Watchdog reset time too short during the debug phase. If it is shorter than the time taken to deploy your code then your device will reboot and the new code never gets loaded. The only way to get out of the problem is to erase the device and reflash the firmware. We advice not to use watchdog during development and debugging. Max Timeouts The following lists shows the max timeout value for watchdog on our various devices in milliseconds. Do note that for G120 and EMX, there is roughly a 30% margin of error around the max value where the device may still reset. G400: 15,995 G120: 134,217 EMX: 4,294,967 Cerberus: 32768 Five Second Watchdog This example shows how to set the watchdog to 5 seconds timeout and create a thread to clear the watchdog every 3 seconds. Should anything go wrong and the thread that clears the watchdog isn't able the run due to another thread using all of the available resources, the device will reset in 5 seconds. Tip Once you enable the Watchdog, it cannot be disabled. So you have to keep resetting the timeout. This is done to assure that no system corruption will disable watchdog accidentally. using System; using System.Threading; using GHI.Processor; public class Program { public static void Main() { // Timeout 5 seconds int timeout = 1000 * 5; // Enable Watchdog Watchdog.Enable(timeout); // Start a time counter reset thread WDTCounterReset = new Thread(WDTCounterResetLoop); WDTCounterReset.Start(); // .... // your program starts here // If we exit the program, // the thread will stop working and the system will reset! Thread.Sleep(Timeout.Infinite); } static Thread WDTCounterReset; static void WDTCounterResetLoop() { while (true) { // reset time counter every 3 seconds Thread.Sleep(3000); Watchdog.ResetCounter(); } } } You may be thinking, if the software locked up then how would the code that handles watchdog ever run? It works because the watchdog is supported in hardware not software. This means that the counter and the reset mechanism are done inside the processor, without the need for any software. Detecting Watchdog In some cases, you need to know if the system did reset because of a watchdog to log this info or run some recovery procedures. This is how it works using System; using System.Threading; using Microsoft.SPOT; using GHI.Processor; public class Program { public static void Main() { // Normally, you can read this flag ***ONLY ONCE*** on power up if (Watchdog.LastResetCause == Watchdog.ResetCause.Watchdog) { Debug.Print(\"Watchdog did Reset\"); } else { Debug.Print(\"Reset switch or system power\"); } } }"
  },
  "software/netmf/tutorials/xml.html": {
    "href": "software/netmf/tutorials/xml.html",
    "title": "XML",
    "keywords": "XML ##Introduction Extensible Markup Language (XML) is a standard for containing data. When you want to transfer some info between two devices, you can set some rules on how the data is to be packed and sent from device A. On the other side, device B receives the data and knows how to unpack it. Before XML, this created some difficulties. What if you were sending the data to a system implemented by a different designer? You would have to explain how you packed your data so the other designer can unpack it. With XML, the design is transmitted with the data. XML is extensively used. For example, when a website's shopping cart wants to know the shipping cost on a certain package, it will pack the shipment details in XML format and then send to FedEx. The FedEx website will read the info and send the cost info back in XML format as well. The usefulness of XML can also be utilized in other ways. Let's say you are designing a data logger. Let's also assume the end users will need to configure the data logger to fit their needs. When a user configures the device, you need to store the info internally somehow. You can save the data with your own format which requires extra coding and debugging, or better just use XML. All GHI Electronics NETMF devices have a built-in XML reader and writer (packer and un-packer ). Here is an example XML file that will help in our data logger design. <?xml version=\"1.0\" encoding=\"utf-8\" ?> <NETMF_DataLogger> <FileName>Data</FileName> <FileExt>txt</FileExt> <SampleFreq>10</SampleFreq> </NETMF_DataLogger> This XML example includes a root element and three child elements. XML is very flexible, for instance all info in the example could have been defined as root elements. The root element \"NETMF_DataLogger\" contains three pieces of info that are important for our logger. It contains the file name, the file extension and a frequency of our saved data. With this example, the logger will create a file called Data.txt and then will log data into that file 10 times every second. Spaces and layout do not mean anything to XML, we (humans) need them to make things easier to read. The previous example can be stored without the spaces and layout like this. <?xml version=\"1.0\" encoding=\"utf-8\" ?><NETMF_DataLogger><FileName>Data</FileName> <FileExt>txt</FileExt><SampleFreq>10</SampleFreq></NETMF_DataLogger> See why spaces are important to us human being! You can also add comments inside XML files, comments do not mean anything to XML but can help in manual reading of the files <?xml version=\"1.0\" encoding=\"utf-8\"?> <!--This is just a comment--> <NETMF_DataLogger> <FileName>Data</FileName> <FileExt>txt</FileExt> <SampleFreq>10</SampleFreq> </NETMF_DataLogger> Finally, XML support attributes. An attribute is an extra info given to an element. Alternatively, you can add another element to describe the extra information. The choice is yours. Attributes are not explained in this document; there are many excellent tutorials and examples on the internet. GHI Electronics' NETMF devices support reading and writing XML format. Reading and writing XML files work over streams which means any stream you already have or implement can work with XML. For example, we will use the built-in MemoryStream and FileStream. The examples shown below require the following assemblies: System.IO, System.Xml, MFDpwsExtensions. XML in Memory This code shows how to make an XML document in memory, it implements the XML presented above. using System.IO; using System.Xml; using System.Ext.Xml; using Microsoft.SPOT; public class Program { public static void Main() { MemoryStream ms = new MemoryStream(); XmlWriter xmlwrite = XmlWriter.Create(ms); xmlwrite.WriteProcessingInstruction(\"xml\", \"version=\\\"1.0\\\" encoding=\\\"utf-8\\\"\"); xmlwrite.WriteComment(\"This is just a comment\"); xmlwrite.WriteStartElement(\"NETMF_DataLogger\");//root element xmlwrite.WriteStartElement(\"FileName\");//child element xmlwrite.WriteString(\"Data\"); xmlwrite.WriteEndElement(); xmlwrite.WriteStartElement(\"FileExt\"); xmlwrite.WriteString(\"txt\"); xmlwrite.WriteEndElement(); xmlwrite.WriteStartElement(\"SampleFeq\"); xmlwrite.WriteString(\"10\"); xmlwrite.WriteEndElement(); xmlwrite.WriteEndElement();//end the root element xmlwrite.Flush(); xmlwrite.Close(); //////// display the XML data /////////// byte[] byteArray = ms.ToArray(); char[] cc = System.Text.UTF8Encoding.UTF8.GetChars(byteArray); string str = new string(cc); Debug.Print(str); } } When you try to add an assembly you will notice that there are two assemblies for XML, the \"System.Xml\" and \"System.Xml.Legacy\". Do not use the \"legacy\" driver, it is there for older NETMF devices with systems that did not have built-in support for XML. If the \"Unsupported Exception\" is raised on an older device, replace the System.Xml assembly with System.Xml.Legacy Readable Output When running the example above, we will see the output XML data at the end. The data is correct but it is not formatted to be \"human\" friendly. Note that we are reading and writing XML files on a very small system so the less info (spaces/formatting) the better it is. So it is actually better not to have any extra spaces or formatting but for the sake of making things look pretty, we will add new lines as follows using System.IO; using System.Xml; using System.Ext.Xml; using Microsoft.SPOT; public class Program { public static void Main() { MemoryStream ms = new MemoryStream(); XmlWriter xmlwrite = XmlWriter.Create(ms); xmlwrite.WriteProcessingInstruction(\"xml\", \"version=\\\"1.0\\\" encoding=\\\"utf-8\\\"\"); xmlwrite.WriteComment(\"This is just a comment\"); xmlwrite.WriteRaw(\"\\r\\n\"); xmlwrite.WriteStartElement(\"NETMF_DataLogger\");//root element xmlwrite.WriteString(\"\\r\\n\\t\"); xmlwrite.WriteStartElement(\"FileName\");//child element xmlwrite.WriteString(\"Data\"); xmlwrite.WriteEndElement(); xmlwrite.WriteRaw(\"\\r\\n\\t\"); xmlwrite.WriteStartElement(\"FileExt\"); xmlwrite.WriteString(\"txt\"); xmlwrite.WriteEndElement(); xmlwrite.WriteRaw(\"\\r\\n\\t\"); xmlwrite.WriteStartElement(\"SampleFeq\"); xmlwrite.WriteString(\"10\"); xmlwrite.WriteEndElement(); xmlwrite.WriteRaw(\"\\r\\n\"); xmlwrite.WriteEndElement();//end the root element xmlwrite.Flush(); xmlwrite.Close(); //////// display the XML data /////////// byte[] byteArray = ms.ToArray(); char[] cc = System.Text.UTF8Encoding.UTF8.GetChars(byteArray); string str = new string(cc); Debug.Print(str); } } Reading and Parsing Creating XML files is actually easier than parsing (reading) them. There are many ways to read the XML file but basically you can just go through the file and read one piece at the time till you reach the end. This code example creates an XML data and it reads it back. using System.IO; using System.Xml; using System.Ext.Xml; using Microsoft.SPOT; public class Program { public static void Main() { MemoryStream ms = new MemoryStream(); XmlWriter xmlwrite = XmlWriter.Create(ms); xmlwrite.WriteProcessingInstruction(\"xml\", \"version=\\\"1.0\\\" encoding=\\\"utf-8\\\"\"); xmlwrite.WriteComment(\"This is just a comment\"); xmlwrite.WriteRaw(\"\\r\\n\"); xmlwrite.WriteStartElement(\"NETMF_DataLogger\");//root element xmlwrite.WriteString(\"\\r\\n\\t\"); xmlwrite.WriteStartElement(\"FileName\");//child element xmlwrite.WriteString(\"Data\"); xmlwrite.WriteEndElement(); xmlwrite.WriteRaw(\"\\r\\n\\t\"); xmlwrite.WriteStartElement(\"FileExt\"); xmlwrite.WriteString(\"txt\"); xmlwrite.WriteEndElement(); xmlwrite.WriteRaw(\"\\r\\n\\t\"); xmlwrite.WriteStartElement(\"SampleFeq\"); xmlwrite.WriteString(\"10\"); xmlwrite.WriteEndElement(); xmlwrite.WriteRaw(\"\\r\\n\"); xmlwrite.WriteEndElement();//end the root element xmlwrite.Flush(); xmlwrite.Close(); //////// display the XML data /////////// byte[] byteArray = ms.ToArray(); char[] cc = System.Text.UTF8Encoding.UTF8.GetChars(byteArray); string str = new string(cc); Debug.Print(str); ///////////read xml MemoryStream rms = new MemoryStream(byteArray); XmlReaderSettings ss = new XmlReaderSettings(); ss.IgnoreWhitespace = true; ss.IgnoreComments = false; //XmlException.XmlExceptionErrorCode. XmlReader xmlr = XmlReader.Create(rms,ss); while (!xmlr.EOF) { xmlr.Read(); switch (xmlr.NodeType) { case XmlNodeType.Element: Debug.Print(\"element: \" + xmlr.Name); break; case XmlNodeType.Text: Debug.Print(\"text: \" + xmlr.Value); break; case XmlNodeType.XmlDeclaration: Debug.Print(\"decl: \" + xmlr.Name + \", \" + xmlr.Value); break; case XmlNodeType.Comment: Debug.Print(\"comment \" +xmlr.Value); break; case XmlNodeType.EndElement: Debug.Print(\"end element\"); break; case XmlNodeType.Whitespace: Debug.Print(\"white space\"); break; case XmlNodeType.None: Debug.Print(\"none\"); break; default: Debug.Print(xmlr.NodeType.ToString()); break; } } } }"
  },
  "software/netmf/tutorials/xtea.html": {
    "href": "software/netmf/tutorials/xtea.html",
    "title": "XTEA",
    "keywords": "XTEA Introduction XTEA is a secure encryption algorithm, though not as secure as RSA or others, that uses a 128bit key and requires very little processing power. Make sure you only attempt to encrypt arrays with a size divisible by eight. Getting Started The following example shows the basic encryption and decryption of a string. When you use the parameterless constructor of the Xtea object, a key is generated for you that you can find in the Key property. If you pass a key to the constructor, it will be used instead. using GHI.Utilities; using Microsoft.SPOT; using System.Text; public class Program { public static void Main() { var xtea = new Xtea(); var encrypted = xtea.Encrypt(Encoding.UTF8.GetBytes(\"0123456776543210\")); var decrypted = xtea.Decrypt(encrypted); Debug.Print(new string(Encoding.UTF8.GetChars(decrypted))); //should be \"0123456776543210\" var keyStr = \"0x\"; for (int i = 0; i < Xtea.KeyLength; i++) keyStr += xtea.Key[i].ToString(\"x2\"); Debug.Print(\"The key used was \" + keyStr); } }"
  },
  "software/tinyclr/bootloader.html": {
    "href": "software/tinyclr/bootloader.html",
    "title": "GHI Electronics Bootloader",
    "keywords": "GHI Electronics Bootloader The GHI Electronics Bootloader is used to update the firmware on our devices. It is the first program to run and unless the device specific LDR pins are set (see device documentation for details), it will execute the firmware on the device (if present). The bootloader communicates over a USB (virtual serial port) and a regular serial port. The interface used is controlled by a MOD pin as detailed in Special Pins. Loading the Firmware The individual product pages include further instructions on the firmware needed and how to set the board in the loader mode. Once you have downloaded the firmware and set the board in loader mode, use the instructions below to load the firmware. Using TinyCLR Config TinyCLR Config tool includes multiple features developers need to work with TinyCLR OS-enabled devices. It simplifies the firmware update and it includes options for accessing the TinyCLR firmware at runtime. Using this tool is the recommended path; however, manual installation instructions are also included on this page. Read more on the TinyCLR Config page. Manual Update TinyCLR Config tool should be used to update the firmware. As a backup, use these instructions: Put your board in bootloader mode. Each product has a specific way to enter the boot loader. Open any terminal software, for example Tera Term. Select serial and pick the COM port associated with your board. (If unsure, check Device Manager) Press V and then enter. You will see back the boot loader version number (v2.x.x) Press U or X and then enter. Use X for firmware file type GHI and U for firmware file type GLB. Press Y to confirm then enter. You will now see CCCC... Go to File -> Transfer -> XMODEM -> Send. IMPORTANT: Make sure you check the 1K option. Select the firmware file. When the transfer is complete, reset your board. Commands All commands and results are terminated with CR and LF (\\r\\n). \"OK.\" will be sent after each successful command. On startup, a banner is sent that is terminated by \"OK.\". Once the banner is received, you are free to enter any of the case-insensitive single-character commands described below. Most commands require confirmation. Send Y or y followed by a new-line to proceed or anything else to cancel. V: Returns the current version. N: Returns the current device type. E: Erases all user sectors of the device. R: Runs the firmware if present. B: Increases the baud rate in serial mode to 921,600. X: Upload a ghi file to the device using 1K XMODEM. Only send *.ghi files meant for your device. U: Upload a glb file to the device. USB Drivers Tip Only needed for Windows 7 and 8. File Date Status MD5 v1.0.0 x64 2018-12-27 Production 74D66FC4236126A83CCCFE28D556F339 v1.0.0 x86 2018-12-27 Production 8BDE68132452E22B14597C0972ABA8FD"
  },
  "software/tinyclr/configuration.html": {
    "href": "software/tinyclr/configuration.html",
    "title": "Configuration",
    "keywords": "Configuration This section covers some of the configuration needed before you can program your board as well as design considerations for designing custom circuit boards. Special Pins Special pins used by the SITCore product line. Learn more... Bootloader Bootloader information and downloads. Learn more... TinyCLR Config Used to load firmware and applications. Learn more..."
  },
  "software/tinyclr/downloads.html": {
    "href": "software/tinyclr/downloads.html",
    "title": "Downloads",
    "keywords": "Downloads This page includes downloads for the SITCore line of products as well as some of our earlier product lines. See individual product pages for details. Software status legend: Status Meaning Production (RTW) Ready to be used commercially (ready to wear). Update An update to a production release, still RTW. Release Candidate (RC) Could become a production release if proven solid. Preview Preview of the next release, not quite ready for production use. Firmware The Firmware is the TinyCLR OS that lives on your hardware. The firmware version loaded on the hardware must match the version number of the extension and the libraries. SITCore SC20xxx File Date Status MD5 v2.2.2.1000 (RTW) 2024-05-02 Update 22FD189E6E4F304CD1211E66EF0E997C v2.2.1.2100 (RTW) 2024-04-09 Update A4F5FBB0C40AC96551365633300F0932 v2.2.1.2000 (RTW) 2024-03-19 Update F4A70BC8017B06A4B7A993F6DEA5A1F4 v2.2.0.7000 (RTW) 2024-02-26 Update A7C14E993D8FDA20DF00944F36829F4D v2.2.0.6200 (RTW) 2023-12-11 Production 54E2FE0A0D609D1FD21A9BE88298D678 v2.2.0.6100 (RTW) 2023-10-13 Production B22ACD2F3CB75ECDC5D745725D07A3C2 v2.2.0.6000 (RTW) 2023-09-14 Production B74FD99F75EBA09C1EEA83FEED9CE250 v2.2.0.5100 (RTW) 2022-09-20 Production 9B69EF733A361D1D4D1484D40E5854B0 v2.2.0.5000 (RTW) 2022-09-15 Production 825F30A6A562005138DC7285A56A2D67 v2.2.0.4000 (RTW) 2022-04-18 Production B4AF89D007656B846FBD18B3FD400947 v2.2.0.3000 (RC1) 2022-03-09 RC1 AF083BB8FB2B66646933D417B2339033 v2.2.0.2000 (Preview2) 2022-02-23 Preview 83057284633DCF09394238E906501945 v2.1.0.6500 (RTW) 2021-12-28 Update 9DC4A9CCFE0D0514BEF253C3453B3D45 v2.1.0.6400 (RTW) 2021-11-29 Update CD29E2BC4D471394B0D000B906DD45CC v2.1.0.6300 (RTW) 2021-11-09 Update 7E7CF2E86170B43CDC4E18E0D701CFC6 v2.1.0.6200 (RTW) 2021-09-21 Update ED93AA54B58BA9FCDE1FC8707B0032BE v2.1.0.6000 (RTW) 2021-06-30 Production E2D7B1BD4BF21C5F1A5C4EF88865732D v2.1.0.6000 (RC2) 2021-06-04 Release Candidate E2D7B1BD4BF21C5F1A5C4EF88865732D v2.1.0.5000 (RC1) 2021-04-26 Release Candidate 19A4CA62B3248C787599623B547D31A8 v2.0.0.8000 (RTW) 2020-08-05 Production AE9DC4E117D04CE058AB305896F273DE v2.0.0.8000 (RC2) 2020-08-05 Release Candidate AE9DC4E117D04CE058AB305896F273DE v2.0.0.70000 (RC1) 2020-07-04 Release Candidate FE2C4E67C5635513B998540C32F96C8D SITCore SC13xxx File Date Status MD5 v2.2.2.1000 (RTW) 2024-05-02 Update 0BF3FF4726C6927B33EF4487A9124B25 v2.2.1.2100 (RTW) 2024-04-09 Update 2BD5B3B73491B27D64522483469CD360 v2.2.1.2000 (RTW) 2024-03-19 Update 6FF9A5C53FC7451924A57C0E27056DCF v2.2.0.7000 (RTW) 2024-02-26 Update A7C14E993D8FDA20DF00944F36829F4D v2.2.0.6200 (RTW) 2023-12-11 Production 6E0DD1A8FFEB41D3A5951A963A03196C v2.2.0.6000 (RTW) 2023-09-14 Production 66078988E3099FE9EAC5788459BE99FD v2.2.0.5100 (RTW) 2022-09-20 Production 4A8FDABC9D47CDD768D238BFBD6FD6A9 v2.2.0.5000 (RTW) 2022-09-15 Production D943F0D26ADCA7A8F18D0FCCAA4696B2 v2.2.0.4000 (RTW) 2022-04-18 Production C56FE59386EB8168E46CC49806DC7CB0 v2.2.0.3000 (RC1) 2022-03-09 RC1 9490A67D5427330D736BE49BE566BAC8 v2.2.0.2000 (Preview2) 2022-02-23 Preview 0B28D0518EC79B5815FB7962A27FF5C7 v2.1.0.6500 (RTW) 2021-12-28 Update AF2EF9BEA3EC23F6AAF6DA1EBBFC61AB v2.1.0.6400 (RTW) 2021-11-29 Update D65C153A2405D05D3AF244E1E27A00C6 v2.1.0.6300 (RTW) 2021-11-09 Update 13D16E476E494940CE1358EFEFD32E26 v2.1.0.6200 (RTW) 2021-09-21 Update 574408495A41FFD9C7AE79C37AC3ECC3 v2.1.0.6100 (RTW) 2021-06-30 Production E4CD5D819192E4260DAB6D4140E434B6 v2.1.0.6000 (RC2) 2021-06-04 Release Candidate 77CF2F7B6E629CE1E1AEEA332F9DC64E v2.1.0.5100 (RC1) 2021-05-10 Release Candidate C77237FACD87F23530CF8B5B2D984830 TinyCLR Config TinyCLR Config is a tool used to update and configure your TinyCLR device. File Date Status MD5 v2.2.2.1000-RTW 2024-05-02 Update 3F5C7FBC39A3B3257E81515CD20D63F1 v2.2.1.2000-RTW 2024-03-19 Update 654012076B0EB611AF2C847C4A9BE1BE v2.2.0.7000-RTW 2024-02-26 Update DEB57E7784F6CC63A48E3FBB77971307 v2.2.0.6000-RTW 2023-09-14 Production F3B62D4163D14FE543CE7CE617609E17 v2.2.0.5000-RTW 2022-09-15 Production 50430F4EE449D0CACF48E0C1D89AE7BD v2.2.0.4000-RTW 2022-04-18 Production 0C4286A9BA44BC893DF953F8B7B2921D v2.2.0.3000-RC1 2022-03-09 RC1 00D367FEEF1E11C97534D07DD2C4EA9B v2.2.0-Preview2 2022-02-23 Preview 4B079D7BF81ADB2191128799E5977B32 v2.1.0.6300 2021-11-09 Update F9AADBCCB75298279E9FE459B7A24244 v2.1.0.6200 2021-09-21 Update A417207CF63A9BFD206BC22C40C66D33 v2.1.0 2021-06-30 Production 4CCC489BCC4A396916F3E09D66E208BB v2.1.0-rc2 2021-06-04 Release Candidate AF235926E98E2CF120E2038AA354B49A v2.1.0-rc1 2021-04-26 Release Candidate B739CCBE3268F0293CED7632088E854B v2.0.0 2020-08-21 Production 9DF8B05E50699505FBAD23F783CF67EA v2.0.0-rc2 2020-08-05 Release Candidate 307A4304D5662B6EB7BF9C75D7777388 v2.0.0-rc1 2020-07-04 Release Candidate 318CCC9D8627BBF30DE2558E4F0395AB Visual Studio Project System The extension is what gets loaded on Visual Studio to allow it to communicate with a TinyCLR OS device. It also includes project templates. Visual Studio 2022 File Date Status MD5 v2.2.2.1100-RTW 2024-05-03 Update D7981B94F6B60342BA598EFD949DB983 v2.2.2.1000-RTW 2024-05-02 Update C268112B07D18F54CB83B8E80BA496F1 v2.2.1.2000-RTW 2024-03-19 Update 21D4E9BF38156075EE9DEB6EFE812365 v2.2.0.7000-RTW 2024-02-26 Update 2787BC5CED9800C19A4B272B0103ECF6 v2.2.0.6000-RTW 2023-09-14 Update 6199684EEE3CD9F07D6861657D12F5CF v2.2.0.5000-RTW 2022-09-15 Update CF0BBD7750F44A716A59C2DB366912AB v2.2.0.4200-RTW 2022-05-18 Update 234252AB352796EFC154FFE8048C7F03 v2.2.0.4100-RTW 2022-04-20 Update 437F2F1BAA03D803F173AF19645C5BED v2.2.0.4000-RTW 2022-04-18 Production C461A9ABCE1052136966DDB1F61A4C61 v2.2.0.3000-RC1 2022-03-09 RC1 FBA1E3352F3E3B6926F045CAD2B4C903 v2.2.0.2-Preview2 2022-02-23 Preview 93FE481A20544EC0ED2882ABE842D4CF v2.1.802 2021-12-28 Production 6E14FA7C2487A5F14F8A7CD675CB5F57 v2.1.801 2021-11-29 Production F57E1BD812B1331F530864F853BE7854 v2.1.801 2021-11-09 Release Candidate F57E1BD812B1331F530864F853BE7854 Visual Studio 2019 File Date Status MD5 v2.1.700 2021-06-30 Production CF90D2E902DB2B4DC5A3643A8E9E2778 v2.1.0-rc2 2021-06-04 Release Candidate 1FBB75384617C0E5E03F54FCF8C9CBD5 v2.1.0-rc1 2021-04-26 Release Candidate 71B6518F55EED3AFD47845AD0F34C4D6 v2.0.0 2020-08-21 Production 09A7643877101E9138E1C5C1E517E2CA v2.0.0-rc2 2020-08-05 Release Candidate 84488ED257F5C4A604490D31793CAC68 v2.0.0-rc1 2020-07-04 Release Candidate B06F587FD2F5C49F08D9BE62808C288A Libraries Libraries provide prebuilt software routines for performing many common tasks. It is preferred to access these libraries through NuGet.org by using Visual Studio's default package source. Note Make sure to check the Include prerelease box in Visual Studio's NuGet package manager if you're not using the production release. The libraries are provided here in case you're having trouble with the online source or need an older library that's not hosted on NuGet. File Date Status MD5 v2.2.2.1000-RTW 2024-05-02 Update 9E2435CE675462199AAC10F3A2826C09 v2.2.1.2000-RTW 2024-03-19 Update A205B8A682CCF785DCE7C39FB3C0DE1C v2.2.0.7000-RTW 2024-02-26 Update DEB57E7784F6CC63A48E3FBB77971307 v2.2.0.6000-RTW 2023-09-14 Update BD1BE7C6FF1A53DE5C2BE020593D4CBA v2.2.0.5000-RTW 2022-09-15 Update 71C5C9FEFD0803C21481D4471A03649F v2.2.0.4200-RTW 2022-05-18 Update AE949C6A35E58F3CB9E7BB8A0716C3C5 v2.2.0.4000-RTW 2022-04-18 Production 4A9D2A2BA2F17C3D7C00AC43903B4E13 v2.2.0.3000-RC1 2021-06-30 RC1 A0FC7B8A90108A1C348F20A7C1DAD287 v2.2.0.2000-Preview2 2022-02-23 Preview 8C183CEE540FF54170A3965EE6C4932E v2.1.2 2021-12-28 Update 4B4E28448C70B2914EB8F66864D7EE1F v2.1.1 2021-11-29 Update 08EA1E78BF10B71728408EC9B2A3BDAD v2.1.0 2021-06-30 Production A02ACD56474A1E5664D05C9A66F91F07 v2.1.0-rc2 2021-06-04 Release Candidate 0E23C7C2888B514D7F546A78D7F80598 v2.1.0-rc1 2021-04-26 Release Candidate 7F9752274034039B4CEF73AB430F2D71 v2.0.0 2020-08-21 Production E182BF265B7D814C92FE2B5DAE7D2BDC v2.0.0-rc2 2020-08-05 Release Candidate 9F7A0EAE22915FB60CF5B49C197B9CD3 v2.0.0-rc1 2020-07-04 Release Candidate 480D51365FC48065AE2406B0A5247F96 TinyCLR Font Converter The font converter is a tool used to convert desktop TrueType fonts to the format used by TinyCLR OS. File Date Status MD5 v2.0.0 2020-01-22 Production 40F6EA89AA8B826956A83220285E471F USB Drivers Tip Only needed for Windows 7 and 8. Windows 10 automatically loads the necessary drivers. File Date Status MD5 Window 7 2020-12-04 Preview AE1462EA84EA5579A5DDA1A241B9B708 Window 8 2020-12-04 Preview 158086B77406B126DABFEE02011A57F4 TinyCLR OS 1.0 These downloads are provided with no support and are not recommended for commercial designs. File Date MD5 Project System 2018-12-27 2CDD88E2203716781CA0735FEAE2BBE3 Libraries 2018-12-27 4EB8D0C9DBD8AABA8C48716256099924 TinyCLR Config 2018-12-27 FFA158A503EBEA0D9F812007608A1974 TinyCLR Font Converter 2018-12-27 9FBDD44955F51BDBE83BBAB4CAD25616 UC5550 2018-12-27 BE4D80D4F88AA0902F25E8353148D2F8 UC2550 2018-12-27 97F2BA54A92107CBFB5DDA029E58DA42 G400 2018-12-27 DF863A79DE30F5C4C204B2F6EE0ED4FE G120 2018-12-27 482C2ADE1B27675A5457D8894D43BB6F G80 2018-12-27 CE90C3F05C6193A68C42E7D4C3A5AB80 G30 2018-12-27 B3A3BC288A4776506D40198847AFAB85 FEZCLR (FEZ T18) 2018-12-27 C089598B40CC7398DD7BBC3723D25D0E"
  },
  "software/tinyclr/drivers/codec.html": {
    "href": "software/tinyclr/drivers/codec.html",
    "title": "Codec",
    "keywords": "Codec VS1053B This codec takes a SPI stream of audio, like MP3, and decodes it to an audio output. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.VlsiSolution.VS1053B This example plays a small MP3 from a resource. Similarly, large file data can be fetched from other external resources. //SC13048 Dev Board var gpio = GpioController.GetDefault(); var dreq = gpio.OpenPin(SC13048.GpioPin.PA4); var reset = gpio.OpenPin(SC13048.GpioPin.PB15); var dataChipSelect = gpio.OpenPin(SC13048.GpioPin.PA0); var commandChipSelect = gpio.OpenPin(SC13048.GpioPin.PB2); var spi = SpiController.FromName(SC13048.SpiBus.Spi1); mp3decoder = new VS1053BController(spi, dreq, reset, dataChipSelect, commandChipSelect); var mp3Bytes = Resources.GetBytes(Resource1.BinaryResources.Song); mp3decoder.SetVolume(250, 250); mp3decoder.SendData(mp3Bytes); WAV Audio This code plays an 8 bit mono WAV file with a sample rate of 8 kHz. The WAV file must be saved as a .BIN file before adding it as a resource. The audio is output to pin PA4 on the SC20100S Dev Board. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.Media var dac = DacController.GetDefault(); var analogOut = dac.OpenChannel(SC20100.DacChannel.PA4); var byteFile = Resources.GetBytes (Resources.BinaryResources.yourWavFileResource); var wavFile = new Wav(byteFile); var dataIndex = wavFile.GetDataIndex(); var size = wavFile.GetDataSize(); var sampleRate = wavFile.GetSampleRate(); if (sampleRate == 8000) { for (int i = dataIndex; i < size; i++) { analogOut.WriteValue(byteFile[i]); for (int timer = 0; timer < 58; timer++) {} } } else { Debug.WriteLine(\"Sorry, file does not have an 8 kHz sample rate.\"); } MJPEG Video The MJPEG video format is simply a chain of JPG images that are stored in a single file. The following code sample demonstrates the use of the driver. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.Media var stream = new FileStream($@\"A:\\128x160.mjpeg\", FileMode.Open); var settings = new Mjpeg.Setting(); settings.BufferSize = 16 * 1024; settings.BufferCount = 3; var mjpegDecoder = new Mjpeg(settings); mjpegDecoder.FrameDecodedEvent += MjpegDecoder_FrameDecodedEvent; mjpegDecoder.StartDecode(stream); // Non-block function Thread.Sleep(Timeout.Infinite); private static void MjpegDecoder_FrameDecodedEvent(byte[] data) { using (var image = new Bitmap(data, 0, data.Length,BitmapImageType.Jpeg)){ if (graphic != null){ graphic.DrawImage(image, 0, 0, image.Width, image.Height); graphic.Flush(); } } GC.WaitForPendingFinalizers();// helps in clearing out the RAM }"
  },
  "software/tinyclr/drivers/connectivity.html": {
    "href": "software/tinyclr/drivers/connectivity.html",
    "title": "Connectivity Drivers",
    "keywords": "Connectivity Drivers WINC15x0 This utility NuGet adds additional services to the WiFi support. See WiFi Tutorial for more info. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.Microchip.Winc15x0"
  },
  "software/tinyclr/drivers/display.html": {
    "href": "software/tinyclr/drivers/display.html",
    "title": "Display Drivers",
    "keywords": "Display Drivers This page contains a collection of supported displays. On devices that support internal graphics, a user can subscribe to the drawing event, which in turn sends the image to the screen For devices with internal graphics support, the Graphics tutorial, under \"Virtual Displays\" has a full working example on how to use the display drivers on this page. Simply change the display controller the appropriate one. Similarly, devices that do not support internal native graphics can use the BasicGraphics instead, detailed under Software Utilities. Displays that support 16BPP 5:6:5, which is native to TinyCLR, DrawBuffer is provided. Displays that have other formats, like 1BPP, DrawBufferNative is provided instead. The developer is responsible for converting the TinyCLR native format to whatever the display expects. TinyCLR includes helper methods to convert color space, detailed under the Encoding Decoding tutorial. Tip BasicGraphics supports 1BPP natively, and it is recommended when using basic 1BPP displays. This saves memory and eliminates the need for converting from 16BPP to 1BPP. ST7735 An SPI color display controller, typically 160x128 pixels. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.Sitronix.ST7735 ST7789 An SPI color display controller, typically 240x240 pixels. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.Sitronix.ST7789 ERC12864 An SPI based mono color display controller, typically 128x64 pixels. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.EastRising.ERC12864 ILI9341 An SPI based mono color display controller, typically 320x240 pixels. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.HiLetgo.ILI9341 SSD1306 An I2C mono color display controller, typically 128x64 pixels. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.SolomonSystech.SSD1306 SSD1351 An I2C color display controller, typically 128x128 pixels. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.SolomonSystech.SSD1351"
  },
  "software/tinyclr/drivers/imaging.html": {
    "href": "software/tinyclr/drivers/imaging.html",
    "title": "Imaging Drivers",
    "keywords": "Imaging Drivers Ov9655 This NuGet package adds camera drivers for the Ov9655. See Camera tutorial for more info. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.Omnivision.Ov9655"
  },
  "software/tinyclr/drivers/intro.html": {
    "href": "software/tinyclr/drivers/intro.html",
    "title": "TinyCLR OS Drivers",
    "keywords": "TinyCLR OS Drivers A number of low-level drivers for various chips and devices can be used with TinyCLR. The source code of all drivers is found at the Drivers Repo Community Provided drivers There are several community-provided libraries scattered around the web. This is a good example https://github.com/MBNSoftware/MBN-TinyCLR"
  },
  "software/tinyclr/drivers/io-control.html": {
    "href": "software/tinyclr/drivers/io-control.html",
    "title": "IO Control Drivers",
    "keywords": "IO Control Drivers PCA9685 16-channel servo/PWM driver that uses I2C Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.Nxp.PCA9685 CD4017B CMOS decade counter. Good for scanning a matrix of LEDs or buttons. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.TexasInstruments.CD4017B SNx4HC595 Shift register, taking a serial data, like from SPI or pin bit-banging to output 8 parallel outputs. For example, drive 8 LEDs using SPI. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.TexasInstruments.SNx4HC595 Rotary Encoder A rotary encoder is an electro-mechanical device that converts the angular position to analog or digital output signals. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.Encoder var gpioController = GpioController.GetDefault(); var pinA = gpioController.OpenPin(SC20100.GpioPin.PC0); var pinB = gpioController.OpenPin(SC20100.GpioPin.PE5); var encoder = new EncoderController(pinA, pinB); encoder.OnCounterChangedEvent += (counter) => { Debug.WriteLine(\"Counter = \" + counter); }; Thread.Sleep(-1);"
  },
  "software/tinyclr/drivers/led.html": {
    "href": "software/tinyclr/drivers/led.html",
    "title": "LED Drivers",
    "keywords": "LED Drivers LED Matrices This example uses the WS2812 LED but applies to all matrices. Tip Needed NuGets: GHIElectronics.TinyCLR.Drivers.Worldsemi.WS2812, GHIElectronics.TinyCLR.Drivers.BasicGraphics LedMatrix Class class LedMatrix : BasicGraphics { private uint row, column; WS2812Controller leds; public LedMatrix(GpioPin pin, uint column, uint row) { this.row = row; this.column = column; this.leds = new WS2812Controller(pin, this.row * this.column, WS2812Controller.DataFormat.rgb565); Clear(); } public override void Clear() { leds.Clear(); } public override void SetPixel(int x, int y, uint color) { if (x < 0 || x >= this.column) return; if (y < 0 || y >= this.row) return; // even columns are inverted if ((x & 0x01) != 0) { y = (int)(this.row - 1 - y); } var index = x * this.row + y; leds.SetColor((int)index, (byte)(color >> 16), (byte)(color >> 8), (byte)(color >> 0)); } public void Flush() { leds.Flush(); } } Use the LEDMatrix Class as shown var pin = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PC6); var screen = new LedMatrix(pin, 8, 32); screen.Clear(); var col = LedMatrix.ColorFromRgb(0, 20, 50); var c = 0; while (true){ screen.Clear(); screen.DrawString(c++.ToString(), col, 0, 0); screen.Flush(); Thread.Sleep(10); } WS2812 The WS2812 driver is implemented natively. It supports 565 and 888 color formats. Note These LEDs are commonly referred to as Neopixel Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.Worldsemi.WS2812 const int NUM_LED = 4; // 4 leds var pin = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PA0); var leds = new WS2812Controller(pin, NUM_LED, WS2812Controller.DataFormat.rgb888); leds.SetColor(0, 0xFF, 0, 0); // red leds.SetColor(1, 0, 0xFF, 0); // green leds.SetColor(2, 0, 0, 0xFF); // blue leds.SetColor(3, 0xFF, 0xFF, 0xFF); // white leds.Flush(); APA102C Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.ShijiLighting.APA102C The APA102C is very similar to the Neopixel WS2812 except it uses standard 3 wire SPI, while the Neopixel uses a single wire and it's own proprietary format. const int NUMOFLED = YourNumLed; var spiBus = SpiController.FromName(SC20100.SpiBus.Spi4); var led = new APA102CCController(spiBus, NUMOFLED); led.SetColor(1, 255, 0, 0); // 2nd LED is Red led.Flush(); LPD8806 Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.GreeledElectronics.LPD8806 const int NUMOFLED = YourNumLed; var spiBus = SpiController.FromName(SC20100.SpiBus.Spi4); var led = new LPD8806Controller(spiBus, NUMOFLED); led.SetColor(1, 255, 0, 0); // 2nd LED is Red led.Flush();"
  },
  "software/tinyclr/drivers/memory.html": {
    "href": "software/tinyclr/drivers/memory.html",
    "title": "Memory Drivers",
    "keywords": "Memory Drivers AT25M02 This is an SPI-based EEPROM driver. It simply provides Read and Write methods. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.Microchip.AT25M02"
  },
  "software/tinyclr/drivers/motor.html": {
    "href": "software/tinyclr/drivers/motor.html",
    "title": "Motor Drivers",
    "keywords": "Motor Drivers Servos Rotational and positional servos are supported. See the PWM tutorial on example use. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.Servo"
  },
  "software/tinyclr/drivers/sensor.html": {
    "href": "software/tinyclr/drivers/sensor.html",
    "title": "Sensor Drivers",
    "keywords": "Sensor Drivers Resistive Touch This driver uses 2 analog and 2 digital pins to read a display's resistive touch panel. The results are not very accurate but it is a low-cost options. Please see the Touch Screen tutorial for more info. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.Touch.ResisitiveTouch FT5xx6 and GSL1680 These are common display capacitive touch controller chips. PPlease see the Touch Screen tutorial for more info. Tip Needed NuGets: GHIElectronics.TinyCLR.Drivers.FocalTech.FT5xx6 or GHIElectronics.TinyCLR.Drivers.GSL1680 LIS2HH12 A 3-axis accelerometer. The driver set to 2g as default. Output value is in range -1024 to 1024. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.STMicroelectronics.LIS2HH12 var lis2hh12 = new LIS2HH12Controller(I2cController.FromName(FEZBit.I2cBus.Accelerometer)); while (true) { Debug.WriteLine(\"X = \" + lis2hh12.X); Debug.WriteLine(\"Y = \" + lis2hh12.Y); Debug.WriteLine(\"Z = \" + lis2hh12.Z); Thread.Sleep(500); } Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.STMicroelectronics.LIS2HH12 MSGEQ7 Equalizer sensor filter. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.MixedSignalIntegrated.MSGEQ7"
  },
  "software/tinyclr/drivers/software-utility.html": {
    "href": "software/tinyclr/drivers/software-utility.html",
    "title": "Software Utility Drivers",
    "keywords": "Software Utility Drivers Azure SAS This utility NuGet adds SAS generation used in Azure. See Microsoft Azure tutorial for more info. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.Azure.SAS Basic Graphics BasicGraphics driver is a simpler alternative that runs on all devices, including small devices without native display support. It contains many useful methods for adding simple graphics,including: SetPixel, DrawLine, DrawRectangle, DrawCircle, DrawString, and DrawCharacter. It also includes support for a micro 5px font through DrawTinyCharacter and DrawTinyString. There are 2 differences between DrawCharacter and DrawTinyCharacter, beside the font size! DrawCharacter can accept scaling to enlarge the font, DrawTinyCharacter does not. Also, DrawCharacter will only set pixels and does not clear blanks. DrawTinyCharacter has the same behavior by default but it has a clear option to set the blanks to 0 (black). There are two ways to use BasicGraphics, the first one is agnostic of what display is being used and simply works by calling SetPixel method that must be overridden by the user. The user has 2 options, either send the pixel directly to the display or buffer the pixels in a \"Video RAM\" working buffer and then flush to the screen when desired. Setting the pixels directly on the screen requires zero memory but it is extremely slow. In the second way, which is the easier way, BasicGraphics will handle allocating the needed video buffer and handles the SetPixel. It already has 2 pixel options, 16BPP 5:6:5 and 1BPP. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.BasicGraphics An example of the first options, that overrides the SetPixel and Clear methods. BasicGraphics will not allocate any memory. public class BasicGraphicsImp : BasicGraphics{ public override void SetPixel(int x, int y, uint color){ // add code to buffer pixels or send directly to display } public override void Clear(){ // add optional clear if buffer is used } // You may need to add this to send an optional buffer... public void Flush(){ // ... for example lcd.DrawBufferNative(this.buffer); } } Now, the Basic Graphics driver can be used. var basicGfx = new BasicGraphicsImp(); var colorBlue = BasicGraphics.ColorFromRgb(0,0,255); var colorGreen = BasicGraphics.ColorFromRgb(0,255,0); var colorRed = BasicGraphics.ColorFromRgb(255,0,0); var colorWhite = BasicGraphics.ColorFromRgb(255,255,255); basicGfx.Clear(); basicGfx.DrawString(\"TinyCLR OS!\", colorGreen, 15, 15, 2, 1); basicGfx.DrawString(\"SITCore\", colorBlue, 35, 40, 2, 2); basicGfx.DrawString(\"SC13xxx\", colorRed, 35, 60, 2, 2); Random color = new Random(); for (var i = 20; i < 140; i ++) basicGfx.DrawCircle((uint)color.Next(), i, 100, 15); basicGfx.Flush(); This example uses the second option where a buffer is allocated automatically. This is the preferred option for using BasicGraphics. var basicGfx = new BasicGraphics(160, 128, ColorFormat.Rgb565); var colorBlue = BasicGraphics.ColorFromRgb(0,0,255); var colorGreen = BasicGraphics.ColorFromRgb(0,255,0); var colorRed = BasicGraphics.ColorFromRgb(255,0,0); var colorWhite = BasicGraphics.ColorFromRgb(255,255,255); basicGfx.Clear() basicGfx.DrawString(\"TinyCLR OS!\", colorGreen, 15, 15, 2, 1); basicGfx.DrawString(\"SITCore\", colorBlue, 35, 40, 2, 2); basicGfx.DrawString(\"SC13xxx\", colorRed, 35, 60, 2, 2); Random color = new Random(); for (var i = 20; i < 140; i ++) basicGfx.DrawCircle((uint)color.Next(), i, 100, 15); // now send to display, using the specific display driver. MyDisplaySendBuffer(basicGfx.Buffer); Managed File System This full FAT file system C# implementation includes SD SPI drivers and is made available for systems that do not have a native built in file system support or if using SD cares over SPI is desired. var dataWrite = new byte[5] { 6, 7, 8, 9, 10 }; var dataRead = new byte[dataWrite.Length]; var spiController = SpiController.FromName(SC13048.SpiBus.Spi1); var chipselect = GpioController.GetDefault().OpenPin(SC13048.GpioPin.PB2); var managedFS = new ManagedFileSystem(spiController, chipselect); managedFS.Mount(); Debug.WriteLine(\"Volumme: \" + managedFS.VolumeLabel); Debug.WriteLine(\"Total Size: \" + managedFS.TotalSize); Debug.WriteLine(\"Free: \" + managedFS.TotalFreeSpace); managedFS.CreateDirectory(@\"\\TEST1\"); var fileWrite = managedFS.OpenFile(@\"\\TEST1\\TEST2.txt\", FileMode.Write | FileMode.CreateAlways); managedFS.WriteFile(fileWrite, dataWrite, 0, (uint)dataWrite.Length); managedFS.FlushFile(fileWrite); managedFS.CloseFile(fileWrite); var fileRead = managedFS.OpenFile(@\"\\TEST1\\TEST2.txt\", FileMode.Read); managedFS.ReadFile(fileRead, dataRead, 0, (uint)dataRead.Length); managedFS.CloseFile(fileRead); IR Infrared remotes are very common and use multiple standards. NCR is very common and a driver is included. A remote with NCR standard will send an 8bit address and an 8bit command with every key press. A repeat signal will be sent as long as the key is continuously pressed. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.Infrared var recievePin = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PH6); var ir = new NecIRDecoder(recievePin); ir.OnDataReceivedEvent += Ir_OnDataRecievedEvent; ir.OnRepeatEvent += Ir_OnRepeatEvent; private static void Ir_OnDataRecievedEvent(byte address, byte command) { // we have a new key press } private static void Ir_OnRepeatEvent() { // we have repeat } Basic Network Basic Network works with W5500 module. Tip Needed NuGets: GHIElectronics.TinyCLR.Drivers.BasicNet, GHIElectronics.TinyCLR.Drivers.BasicNet.Sockets, GHIElectronics.TinyCLR.Drivers.WIZnet.W5500 var cs = GpioController.GetDefault().OpenPin(SC13048.GpioPin.PB2); var reset = GpioController.GetDefault().OpenPin(SC13048.GpioPin.PB15); var interrupt = GpioController.GetDefault().OpenPin(SC13048.GpioPin.PA0); var spiController = SpiController.FromName(SC13048.SpiBus.Spi1); var networkController = new W5500Controller(spiController, cs, reset, interrupt); var isReady = false; networkController.NetworkAddressChanged += (a, b) => { isReady = networkController.Address.GetAddressBytes()[0] != 0 && networkController.Address.GetAddressBytes()[1] != 0; }; NetworkInterfaceSettings networkSettings = new NetworkInterfaceSettings() { Address = new IPAddress(new byte[] { 192, 168, 0, 200 }), SubnetMask = new IPAddress(new byte[] { 255, 255, 255, 0 }), GatewayAddress = new IPAddress(new byte[] { 192, 168, 0, 1 }), DnsAddresses = new IPAddress[] { new IPAddress(new byte[] { 75, 75, 75, 75 }), new IPAddress(new byte[] { 75, 75, 75, 76 }) }, MacAddress = new byte[] { your mac }, DhcpEnable = false, DynamicDnsEnable = false, }; networkController.SetInterfaceSettings(networkSettings); networkController.Enable(); while (isReady == false) ; // wait for valid IP addrress. var dns = new Dns(networkController); var host = dns.GetHostEntry(\"www.example.com\"); var ep = new IPEndPoint(host.AddressList[0], 80); // Streaming socket var socket = new Socket(networkController, AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); socket.Connect(ep); var content = \"GET / HTTP/1.1\\r\\nHost: www.example.com\\r\\nConnection: close\\r\\n\\r\\n\"; socket.Send(Encoding.UTF8.GetBytes(content)); var received = socket.Receive(SocketFlags.None); if (received.Length > 0) { var recvdContent = new string(Encoding.UTF8.GetChars(received)); Debug.WriteLine(\"Received : \\r\\n\" + recvdContent); } QR Code Generator This driver converts a string to an image, which can be displays on screen for example. No NuGet is provided but source code is found here. GPS Parser This driver parses standard NEMA strings // Find NEMA strings and parse (probably in a seperate thread) // Read UART, find start and end and then send byte array to parser // strings start with $ and end with CR new Thread(() => { while (true) { Parser.Parse(UTF8Encoding.UTF8.GetBytes(\"NEMA string\")); Thread.Sleep(1); } } ).Start(); // parsed data are available from the class while (true) { if (Parser.RMCSentence.DataStatus == Parser.DataStatus.Valid) { //Do something } if (Parser.GLLSentence.DataStatus == Parser.DataStatus.Valid) { //Do something } // ...etc Thread.Sleep(1); }"
  },
  "software/tinyclr/due/api.html": {
    "href": "software/tinyclr/due/api.html",
    "title": "DUE - API",
    "keywords": "DUE - API The DUE API is designed to give full access of the ScriptEngine in a simple user-friendly way. Tip We will assume GpioExtension sample from Extensions is being used. Run This method will execute a script. var script = new ScriptEngine(typeof(GpioExtension)); script.Run(@\" var led = DigitalPin(4*16+11)//PE11 func OnOff() writePin(led, On) Delay(100) writePin(led, Off) Delay(100) end \"); Run only returns when it has completed running the script. If the script has an infinite loop then Run will never return. A good option would be to spin a thread for Run. The rest of the system will continue to run normally and the thread can be terminated to abort Run when desired. SetConsole Redirects the Console Statements. For example, the output can be forwarded to a display. class MyConsole : IConsole { private int row = 0; private const int charHeight = 9; // I2C Display static I2cController i2c = I2cController.FromName(SC13048.I2cBus.I2c1); static SSD1306Controller ssd1306 = new SSD1306Controller(i2c.GetDevice(new I2cConnectionSettings(0x3d))); // Basic Graphics static BasicGraphics basicGfx = new BasicGraphics(128, 64, ColorFormat.OneBpp); public void Cls() { basicGfx.Clear(); this.row = 0; } public void Locate(int row, int col) { }// deprecated! public void Print(string s) { if (row >= (basicGfx.Height / charHeight)) { Cls(); row = 0; } basicGfx.DrawString(s, BasicGraphics.ColorFromRgb(0xff, 0xff, 0xff), 0, row * charHeight); ssd1306.DrawBufferNative(basicGfx.Buffer); row++; } } The IConsole interface is then passed to the engine. var script = new ScriptEngine(); var console = new MyConsole(); script.SetConsole(console); script.Run(@\" cls print('Hello World!') cls // will clear the previous prints print('Hello World!') print print 'TinyCLR' print \"\"with DUE\"\" print 'is the best!' \");"
  },
  "software/tinyclr/due/debugging.html": {
    "href": "software/tinyclr/due/debugging.html",
    "title": "DUE - Debugging",
    "keywords": "DUE - Debugging No modern system should exist if it does not have debugging, and DUE has just what is needed. Stepping Debugging is simply enabled through a flag on the Run method. script.Run() var script = new ScriptEngine(typeof(GpioExtension)); script.Run(@\" var led = DigitalPin(4*16+11)//PE11 func OnOff() writePin(led, On) Delay(100) writePin(led, Off) Delay(100) end OnOff() \", GHIElectronics.TinyCLR.DUE.Debugging.DebugLevel.Line);// enable debugging Once debugging option is enabled, an event script.DebugEvent += DebugStep_DebugEvent is raised for every program step. In teh event handler, the user has the option to continue, step into or step over. private static DebugAction Script_DebugEvent(IDebuggee debuggee) { Debug.WriteLine($\"Executing: {debuggee.SrcLine} : {debuggee.SrcCol}..{debuggee.SrcCol + debuggee.SrcLength}\"); Debug.WriteLine(\"Locals\"); foreach (var v in debuggee.GetLocals()) { Debug.WriteLine($\"{v.Name} = {v.Value}\"); } Debug.WriteLine(\"\"); return DebugAction.StepInto; // Step into next statement } Breakpoints A breakpoint is set through script.ToggleBreakpoint(lineNumber). Once execution hits a breakpoint, the debug event is raised with e.Breakpoint set to true. private static DebugAction Script_DebugEvent(IDebuggee debuggee) { if (e.Breakpoint) { // we hit a breakpoint } } else { // This will get hit once on start up, because when we start debugging the debugger breaks on the first // executable statement, without requiring an explicit breakpoint } return DebugAction.Continue; // Run until next breakpoint }"
  },
  "software/tinyclr/due/downloads.html": {
    "href": "software/tinyclr/due/downloads.html",
    "title": "DUE - Downloads",
    "keywords": "DUE - Downloads Status Meaning Production (RTW) Ready to be used commercially (ready to wear). Release Candidate (RC) Could become a production release if proven solid. Preview Preview of the next release, not quite ready for production use. File Date Status Requires MD5 v2.2.0.5000 2022-09-15 Preview TinyCLR 2.2.0.5000 63F3501C3704BADEEACEDEB1D47A428A v1.0.0-preview1 2021-05-06 Preview TinyCLR 2.1 RC1 3619456EA4887825E9A647DD28743667 Roadmap DUE Language was just born and we are all focused around the user experience. There will be 2 important stages for DUE's future. The first stage is in making sure the language is complete and serves most needs. The second stage will be in introducing the IDE debugger....you heard that right! Beyond above, we are going to make DUE 100 times faster! We can do that easily but we are not ready for it yet. Not only that, DUE can, and should, run on every hardware! It is designed from the ground up to be very lean and mean. Release notes 2.2.0.5000 Released 2022-09-15 | Requires TinyCLR OS 2.2.0.5000 Changes Second preview. Known Issues None. 1.0.0 Preview1 Released 2021-05-06 | Requires TinyCLR OS 2.1 RC1 Changes Initial Release! Known Issues DUE supports loading multiple scripts but messaging about debugging and errors do not indicate which script. Pause is not currently supported."
  },
  "software/tinyclr/due/extensions.html": {
    "href": "software/tinyclr/due/extensions.html",
    "title": "",
    "keywords": "DUE - Extensions Extensions are user defined functions that reside in the environment until called, they are just like any other functions in the script however these functions are provided from the TinyCLR C# side. Defining Extensions A static class is used to implement the extensions. Each static method in this class become available to scripts. static class ExtensionLibrary { public static void ExtensionFuncSample(string arg) { Debug.WriteLine(\"Arg: \" + arg); } public static int ExtensionAdder(int arg1, int arg2) { return arg1 + arg2; } } Constants (const in DUE) can also be made available to the DUE system using readonly C# keyword. static class ExtensionLibrary { public static void TestSample(int arg) { Debug.WriteLine(\"Arg: \" + arg); } public readonly int PE11 = 75; Any members of the extension that should not be accessed from within DUE scripts should not be made public. Tip Variable binding is not supported and should not be used, only use variables that are readonly. Acessing Extensions The DUE ScriptEngine does all the necessary magic internally. The user only needs to provide the extension class. var script = new ScriptEngine(typeof(ExtensionLibrary)); script.Run(@\"ExtensionFuncSample(\"\"Hello DUE!\"\") var x = ExtensionAdder(44, 77) ExtensionFuncSample(\"\"x: \"\" + x) \"); Example // Non-public functions and member variables are not loaded into the script engine static class GpioExtension { private static Hashtable pins = new Hashtable(); private static GpioController gpio = GpioController.GetDefault(); // Public static redonly member variables will be exposed as constants in the engine public static readonly int On = 1; public static readonly int Off = 0; // DigitalPin - Return a Pin object for the specified pin public static object DigitalPin(int pinNumber) { if (!pins.Contains(pinNumber)) { pins[pinNumber] = gpio.OpenPin(pinNumber); } return pins[pinNumber]; } // WritePin - Write the state to the pin public static void WritePin(object pin, int state) { if (pin is GpioPin gpioPin) { gpioPin.SetDriveMode(GpioPinDriveMode.Output); gpioPin.Write(state == 0 ? GpioPinValue.Low : GpioPinValue.High); } else { throw new InterpreterException(\"Not a valid pin\"); } } // ReadPin - Read the current state of the pin public static int ReadPin(object pin) { if (pin is GpioPin gpioPin) { gpioPin.SetDriveMode(GpioPinDriveMode.Input); return gpioPin.Read() == GpioPinValue.High ? 1 : 0; } else { throw new InterpreterException(\"Not a valid pin\"); } } // Delay - sleep public static void Delay(int ms) { Thread.Sleep(ms); } }"
  },
  "software/tinyclr/due/overview.html": {
    "href": "software/tinyclr/due/overview.html",
    "title": "DUE Scripting Language",
    "keywords": "DUE Scripting Language Why DUE? DUE stands for Dynamic, Universal and Extensible. A user-friendly scripting language with full debugging capabilities. Dynamic Arguably, DUE is the most user-friendly programming language out there! It is so Dynamic, it supports multiple coding styles. BASIC-style If temp > 60 Print \"Too Hot!\" end C-style if (temp > 60) { print (\"Too Hot!\"); } Python-style If (temp > 60): Print (\"Too Hot!\") DUE simply understand any of the most common formats. Users can even mix and match! Mixing styles between styles within the same block is not supported. This code is not allowed and will raise an error: If (temp > 60) { Print (\"Too Hot!\") end C-style and BASIC-style ignore white-space as how the style work. The Python-style however needs the proper indentation, just like expected by the full python language. Universal DUE uses syntax that is universally used and common among most popular programming languages. Comments, variables, constants are some of the examples. While not found in most scripting languages, DUE has full built-in debugging capability similar to any world-class language. Extensible Users can extend the DUE available functions, right from C#. Learn more at the Extensions page. Getting Started The API has examples on how to use DUE ScriptEngine to write a script using the available statements. DUES comes with several Standard Library functions. Developers have a ways to securely add Extensions to give DUE additional functionality. When programs get to be more complex, debugging will come in handy. Comments Comments are ignored text added to help developers read code. // This is a comment print x // This is also a comment #this is a python-style comment Understanding Environment The ScriptEngine takes a script and compiles it and then it will run any top level statements. Any functions and variables are loaded in the environment, and will still be there even when execution has completed. This script Foo(x) will raise an error. There is no Foo function and no variable x in the script. Now this script is ran: var x=5 func Foo(s) print s end While the earlier script will not do anything, it actually loads the environment with a variable and a function. Running the first script now works fine Foo(x). Samples Recursion func factorial(n) if n == 0 return 1 end return n * factorial(n - 1) end print(factorial(5)) if func ToWords(i) if i < 10 return i + \" units\" elseif i < 100 return i + \" tens\" elseif i < 1000 return i + \" hundreds\" else return i + \" thousands\" end end print(ToWords(3)) print(ToWords(55)) print(ToWords(432)) print(ToWords(2342)) while var i = 1 while i <= 10 print(i) i = i + 1 end PI const scale = 10000 const arrinit = 2000 func pi_digits(digits) var carry = 0 var arr = [] var result = [] // Adjust digits for groups of 4 digits = (digits * 14) / 4 // Initialize array var i = 0 while i < digits + 1 append(arr, arrinit) i = i + 1 end // Calculate digits i = digits while i > 0 var sum = 0 var j = i while j > 0 sum = sum * j + scale * arr[j] arr[j] = sum % (j * 2 - 1) sum = trunc(sum / (j * 2 - 1)) j = j - 1 end append(result, carry + trunc(sum / scale)) carry = sum % scale i = i - 14 end return result end var result = pi_digits(20)"
  },
  "software/tinyclr/due/standardlib.html": {
    "href": "software/tinyclr/due/standardlib.html",
    "title": "DUE - Standard Library",
    "keywords": "DUE - Standard Library (Under development) General Function Description Array & Strings Function Description Len(object o) Returns the length of an array or string Math Function Description"
  },
  "software/tinyclr/due/statements.html": {
    "href": "software/tinyclr/due/statements.html",
    "title": "DUE - Statements",
    "keywords": "DUE - Statements Language Statements Statement Description print/cls Special Output Console Statements print Prints the following expression to the console and moves to the next line locate Locates where the print will take place in rows, columns if/elseif/else Conditional execution of the code while Executes a block of code until the condition is false break Breaks out of the current while loop continue Continues the current while loop skipping the rest of the body return Returns a value from a function end Used in BASIC-style to indicate the end of if or while var Declares a variable const Declares a constant, a variable that can't be modified! func Declares a function block AND/OR Boolean operators Console Statements These statements are a quick and dirty way to output information. By default, cls does not do anything but print will simply call Debug.WriteLine internally. The behavior can be change, to forward the output to a serial port or a display for example. See API page from more details. Tip print will format double ToString(\"N4\") Execution Statements while, if/elseif/else, continue, break and 'return' work just like most globally-acceptable programming languages. The end statement DUE supports multiple code block types. When basic-style is selected, the end statement marks the end of a block. if x > 10 print x end In the case other style is used, like C-style, using end is not needed and not allowed. if (x>10) { print(x); } This is not allowed if (x>10){ print(x); end var var is how variables are created. var will automatically select the correct type and will even change the type on the next assignment, like change it from numerical to string. Numerical Variables are always double-type and must always have a starting value var x = 10 is good but var x is not allowed. Strings var s = \"Hello DUE\" creates a variable of a string type. Just like modern languages, strings can be combined. var s = \"Hello \" + \"DUE\". With strings, numerical variable or constants are automatically converted to strings internally. print \"x= \" + x. Both single quote and double-quote are supported and work the same. print 'hi'. Arrays Arrays, and arrays of arrays, are supported. It is important to note that arrays hold an array of var and each var in itself can be any kind, even another array. var numbers = [1, 2, 3, 4] var names = [\"DUE\", \"is\", \"amazing\"] var mix = [\"Hi\", 55, 96.34] Arrays can even contain other arrays var setsOfNumbers = [[1,3,5], [2,4,6]] Array elements are indexed starting zero. var numbers = [1, 2, 3, 4] print numbers[2] // Will access the 3rd element in the array Creating an empty array is supported var arr = []. Tip Creating an empty array of specific length is supported through the Array functions from Standard Library. const const is a special type of variable that can't be changed. const x = 5 const s = \"Hello\" // these are not allowed x = 10 s = \"Bye!\" Arrays are slightly different as in the values can be changed but not the array itself. const a = [1, 2, 5] a[2] = 3 // this is not allowed a = 5 Functions (func) Functions are added using func statement. func printsomething() print(\"Hello There!\") end printsomething() Of course, curly brackets can be used instead, and even semicolons! func printsomething() { print \"Hello There!\"; } printsomething() Passing arguments to functions is supported. func greet(name) print \"Hello \" + name end greet(\"Gus\") // This will show Hello Gus on the output window Functions can also return values func add(x, y) return x + y end var answer = add(32, 10) Functions can also be added from C# through Extensions. Boolean Operators Some programming languages use && and some use AND to check of 2 statements are true, similarly they have || and OR. if speed > 100 AND temp < 32 print \"Slow down!\" end if (speed > 200 && temp < -40) { print(\"Goodbye!\"); } Bitwise Operators Not currently supported."
  },
  "software/tinyclr/getting-started.html": {
    "href": "software/tinyclr/getting-started.html",
    "title": "Getting Started",
    "keywords": "Getting Started This page explains how to set up the TinyCLR programming environment. It covers device and computer setup and deployment of a \"hello world\" program to a SITCore device. Compatible Hardware TinyCLR OS is made to run on our SITCore line of products. Check out the SITCore page in the hardware section of this documentation to find the device best suited for your project. TinyCLR Device Setup To use TinyCLR with a device you must first install the latest version of the TinyCLR firmware on the device. The TinyCLR firmware includes the Common Language Runtime (CLR) which converts compiled code into machine instructions and manages program execution. The TinyCLR firmware is also responsible for interacting with Microsoft Visual Studio to load and debug your application programs. Use the TinyCLR Config tool to update the firmware on your device to the latest version. Development Machine Setup If you don't already have Visual Studio 2022, download and install one of the latest editions. Any edition will work, including the free community edition: Visual Studio Community. Make sure to select the .NET desktop development workload when installing Visual Studio. Download and install the newest TinyCLR Visual Studio Project System by going to Extensions > Manage Extensions. In the Manage Extensions dialog box select Online in the left panel. Type tinyclr into the Search text box in the upper right of the window to search for and install the TinyCLR OS Project System. You'll need to restart Visual Studio to let the extension installer complete the installation. Alternately you can download the Visual Studio Project System from our Downloads page and open or double click on the file to install the extension. Note Pre-releases of the Project System are not hosted online but are found on the Downloads page. Starting a New Project Let's blink an LED on a SITCore board. Open Visual Studio and select Create a new project. In the Create a new project window, select TinyCLROS from the platforms drop down list. Now select the C# TinyCLR Application template and click the Next button. We're going to stick with the default name and location. If you use a different name, make sure the program's namespace statement matches the namespace of your program. Now click on the \"Create\" button. Now cut and paste the following code into the Program.cs window. Make sure to install both GHIElectronics.TinyCLR.Devices.Gpio and GHIElectronics.TinyCLR.Pins NuGet packages. using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; using System.Threading; namespace TinyCLRApplication1 { class Program { static void Main() { //Use \"SC20100.GpioPin.PE11\" on SC20100S Dev Board. //Use \"SC20260.GpioPin.PB0\" on SCM20260D Dev Board. var LED = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PB0); LED.SetDriveMode(GpioPinDriveMode.Output); while (true) { LED.Write(GpioPinValue.High); Thread.Sleep(100); LED.Write(GpioPinValue.Low); Thread.Sleep(100); } } } } Make sure your device is plugged into the computer's USB port. Now hit the start button as shown on the above image (or hit the F5 key). If you've done everything correctly, the program will compile and deploy to your device. The left most LED on the dev board should blink if you've done everything correctly. Top Level Statements The use of C#9 Top Level Statements allows for easier to read example code snippets. The docs will utilize top level statements when possible. The TinyCLR project system templates include a C#9 application template. To use Top Level Statements: Start a new project, but this time select TinyCLR Application C#9. install both GHIElectronics.TinyCLR.Devices.Gpio and GHIElectronics.TinyCLR.Pins NuGet packages. Copy/paste the code below. Note how it is identical to the earlier code, but now it is top-level-statement! using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; using System.Threading; //Use \"SC20100.GpioPin.PE11\" on SC20100S Dev Board. //Use \"SC20260.GpioPin.PB0\" on SCM20260D Dev Board. var LED = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PB0); LED.SetDriveMode(GpioPinDriveMode.Output); while (true) { LED.Write(GpioPinValue.High); Thread.Sleep(100); LED.Write(GpioPinValue.Low); Thread.Sleep(100); } Congratulations! You're on your way to becoming a TinyCLR embedded developer! To find the best hardware for your TinyCLR application, go to the SITCore Docs page in the hardware section of this documentation. or visit the GHI Electronics website. To learn more about TinyCLR embedded programming check out our tutorials."
  },
  "software/tinyclr/intro.html": {
    "href": "software/tinyclr/intro.html",
    "title": "",
    "keywords": "TinyCLR OS Introduction TinyCLR OS started with Microsoft's .NET Micro Framework and continues to enable managed .NET development and debugging using Visual Studio on embedded devices. All you need to get started is Visual Studio (free version available), a SITCore device, and a USB cable. Getting Started Deploy your first TinyCLR program. Learn more... Configuration Special pins, bootloader, TinyCLR Config Learn more... Tutorials Learn TinyCLR embedded programming. Learn more... Drivers TinyCLR Drivers. Learn more... Downloads Visual Studio and device downloads. Learn more... Release Notes Find the latest changes to TinyCLR. Learn more... Resources External additional TinyCLR resources. Learn more... Limitations How TinyCLR OS is different from full .NET. Learn more... To learn more about TinyCLR embedded programming check out our tutorials. You can also visit our main website at main website and our community forum."
  },
  "software/tinyclr/limitations.html": {
    "href": "software/tinyclr/limitations.html",
    "title": "Limitations",
    "keywords": "Limitations TinyCLR OS is made to run on small, secure, IoT devices. TinyCLR was built from the ground up with security first and foremost. Performance is also excellent, but we did have to limit some of the less important features to achieve this performance while maximizing application memory. Here is a list of limitations and possible workarounds: There is no support for multidimensional arrays, use jagged arrays instead. Simply use [1][1] instead of [1,1]. Each assembly is limited to 64KB. If you have gigantic code, just split your solution into multiple assemblies. This approach improves code maintainability as well. Resource files are not subject to this limitation, so if you are adding large lookup tables or binary objects, include them as a resource. There is a limit of 64 total assemblies. TinyCLR does not support generics. While this is less of a limitation on an embedded device than on the desktop, we understand that professional .NET developers will miss this feature. However, on small embedded systems implementing generics can reduce performance. The async/await pattern is not supported. All libraries, networking sockets for example, are tweaked to be a subset of the full .NET framework that will perform well on embedded devices. These tweaks have allowed us to support essential IoT features like CAN and USB."
  },
  "software/tinyclr/release-notes.html": {
    "href": "software/tinyclr/release-notes.html",
    "title": "Release Notes",
    "keywords": "Release Notes 2.2.2.1100 - RTW Released 2024-05-03 Visual Studio Project System Changes VS2022: Fixed deploying application failed sometime when enable external flash Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug 2.2.2.1000 - RTW Released 2024-05-02 Visual Studio Project System Changes VS2022: None Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Libraries Changes Fixed context.Request.InputStream returns unwanted bytes Fixed DigitalSignal event is not called when call Abort() Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Drivers Changes Basic graphic: DrawTinyString: Supports new line Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Firmware Changes SC20xxx: Fixed system crashed if create a new object when memory is too low Improved memory ram backup Improved QSPI (SC20xxx) SC13xxx Fixed wakeup pin PA2 don't work Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug TinyCLR Config Changes None. Known Issues Erase all does not erase external flash. Sometimes fails to connect until reset the board. 2.2.1.2100 - RTW Released 2024-04-09 Firmware Changes SC20xxx: Fixed Display rotate 90, 180 and 270. Fixed UART, CAN: Fixed receiving event send wrong data/message count sometime SC13xxx Fixed UART, CAN: Fixed receiving event send wrong data/message count sometime Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug 2.2.1.2000 - RTW Released 2024-03-19 Visual Studio Project System Changes VS2022: None. Known Issues None. Libraries Changes FileSystem: Added Format command UsbClient: Fix leak memory UI: Add Close method to Messagbox Improved Number.ToString Removed seal class on GHIElectronics.TinyClr.Drawing assembly Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Firmware Changes SC20xxx: Added FileSystem Format Fixed USBClient leak memory Fixed detect media size incorrect if larger than 4G Fixed USB Device Not Recognized when stop usbclient in MSC mode SC13xxx Fix USBClient leak memory Known Issues None. Drivers Changes None. Known Issues None. TinyCLR Config Changes None. Known Issues Erase all does not erase external flash. Sometimes fails to connect until board is reset. 2.2.0.7000 - RTW Released 2024-02-26 Visual Studio Project System Changes VS2022: None. Known Issues None. Libraries Changes Signal Digital: Fixed event raise incorrectly when both signals are used. Signal Digital Capture: Fixed pulse-count is wrong if calling Abort when no pulse detected. Remove WiFi AP mode. Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Firmware Changes SC20xxx: Signal Digital: Fixed event raise incorrectly when both signals are used. Signal Digital Capture: Fixed pulse-count is wrong if calling Abort when no pulse detected. SC13xxx Signal Digital Capture: Fixed pulse-count is wrong if calling Abort when no pulse detected. Known Issues None. Drivers Changes None. Known Issues None. TinyCLR Config Changes None. Known Issues Erase all does not erase external flash. Sometimes fails to connect until board is reset. 2.2.0.6200 - RTW Released 2023-12-11 Visual Studio Project System Changes VS2022: None. Known Issues None. Libraries Changes None Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Firmware Changes SC20xxx: Fixed RTC Fixed GPIO interrupt: The first falling edge after a reset is ignored SC13xxx Fixed RTC Fixed GPIO interrupt: The first falling edge after a reset is ignored Known Issues None. Drivers Changes None. Known Issues None. TinyCLR Config Changes None. Known Issues Erase all does not erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. 2.2.0.6100 - RTW Released 2023-10-13 Visual Studio Project System Changes VS2022: None. Known Issues None. Libraries Changes None Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Firmware Changes SC20xxx: Fixed wakeup issue when enable external RAM SC13xxx None Known Issues None. Drivers Changes None. Known Issues None. TinyCLR Config Changes None. Known Issues Erase all does not erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. 2.2.0.6000 - RTW Released 2023-09-14 Visual Studio Project System Changes VS2022: Display assembly name if exceed byte code. VS2019: None. Known Issues None. Libraries Changes Changed from net4.5 to 4.8 TFS: Implement Dispose() Fixed SoftwareI2C throws exception in constructor. Fixed DigitalSignal leaks memory when create new object Fixed incorrect build string in StringBuilder.ToString(int startIndex, int length) Improve Networking.Http Cryptography: Added SignData and VerifyData method Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Firmware Changes SC20xxx: USBHost: Fixed crashed on some thhumbdrives if they are inserted at boot. USBHost: RawDevice mode, fixed crashed on some HID that not supported. USBClient: Fixed can't switch between WinUsb and Masstogare mode Add handshaking for UART8 on SC20100 (PD15: RTS, PD14: CTS) LWIP: Exclude the transmission of the Host Name field from the DHCP REQUEST packet TLS: When Verification mode is none, ignore verifiy. Fixed double to string overload. SignalDigital: Fixed can't use Capture mode if Generate mode was used. Fixed can't set RTC alarm more than 7 days SC13xxx Fixed double to string overload. SignalDigital: Fixed can't use Capture mode if Generate mode was used. Fixed can't set RTC alarm more than 7 days Known Issues None. Drivers Changes None. Known Issues None. TinyCLR Config Changes None. Known Issues Erase all does not erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. 2.2.0.5100 - RTW Released 2022-09-20 Visual Studio Project System Changes VS2022: None. VS2019: None. Known Issues None. Libraries Changes None. Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Firmware Changes SC20xxx: Fixed WS2812 SC13xxx Fixed WS2812 Known Issues None. Drivers Changes None. Known Issues None. TinyCLR Config Changes None. Known Issues Erase all does not erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. 2.2.0.5000 - RTW Released 2022-09-15 Visual Studio Project System Changes VS2022: Rebuild, increment version. VS2019: None. Known Issues None. Libraries Changes JSON: Limited preservation of order UI: Exposed Button.IsPressed UI: Fixed Slider value is always zero after initialize. Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Firmware Changes SC20xxx: Add option to reduce SDCard clock (using Marshall class) Fixed native flush exception when orientation is not zero degree. Improved mounting on some USB sticks. SC13xxx None (rebuild, increment version) Known Issues None. Drivers Changes WS2812: Add option to swap RGB. Known Issues None. TinyCLR Config Changes None (rebuild, increment version) Known Issues Erase all does not erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. 2.2.0.4200 - RTW Released 2022-05-18 Visual Studio Project System Changes VS2022: Increment version. VS2019: None. Known Issues None. Libraries Changes I2C: Master mode, fixed WriteReadPartial throw NotSupport exception. Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Firmware Changes SC20xxx: None. SC13xxx None. Known Issues None. Drivers Changes Increased version. Known Issues None. TinyCLR Config Changes None. Known Issues Erase all does not erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. 2.2.0.4000 - RTW Released 2022-04-18 Visual Studio Project System Changes VS2022: Added generate Tca and raw application. VS2022: Fixed deploying external flash with large image white color (0xFF) failed sometime. VS2019: None. Known Issues None. Libraries Changes Increment version. Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Firmware Changes SC20xxx: Fixed ADC: close channel effect to other channel if same controller. MSC: Fixed QSPI MSC: Added event when select eject from PC. Fixed PWM: Change dutycyle change polarity. SC13xxx Fix ADC: close channel effect to other channel if same controller. Fix PWM: Change dutycyle change polarity. Known Issues None. Drivers Changes Increment version. Known Issues None. TinyCLR Config Changes Increment version. Known Issues Erase all does not erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. 2.2.0.3000 - RC1 Released 2022-03-09 Visual Studio Project System Changes VS2022: Increment version. VS2019: None. Known Issues None. Libraries Changes Added CRC16 seed Added USB Host mouse absolute mode Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Firmware Changes SC20xxx: Reduce CPU workload. Reduce CPU temperature when system idle. Reduces power consumption when system idle. Native Filesystem now work with MSC QSPI Increase QSPI MSC 16MB. Ethernet Built-in: Reduce timeout from 4 seconds to 2 second if no cable connected. Fixed system crashed when deploy tca file on external flash. SC13xxx Fixed Thread.Sleep(1) or Thread.Sleep(2) still use 100% CPU Fixed CPU 100% after data received event. Fixed system crashed when deploy tca file on external flash. Known Issues None. Drivers Changes None. Known Issues None. TinyCLR Config Changes Fixed can't re-connect the device after deploying tca file. Known Issues Erase all does not erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. 2.2.0.2000 - Preview2 Released 2022-02-23 Visual Studio Project System Changes VS2022: Increment version. VS2019: None. Known Issues None. Libraries Changes Added CPU usage statistic Added I2C slave Added USB Client Mass Storage. CDC and WinUSB: Allow send multiple of 64 bytes instead of splitting (63+1) Added Debug.Write Added Timeout.InfiniteTimeSpan Added Gpio.Toggle() Removed sealed UI: Add Gauge, Chart. UI: Fixed touch DataGrid Pins: Add Feather.SpiBus.WiFi Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Firmware Changes SC20xxx: USB Client Mass Storage for QSPI, SD, USB thumb drive. Fixed PWM glitch. Fixed UART threshold. Fixed UART couldn't activate a second time if handshaking was enabled first time. Fixed couldn't mount on some USB thumb drives. Fixed Gpio Interrupt. Fixed Ethernet direct mode. Fixed DrawLine n pixels thickness is wrong if n=2 or higher. Fixed GetBitmap() return not enough data. Fixed CAN full event not raised. SC13xxx Fixed PWM glitch. Fixed UART threshold. Fixed UART couldn't activate a second time if handshaking was enabled first time. Fixed Gpio Interrupt. Fixed CAN full event not raised. UART, CAN data received, error events interval down from 100ms to 10ms Known Issues None. Drivers Changes Resistive Touch: Allow two different ADC controllers for YU and XL pins. Known Issues None. TinyCLR Config Changes Increment version. Known Issues Erase all does not erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. 2.1.0.6500 - RTW Release Released 2021-12-28 Visual Studio Project System Changes VS2022: Fixed template doesn't include GHIElectronics.TinyCLR.Core library as default. VS2019: None. Known Issues None. Libraries Changes UI: Add Slider, DataGrid UI: Rework MessageBox UI: Fixed Exceptions in event handlers leave the UI corrupted https://github.com/ghi-electronics/TinyCLR-Libraries/issues/498 UI: Fixed Expand support for hardware UI buttons https://github.com/ghi-electronics/TinyCLR-Libraries/issues/812 UI: Fixed No vertical alignment for TextBox text https://github.com/ghi-electronics/TinyCLR-Libraries/issues/1082 UI: Fixed There is no password field option for the textbox https://github.com/ghi-electronics/TinyCLR-Libraries/issues/1066 UI: Fixed Onscreen keyboard miss-aligned with 4.3 https://github.com/ghi-electronics/TinyCLR-Libraries/issues/1087 Json: Throw not supported exception if ArrayList found. Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Firmware Changes SC20xxx: Fixed WiFi AP mode Password doesn't work. SC13xxx None Known Issues None. Drivers Changes None. Known Issues None. TinyCLR Config Changes None. Known Issues Erase all does not erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. 2.1.0.6400 - RTW Release Released 2021-11-29 Visual Studio Project System Changes VS2022: Release candidate is moved to production. VS2019: None. Known Issues None. Libraries Changes Fixed Modbus blocks other threads. Fixed RadioButton doesn't support multi groups. Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Firmware Changes SC20xxx: Fixed network crashed randomly. Fixed IsDriveModeSupported always return false if OpenDrain mode. Fixed Abort always return few ticks (ReadPulse) SC13xxx Fixed IsDriveModeSupported always return false if OpenDrain mode. Fixed Abort always return few ticks (ReadPulse) Known Issues None. Drivers Changes None. Known Issues None. TinyCLR Config Changes None. Known Issues Erase all does not erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. 2.1.0.6300 - RTW Release Released 2021-11-09 Visual Studio Project System Changes Supports Visual Studio 2022 (Release Candidate) Fixed: Sometimes a longer delay than usual during deployment. (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/660) Fixed: Debug breakpoints sometimes hang for 5-6 seconds before resuming normally (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/659) Known Issues None. Libraries Changes Added FEZ family to pins. Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Firmware Changes SC20xxx: Fixed Ethernet enable lockup system few seconds if no cable connected. Fixed OutOpenDrain raise exception. Corrected reset source flags Fixed WiFi crashed if Enable() without interface configuration. SC13xxx Fixed OutOpenDrain raise exception. Correct reset source flags Known Issues None. Drivers Changes Fixed LIS2HH12 driver. Known Issues None. TinyCLR Config Changes Fixed COM port has no (GHI Electronics) if bootloader v2.1.3 or older. Known Issues Erase all does not erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. 2.1.0.6200 - RTW Release Released 2021-09-20 Visual Studio Project System Changes None. Known Issues Sometimes a longer delay than usual during deployment. (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/660) Debug breakpoints sometimes hang for 5-6 seconds before resuming normally (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/659) Libraries Changes None. Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Firmware Changes SC20xxx: Fix Ethernet not working on some modules. Fix SPI throw exception sometime. Improve LCD high frequency clock to support HDMI. Fix CAN stop receiving message after full buffer if error event not subscribed. SC13xxx Fix UART event buffer full never called. Fix CAN event buffer full never called. Fix CAN stop receiving after buffer full. Fix UART / CAN out of memory if many error events occurs. Free up an additional ~8K for heap. Add RTC backup ram. Fix PWM has big delay when changed to low frequencies. Known Issues None. Drivers Changes Add TFP410 driver support HDMI Fixed BasicGraphics DrawTextEx x, y position is doubled. No longer support WiFi update by buffer. Known Issues None. TinyCLR Config Changes No warning if detect compatible firmware. Known Issues Erase all does not erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. 2.1.0 - RTW Release Released 2021-06-30 Visual Studio Project System Changes Fixed deploying sometime stop 20-30 seconds. Added warning when deploy an assembly larger than regions size. Known Issues Sometimes a longer delay than usual during deployment. (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/660) Debug breakpoints sometimes hang for 5-6 seconds before resuming normally (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/659) Libraries Changes Fixed USBClient WinUSB, Cdc failed when sending multiple of 64 bytes. Fixed UART crashed when enable handshaking on SC13xxx Fixed enabling SoftwarePWM cause Timer 16 stop working on SC13xxx Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Firmware Changes SC20xxx: None. SC13xxx Increased secure storage from 2K to 8K Known Issues None. Drivers Changes Added BasicNet. Add Rotary Encoder. Improved BasicGraphics performance. Known Issues None. TinyCLR Config Changes None. Known Issues Erase all does not erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. 2.1.0 - RC2 Released 2021-06-04 Visual Studio Project System Changes Fixed VS crashed sometime. Add C#9 template. Known Issues Sometimes a longer delay than usual during deployment. (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/660) Debug breakpoints sometimes hang for 5-6 seconds before resuming normally (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/659) Libraries Changes Added temperature sensor. SwapEndianness: Added support offset, count. Rewrite thread-safe Software I2C API. RTC: Added flag to detect internal RC used. Fixed Alarm wake up immediately if set period time more than 24 hours. Fixed Ethernet doesn't work on some modules. Improved ENC. Fixed UART event doesn't work if subscribe event after Enable(). Fixed UART / CAN crashed if unsubscribe event. Fixed Digital Signal work incorrectly if large buffer. Fixed slow clock in RAM mode (non-persist) failed. Fixed PPP doesn't raise event if connection lost. Fixed PPP failed when call Disable(). Fixed insert multi row failed SQLite. Enabled Threadsafe SQLite. Increase network socket from 20 to 32. Fixed IFU crashed when use memory stream and large external tca. Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Firmware Changes Improved SPI, SPI pins set to GPIO::High (they were very high that causes bad on MP3 click module). Fixed Shutdown still draw high power consumption after enable external ram. Add native NeoPixel driver. SC20xxx Fixed Ethernet doesn't work on some modules. Improve ENC28J60. SC13xxx Added 20KB to deployment. Fixed CDC. Added I2C4. Known Issues None. Drivers Changes Rewrote neopixel WS2812 natively, supporting 16/24 bit. Added managed file system (SD SPI). Improve OV9655 camera driver. Known Issues None. TinyCLR Config Changes Add support glb format (micropython firmware). Known Issues Erase all does not erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. 2.1.0 - RC1 Released 2021-04-26 Visual Studio Project System Changes Fixed generating assemblies take too long on large projects. Added System.Diagnostic to application template. Removed TCP/IP port. Known Issues Sometimes a longer delay than usual during deployment. (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/660) Debug breakpoints sometimes hang for 5-6 seconds before resuming normally (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/659) Libraries Changes Rework IFU API Add DataAvailable property to Stream. Rewrote USB stream timeout match to Network stream. Removed Application.Lock() Rewrote DeviceInformation class. Allow to set debug port, disable APP pin, lock debug... UI TextBox: Added border. Fixed missing PB14, PB15 GpioPin class. Add STM32L4, STM13048 GpioPin class. Add SHA1, HMAC-SHA1 cryptography. Moved VNC NuGet to drivers. Moved Media NuGet to drivers. Add GPIO low level allow transfer feature. JsonConverter supports enum. Fixed OTA doesn't work because SSID length hardcode to 3. Fixed crashed when flush partial rotate screen (native LCD). Fixed Enable/Disable has no effect with UART. Fixed CDC stop response with large package. Network: Fixed GetIPProperties sometime null. PWM: Fixed open channel fail then close the pin although the pin is reserved for other function. Remove checking Wakeup pin (PA0) if call Shutdown(). Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug Firmware Changes Signal PulseFeedback: Enable pullup or pulldown internally. Disable global interrupt when QSPI is writing/erasing. Raise exception if enable some configuration on non-support devices (example enable heap on SC20100) SC20xxx Rework IFU. Rework deployment configuration. SC13xxx Initial. Known Issues None. Drivers Changes Added Media NuGet. Fixed WAV play only 1 second. Added VNC NuGet. Fixed VNC allocate memory every frame Fixed VNC stop when much mouse events received. Added QR barcode. Added Infrared NecIR driver Added BasicGraphics (useful for low memory devices) Added ST7789 driver Deleted SPWF04Sx driver Added OneTimePassword Corrected Neopixel company name. Added DrawBufferNative on some screens don't support 16bit. Added TexasInstruments.ADC121 Added Microchip.MCP4725 Added ScaniaJ1939 Added Gps.Nmea0183 Wi-Fi OTA update: Timeout changed from integer to TimeSpan. Uniform SetColor(), Flush(), Clear() for all LEDs driver SetDrawWindow take argument (0, 0, width-1, hight-1) for full screen. Known Issues None. TinyCLR Config Changes Fixed USB friendly name duplicate. Detect GHI bootloader by GHI VID. Allow to set USB, Serial debug port, disable application pin. Detect mismatch versions. Known Issues Erase all does not erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. 2.1.0 - Preview4 Released 2021-03-08 Visual Studio Project System Changes Prevent deploying an assembly that is larger than 6MB, not supported. Known Issues Sometimes a longer delay than usual during deployment. (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/660) Debug breakpoints sometimes hang for 5-6 seconds before resuming normally (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/659) Libraries Changes Added SetPersistDeviceName allows user set device name, mainly used for USB. USB host: Added Joystick. USB host: Rework HID polling interval. USBClient: Add BOS support WebUSB. USBClient: Correct endpoint bmAttribute for CDC/WinUSB. Fixed Graphic Flush() with custom size. Added convert RGB565 to RGB444. Added convert RGB565 to 1BPP. Rework VNC API. Fixed File System hangs when reach EOF. Added HMAC SHA256. Fixed Converter class hidden. Added 'Retry' NetworkStream (Send) Optimized ArrayList. Changed DeviceInformation.UniqueID from property to function. Fixed get power reset source incorrect. Added DigitalSignal Generator. GHIElectronics.TinyCLR.Pins: Rename Timer.Capture to Timer.DigitalSignal Added array Copy2D. IFU: Added activity led. Socket Send and Receive are now non-blocking. Known Issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues?q=is%3Aissue+is%3Aopen+label%3Abug+ Firmware Changes Fixed VS crash when set a breakpoint at bitmap array. Fixed PPP now automatically includes default TLS Entropy. Use Double-precision floating-point argument for compiling. Fixed could not deploy via USB debug after enabled USBClient controller. Fixed system slow after connected an HID device. APP button is free to use once disabled debug interface. Fixed reading EnableSlowClock flag might crash system. Random Class: Changed to hardware true random generator. Socket: Raise exception if Read/Write has timeout. Fixed exception when draw to N18 high SPI frequency. Fixed enable CAN2 corrupted CAN1 filter. Fix lag when set PWM in very low frequency. Fix DAC Controller GetDefault throws exception Added support wakeup pin by rising or failing edge. Raise OutOfMemory exception of Allocate unmanaged memory failed. Known Issue None. Drivers Changes Added Azure SAS generator. ST7735 support RGB444. Add ERC12864 (128x64). Fixed FT5xx6 touch has nothing when rotate screen. NeoPixel constructor supports software and hardware signal generator. Added resistive touch driver. Known Issues None. TinyCLR Config Changes Added update device name. Fixed Connect to Bootloader take long time. Known Issues Erase all doesn't erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. 2.1.0 - Preview3 Released 2021-01-05 Visual Studio Project System Changes Increment version number 2.1.300 Known Issues Sometimes a longer delay than usual during deployment. (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/660) Debug breakpoints sometimes hang for 5-6 seconds before resuming normally (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/659) Libraries Changes Increment version number 2.1.0-preview3. Change IFU API. Support network stream, file stream, memory stream. IFU: Support update firmware on SC20100. UART: Rename USART to UART Improved Digital Signal: Use double (fraction) for more accurate. Improve networking sending speed. WiFI: Fixed DHCP Server Null-pointer Exception Fixed DNS address not retrieved from DHCP Fixed WiFi: Socket closed if call Scan() Graphic: Support Flush(x, y, width, height) Graphic: Support sending buffer to SPI display with custom size Graphic: Flush event support multi screens. Add DrawTextInRect Fixed Rotate Bitmap crash. Fixed SPI: support sending more than 64KB JSON: Support compact formatting. Fixed File open for read in share mode not work. UsbClient: Rename ByteToRead to BytesToRead Slow Clock: Support persist mode. Add Software PWM. Add mDNS Add sampling time for ADC Add VNC Known Issues Exception filter causes lockup when exception thrown from instance method (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/652) GetChars throwing on certain byte values (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/651) Double ToString() show number incorrectly sometime (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/629) Running out of stack kills Visual studio (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/586) Network operations on any thread block all threads (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/525) String does not implement IEnumerable (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/323) Equals() throws unsupported instruction exception (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/502) TinyCLR Config Changes Increment version number 2.1.0-preview3 Add Persist slow clock option in Device Configuration. No longer support .glb file format. Known Issues Erase all doesn't erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. Firmware Changes Increment version number 2.1.0.30000. Reduced external deployment size from 8MB to 6MB. Improved Network sending speed. Known Issue None. Drivers Changes Increment version number 2.1.0-preview3. Add motor servo driver. Add ILI9341 SPI 320x240 driver. Known Issues None. 2.1.0 - Preview2 Released 2020-12-04 Visual Studio Project System Changes Increment version number 2.1.200 Known Issues Sometimes a longer delay than usual during deployment. (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/660) Debug breakpoints sometimes hang for 5-6 seconds before resuming normally (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/659) Libraries Changes Updated version number 2.1.0-preview2. Fixed JSON Boolean type. Fixed MQTT IsConnected property never set to false Added WiFI AccessPoint mode Added DHCP Server for WiFi in AccessPoint mode. Fixed Tim.Capture.Controller5 and Tim.Capture.Controller2 swapped. Rewrite USBClient API (CDC and WinUsb) Added Raw HID, Mouse (Absolute and Relative mode), Keyboard, Joystick for USBClient. Known Issues Exception filter causes lockup when exception thrown from instance method (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/652) GetChars throwing on certain byte values (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/651) Double ToString() show number incorrectly sometime (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/629) Running out of stack kills Visual studio (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/586) Network operations on any thread block all threads (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/525) String does not implement IEnumerable (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/323) Equals() throws unsupported instruction exception (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/502) TinyCLR Config Changes Increment version number 2.1.0-preview2 Known Issues Erase all doesn't erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. Firmware Changes Increment version number 2.1.0.20000. Added AutoIP. Fixed CAN stop receiving message once internal FIFO is full. Fixed Reuse socket address doesn't work. Fixed Dns.GetHostEntry(\"\") doesn't work. Fixed digital signal doesn't work at low frequency. Fixed WiFI doesn't connect to an Open AP. Fixed GPIO interrupt native timestamp not accurate. Fixed Set PWM in low frequency lock the system for long time. Known Issue None. Drivers Changes Increment version number 2.1.0-preview2. WinC15xx: Added Set/Remove multicast address. Known Issues SSD1351-Draw at position X may need offset = 10 to correct position. (https://github.com/ghi-electronics/TinyCLR-Drivers/issues/109) 2.1.0 - Preview1 Released 2020-11-03 Visual Studio Project System Changes Increment version number 2.1.100 Known Issues None Libraries Changes Increment version number 2.1.0-preview1. Added Unique ID. Fixed Socket.Poll(-1) cause system slow. Fixed multicast. Correct SPI6 clock source. Prevent active USB client in USB debug mode. Fixed WiFi doesn't fire event when disconnected from a hotspot. Added analog temperature reading, VREFINT, VSENSE channels (GHIElectronics.TinyCLR.Pins) Fixed UART RTS pin doesn't go high when buffer full. Fixed USB Host: FS.Unmount() failed without calling Flush() TFS: Improved and removed \"StorageDriver\". Storage: Added EraseAll() API. Fixed CAN 'CanWriteMessage' property always return true. Added DigitalSignal. System timer now is accurate.. Supports slow clock mode (240MHz) Fixed JSON cannot deserialize long integers. Supports write out bitmap file (24 bit BMP format). Supports native CRC. Supports RegularExpression. Rename AdcChannel to ADC (GHIElectronics.TinyCLR.Pins) Rename DacChannel to DAC (GHIElectronics.TinyCLR.Pins) Added Timer.Capture (GHIElectronics.TinyCLR.Pins) Added Timer.Pwm (GHIElectronics.TinyCLR.Pins - Changed from PwmChannel) MQTT: Add MQTT pass the topic to the received message function. Fixed Modbus TCP. Fixed UART parity Odd/Even doesn't work with 8 bit data. Fixed initializing the ATWINC with null SSID and password hangs system. Known Issues Sometimes a longer delay than usual during deployment. (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/660) Debug breakpoints sometimes hang for 5-6 seconds before resuming normally (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/659) Exception filter causes lockup when exception thrown from instance method (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/652) GetChars throwing on certain byte values (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/651) Double ToString() show number incorrectly sometime (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/629) Running out of stack kills Visual studio (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/586) Network operations on any thread block all threads (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/525) String does not implement IEnumerable (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/323) Equals() throws unsupported instruction exception (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/502) Empty string - Dns.GetHostEntry(\"\") doesn't work https://github.com/ghi-electronics/TinyCLR-Libraries/issues/724 TinyCLR Config Changes Increment version number 2.1.0-preview1 Known Issues Erase all doesn't erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. Firmware Changes Increment version number 2.1.0.10000 Speed up system speed 15% Use Timer Counter (TIM) for system timer. Fixed SDCard writing failed sometime. Improved SDCard speed. Open HiRes Timer register for Marshal. Open TEMPERATURE_TS1_CALIBRATION, TEMPERATURE_TS2_CALIBRATION registers for Marshal. Open TTCAN, CAN clock calibration for Marshal. Graphics: Improved color table. Support color table for all modes (8888, 888, 565, 323). SC20260: Reduced power consumption SDRAM in Sleep and Shutdown mode. Known Issue None. Drivers Changes Increment version number 2.1.0-preview1 Known Issues SSD1351-Draw at position X may need offset = 10 to correct position. (https://github.com/ghi-electronics/TinyCLR-Drivers/issues/109) 2.0.0 - Release Released 2020-08-21 Production ready release! Visual Studio Project System Changes Increment version number 2.0.0 Known Issues None Libraries Changes Increment version number 2.0.0 Known Issues Sometimes a longer delay than usual during deployment. (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/660) Debug breakpoints sometimes hang for 5-6 seconds before resuming normally (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/659) Exception filter causes lockup when exception thrown from instance method (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/652) GetChars throwing on certain byte values (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/651) Double ToString() show number incorrectly sometime (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/629) Running out of stack kills Visual studio (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/586) JSON cannot deserialize long integers (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/540) Network operations on any thread block all threads (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/525) String does not implement IEnumerable (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/323) Equals() throws unsupported instruction exception (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/502) CAN CanWriteMessage always return true (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/635) Power consumption is high in Shutdown mode (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/667) USB Host: Unmount FS may cause system hang in Disconnected event. See workaround: https://github.com/ghi-electronics/TinyCLR-Libraries/issues/665 System time need to be more accurate (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/664) UART Rx buffer full doesn't make RTS pin go high (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/669) TinyCLR Config Changes Increment version number 2.0.0 Fixed text. Known Issues Erase all doesn't erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. Firmware Changes None. Known Issue None. Drivers Changes Increment version number 2.0.0 Known Issues SSD1351-Draw at position X may need offset = 10 to correct position. (https://github.com/ghi-electronics/TinyCLR-Drivers/issues/109) 2.0.0-RC2 Released 2020-08-05 Fixed final bug, making it ready for production. Visual Studio Project System Changes Fixed assemblies that contain resources with a lot of 0xFF, where the system mistook them for blank spaces. Prevent deploy if the size didn't fit in a region in some cases. Known Issues None Libraries Changes Support old NETMF Graphics API. Add Tiny File System. Add RTC calibration. Fixed XML EOF (End Of File) doesn't work. UI MessageBox support one button, instead of always two buttons. Graphic Color class now supports array convert between RGB565, ARGB8888, RGB888 and RGB323 and scale pattern color table. BitConverter now supports convert array with pattern index table. Fixed WiFi and ENC can't enable/disable multi-time. Fixed PWM Controller 1 doesn't work on SC20100. Fixed QSPI check blank failed after erase in some cases. Known Issues Sometimes a longer delay than usual during deployment. (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/660) Debug breakpoints sometimes hang for 5-6 seconds before resuming normally (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/659) Exception filter causes lockup when exception thrown from instance method (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/652) GetChars throwing on certain byte values (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/651) Double ToString() show number incorrectly sometime (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/629) Running out of stack kills Visual studio (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/586) JSON cannot deserialize long integers (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/540) Network operations on any thread block all threads (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/525) String does not implement IEnumerable (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/323) Equals() throws unsupported instruction exception (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/502) CAN CanWriteMessage always return true (https://github.com/ghi-electronics/TinyCLR-Libraries/issues/635) TinyCLR Config Changes Update Application also update Firmware at the same time if both file are selected. Fixed Invalid Key message if without clicking the \"Generate Key\" button sometime. Fixed some minor GUI. Export .tca file has smaller size. Known Issues Erase all doesn't erase external flash. Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. Firmware Changes UART: Fixed can not release CTS, RTS pins when close UART UART: Enable FIFO mode. UART: Flush() will wait until last byte transfer completed. QSPI: Fixed total size was wrong. Disable some peripherals interrupt during deploy application. Fix freeze in some cases when update application by TinyCLR Config. Known Issue None. Drivers Changes LPD8806, WS2812, APA102C: Add SetBuffer(), Flush() to speed up transfer. Rename: LPD8806, WS2812, APA102C, OV9655, VS1053B, Msgeq7 to LPD8806Controller, WS2812Controller, APA102CController, OV9655Controller, VS1053BController, Msgeq7Controller. Known Issues SSD1351-Draw at position X may need offset = 10 to correct position. (https://github.com/ghi-electronics/TinyCLR-Drivers/issues/109) 2.0.0-rc1 Released 2020-07-04 Complete software package prepping for production. Visual Studio Project System Changes Fixed the issue where an application wouldn't start automatically when trying to Start Without Debugging (CTRL+F5). Known Issues Debug breakpoints will sometimes hang for 5-6 seconds before resuming normally. There is sometimes a longer than usual delay during deployment at the \"Found debugger\" and \"Waiting for device to initialize\" steps. Libraries Changes Fixed sockets blocking code execution while connecting. Added XTEA cryptography. Added CAN FD support. Added CAN hardware filters. UART: - Added DE pin support. - Added ability to invert RX and TX polarity. - Added support for swapping TX and RX pins. - Added support generating a Break signal of user defined length. - Changed SetActiveSettings API. Changed SetActiveSettings API for USB client. Added XML support. Added the SecureStorage class to support both the OTP and configuration storage areas. Added support for changing some processor peripheral registers through use of the Marshal class. Enabled garbage collection (GC) messages. Added ability to enable and disable global interrupts. Improved UI and fixed some UI bugs. Fixed issue where the WiFi Scan() method would return an array of SSIDs with the last element always empty. Known Issues Running out of stack kills Visual Studio: https://github.com/ghi-electronics/TinyCLR-Libraries/issues/586. PNG file deployment issue: https://github.com/ghi-electronics/TinyCLR-Libraries/issues/557. JSON cannot deserialize long integers: https://github.com/ghi-electronics/TinyCLR-Libraries/issues/540. Network operations (except socket connection) on any thread blocks all other threads: https://github.com/ghi-electronics/TinyCLR-Libraries/issues/525. String does not implement IEnumerable: https://github.com/ghi-electronics/TinyCLR-Libraries/issues/323. Exceptions in event handlers leave the UI corrupted: https://github.com/ghi-electronics/TinyCLR-Libraries/issues/498. Project->Add->Class does not select the correct template: https://github.com/ghi-electronics/TinyCLR-Libraries/issues/500. Equals() throws an unsupported instruction exception: https://github.com/ghi-electronics/TinyCLR-Libraries/issues/502. Double.ToString() sometimes shows incorrect number. https://github.com/ghi-electronics/TinyCLR-Libraries/issues/629. CAN: CanWriteMessage always return true: https://github.com/ghi-electronics/TinyCLR-Libraries/issues/635 UART: Break Signal need to wait to last byte transfer complete https://github.com/ghi-electronics/TinyCLR-Libraries/issues/634 TinyCLR Config Changes Changed export key template. Fixed progress bar no longer appearing once a firmware update fails. Known Issues Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. Firmware Changes Fixed issue of SPI locking up the system. Added protection for QSPI pins to prevent their use if external flash is enabled. Added WiFi activity and status LED support. Fixed issue with UART when using two stop bits. Fixed incorrect Ethernet RX/TX buffer allocation. Fixed USB disconnection causing crash on SC20100 series devices. Fixed use of ADC on PC3 pin throwing an invalid operator exception. Improved In-Field Update (IFU) by raising an exception if the application is too large to deploy to device. Fixed issue of an exception not being raised when attempting to write to a configuration storage block which is not blank. Fixed System Timer updating incorrectly. Fixed USBClient.Read() sometimes losing data. Known Issue Networking won't work correctly if WiFi Scan() is called after Network.Enable(). Drivers Changes None. Known Issues None. 2.0.0-preview6 Released 2020-05-20 This preview release implements all remaining functionality, fixes bugs, and improves the API. Visual Studio Project System Changes Added support for secure assemblies. Removed Visual Basic template. Known Issues Debug breakpoint will sometimes hang for 5-6 seconds before resuming normally. There is sometimes a longer than usual delay during deployment at the \"Found debugger\" and \"Waiting for device to initialize\" steps. Libraries Changes MQTT keep alive timeout default has been changed to 60 seconds. \"EnableExternalHeap\" has been renamed to \"ExtendHeap.\" Added OTP support to API. Added external flash support to API. Fixed Double.Compare incorrectly returning zero. Fixed intermittent crashing when using SPI with no chip select. Known Issues String does not implement IEnumerable (GitHub issue #323). JSON cannot deserialize long integers (GitHub issue #540). Network operations on any thread block all other threads (GitHub issue #525). Network stack requires delays in order to work properly (GitHub issue #503). Equals() throws unsupported instruction exceptions (GitHub issue #502). On touch screens, moving off of a button does not release the button (GitHub issue #479). I2C raises timeout exception when using address 0x00 (GitHub issue #554). Several other bugs have been reported which have not yet been verified by GHI Electronics. TinyCLR Config Changes Improved user experience during installation. Added Device Configuration window to enable extension of RAM (Extend heap) and extension of flash (Enable external flash) into external memories. Also added ability to disable the debug interface. Added Deployment Map. Added progress bar while erasing device. Known Issues Sometimes fails to connect until board is reset. TinyCLR Font Converter Changes None. Known Issues None. Firmware Changes Support for deployments in external QSPI flash in addition to internal flash. Deployment size has changed. Secure deployments can now be up to 640 KBytes in size, external deployments can be up to 8 MBytes. Added 64 KByte one time programmable (OTP) region. Improved Ethernet performance. Green Ethernet LED is now activity indicator instead of link indicator. MAC addressing has changed. Ethernet and ENC always require a MAC address, WiFi MAC address is optional, PPP needs no MAC address. Fixed Thread.Sleep() adding 2 ms when not debugging. Fixed USB and SD card not working at the same time. Known Issues User can access QSPI pins even when QSPI is active for deployment. Networking won't work correctly if WiFi scan is called after Network.Enable(). WiFi scan always adds a blank SSID at the end of the list. Drawing on screen may be slower when network that uses SPI is running (WiFi, ENC28). In Visual Studio, the application doesn't start automatically when trying to Start Without Debugging (CTRL+F5). Resetting the board will start the application. The PJ0 interrupt configuration changes when the device is reset with the reset button, but there is no problem when power cycling the board. Drivers Changes Fixed issue of intermittent noise coming from OV9655 camera modules. Known Issues None. 2.0.0-preview5 Released 2020-04-21 This preview release moves us closer to a commercially viable product with new and updated features and some API improvements. Visual Studio Project System Changes Updated to preview5 Known Issues None Libraries Changes Added rotation to display and touch. Added endianness argument to SPI API. Removed data bit length from SPI API. Changed SPI chip select argument type from integer to GpioPin. AssemblySigner has been removed. Updated user interface keyboard resource image. Added support for USB keyboards, mice, and raw device library to USB host class. SignalGenerator now always uses a carrier frequency of 38 kHz. Added missing QSPI pins to GHIElectronics.TinyCLR.Pins. Improved JSON support. Changed GeneratePulse() to Trigger() in SignalGenerator, SignalCapture, and PulseFeedback APIs. Simplified formatting of RFC dates. Fixed TextBox misalignment in UI library. Made CheckBoxes consistent with XAML API in UI library. Fixed problem with building libraries. Added PWM15 pin definition. Known Issues The ToString() method fails on structs, including GUID and enum. Equals() throws an CLR_E_UNSUPPORTED_INSTRUCTION exception. Dropdowns in user interface do not respond to direct touches. In networking, Socket.Connect blocks all threads until it finishes. TinyCLR Config Changes Added a progress bar and result highlighting. Known Issues TinyCLR Config forces device reboot several times when reconnecting to the device. Does not happen during firmware update. TinyCLR Font Converter Changes None. Known Issues None. Firmware Changes Removed GetDefault() from the API of peripherals that have more than one controller or channel. Reworked the SPI API. Added screen rotation. Added USB host keyboard, mouse, and raw device. Fixed PulseFeedback DrainDuration mode. Fixed file information calls returning a Not Implemented exception. Fixed incorrect reporting of static IP addresses when there is no connection. Fixed inability to set socket timeout. Changed serial deploy/debug port from UART5 to UART1 on 100 pin devices. SC20260B still uses UART5. The RTC will run approximately one second slower every 4-6 hours. Drawing on display becomes slower if there is network activity. Known Issues In Visual Studio, the application doesn't start automatically when trying to Start Without Debugging (CTRL+F5). Resetting the board will start the application. The PJ0 interrupt configuration changes when the device is reset with the reset button, but there is no problem when power cycling the board. Drivers Changes Added support for display rotation to the FT5x06 Touch driver Reworked the MSGEQ7 graphic equalizer API. Fixed incorrect color rendition in the WS2812 LED driver. Known Issues When drawing to SSD1351 displays, you may have to add ten to the x coordinate for the screen position to be correct. The OV9655 camera can intermittently have a noisy picture. Resetting the board should fix the problem. 2.0.0-preview4 Released 2020-03-10 This preview release includes many bug fixes, a few new and updated features, and some API improvements. Visual Studio Project System Changes Updated with the latest core libraries. Known Issues None Libraries Changes Fixed missing UART dependency when adding Network NuGet. Fixed ADC that was incorrectly mapped to wrong controller. Added serialization. Reworked power management API. DisplayController is now only used with parallel interface displays. Graphics.Clear() no longer takes an argument. Added NeoPixel WS2812 driver. Added SSD1351 display driver. Changed MJPEG driver to return raw jpeg data instead of internally flushing data to display. Fixed dependency for OV9655 driver and sped up screen refresh rate. Reworked the SSD1306 and ST7735 display drivers so they no longer inherit from DisplayController. Known Issues JSON does not work in some cases. When drawing to SSD1351 displays, you may have to add ten to the x coordinate for the screen position to be correct. The OV9655 camera can intermittently have a noisy picture. Resetting the board should fix the problem. TinyCLR Config Changes Fixed occasional crashes during firmware updates. Known Issues None TinyCLR Font Converter Changes None. Known Issues None. Firmware Changes Signal generator has been improved and can now generate signals of up to 1.25 MHz in frequency. Fixed SPI locking up networking. Fixed bug when sharing SPI bus with multiple devices. Fixed incorrect timestamping of events. Added support for microcontroller temperature sensor. Added support for VBAT voltage monitoring. Added support for ADC internal reference voltage. Fixed I2C bug with messages larger than 255 bytes. Corrected I2C clock bug. Added support for wake up from RTC alarm. Reworked power management with support for stopping processor during Thread.Sleep(). Added pin PC1 as analog input on SC20100S. Fixed crashing when deploying application over UART. Improved Ethernet Fixed networking bug when using static IP Addressing. Known Issues In Visual Studio, the application doesn't start automatically when trying to Start Without Debugging (CTRL+F5). Resetting the board will start the application. The PJ0 interrupt configuration changes when the device is reset with the reset button, but there is no problem when power cycling the board. ToString() does not work if the argument is an enum. PulseFeedback DrainDuration does not work correctly. Cannot send more than 64 KBytes in one SPI transaction. The workaround is to split the data so the transactions are smaller. When using static IP addressing, after disconnecting the device from an Ethernet network the old IP address will still be assigned instead of 0.0.0.0. Graphics.DrawString() with native displays on the SC20260B may stop WiFi. 2.0.0-preview3 Released 2020-02-20 Our third preview includes bug fixes, added features, and increases performance. Visual Studio Project System Changes None Known Issues None Libraries Changes Added missing USB host controller definition. Added missing UART controller definition. Removed Network Stream timeout. Removed Streams. Removed GHIElectronics.TinyCLR.Devices NuGet package. Fixed HTTP exception that sometimes occurs when parsing data. Added Button, ListBoxHighLightItem, ProgressBar, CheckBox, Radio Button, and Drop-Down List elements to UI. Added ability to get current WiFi MAC Address. Added simple MJPEG driver that supports decoding of MJPEG files. Added simple WAV driver that supports decoding of WAV files. Known Issues JSON doesn't work in some cases. Ov9655 camera can randomly have a noisy picture. Reset the board as a workaround. TinyCLR Config Changes Fixed display of incorrect version number. Fixed crashing when trying to connect to bootloader. Fixed Connect button not returning to Enable after firmware update is done. Known Issues None. TinyCLR Font Converter Changes None. Known Issues None. Firmware Changes Increased Performance by 15%. Added RSA cryptography. Added MD5 hash. Fixed One-Wire exceptions and inconsistent operation. Added Network Suspend/Resume to support changing back and forth between a modem's PPP data frame mode and AT command mode. Added Enable External Memory for heap (heap can be 32 MBytes). Fixed SPI from using PA0 for chip select if no chip select pin is specified. Fixed SPI4 and SPI5 clock errors. Increased default free heap size from 300 KBytes to 364 KBytes (maximum size is still 512 KBytes). Fixed USB client reading only a single byte of each packet. Fixed system crashing when there are missing network configuration settings. Added support for hardware random number generator. Fixed SPI throwing exceptions when drawing on N18 display. Known Issues In Visual Studio the application doesn't start automatically when trying to Start Without Debugging (Ctrl+F5). Pressing the reset button will start the application. The PJ0 interrupt configuration changes when the device is reset with the reset button, but there is no problem when resetting by power cycling the board. ToString() doesn't work if the argument is an enum. PulseFeedback DrainDuration does not work correctly. 2.0.0-preview2 update Released 2020-01-31 A refresh release of the firmware only with improved performance. Changes Considerably faster execution speed. Known Issues See the 2.0.0-preview2 release notes. This 2.0.0.21000 release activates all accelerators which might cause some bugs. If you have any strange behavior, please load the previous 2.0.0.20000 release and see if that fixes your issue. Both firmware versions are identical otherwise, and both run with same 2.0.0-preview2 NuGet packages. 2.0.0-preview2 Released 2020-01-22 Initial insider release for SITCore hardware. Visual Studio Project System Changes First release to private insiders with major changes. Known Issues Cannot change boards or connect an additional board to your PC while Visual Studio is open, or Visual Studio will get confused and deployment will stop working. Do not switch devices while Visual Studio is open. Not digitally signed. Libraries Changes First release to private insiders with major changes. Known Issues None, still going through final testing. Cryptography and hashing are currently only supported through TLS. We are still planning how to securely expose this functionality. Not digitally signed. TinyCLR Config Changes First release to private insiders with major changes. Known Issues TinyCLR may not work when connecting over UART. Use Tera Term to update firmware when in UART mode. Not digitally signed. TinyCLR Font Converter Changes None. Known Issues None. Not digitally signed. Firmware Changes First release to private insiders with major changes. Known Issues TinyCLR OS is not yet optimized for full performance as this release is focused on stability. Conversion from enum to string (enumObject.ToString()) may fail. PulseFeedback DrainDuration does not work when going from low to high. Not digitally signed. 2.0.0-preview1 Released 2019-12-09 A preview of the new API and available features. Libraries Changes Major changes. Known Issues Still going through complete testing. Firmware Changes Major changes. Known Issues Internal use only. TinyCLR Config Changes None. Known Issues Random crash."
  },
  "software/tinyclr/resources.html": {
    "href": "software/tinyclr/resources.html",
    "title": "Resources",
    "keywords": "Resources Professional Community Our forum consists of intelligent professionals building commercial products based on SITCore and TinyCLR OS. And it is monitored and supported by our staff. https://forums.ghielectronics.com/ Samples Repo The samples repo a collection of projects we have built around TinyCLR OS, including the samples we ship on SITCore boards. https://github.com/ghi-electronics/TinyCLR-Samples Drivers Repo These are drivers built for common devices used by us and our commercial customers. These drivers are also available as NuGet packages. Feel free to use the sources to build your own. All of these drivers are documented here inside documentation. https://github.com/ghi-electronics/TinyCLR-Drivers Libraries Repo These are the entire set of libraries included with TinyCLR OS. Use to get a deeper understanding of the operating system. We do not recommend making changes but recommendations are welcome. https://github.com/ghi-electronics/TinyCLR-Libraries This is also the home for all public TinyCLR OS issues https://github.com/ghi-electronics/TinyCLR-Libraries/issues Docs Repo Basically, everything you see here comes from this repo. https://github.com/ghi-electronics/Documentation"
  },
  "software/tinyclr/special-pins.html": {
    "href": "software/tinyclr/special-pins.html",
    "title": "Special Pins",
    "keywords": "Special Pins Beside power and standard GPIO pins, there are a number of predefined pins that have special functionality on SITCore SoMs and SoCs: RESET LDR APP MOD WKUP VBAT All special pins except RESET and VBAT can be used as GPIO or peripheral pins, however it is up to the designer to make sure these pins do not interfere with their special features. RESET The SITCore chip is held in reset while the RESET(NRST) pin is held low. Releasing RESET and allowing it to go high will begin the system startup process. All SITCore processors have a permanent internal pull up resistor on the RESET pin. An external pull up resistor is not required on the RESET(NRST) pin. LDR The LDR pin is normally pulled high internally during startup or reset, allowing TinyCLR OS to run. When the LDR pin is pulled low during startup or reset, the device enters GHI Electronics bootloader mode, which is used to load the firmware. LDR has an internal pull up resistor. The Bootloader page details its use. APP The APP pin is used to prevent the application from running. The APP pin is checked shortly after startup. When the APP pin is high (internall pull up) the application will run normally; otherwise, the system will not run the application and hold waiting for new deployment. The pin has an internal pull up resistor. If desired, the APP pin feature can be disabled so the application can't be stopped. See Device Info for more details. MOD The MOD pin is used to select the debugging/deployment interface, as explained in the Debugging tutorial. An internal pull up keeps the pin high during power up to select USB debugging. Setting the pin low will switch to serial debugging. WKUP The WKUP pin is used to wake the system up from Shut Down mode. See the Power Management page for more information. VBAT The VBAT pin on SITCore SoCs and SoMs is used to provide battery power to the Real Time Clock (RTC) and its battery backed memory. Debug Interface USB or Serial can be used for debugging."
  },
  "software/tinyclr/tinyclr-config.html": {
    "href": "software/tinyclr/tinyclr-config.html",
    "title": "TinyCLR Config",
    "keywords": "TinyCLR Config TinyCLR Config is a stand-alone tool to help manage TinyCLR OS devices, including firmware installation and creating encrypted application deployments and loading them onto SITCore devices. There is also a Debug panel that shows any debug data coming from the connected device. You can download TinyCLR Config from the Downloads page. Connecting a Device When TinyCLR Config opens, you will notice a Device section near the top of its window. Connect your device to your PC's USB port and click on the Select a device drop down text box. The name of your device should appear. Click on the device and hit the Connect button. The Assemblies menu there is an Assemblies Listing command that will list all the assemblies installed on the connected device along with their version number. The Utilities top menu has options to ping the device using the Ping command. There are also options in the Utilities menu to reboot the device, show a deployment map, or update the device configuration. Deployment Map The deployment map can be used to gauge the resources used by your application, but more importantly it allows you to make sure assemblies are stored in secure internal flash memory. See the IP Protection page for more information about secure assemblies. Device Configuration The device configuration window contains options that have important implications on the system and its security. There are two regions for holding configurations, the Firmware Config and the Application Config. Firmware Configuration These firmware settings are stored in flash and can only be modified by reflashing the firmware or by doing an Erase all. The Extend heap uses the external RAM for the system, which reduces the level of security. This is explained further under External Memory. Persist slow clock Sets the system clock speed to run at half speed, saving about 40% power consumption. See Power Management. 'Disable APP pin', Debug Mode and Device Name options change/disable the MOD and APP pins behavior. Those pins are explained under Device Info. Application Configuration There Application configuration are stored and flash and can only be reset by doing an 'Erase all` only. Updating the firmware will have no effect. For added security, the debug interface can be disabled. Secure designs will disable the interface and implement In-Field-Update. You can also disable the debug interface from within your code. Please refer to the IP Protection page for more information about disabling the debug interface. Managing TinyCLR Firmware TinyCLR Config can be used to install/update TinyCLR firmware on a connected device. The firmware is the TinyCLR software installed on your device that runs and manages your application program. To update your firmware, click on the ... button to the left of the Update Firmware button. A dialog box will open so you can select your firmware file. Only .ghi and .glb files will be recognized. After selecting your firmware file, click on the Update Firmware button to copy it to your device. In the Erase menu, the Erase All selection will erase the firmware on the device, but will also erase the application. While it's not necessary to delete the firmware or the application to install new firmware, it can sometimes help if your device stops working properly. Managing Your Application TinyCLR Config lets you create and deploy encrypted application files. A key is needed to install an encrypted application deployment file on your device. This key can be generated by TinyCLR Config or provided by you. Creating a Deployment File To create an encrypted deployment, you must first have the application installed on your device and the device must be connected to TinyCLR Config. A key is needed to encrypt your deployment file. Either enter a key into the key text box (hexadecimal pairs delimited by hyphens) or just press the Generate Key button to generate a random key. If you want to add a version number to your deployment, enter it in the Version of created app: text box. Click on the ... button next to the Create App button and select a directory and enter a filename for your deployment file. Now press the Create App button. The encrypted deployment file and a text file with the key will be saved in the directory you selected. Installing a Deployment File To install an encrypted deployment file on your device, first use TinyCLR Config to connect to your device. Click on the ... button next to the Update App button and select the deployment file (should have a .tca extension). Enter the correct key in the text box next to the Generate Key button. The key is a series of hexadecimal pairs that are separated by hyphens. Now click on the Update App button. If the key matches the deployment file, the application will be deployed to your device."
  },
  "software/tinyclr/tutorials/1-wire.html": {
    "href": "software/tinyclr/tutorials/1-wire.html",
    "title": "1-Wire",
    "keywords": "1-Wire 1-Wire is a communication protocol designed by Dallas Semiconductor. 1-Wire is similar to I2C, but with lower data rates, longer range, and the ability to power remote sensors over the two bus lines (data and ground). The following sample code is written for the SC20100S Dev Board with one or more DS18B20 temperature sensors. The temperature sensors are powered directly from the dev board with the data line connected to pin PA1. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Onewire, GHIElectronics.TinyCLR.Native, and GHIElectronics.TinyCLR.Pins. var oneWireBus = new OneWireController(SC20100.GpioPin.PA1); var oneWireDevices = oneWireBus.FindAllDevices(); oneWireBus.TouchReset(); Debug.WriteLine(\"Number of sensors found = \" + oneWireDevices.Count.ToString()); foreach (byte[] serialNumber in oneWireDevices) { oneWireBus.TouchReset(); oneWireBus.WriteByte(0x55); //Match ROM command. for (int i = 0; i < serialNumber.Length; i++) { oneWireBus.WriteByte(serialNumber[i]); //Send serial number of device. } oneWireBus.WriteByte(0x44); //Convert temperature. while (oneWireBus.ReadByte() == 0) { // Wait for conversion to finish. } oneWireBus.TouchReset(); oneWireBus.WriteByte(0x55); //Match ROM command. for (int i = 0; i < serialNumber.Length; i++) { oneWireBus.WriteByte(serialNumber[i]); //Send serial number of device. } oneWireBus.WriteByte(0xBE); //Read scratchpad command. Debug.WriteLine(\"Temperature: \" + ((float)(oneWireBus.ReadByte() + (oneWireBus.ReadByte() << 8)) / 16.0).ToString()); Debug.WriteLine(\"Remaining 7 bytes of scratch pad:\"); for (int i = 0; i < 7; i++) { Debug.WriteLine(oneWireBus.ReadByte().ToString()); } Debug.WriteLine(\"--------\"); } Sample output: Number of sensors found = 3 Temperature: 21.125 Remaining 7 bytes of scratch pad: 75 70 127 255 14 16 255 -------- Temperature: 21 Remaining 7 bytes of scratch pad: 75 70 127 255 16 16 73 -------- Temperature: 21.1875 Remaining 7 bytes of scratch pad: 75 70 127 255 13 16 233 --------"
  },
  "software/tinyclr/tutorials/adafruit-io.html": {
    "href": "software/tinyclr/tutorials/adafruit-io.html",
    "title": "Adafruit IO",
    "keywords": "Adafruit IO The Adafruit cloud, Adafruit IO, is a cloud service primarily aimed at the maker market. While Adafruit IO is more limited than the major players in cloud services, it is very easy to use and there's a free option making this a great way to test IoT proofs of concept and prototypes. We'll need create a few things for our code. We'll need an Adafruit Certificate, a dashboardID, a username, a password key, and a feed to subscribe to. First download the required Adafruit Root Certificate and add to resources. The TLS Client shows how to download the root certificate. var caCertSource = Resources.GetBytes(Resources.BinaryResources.DigiCertGlobalRootG2); Next, we'll create a 'Dashboard', from the Dashboards page. Click on 'Create a New Dashboard' found inside the 'Actions' dropdown. Create a meaningful name for our Dashboard. This will be the 'dashboardID' inside our code sample. Click on our newly created 'Dashboard' This opens the Dashboard canvas for our project. This is where we will add blocks to control our IoT device. Click on '+' to create a new block. Let's add our first block to the canvas. There are many kinds of blocks you can add, for this we'll first add a 'Toggle' block. Click on the 'Toggle' block. We need to create a 'feed' name to attach to our newly created block. Enter a name for the feed and click 'Create'. In our example we'll call this block's feed 'ToggleSwitch' Check the box of the newly created feed and click 'Next Step' Here we can set the Text we want to use that appears on the button and the value the button will send when used. Let's change the Button value to 1 for on and 0 for off. Then click 'Create block' The new Toogle we created now appears in the Dashboard canvas, the blocks can be placed anywhere we like on the Dashboard. But let's add another block first. Let's add a 'Gauge' block to our canvas next. Like we did the ToggleSwitch feed, we need to create a feed for the Gauge. We'll just call the feed 'Gauge', click on the 'Create', select the 'Gauge' and click 'Next step' There are several setting we can adjust but for this tutorial we'll just us the default and click on 'Create block' We can see that the gauge has been added to our Dashboard Canvas. The final element we need for our code is an 'Adafruit IO Key'. Click on it located in the top menu. Copy the generated key... ...and paste in our code as shown in the example below. var key = \"aio_XXJy54zT7H0X89PMZhUwlsfA7\"; We now have all the elements we need to complete the code in our sample. Here are the values we created and need to add. var dashboardId = \"SITCore\"; var username = \"Your Username\"; var key = \"aio_XXJy54zT7H0X89PMZhUwlsfA7\"; var feed = \"your username/feeds/ToggleSwitch\"; Deploy your program to your SITCore IoT device, once launched the gauge on our Dashboard will start at 50 and increment by 5 every 2 seconds. Clicking on the 'Toggle Switch' will send the value to our device, which can be seen in Visual Studio's output window. Using MQTT var caCertSource = Resources.GetBytes(Resources.BinaryResources.DigiCertGlobalRootG2); X509Certificate CaCert = new X509Certificate(caCertSource); var mqttHost = \"io.adafruit.com\"; var mqttPort = 8883; //Default SSL port is 8883, default insecure port is 1883. var dashboardId = \"Your Dashboard\"; var username = \"Your Username\"; var key = \"Your Adafruit IO Key\"; var feed = \"Feed you wish to subscribe to\"; try { var clientSetting = new MqttClientSetting { BrokerName = mqttHost, BrokerPort = mqttPort, ClientCertificate = null, CaCertificate = CaCert, SslProtocol = System.Security.Authentication.SslProtocols.Tls12, }; var client = new Mqtt(clientSetting); var connectSetting = new MqttConnectionSetting { ClientId = dashboardId, UserName = username, Password = key }; // Connect to host var returnCode = client.Connect(connectSetting); if(returnCode == ConnectReturnCode.ConnectionAccepted) Debug.WriteLine(\"Connected to Adafruit IO\"); var packetId = 1; // Subscribe to a feed client.Subscribe(new string[] {feed}, new QoSLevel[] { QoSLevel.ExactlyOnce }, (ushort)packetId++); // Publish to a feed client.PublishReceivedChanged += Client_PublishReceivedChanged; var dx = 5; var x = 50; while (true) { x += dx; if (x >= 100 || x <= 0) dx *= -1; // Publish a topic client.Publish(\"your username/feeds/gauge\", Encoding.UTF8.GetBytes(\" \" + x), QoSLevel.MostOnce, false, (ushort)packetId); //Sets gauge Thread.Sleep(2000); } } catch (Exception e) { } Thread.Sleep(Timeout.Infinite); } private static void Client_PublishReceivedChanged(object sender, string topic, byte[] data, bool duplicate, QoSLevel qosLevel, bool retain) { if (data[0] == '1') { //Toggle is set to '1' Debug.WriteLine(\"ToggleSwitch set to 1\"); } if (data[0] == '0') { //Toggle is set to '0' Debug.WriteLine(\"ToggleSwitch set to 0\"); } } Using HTML Your IoT device can communicate with Adafruit IO using simple HTTP GET and POST commands. However, to respond to input on your Adafruit IO dashboard you must repeatedly execute HTTP GET requests to poll the input. If you would rather use event driven input from Adafruit IO, MQTT is a better choice than HTML. The following code uses an HTTP POST request to send a value to an Adafruit IO feed named \"Gauge\" which is represented by a gauge on an Adafruit IO dashboard. It uses a secure connection, so you must have the Adafruit certificate loaded as a resource. There must be a working Internet connection for this code to work. var url = \"http://io.adafruit.com/api/feeds/temperature/data.json\"; var postData = \"{\\\"value\\\":\\\"20\\\"}\"; //Sending a value of 20. var byteArray = System.Text.Encoding.UTF8.GetBytes(postData); var cert = Resource.GetBytes(Resource.BinaryResources.DigiCertGlobalRootG2); certx509 = new X509Certificate[] { new X509Certificate(cert) }; int read = 0, total = 0; byte[] result = new byte[512]; try { using (var postRequest = HttpWebRequest.Create(url) as HttpWebRequest) { postRequest.KeepAlive = false; postRequest.HttpsAuthentCerts = certx509; postRequest.ReadWriteTimeout = 2000; postRequest.Headers.Add(\"x-aio-key: your_adafruit_io_key_goes_here\"); postRequest.ContentType = \"application/json\"; postRequest.Method = \"POST\"; postRequest.ContentLength = byteArray.Length; System.IO.Stream dataStream = postRequest.GetRequestStream(); dataStream.Write(byteArray, 0, byteArray.Length); dataStream.Close(); using (var res = postRequest.GetResponse() as HttpWebResponse) { using (var stream = res.GetResponseStream()) { do { read = stream.Read(result, 0, result.Length); total += read; System.Diagnostics.Debug.WriteLine(\"read : \" + read); System.Diagnostics.Debug.WriteLine(\"total : \" + total); String page = \"\"; page = new String(System.Text.Encoding.UTF8.GetChars (result, 0, read)); System.Diagnostics.Debug.WriteLine(\"Response : \" + page); } while (read != 0); } } } } catch { } You can use an HTTP GET request to read the status of an Adafruit IO feed. The following code reads that status of a toggle block called \"Digital.\" You will need the rename the toggle's Button On Text to \"1\" and the Button Off Text to \"0\" on the Adafruit IO dashboard. There must be a working Internet connection for this code to work. url = \"https://io.adafruit.com/api/v2/adafruit_io_username/ feeds/toggleswitch/data?include=value&limit=1\"; var cert = Resource.GetBytes(Resource.BinaryResources.DigiCertGlobalRootG2); certx509 = new X509Certificate[] { new X509Certificate(cert) }; using (var getRequest = HttpWebRequest.Create(url) as HttpWebRequest) { getRequest.KeepAlive = false; getRequest.HttpsAuthentCerts = certx509; getRequest.ReadWriteTimeout = 2000; getRequest.Headers.Add(\"x-aio-key: your_adafruit_io_key_goes_here\"); getRequest.Method = \"GET\"; using (var response = getRequest.GetResponse() as HttpWebResponse){ using (var stream = response.GetResponseStream()) { do { read = stream.Read(result, 0, result.Length); total += read; System.Diagnostics.Debug.WriteLine(\"read : \" + read); System.Diagnostics.Debug.WriteLine(\"total : \" + total); String page = \"\"; page = new String(System.Text.Encoding.UTF8.GetChars (result, 0, read)); System.Diagnostics.Debug.WriteLine(\"Response : \" + page); } while (read != 0); } } }"
  },
  "software/tinyclr/tutorials/analog-in.html": {
    "href": "software/tinyclr/tutorials/analog-in.html",
    "title": "Analog In",
    "keywords": "Analog In Unlike digital input pins, which can only read high or low, analog pins can read a range of voltage levels. Microcontrollers based on 3.3V can typically read voltages anywhere between zero and 3.3V. Analog inputs connect internally to an Analog to Digital Converter (ADC) that converts the analog voltage level on the pin to a digital value. Tip Note that the analog channel number is not the pin number. You need to determine the channel number of a specific pin using your system's documentation. The resolution of the ADC determines its accuracy. An 8bit ADC has 256 steps to work with, 3.3V/256=0.013V. This means an increase of 0.013V will increase the ADC value by one. In other words, a voltage change of less than 0.013V has no effect. var adc = AdcController.FromName(SC20100.Adc.Controller1.Id); var analog = adc.OpenChannel(SC20100.Adc.Controller1.PA0); while (true) { double d = analog.ReadRatio(); Debug.WriteLine(\"An-> \" + d.ToString(\"N2\")); Thread.Sleep(100); } Support Sampling timing Changing sampling time can be configured as follows: adcChannel.SamplingTime = TimeSpan.FromTicks(10); // Set to 1us (a tick is 100ns) SITCore allows these sampling times. If the SamplingTime is between two values above, the higher values will be used. Note SITCore ADC resolution by device SC20xxx = 16 bit SC13xxx = 12 bit Ticks SC20xxx (Full/Half Speed) 0 23ns 1 132ns 2 257ns 5 507ns 10 1007ns 60 6054ns 126 12664ns Ticks SC13xxx (Full Speed) 0 81ns 1 156ns 3 306ns 5 593ns 11 1156ns 30 3094ns 80 8006ns Ticks SC13xxx (Half Speed) 1 162ns 3 312ns 6 612ns 11 1187ns 23 2312ns 60 6187ns 160 16012ns Tip Default is 1 tick. Temperature sensor SITCore support reading temperature sensor. var sc20xxx = DeviceInformation.DeviceName.IndexOf(\"SC20\") >= 0 ? true : false; var ts_reg1 = sc20xxx ? (IntPtr)0x1FF1E820 : (IntPtr)0x1FFF75A8; var ts_reg2 = sc20xxx ? (IntPtr)0x1FF1E840 : (IntPtr)0x1FFF75CA; var enable_reg = sc20xxx ? (IntPtr)((0x40000000U + 0x18020000 + 0x6300 + 8)) : (IntPtr)(0x40000000U + 0x08000000U + 0x08040300U + 8); var controller = sc20xxx ? AdcController.FromName(SC20100.Adc.Controller3.Id) : AdcController.FromName(SC13048.Adc.Controller1.Id); var channel = sc20xxx ? controller.OpenChannel(SC20100.Adc.Controller3.InternalTemperatureSensor) : controller.OpenChannel(SC13048.Adc.Controller1.InternalTemperatureSensor); var enable_val = Marshal.ReadInt32(enable_reg); enable_val |= (1 << 23); Marshal.WriteInt32(enable_reg, enable_val); while (true) { var v = channel.ReadValue() * 1.0; var ts1 = Marshal.ReadInt32(ts_reg1); var ts2 = Marshal.ReadInt32(ts_reg2); if (!sc20xxx) { ts1 &= 0xFFFF; ts2 &= 0xFFFF; v *= 1.1; } var t1 = (110 - 30) * 1.0; var t2 = (ts2 - ts1) * 1.0; var t3 = (v - ts1) * 1.0; var temperature = t1 / t2 * t3 + 30; Debug.WriteLine(\"T = \" + temperature + \" Celsius\"); Thread.Sleep(1000); }"
  },
  "software/tinyclr/tutorials/analog-out.html": {
    "href": "software/tinyclr/tutorials/analog-out.html",
    "title": "Analog Out",
    "keywords": "Analog Out DAC A Digital to Analog Converter (DAC) will convert a digital input (number) to an analog output (voltage). The voltage of a DAC usually swings from very close to zero volts up to nearly the voltage of the microcontroller (usually 3.3 volts). This output voltage is only a weak signal and is not meant to drive a load. An op-amp or similar circuit can be added to drive a load, such as a speaker. The param accepted by the api is from 0.0 to 1.0. This is ratio from 0V to the microcontroller's voltage source, 3.3V on SITCore. Note SC20xxx and SC13xxx support 12 bit resolution. var dac = DacController.GetDefault(); var analog = dac.OpenChannel(SC20100.Dac.PA4); double d = 0.5; double dd = 0.01; while (true) { analog.WriteValue(d); d += dd; if (d <= 0 || d >= 1) dd *= -1; //Invert Thread.Sleep(10); } Tip Do not use analog outputs to control the power of an LED or a motor. Use PWM for that. PWM PWM can also be used to output an analog voltage. Click here for details. Audio Playback WAV audio playback can be done using an analog output pin. See Audio Playback."
  },
  "software/tinyclr/tutorials/application-domain.html": {
    "href": "software/tinyclr/tutorials/application-domain.html",
    "title": "Application Domain",
    "keywords": "Application Domain The AppDomain class lets you load assemblies from any file stream at runtime. This feature can be used to reduce the need for program flash memory by loading code only as needed from a USB flash drive or SD card, or when you won't know until runtime which assemblies will be used. The sample code below loads and executes a small assembly from a USB flash drive. To run this sample, start a new project in Visual Studio and copy the first code sample into the Program.cs window. Then add a new TinyCLR class named TestAppDomainAssembly.cs, and copy the second code sample into this window. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Storage, GHIElectronics.TinyCLR.IO, GHIElectronics.TinyCLR.Native, and GHIElectronics.TinyCLR.Pins. var storageController = StorageController. FromName(SC20260.StorageController. UsbHostMassStorage); var drive = FileSystem.Mount(storageController.Hdc); var filename = drive.Name + \"\\\\TestAppDomain.pe\"; FileStream fsRead = new FileStream(filename, System.IO.FileMode.Open); var assemblyInBytes = new byte[fsRead.Length]; fsRead.Read(assemblyInBytes, 0, assemblyInBytes.Length); var assembly = Assembly.Load(assemblyInBytes); var obj = AppDomain.CurrentDomain.CreateInstanceAndUnwrap(\"TestAppDomain\", \"TestAppDomain.TestAssembly\"); var type = assembly.GetType(\"TestAppDomain.TestAssembly\"); MethodInfo mi = type.GetMethod(\"PrintMessage\"); mi.Invoke(obj, null); TestAppDomainAssembly.cs class: namespace TestAppDomain { public class TestAssembly { public void PrintMessage() { System.Diagnostics.Debug.WriteLine(\"Hello from TestAssembly\"); } } } In the TestAppDomain properties window (right click on TestAppDomain in Solution Explorer and select Properties), click on TinyCLR OS in the left panel and check the Generate native stubs for internal methods and Generate bare native stubs boxes. This tells Visual Studio to create the Portable Executable (PE) file that will be copied to the USB flash drive and then executed by the main program. Now build the project. Inside of the project's directory navigate to the TestAppDomain/bin/Debug/pe directory and copy the file TestAppDomain.pe to a USB flash drive. Now insert the flash drive into your SITCore board and deploy the program. The main program will load and run TestAppDomain.pe from the USB flash drive. If everything worked, you should see the following in your output window: 'GHIElectronics.TinyCLR.VisualStudio.ProjectSystem.dll' (Managed): Loaded 'TestAppDomain' Assembly: TestAppDomain (1.0.0.0) Hello from TestAssembly"
  },
  "software/tinyclr/tutorials/audio-playback.html": {
    "href": "software/tinyclr/tutorials/audio-playback.html",
    "title": "Audio Playback",
    "keywords": "Audio Playback WAV Files Simple audio playback is accomplished by reading a PCM WAV file and passing the data to the built-in analog out pin. Even easier, parse the WAV file on a PC and include the PCM samples. A WAV file parser driver is provided under the Codec drives page. MP3 Files MP3 file decoding can be accomplished by using one of the many MP3 decoders available from VLSI Solution http://www.vlsi.fi/. A driver is already provide, see the Codec drives page."
  },
  "software/tinyclr/tutorials/aws.html": {
    "href": "software/tinyclr/tutorials/aws.html",
    "title": "Amazon Web Services",
    "keywords": "Amazon Web Services This example shows how to communicate with AWS using MQTT. You'll also need to set up a Network Interface connection on the device such as WiFi to Connect to AWS in your program. First download the required AWS Root Certificate and add to resources. The TLS Client shows how to download the root certificate. There is also a Client certificate that needs to be downloaded from the AWS account, detailed below. var iotEndPoint = \"Need your Rest API Endpoint\"; var iotPort = 8883; var deviceId = \"Need your Device ID\"; var topicShadowUpdate = string.Format(\"$aws/things/{0}/shadow/update\", deviceId); var topicShadowGet = string.Format(\"$aws/things/{0}/shadow/get\", deviceId); var message = \"{\\\"state\\\":{\\\"desired\\\":{\\\"My message\\\":\\\"Hello World\"}}}\"; var caCertSource = UTF8Encoding.UTF8.GetBytes(\"Need AWS root CA certificate\"); var clientCertSource = UTF8Encoding.UTF8.GetBytes(\"Need your AWS client CA certificate\"); var privateKeyData = UTF8Encoding.UTF8.GetBytes(\"Need your AWS private key\"); X509Certificate CaCert = new X509Certificate(caCertSource); X509Certificate ClientCert = new X509Certificate(clientCertSource); ClientCert.PrivateKey = privateKeyData; var clientSetting = new MqttClientSetting { BrokerName = iotEndPoint, BrokerPort = iotPort, CaCertificate = CaCert, ClientCertificate = ClientCert, SslProtocol = System.Security.Authentication.SslProtocols.Tls12 }; var iotClient = new Mqtt(clientSetting); iotClient.PublishReceivedChanged += (p1, p2, p3, p4, p5, p6) => { Debug.WriteLine(\"Received message: \" + Encoding.UTF8.GetString(p3)); }; iotClient.SubscribedChanged += (a, b) => { Debug.WriteLine(\"Subscribed\"); }; Debug.WriteLine(\"Connecting....\") var connectSetting = new MqttConnectionSetting { ClientId = deviceId, UserName = null, Password = null }; var connectCode = iotClient.Connect(connectSetting); ushort packetId = 1; iotClient.Subscribe(new string[] { topicShadowGet }, new QoSLevel[] { QoSLevel.LeastOnce }, packetId++); iotClient.Publish(topicShadowUpdate, Encoding.UTF8.GetBytes(message), QoSLevel.MostOnce, false, packetId++); We need a few things to complete the code sample that we'll get from AWS. We need an iotEndPoint, a deviceId, an AWS root certificate, a client certificate and a private key. First, you'll need to create an AWS account. Once you've created your account, we need to find the service to set up our device. On the AWS Management Console, search for the service 'IoT Core' and select it. Before we add our device, we need to create a Policy that the device will use. From the side menu under the 'Secure' tab click 'Polices' click on the button to create a new policy. Name your policy and then click on advanced mode. Paste the code found below in the code window. Then click the 'Create' button. We'll attach the policy to the device later. Paste this code in the above window. { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [ \"iot:Publish\", \"iot:Subscribe\", \"iot:Connect\", \"iot:Receive\" ], \"Resource\": [ \"*\" ] } ] } Now we need to create our IoT device within AWS. Click on the 'Manage' Dropdown and select 'Things', then click on 'Register a thing' Next, we click on 'Create a single thing' Now we'll create a Name for our IoT device and add it to the 'Things' registry. This will be the deviceId we will use in the code sample. There are other options available that can be added, but in this tutorial, we only need to create a 'Name' and click 'NEXT' The next page is where we'll create the CA Certificates, we need to add to our projects resources. In this case we can use the 'One-Click certificate creation'. Click on 'Create certificate' Next we need to download the CA Certificates we need. We need 'A certificates for this thing' and 'the private key', we don't need to download the public key for this project. You'll also need an AWS root certificate, you can follow the link to download RSA 2048 bit key: Amazon Root CA 1. Next we need to click on the 'Activate' button to activate the certificates we created, then click 'Attach a policy' Check the box for the 'Policy' we created earlier, and then click the 'Register Thing' button. Add the 3 Certificates we downloaded to Resources in our project and SAVE your project. Inside the 'Things' registry list click on the device you just created. Once you're on your devices dashboard, click on the 'Interact' tab. This will give you the iotEndPoint we'll need for our code. Copy the code... ...and paste it into the code as shown below. Also add the name of your device to the variable deviceId. var iotEndPoint = \"a13gxtasnslh-ats.iot.us-west-2.amazonaws.com\"; var iotPort = 8883; var deviceId = \"MyDevice\"; Finally, we need to link the CA Certificates we placed in our project resources to our code as shown in the example below. var caCertSorce = Resources.GetBytes(Resources.BinaryResources.AmazonRootCA1); var clientCertSource = Resources.GetBytes(Resources.BinaryResources._3a59c69926_certificate_pem); var privateKeyData = Resources.GetBytes(Resources.BinaryResources._3a59c69926_private_pem); You can now deploy your program in Visual Studio, to connect your device to AWS. Clicking on the 'Activity' Tab on our device dashboard will show the active connection. We view the messages being sent from our IoT device to AWS by clicking on the 'Shadows' Tab, then click 'Classic Shadows'. The message in the window is sent from our device... We can edit the message being sent from the device in Visual Studio by changing the message in this line of our code. var Message = \"{\\\"state\\\":{\\\"desired\\\":{\\\"My message\\\":\\\"Hello World\\\"}}}\";"
  },
  "software/tinyclr/tutorials/azure.html": {
    "href": "software/tinyclr/tutorials/azure.html",
    "title": "Microsoft Azure",
    "keywords": "Microsoft Azure This example shows how to communicate with Azure IoT Hub using MQTT. User will need to set up a Network Interface connection on the device such as WiFi to Connect to Azure. First download the required Azure Root Certificate and add to resources. The TLS Client shows how to download the root certificate. Tip Needed NuGets: GHIElectronics.TinyCLR.Networking.Mqtt, GHIElectronics.TinyCLR.Drivers.Azure.SAS Add using statement: using System.Security.Cryptography.X509Certificates; using System.Security.Authentication; var caCert = new X509Certificate(\"Need Azure certificate\"); var iotHubName = \"Your.azure-devices.net\"; var iotHubPort = 8883; // device/client information const string deviceId = \"your device id\"; var username = string.Format(\"{0}/{1}\", iotHubName, deviceId); // Data time is important for calculate expire time SystemTime.SetTime(new DateTime(2021, 2, 23)); var sas = new SharedAccessSignatureBuilder() { Key = \"your key\", KeyName = \"iothubowner\", Target = \"Your.azure-devices.net\", TimeToLive = TimeSpan.FromDays(1) // at least 1 day. }; // define topics var topicDeviceToServer = string.Format(\"devices/{0}/messages/events/\", deviceId); var topicService2Device = string.Format(\"devices/{0}/messages/devicebound/#\", deviceId); try { var clientSetting = new MqttClientSetting { BrokerName = iotHubName, BrokerPort = iotHubPort, ClientCertificate = null, CaCertificate = caCert, SslProtocol = System.Security.Authentication.SslProtocols.Tls12 }; var client = new Mqtt(clientSetting); client.PublishReceivedChanged += (p1, p2, p3, p4, p5, p6) => { Debug.WriteLine(\"Received message: \" + Encoding.UTF8.GetString(p3)); }; var connectSetting = new MqttConnectionSetting { ClientId = deviceId, UserName = username, Password = sas.ToSignature() }; var returnCode = client.Connect(connectSetting); if (returnCode != ConnectReturnCode.ConnectionAccepted) throw new Exception(\"Could not connect!\"); ushort packetId = 1; client.Subscribe(new string[] { topicService2Device }, new QoSLevel[] { QoSLevel.ExactlyOnce }, packetId++); client.Subscribe(new string[] { topicDeviceToServer }, new QoSLevel[] { QoSLevel.ExactlyOnce }, packetId++); client.Publish(topicDeviceToServer, Encoding.UTF8.GetBytes (\"Your message\"), QoSLevel.MostOnce, false, packetId++); } catch (Exception e) { throw; } In the first line of code above, an Azure Certificate is referenced, place the certificate inside project resources and change the code to reflect the name of that certificate, in the example below the name is zura. var caCert = new X509Certificate(Resources.GetByte(Resources.BinaryResources.zura)); The example code also requires iotHubName and deviceId, which are available only when a user opens an Azure account. To create the iotHubName and deviceId follow these instructions found on their website. Create an IoT Hub & Device ID Using the earlier code will send the incoming message the 'Output' window of Visual Studio."
  },
  "software/tinyclr/tutorials/camera.html": {
    "href": "software/tinyclr/tutorials/camera.html",
    "title": "Camera Interface",
    "keywords": "Camera Interface TinyCLR OS supports digital camera interface, sometimes referred to as DCMI or DCI, on devices using the SITCore SC20260 SoC. Typically, cameras need to be configured using I2C bus. Check the Omnivision/Ov9655 driver under https://github.com/ghi-electronics/TinyCLR-Drivers for an example of how to configure your camera, or refer to the camera's manual to determine the needed configuration. The following function captures camera images: public void Capture(byte[] data, int timeoutMillisecond) => this.cameraController.Capture(data, timeoutMillisecond); This example configures the camera and sends the images to the 4.3 inch display attached to the SCM20260D Dev Board. Tip Needed NuGets: GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.I2c, GHIElectronics.TinyCLR.Drivers.Omnivision.Ov9655, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Pins, GHIElectronics.TinyCLR.Devices.Display, GHIElectronics.TinyCLR.Drawing Needed Namespaces: GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.I2c, GHIElectronics.TinyCLR.Drivers.Omnivision.Ov9655, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Pins, System.Diagnostics, GHIElectronics.TinyCLR.Devices.Display, System.Drawing GpioPin backlight = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PA15); backlight.SetDriveMode(GpioPinDriveMode.Output); backlight.Write(GpioPinValue.High); var displayController = Display.DisplayController.GetDefault(); var controllerSetting = new ParallelDisplayControllerSettings { Width = 480, Height = 272, DataFormat = DisplayDataFormat.Rgb565, Orientation = DisplayOrientation.Degrees0, //Rotate display. PixelClockRate = 10000000, PixelPolarity = false, DataEnablePolarity = false, DataEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, }; displayController.SetConfiguration(controllerSetting); displayController.Enable(); var screen = Graphics.FromHdc(displayController.Hdc); var controller = I2cController.FromName(SC20260.I2cBus.I2c1); // Camera var ov9655 = new Ov9655Controller(controller); ov9655.FrameReceived += Ov9655_FrameReceived; var id = ov9655.ReadId(); Debug.WriteLine(\"id = \" + id); ov9655.SetResolution(Ov9655Controller.Resolution.Vga); byte temp = 0; while (true) { try { ov9655.Capture(); } catch (System.Exception) { } Thread.Sleep(10); } private static void Ov9655_FrameReceived(byte[] data, int size) { // 480 is screen width // 272 is screen height // 640 is original image width with VGA = 640 displayController.DrawBuffer(0, 0, 0, 0, 480, 272, 640, data, 0); }"
  },
  "software/tinyclr/tutorials/can.html": {
    "href": "software/tinyclr/tutorials/can.html",
    "title": "CAN",
    "keywords": "CAN Controller Area Network (CAN) bus is a serial communication protocol with built-in error checking and retransmission. It is generally a two wire bus, but other transceivers with one wire or LSFT (Low Speed Fault Tolerant) are used. The common high-speed two-wire CAN requires termination resistors at the end of the wires, typically 120 ohm. Tip Some CAN devices, including our own development boards, have built in termination resistors. CAN bit timing is a complex topic that requires considerable knowledge of the CAN protocol. All nodes on a CAN network must use the same baud rate. Sample bit timing settings are provided further down on this page to help you get started. SetNominalBitTiming() and SetDataBitTiming() define the CAN bus timing using the arguments listed below. Note that SetDataBitTiming() is only used for CAN-FD to specify the faster data rate. SetNominalBitTiming() is used both for standard CAN and to define the slower data bit rate for CAN-FD. Tip The propagationPhase1 argument combines the propagation and phase1 CAN timing parameters. Baud Propagation+Phase1 Phase2 Baudrate Prescaler Synchronization Jump Width Use Multi Bit Sampling Sample Point Max Osc. Tolerance Max Cable Length 33.333K 13 2 90 1 False 87.5% 0.31% 2200M 83.333K 13 2 36 1 False 87.5% 0.31% 850M 125K 13 2 24 1 False 87.5% 0.31% 550M 250K 13 2 12 1 False 87.5% 0.31% 250M 500K 13 2 6 1 False 87.5% 0.31% 100M 1M 13 2 3 1 False 87.5% 0.31% 40M Note The table above is calculated base on 40MHz clock source. There are many online CAN calculators that can be used to help you with CAN timing, for example. The CAN calculator needs the microcontroller's CAN clock speed. For the SITCore series SC20xxx, this is 48 MHz. For the SC13xxx the speed is 40MHz. These can easily be found with SourceClock property. Filtering Filters can be set to automatically accept or ignore messages based on their arbitration ID. Tip On SC20xxx, each CAN channel supports up to 64 standard IDs and 32 Extended IDs. SC13xxx supports up to 14 filters. Range Filter AddRangeFilter() allows you to set a range of arbitration IDs that will be accepted as valid messages. Messages with arbitration IDs outside of this range will be ignored. You can add more than one range filter. In the sample code below, the range filters will accept messages with arbitration IDs ranging from 0x12 to 0x20 and also between 0x500 and 0x1000 inclusive. Note Only SC20xxx supports Range Filter, SC13xxx doesn't. Mask Filter AddMaskFilter() can be used to specify an individual arbitration ID or a range of arbitration IDs that will be accepted regardless of the group filter settings. If the arbitration ID of the message is bitwise anded with the given mask argument, and the result is equal to the compare argument you provide, the message will be accepted. In the sample code below, CAN messages with arbitration IDs of 0x11, 0x13, and 0x5678 will be accepted in addition to the arbitration IDs specified by the group filters. Sample Code Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices and GHIElectronics.TinyCLR.Pins using GHIElectronics.TinyCLR.Devices.Can; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; using System; using System.Diagnostics; using System.Threading; var LdrButton = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PE3); LdrButton.SetDriveMode(GpioPinDriveMode.InputPullUp); var can = CanController.FromName(SC20100.CanBus.Can1); var propagationPhase1 = 13; var phase2 = 2; var baudratePrescaler = 3; var synchronizationJumpWidth = 1; var useMultiBitSampling = false; can.SetNominalBitTiming(new CanBitTiming(propagationPhase1, phase2, baudratePrescaler, synchronizationJumpWidth, useMultiBitSampling)); var message = new CanMessage() { Data = new byte[] { 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x2E, 0x20, 0x20 }, ArbitrationId = 0x11, Length = 6, RemoteTransmissionRequest = false, ExtendedId = false, FdCan = false, BitRateSwitch = false }; //The following filter will accept arbitration IDs from 0x12 to 0x20 inclusive. can.Filter.AddRangeFilter(Filter.IdType.Standard, 0x12, 0x20); //The following filter will accept arbitration IDs from 0x500 to 0x1000 inclusive. can.Filter.AddRangeFilter(Filter.IdType.Standard, 0x500, 0x1000); //The following filter will accept arbitration IDs of 0x11 and 0x13. can.Filter.AddMaskFilter(Filter.IdType.Standard, 0x11, 0xFD); //The following filter will accept arbitration IDs of 5678 only. can.Filter.AddMaskFilter(Filter.IdType.Standard, 0x5678, 0xFFFF); can.MessageReceived += Can_MessageReceived; can.ErrorReceived += Can_ErrorReceived; can.Enable(); while (true) { if (LdrButton.Read() == GpioPinValue.Low) can.WriteMessage(message); Thread.Sleep(100); } void Can_MessageReceived(CanController sender, MessageReceivedEventArgs e) { sender.ReadMessage(out var message); Debug.WriteLine(\"Arbitration ID: 0x\" + message.ArbitrationId.ToString(\"X8\")); Debug.WriteLine(\"Is extended ID: \" + message.ExtendedId.ToString()); Debug.WriteLine(\"Is remote transmission request: \" + message.RemoteTransmissionRequest.ToString()); Debug.WriteLine(\"Time stamp: \" + message.Timestamp.ToString()); var data = \"\"; for (var i = 0; i < message.Length; i++) data += Convert.ToChar(message.Data[i]); Debug.WriteLine(\"Data: \" + data); } void Can_ErrorReceived(CanController sender, ErrorReceivedEventArgs e) => Debug.WriteLine(\"Error \" + e.ToString()); CAN-FD CAN-FD allows for faster data transmission and larger data packet size to increase throughput. At the same time, CAN-FD is compatible with traditional CAN -- CAN-FD and standard CAN nodes can even coexist on the same CAN bus! CAN-FD can be used by setting the FdCan property of your CAN message to true. This setting will allow you to send up to 64 bytes of data per CAN message. To send the data at higher speed you will also need to set two bit timings, one for the normal, slower speed (SetNominalBitTiming()), and one for the faster speed (SetDataBitTiming()). You will also have to set the BitRateSwitch property of the CAN message to true. The following code shows the changes needed to make the above code sample use CAN-FD with speeds of 250 kilobaud and 1 megabaud. Note Only SC20xxx supports CAN-FD, SC13xxx doesn't support this feature. var propagationPhase1 = 13; //250 kilobaud settings var phase2 = 2; var baudratePrescaler = 12; var synchronizationJumpWidth = 1; var useMultiBitSampling = false; //Set the lower CAN speed to 250 kilobaud. can.SetNominalBitTiming(new CanBitTiming(propagationPhase1, phase2, baudratePrescaler, synchronizationJumpWidth, useMultiBitSampling)); baudratePrescaler = 3; //Change bit timing to 1 megabaud. //Set faster CAN speed to 1 megabaud. can.SetDataBitTiming(new CanBitTiming(propagationPhase1, phase2, baudratePrescaler, synchronizationJumpWidth, useMultiBitSampling)); can.Enable(); var message = new CanMessage() { Data = new byte[] { 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x2E, 0x20, 0x20 }, ArbitrationId = 0x11, Length = 6, RemoteTransmissionRequest = false, ExtendedId = false, FdCan = true, BitRateSwitch = true };"
  },
  "software/tinyclr/tutorials/cellular.html": {
    "href": "software/tinyclr/tutorials/cellular.html",
    "title": "Cellular",
    "keywords": "Cellular Any Cellular modem with PPP support should simply work with TinyCLR OS. Please see our PPP tutorial for more details and sample code. Other networking information and sample code can be found on our WiFi and Ethernet tutorials. Security Clarification Most users of embedded systems that connect to mobile networks assume they are secure, but often they are not. Typically, a serial connection with AT commands is used to communicate with the Internet. While the data over the air is secure, all data transmitted over the serial connection is raw unencrypted data that can be easily scoped. This is not the case with TinyCLR OS. With TinyCLR OS, serial data between the device and the modem is encrypted. All data handling is done internally inside the core processor, which is extremely difficult to hack into."
  },
  "software/tinyclr/tutorials/collections.html": {
    "href": "software/tinyclr/tutorials/collections.html",
    "title": "Collections",
    "keywords": "Collections Similar data can often be handled more efficiently when stored and manipulated as a collection. You can use the System.Array class or the classes in the System.Collections namespace to add, remove, and modify either individual elements or a range of elements in a collection. For more info go to https://docs.microsoft.com/en-us/dotnet/standard/collections/index. TinyCLR OS collections support ArrayLists, Hash tables, Stacks, and Queues. ArrayLists ArrayLists have a significant advantage over arrays in that ArrayLists are automatically resized as needed, whereas arrays are limited to a fixed number of elements. The following code sample creates an ArrayList, adds a couple of records, and then iterates through the ArrayList items and displays each record. class Program { private struct rmaRecord { public System.DateTime date; public string modelNumber; public string fault; } private static void Main() { var rmaList = new System.Collections.ArrayList(); var record = new rmaRecord(); record.date = new System.DateTime(2020, 2, 21); record.modelNumber = \"XY23\"; record.fault = \"No power\"; rmaList.Add(record); record.date = new System.DateTime(2020, 2, 20); record.modelNumber = \"XY42\"; record.fault = \"Blown fuse\"; rmaList.Add(record); PrintValues(rmaList); } private static void PrintValues(System.Collections.ArrayList list) { System.Diagnostics.Debug.WriteLine(\"Count: \" + list.Count); System.Diagnostics.Debug.WriteLine(\"Capacity: \" + list.Capacity); System.Diagnostics.Debug.WriteLine(\" \"); System.Diagnostics.Debug.WriteLine(\"Values:\"); foreach (rmaRecord record in list) { System.Diagnostics.Debug.WriteLine(\" Date: \" + record.date.Year + \"/\" + record.date.Month + \"/\" + record.date.Day); System.Diagnostics.Debug.WriteLine(\" Model#: \" + record.modelNumber); System.Diagnostics.Debug.WriteLine(\" Fault: \" + record.fault); System.Diagnostics.Debug.WriteLine(\"----------\"); } } } The above code outputs the following: Count: 2 Capacity: 4 Values: Date: 2020/2/21 Model#: XY23 Fault: No power ---------- Date: 2020/2/20 Model#: XY42 Fault: Blown fuse ---------- In the above sample, rmaList.Clear() will remove all elements from rmaList, rmaList.RemoveAt(1) will remove only the second element in the list, and rmaList.Remove(record) will remove the first element that is equal to record. Hash tables Hash tables are used to store information in a way that associates each data element, or value, with a key that can be used to look up that value. Hash tables make it easy to quickly retrieve information that would otherwise be difficult to organize in an efficient manner. For example, imagine trying to look up a phone number from a given name. You could make a two dimension array of names and phone numbers and then iterate through the array looking for the correct name, but this would be slow with a large array. Hash tables solve this problem by using a hash function to convert a key, in this case a name, into an array index that points directly to the data element you are looking for. This allows you to quickly retrieve the data directly instead of searching for it. The following code sample creates a hash table, adds elements to the hash table, and then reads back the value for each key. //Create a hash table. System.Collections.Hashtable processorPin = new System.Collections.Hashtable(); //Add some elements to the hash table. There can be no duplicate keys, but duplicate // values are allowed. // Key Value processorPin.Add(\"LDR\", \"PE3\"); processorPin.Add(\"APP\", \"PB7\"); processorPin.Add(\"MOD\", \"PD7\"); processorPin.Add(\"WKUP\", \"PA0\"); processorPin.Add(\"BTN1\", \"PE3\"); processorPin.Add(\"BTN2\", \"PB7\"); processorPin.Add(\"BTN3\", \"PD7\"); //If a key does not exist, setting the default Item property //for that key adds a new key/value pair. processorPin[\"BTN4\"] = \"PD9\"; //When you use foreach to enumerate hash table elements, the elements are retrieved // as DictionaryEntry objects. foreach (System.Collections.DictionaryEntry de in processorPin) { System.Diagnostics.Debug.WriteLine(\"Key = \" + de.Key + \" Value = \" + de.Value); } The above code outputs the following: Key = MOD Value = PD7 Key = LDR Value = PE3 Key = BTN1 Value = PE3 Key = BTN2 Value = PB7 Key = BTN3 Value = PD7 Key = BTN4 Value = PD9 Key = WKUP Value = PA0 Key = APP Value = PB7 Stacks Stacks are first in, last out (or last in, first out) collections of objects. The Push method is used to add items to a stack, and the Pop method is used to remove items from a stack. There is also a Peek method that returns the item at the top of the stack without removing it from the stack. var sitCoreDevices = new System.Collections.Stack(); sitCoreDevices.Push(\"SC20100S\"); sitCoreDevices.Push(\"SC20260B\"); sitCoreDevices.Push(\"SCM20260D\"); sitCoreDevices.Push(\"SCM20260E\"); sitCoreDevices.Push(\"SCM20260N\"); PrintValues(sitCoreDevices); System.Diagnostics.Debug.WriteLine(\"Popped: \" + sitCoreDevices.Pop().ToString()); System.Diagnostics.Debug.WriteLine(\" \"); PrintValues(sitCoreDevices); void PrintValues(System.Collections.Stack myQueue) { System.Diagnostics.Debug.WriteLine(\"Count: \" + myQueue.Count); System.Diagnostics.Debug.WriteLine(\"Items in queue:\"); foreach (System.Object obj in myQueue) System.Diagnostics.Debug.WriteLine(\" \" + obj); System.Diagnostics.Debug.WriteLine(\" \"); } The above code outputs the following: The thread '<No Name>' (0x2) has exited with code 0 (0x0). Count: 5 Items in queue: SCM20260N SCM20260E SCM20260D SC20260B SC20100S Popped: SCM20260N Count: 4 Items in queue: SCM20260E SCM20260D SC20260B SC20100S Queues Queues are first in, first out collections of objects. To add items to a queue, the enqueue method is used. To remove items, the dequeue method is used. var sitCoreDevices = new System.Collections.Queue(); sitCoreDevices.Enqueue(\"SC20100S\"); sitCoreDevices.Enqueue(\"SC20260B\"); sitCoreDevices.Enqueue(\"SCM20260D\"); sitCoreDevices.Enqueue(\"SCM20260E\"); sitCoreDevices.Enqueue(\"SCM20260N\"); PrintValues(sitCoreDevices); System.Diagnostics.Debug.WriteLine(\"Dequeued: \" + sitCoreDevices.Dequeue().ToString()); System.Diagnostics.Debug.WriteLine(\" \"); PrintValues(sitCoreDevices); void PrintValues(System.Collections.Queue myQueue) { System.Diagnostics.Debug.WriteLine(\"Count: \" + myQueue.Count); System.Diagnostics.Debug.WriteLine(\"Items in queue:\"); foreach (System.Object obj in myQueue) System.Diagnostics.Debug.WriteLine(\" \" + obj); System.Diagnostics.Debug.WriteLine(\" \"); } The above code outputs the following: Count: 5 Items in queue: SC20100S SC20260B SCM20260D SCM20260N SCM20260E Dequeued: SC20100S Count: 4 Items in queue: SC20260B SCM20260D SCM20260N SCM20260E"
  },
  "software/tinyclr/tutorials/cryptography.html": {
    "href": "software/tinyclr/tutorials/cryptography.html",
    "title": "Cryptography",
    "keywords": "Cryptography TinyCLR OS supports multiple algorithms. XTEA XTEA encryption is a symmetrical encryption method that always uses a 128 bit key. Keys of any other size will throw an exception. XTEA encryption also requires the data to you are encrypting to be a multiple of eight bytes in length. XTEA encryption is not only dependent upon the supplied key, but also the \"number of rounds\" or iterations the encryption algorithm uses to encode and decode information. TinyCLR OS always uses 32 rounds. So, for example, if you are using a PC to decode data that was encoded using TinyCLR OS, make sure that both the correct key and number of rounds (32) are used on the PC side. Tip Needed NuGets: GHIElectronics.TinyCLR.Core and GHIElectronics.TinyCLR.Cryptography The following sample code encrypts and decrypts a string of text. //Argument below is the 128 bit key. XTEA always uses a 128 bit key. var crypto = new Xtea(new uint[] { 0x01234567, 0x89ABCDEF, 0xFEDCBA98, 0x76543210 }); byte[] dataToEncrypt = Encoding.UTF8.GetBytes(\"Data to encrypt.\"); byte[] encryptedData; byte[] decryptedData; //Encrypt data. Data must be a multiple of 8 bytes. encryptedData = crypto.Encrypt(dataToEncrypt, 0, (uint)dataToEncrypt.Length); //Decrypt data. decryptedData = crypto.Decrypt(encryptedData, 0, (uint)encryptedData.Length); Debug.WriteLine(\"Decrypted: \" + Encoding.UTF8.GetString(decryptedData)); The above code outputs the following: Decrypted: Data to encrypt. RSA RSA public key cryptography has become the most popular asymmetric cryptography scheme on the Internet. While public key cryptography systems solve the problem of secure key sharing that exists in symmetric cryptography, they are much more computationally intensive. As a result, cryptography systems such as RSA are often used only to securely transfer the key for a symmetric cryptography method such as XTEA. Once the key has been sent, the computationally less intensive symmetric cryptography system is then used to encode and decode the bulk of the data. Note RSACryptoServiceProvider() implements the IDisposable interface Tip Needed NuGets: GHIElectronics.TinyCLR.Core and GHIElectronics.TinyCLR.Cryptography The following sample code encrypts and decrypts a string of text. byte[] dataToEncrypt = Encoding.UTF8.GetBytes(\"Data to Encrypt\"); byte[] encryptedData; byte[] decryptedData; using (RSACryptoServiceProvider RSA = new RSACryptoServiceProvider(2048)) { //Encrypt data. using (RSACryptoServiceProvider encryptRSA = new RSACryptoServiceProvider()) { encryptRSA.ImportParameters(RSA.ExportParameters(false)); encryptedData = encryptRSA.Encrypt(dataToEncrypt); } //Decrypt data. using (RSACryptoServiceProvider decryptRSA = new RSACryptoServiceProvider()) { decryptRSA.ImportParameters(RSA.ExportParameters(true)); decryptedData = decryptRSA.Decrypt(encryptedData); } } Debug.WriteLine(\"Decrypted: \" + Encoding.UTF8.GetString(decryptedData)); The above code outputs the following: Decrypted: Data to Encrypt If no key size is provided as an argument to RSACryptoServiceProvider(), a default key size of 1024 bits will be used. The boolean argument for RSA.ExportParameters() determines whether this method returns the private key (true) or public key (false). The public key is used to encrypt messages, while the private key is needed to decrypt messages. The code sample below demonstrates how to sign & verify data. var dataToSign = Encoding.UTF8.GetBytes(\"Data to sign. This is for test\"); byte[] signData; RSAParameters signKey; using (RSACryptoServiceProvider SignRSA = new RSACryptoServiceProvider()){ signKey = SignRSA.ExportParameters(true); SignRSA.ImportParameters(signKey); signData = SignRSA.SignData(dataToSign, true); } using (RSACryptoServiceProvider VerifyRSA = new RSACryptoServiceProvider()){ VerifyRSA.ImportParameters(signKey); Debug.WriteLine(\"Signed: \" + VerifyRSA.VerifyData(dataToSign, signData, true)); }"
  },
  "software/tinyclr/tutorials/debugging.html": {
    "href": "software/tinyclr/tutorials/debugging.html",
    "title": "Debugging",
    "keywords": "Debugging TinyCLR OS allows developers to debug tiny IoT devices just like you would debug an application on a full PC, right from within Visual Studio, over USB or Serial. Set breakpoints, step through code, and examine variables without the need for specialized hardware or software. By default, the system checks the MOD pin to determine the debug interface, USB or Serial. The user has the option to disable MOD pin feature and force (or disable) the debug interface. See Device Info for details. When serial debugging is selected, it defaults to: UART1 on SC13xxx UART1 on SC20100 UART5 on SC20260 Tip Information on using the Visual Studio debugger can be found in Microsoft's documentation here."
  },
  "software/tinyclr/tutorials/device-info.html": {
    "href": "software/tinyclr/tutorials/device-info.html",
    "title": "Device Information",
    "keywords": "Device Information CPU usage statistic CPU usage statistic measures between 0 and 100% while (true) { Thread.Sleep(100); // Check CPU every one second if ((DateTime.Now - last).TotalMilliseconds >= 1000) { var cpuUsage = DeviceInformation.GetCpuUsageStatistic(); Debug.WriteLine(\"Cpu usage = \" + cpuUsage + \" %\"); last = DateTime.Now; } } Debug Interface MOD pin is normally used to select the debug interface as explained in the Debugging tutorial. However, the MOD pin feature can be disabled and the debug interface can be forced to a specific interface. DeviceInformation.SetDebugInterface(DebugInterface.Usb); DeviceInformation.SetDebugInterface(DebugInterface.Serial); The debug interface can be completely disabled for the managed application's IP Protection DeviceInformation.SetDebugInterface(DebugInterface.Disable); The current debug interface can be determined as follows: if (DeviceInformation.DebugInterface == DebugInterface.Usb) Debug.WriteLine(\"Debug is in USB mode\"); The return results from DeviceInformation.DebugInterface only states the current interface but it does not know if that is due to MOD pin being set in that mode or the interface was forced to that specific interface. The DeviceInformation.IsModePinDisabled can be used to determine if MOD was used. As an alternate option, users can change the debug interface using TinyCLR Config tool. Note Once the debug interfaces changed or disabled, it may not be possible to communicate with the device anymore. However, changing or disabling the interface does not affect the bootloader. Users can always enter the bootloader, which will be in serial or USB depending on MOD pin. From there a Erase All can be issues, manually or though the TinyCLR Config tool. APP Pin The Special Pin APP's feature can be disabled using: DeviceInformation.AppPinDisable(); var appDisPin = DeviceInformation.IsAppPinDisabled(); TinyCLR Config tool can also be used to disable APP feature. Unique ID Returns devices UniqueId var deviceId = DeviceInformation.GetUniqueId(); Firmware Info Returns devices firmware Version. var major = (ushort)((DeviceInformation.Version >> 48) & 0xFFFF); var minor = (ushort)((DeviceInformation.Version >> 32) & 0xFFFF); var build = (ushort)((DeviceInformation.Version >> 16) & 0xFFFF); var revision = (ushort)((DeviceInformation.Version >> 0) & 0xFFFF); Debug.WriteLine(major +\".\"+ minor +\".\"+ build +\".\"+ revision); Manufacture Name Returns ManufacturerName information. Debug.WriteLine(DeviceInformation.ManufacturerName); Device Name Devices have a default name that they ship with. This can be read using DeviceInformation.DeviceName. This name also shows on the USB debug interface. The name can changed only once through DeviceInformation.SetDeviceName(\"New Device Name\"). Once set, a complete device erase is required before changing the name again. Tip Since Windows caches the name when loading the driver, Windows Device Manager will still show the old name. Simply right-click on the device and uninstall the driver. The next time it installs the drivers it will update with the new name."
  },
  "software/tinyclr/tutorials/displays.html": {
    "href": "software/tinyclr/tutorials/displays.html",
    "title": "Displays",
    "keywords": "Displays Graphical Displays can be grouped into two distinct interface categories, built-in parallel TFT displays and virtual displays, typically serial (SPI/I2C) displays. There are also non-graphical character displays and those work through a simple driver, not using the graphics. The display drivers are meant to transfer the pixel data from memory to the actual display. The graphics tutorial shows how drawing is done in memory. Native Displays These displays connect to special dedicated pins on the processor. Internally, the display controller automatically transfers (refreshes) the display directly from memory without any processor interaction, using DMA. When the system needs to update the display, it simply writes to memory. Neither the operating system nor the application program are burdened with display processing. The down side to this is that the system needs to have enough RAM to handle the display. An 800x600 display with 16bpp needs 960,000 bytes! Virtual Displays The internal graphics services can be mapped to work with virtual display displays, such as SPI displays. See the Graphics tutorial for more information and sample code. Character Displays These displays are capable of only showing characters. Most of these displays use the HD44780 controller. They are available in different sizes, but two lines of 16 characters is most common. These displays only require GPIO pins and can be used with TinyCLR. Sample code for HD44780 displays can be found in our GitHub Samples Repo. Low Level Display Access TinyCLR also provides low level display access as part of the GHIElectronics.TinyCLR.Devices.Display library. These methods provide a simple way to write to a display without need for the System.Drawing library or an added font resource file. Tip The low level support should only be used in advanced edge cases only. The following example is written for the SC20260D Dev Board with the 4.3\" display. It will paint the screen as shown in the picture beneath the code. Note that low level display access requires that you use the data format required by your display as configured. The SC20260D Dev Board used in this example expects each pixel to have 16 bits (two bytes per pixel) of color information in RGB565 format. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Display, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.I2c, GHIElectronics.TinyCLR.Devices.Spi, GHIElectronics.TinyCLR.Native, and GHIElectronics.TinyCLR.Pins. using GHIElectronics.TinyCLR.Devices.Display; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; GpioPin backlight = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PA15); backlight.SetDriveMode(GpioPinDriveMode.Output); backlight.Write(GpioPinValue.High); var displayController = DisplayController.GetDefault(); // Enter the proper display configurations displayController.SetConfiguration(new ParallelDisplayControllerSettings{ Width = 480, Height = 272, DataFormat = GHIElectronics.TinyCLR.Devices.Display.DisplayDataFormat.Rgb565, Orientation = DisplayOrientation.Degrees0, //Rotate display. PixelClockRate = 10000000, PixelPolarity = false, DataEnablePolarity = false, DataEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, }); displayController.Enable(); byte[] myPic = new byte[480 * 272 * 2]; for (var i = 0; i < myPic.Length; i++){ myPic[i] = (byte)(((i % 2) == 0) ? ((i / 4080) & 0b00000111) << 5 : i / 32640); } displayController.DrawString(\"\\f\"); displayController.DrawBuffer(0, 0, 0, 0, 480, 272, 480, myPic, 0); displayController.DrawString(\"GHI Electronics\\n\"); displayController.DrawString(\"Low Level Display Demo.\"); for (var x = 20; x < 459; x++){ displayController.DrawPixel(x, 50, 0xF800); //Color is 31,0,0 (RGB565). displayController.DrawPixel(x, 51, 0xF800); } SCM20260D Dev Board 4.3\" display after running the sample code:"
  },
  "software/tinyclr/tutorials/encoding-decoding.html": {
    "href": "software/tinyclr/tutorials/encoding-decoding.html",
    "title": "Encoding & Decoding",
    "keywords": "Encoding & Decoding TinyCLR OS provides many internal fast methods to handle many encoding and decoding tasks. Strings and Arrays The Encoding class is used to convert between strings, character arrays, and byte arrays. For example, to convert from a byte array to a string: var string = System.Text.Encoding.UTF8.GetString(new byte[] { 65, 66, 67, 68, 69 }); //string = \"ABCDE\" Convert From String to Byte Array System.Text.Encoding.UTF8.GetBytes(string s) //The following method returns an integer for the number of bytes converted. //The resulting bytes are returned within the byte[] array. System.Text.Encoding.UTF8.GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex) Convert From Byte Array to Character Array System.Text.Encoding.UTF8.GetChars(byte[] bytes) System.Text.Encoding.UTF8.GetChars(byte[] bytes, int byteIndex, int byteCount) Convert From Byte Array to String System.Text.Encoding.UTF8.GetString(byte[] bytes) System.Text.Encoding.UTF8.GetString(byte[] bytes, int index, int count) Base64 Base64 is a standard way to convert binary data into readable ASCII readable. var base64EncodedString = System.Convert.FromBase64String(string); var base64EncodedChar = System.Convert.FromBase64CharArray(char[]); var convertedFromBase64 = System.Convert.ToBase64String(byte[]); RFC4648 Base64 standard is supported by adding Convert.UseRFC4648Encoding = true;. BitConverter The BitConverter class is used to convert from one data type to another. For example, to convert an integer into a byte array: var byteArray = System.BitConverter.GetBytes(23); //byteArray[0] = 23, byteArray[1] = 0, byteArray[2] = 0, byteArray[3] = 0 byteArray = System.BitConverter.GetBytes(65536); //byteArray[0] = 0, byteArray[1] = 0, byteArray[2] = 1, byteArray[3] = 0 You can also convert from a byte array to a string, but the results are different than the results from the Encoding class: var string = System.BitConverter.ToString(new byte[] { 65, 66, 67, 68, 69 }); //string = \"41-42-43-44-45\" (hexadecimal values delimited by hyphens). var string = System.Text.Encoding.UTF8.GetString(new byte[] { 65, 66, 67, 68, 69 }); //string = \"ABCDE\" BitConverter Overloads Convert to a Byte Array System.BitConverter.GetBytes(char value) System.BitConverter.GetBytes(double value) System.BitConverter.GetBytes(float value) System.BitConverter.GetBytes(int value) System.BitConverter.GetBytes(long value) System.BitConverter.GetBytes(short value) System.BitConverter.GetBytes(uint value) System.BitConverter.GetBytes(ulong value) System.BitConverter.GetBytes(ushort value) System.BitConverter.GetBytes(bool value) Convert from a Byte Array System.BitConverter.ToBoolean(byte[] bytes, int startIndex) System.BitConverter.ToChar(byte[] bytes, int startIndex) System.BitConverter.ToDouble(byte[] bytes, int startIndex) System.BitConverter.ToInt16(byte[] bytes, int startIndex) System.BitConverter.ToInt32(byte[] bytes, int startIndex) System.BitConverter.ToInt64(byte[] bytes, int startIndex) System.BitConverter.ToSingle(byte[] bytes, int startIndex) System.BitConverter.ToString(byte[] bytes) System.BitConverter.ToString(byte[] bytes, int startIndex) System.BitConverter.ToString(byte[] bytes, int startIndex, int length) System.BitConverter.ToUInt16(byte[] bytes, int startIndex) System.BitConverter.ToUInt32(byte[] bytes, int startIndex) System.BitConverter.ToUInt64(byte[] bytes, int startIndex) Convert Between Double and Long System.BitConverter.DoubleToInt64Bits(double value) System.BitConverter.Int64BitsToDouble(long value) Swap Endianness SwapEndianness(byte[] data, int groupSize, int index, int size); String Handling ToString() Supported Conversions As TinyCLR OS is a subset of the full desktop .NET development system, not all desktop .NET features are supported. The following ToString() arguments are supported: Debug.WriteLine(123.ToString(\"N4\")); //Outputs 123.0000 Debug.WriteLine(123.ToString(\"F4\")); //Outputs 123.0000 Debug.WriteLine(123.ToString(\"D4\")); //Outputs 0123 Debug.WriteLine(123.ToString(\"G4\")); //Outputs 123 Debug.WriteLine(123.ToString(\"X4\")); //Outputs 007B The following ToString() arguments are not supported and will raise an exception: Debug.WriteLine(123.ToString(\"E4\")); //'E' option not supported Debug.WriteLine(123.ToString(\"R4\")); //'R' option not supported Debug.WriteLine(123.ToString(\"P4\")); //'P' option not supported Debug.WriteLine(123.ToString(\"C2\")); //'C' option not supported StringBuilder As strings are immutable, manipulating strings, especially in a tight loop, can impact system performance and increase memory usage and fragmentation. Because strings cannot be changed, every time you manipulate a string a new string is created and the original string becomes garbage. The StringBuilder class uses a string buffer to improve the performance of string manipulation, allowing you to manipulate strings instead of creating new strings. The following example changes the content of a string without creating a new string. var sb = new System.Text.StringBuilder(\"PA0 is the pin to use.\"); sb[1] = 'B'; System.Diagnostics.Debug.WriteLine(sb.ToString()); //Will output \"PB0 is the pin to use.\" StringBuilder is also great when you want to build strings by concatenating characters or other strings. Without StringBuilder, each time you add a character to a string, a new string is created and the old string becomes garbage. The following code creates a string one character at a time without creating all the garbage strings. var sb = new System.Text.StringBuilder(); for (int i=48; i<58; i++) { sb.Append((char)i); } Debug.WriteLine(sb.ToString()); //Will output \"0123456789\" Color Space Internally TinyCLR uses the 5:6:5 RGB 16BPP color space, requiring two bytes per pixel. Users may find the need to use a different color space. Conversion Convert(byte[] inArray, byte[] outArray, ColorFormat colorFormat, RgbFormat rgbFormat, byte alpha, byte[] colorTable) Users must create outArray of a length that is determined based on the ColorFormat the user is converting to. The table below will help in determining outArray buffer size. Color Space Desired size of outArray buffer 3:5:2 inArray.Length x 0.5 4:4:4 inArray.Length x 0.75 5:6:5 inArray.Length x 1 8:8:8 inArray.Length x 1.5 8:8:8:8 inArray.Length x 2.0 RgbFormat is used to swap colors is necessary. Tip Converting to from 5:6:5 to 5:6:5 doesn't convert the color space but it is useful to change the RgbFormat or scale using colorTable. The 64 values in colorTable maps each RGB original colors (6bit max from 5:6:5) to a new scaled color (up to 8bit in 8:8:8). This is optional as Convert will be default simply shift 6 bit up into 8 bits. This is an example of colorTable with more ideal results var ColorTable565To888 = new byte[64]{ 0,2,4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,85,89,93,97,101,105,109,113,117,121,125,129,133,137,141,145,149,153,157,161,165,170,174,178,182,186,190,194,198,202,206,210,214,218,222,226,230,234,238,242,246,250 }; Tip The custom color table option is only available in 5:6:5, 8:8:8, and 8:8:8:8 color spaces. The alpha is only used with the 8:8:8:8 color space to set the alpha channel value, between 0(transparent) to 255(opaque). 1Bpp Conversion The ConvertTo1Bpp function converts the internal 5:6:5 color space to 1BPP. Any color will result in 1 and only black will result in 0. ConvertTo1Bpp(byte[] inArray, byte[] outArray, uint width) width is the pixel-width of the image that was used to create inArray. The outArray buffer size is = inArray.Length x 0.0625 By default, ConvertTo1Bpp groups each 8 pixels vertically, which is what most 1BPP display use. There is an overload that include BitFormat to change to horizontal if desired. ConvertTo1Bpp(byte[] inArray, byte[] outArray, uint width, BitFormat bitFormat)"
  },
  "software/tinyclr/tutorials/ethernet.html": {
    "href": "software/tinyclr/tutorials/ethernet.html",
    "title": "Ethernet",
    "keywords": "Ethernet Ethernet is supported through the internal MAC, by adding an external PHY (100BASE), and also by using an ENC28J60 over SPI bus (10BASE). Some available modules include the necessary PHY, so the user will only need to add an Ethernet connector with magnets. Important You will need to ship each device with a valid and unique MAC address. More information about MAC addresses can be found here. Built-in Ethernet Here is a simple example: Tip Needed NuGets: GHIElectronics.TinyCLR.Devices.Network, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Pins static bool linkReady = false; static void EthernetTest() { //Reset external phy. var gpioController = GpioController.GetDefault(); var resetPin = gpioController.OpenPin(SC20260.GpioPin.PG3); resetPin.SetDriveMode(GpioPinDriveMode.Output); resetPin.Write(GpioPinValue.Low); Thread.Sleep(100); resetPin.Write(GpioPinValue.High); Thread.Sleep(100); var networkController = NetworkController.FromName(SC20260.NetworkController.EthernetEmac); var networkInterfaceSetting = new EthernetNetworkInterfaceSettings(); var networkCommunicationInterfaceSettings = new BuiltInNetworkCommunicationInterfaceSettings(); networkInterfaceSetting.Address = new IPAddress(new byte[] { 192, 168, 1, 122 }); networkInterfaceSetting.SubnetMask = new IPAddress(new byte[] { 255, 255, 255, 0 }); networkInterfaceSetting.GatewayAddress = new IPAddress(new byte[] { 192, 168, 1, 1 }); networkInterfaceSetting.DnsAddresses = new IPAddress[] {new IPAddress(new byte[] { 75, 75, 75, 75 }), new IPAddress(new byte[] { 75, 75, 75, 76 })}; networkInterfaceSetting.MacAddress = new byte[] { 0x00, 0x4, 0x00, 0x00, 0x00, 0x00 }; networkInterfaceSetting.DhcpEnable = true; networkInterfaceSetting.DynamicDnsEnable = true; networkController.SetInterfaceSettings(networkInterfaceSetting); networkController.SetCommunicationInterfaceSettings(networkCommunicationInterfaceSettings); networkController.SetAsDefaultController(); networkController.NetworkAddressChanged += NetworkController_NetworkAddressChanged; networkController.NetworkLinkConnectedChanged += NetworkController_NetworkLinkConnectedChanged; networkController.Enable(); while (linkReady == false) ; Debug.WriteLine(\"Network is ready to use\"); Thread.Sleep(Timeout.Infinite); } private static void NetworkController_NetworkLinkConnectedChanged (NetworkController sender, NetworkLinkConnectedChangedEventArgs e) { //Raise connect/disconnect event. } private static void NetworkController_NetworkAddressChanged (NetworkController sender, NetworkAddressChangedEventArgs e) { var ipProperties = sender.GetIPProperties(); var address = ipProperties.Address.GetAddressBytes(); linkReady = address[0] != 0; Debug.WriteLine(\"IP: \" + address[0] + \".\" + address[1] + \".\" + address[2] + \".\" + address[3]); } ENC28J60 This example uses the ENC28J60 click on our SC20260D Dev Board. Tip Needed NuGets: GHIElectronics.TinyCLR.Devices.Network, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.Spi, GHIElectronics.TinyCLR.Pins static void Enc28Test() { var networkController = NetworkController.FromName (SC20260.NetworkController.Enc28j60); var networkInterfaceSetting = new EthernetNetworkInterfaceSettings(); var networkCommunicationInterfaceSettings = new SpiNetworkCommunicationInterfaceSettings(); var cs = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PG12); var settings = new Spi.SpiConnectionSettings(){ ChipSelectLine = cs, ClockFrequency = 4000000, Mode = GHIElectronics.TinyCLR.Devices.Spi.SpiMode.Mode0, ChipSelectType = SpiChipSelectType.Gpio, ChipSelectHoldTime = TimeSpan.FromTicks(10), ChipSelectSetupTime = TimeSpan.FromTicks(10) }; networkCommunicationInterfaceSettings.SpiApiName = SC20260.SpiBus.Spi3; networkCommunicationInterfaceSettings.GpioApiName = SC20260.GpioPin.Id; networkCommunicationInterfaceSettings.SpiSettings = settings; networkCommunicationInterfaceSettings.InterruptPin = GetDefault().OpenPin(SC20260.GpioPin.PG6); networkCommunicationInterfaceSettings.InterruptEdge = GpioPinEdge.FallingEdge; networkCommunicationInterfaceSettings.InterruptDriveMode = GpioPinDriveMode.InputPullUp; networkCommunicationInterfaceSettings.ResetPin = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PI8); networkCommunicationInterfaceSettings.ResetActiveState = GpioPinValue.Low; networkInterfaceSetting.Address = new IPAddress(new byte[] { 192, 168, 1, 122 }); networkInterfaceSetting.SubnetMask = new IPAddress(new byte[] { 255, 255, 255, 0 }); networkInterfaceSetting.GatewayAddress = new IPAddress(new byte[] { 192, 168, 1, 1 }); networkInterfaceSetting.DnsAddresses = new IPAddress[] { new IPAddress(new byte[] { 75, 75, 75, 75 }), new IPAddress(new byte[] { 75, 75, 75, 76 }) }; networkInterfaceSetting.MacAddress = new byte[] { 0x00, 0x4, 0x00, 0x00, 0x00, 0x00 }; networkInterfaceSetting.DhcpEnable = true; networkInterfaceSetting.DynamicDnsEnable = true; networkController.SetInterfaceSettings(networkInterfaceSetting); networkController.SetCommunicationInterfaceSettings(networkCommunicationInterfaceSettings); networkController.SetAsDefaultController(); networkController.NetworkAddressChanged += NetworkController_NetworkAddressChanged; networkController.NetworkLinkConnectedChanged += NetworkController_NetworkLinkConnectedChanged; networkController.Enable(); while (linkReady == false) ; System.Diagnostics.Debug.WriteLine(\"Network is ready to use\"); Thread.Sleep(Timeout.Infinite); } private static void NetworkController_NetworkLinkConnectedChanged (NetworkController sender, NetworkLinkConnectedChangedEventArgs e) { // Raise event connect/disconnect } private static void NetworkController_NetworkAddressChanged (NetworkController sender, NetworkAddressChangedEventArgs e) { var ipProperties = sender.GetIPProperties(); var address = ipProperties.Address.GetAddressBytes(); linkReady = address[0] != 0; Debug.WriteLine(\"IP: \" + address[0] + \".\" + address[1] + \".\" + address[2] + \".\" + address[3]); } W5500 Tip Needed NuGets: GHIElectronics.TinyCLR.Drivers.BasicNet, GHIElectronics.TinyCLR.Drivers.BasicNet.Sockets, GHIElectronics.TinyCLR.Drivers.WIZnet.W5500 The Wiznet W5500 chipset has a built-in TCP/IP stack making it ideal for SC13048, which doesn't have built-in networking support, but it works with SC20xxx as well. The example below does 'http GET' using ETH WIZ Click, on SC13048 Development board. var cs = GpioController.GetDefault().OpenPin(SC13048.GpioPin.PB2); var reset = GpioController.GetDefault().OpenPin(SC13048.GpioPin.PB15); var interrupt = GpioController.GetDefault().OpenPin(SC13048.GpioPin.PA0); var spiController = SpiController.FromName(SC13048.SpiBus.Spi1); var networkController = new W5500Controller(spiController, cs, reset, interrupt); var isReady = false; networkController.NetworkAddressChanged += (a, b) => { isReady = networkController.Address.GetAddressBytes()[0] != 0 && networkController.Address.GetAddressBytes()[1] != 0; }; NetworkInterfaceSettings networkSettings = new NetworkInterfaceSettings() { Address = new IPAddress(new byte[] { 192, 168, 0, 200 }), SubnetMask = new IPAddress(new byte[] { 255, 255, 255, 0 }), GatewayAddress = new IPAddress(new byte[] { 192, 168, 0, 1 }), DnsAddresses = new IPAddress[] { new IPAddress(new byte[] { 75, 75, 75, 75 }), new IPAddress(new byte[] { 75, 75, 75, 76 }) }, MacAddress = new byte[] { your mac }, DhcpEnable = false, DynamicDnsEnable = false, }; networkController.SetInterfaceSettings(networkSettings); networkController.Enable(); while (isReady == false) ; // wait for valid IP address. var dns = new Dns(networkController); var host = dns.GetHostEntry(\"www.example.com\"); var ep = new IPEndPoint(host.AddressList[0], 80); // Streaming socket var socket = new Socket(networkController, AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); socket.Connect(ep); var content = \"GET / HTTP/1.1\\r\\nHost: www.example.com\\r\\nConnection: close\\r\\n\\r\\n\"; socket.Send(Encoding.UTF8.GetBytes(content)); var received = socket.Receive(SocketFlags.None); if (received.Length > 0) { var recvdContent = new string(Encoding.UTF8.GetChars(received)); Debug.WriteLine(\"Received : \\r\\n\" + recvdContent); } Event Handlers NetworkController provides two events: private static void NetworkController_NetworkLinkConnectedChanged (NetworkController sender, NetworkLinkConnectedChangedEventArgs e) { // Raise event connect/disconnect } private static void NetworkController_NetworkAddressChanged (NetworkController sender, NetworkAddressChangedEventArgs e) { var ipProperties = sender.GetIPProperties(); var address = ipProperties.Address.GetAddressBytes(); var subnet = ipProperties.SubnetMask.GetAddressBytes(); var gw = ipProperties.GatewayAddress.GetAddressBytes(); var interfaceProperties = sender.GetInterfaceProperties(); for (int i = 0; i < dnsCount; i++){ var dns = ipProperties.DnsAddresses[i].GetAddressBytes(); } }"
  },
  "software/tinyclr/tutorials/external-memory.html": {
    "href": "software/tinyclr/tutorials/external-memory.html",
    "title": "External Memory",
    "keywords": "External Memory External memory is typically not secure as it can be probed by hackers. However, external memory provides the large amount of storage required by some applications. External RAM Devices with external RAM have the option of utilizing this memory as Unmanaged Heap. Unmanaged heap is great for storing large amounts of data, but it is not considered secure. Bitmaps and UnmanagedBuffer are automatically stored in unmanaged heap. Developers also have the option of extending core managed heap into unsecure external memory, in which case, it removes unmanaged heap space. This feature is a trade off between security and convenience -- it provides a large amount of managed heap space, but data is stored outside of the microcontroller chip where it's less secure. Please see the IP Protection page for more information. TinyCLR Config can be used to extend the heap into external SDRAM, as well as the following method, you'll also have to follow with software reset method: GHIElectronics.TinyCLR.Native.Memory.ExtendHeap() GHIElectronics.TinyCLR.Native.Power.Reset(); External Flash An optional 16MB QSPI external flash can be used to increase the available flash memory. In fact, most SITCore SoMs/boards already include this 16MB external flash. The top 6MB of the optional external flash can be used to extend the deployment region, which holds the application and its resources. This is done by using TinyCLR Config or through code: GHIElectronics.TinyCLR.Native.Flash.EnableExtendDeployment() GHIElectronics.TinyCLR.Native.Power.Reset(); Since external memory chips can be probed, TinyCLR supports Secure Assemblies. See the IP Protection page for more information. Tip TinyCLR Config can be used to display the internal Deployment Map. The entire 16MB of flash, or 10MB when deployment is extended, can be used directly by reading/writing raw sectors or using Tiny File System."
  },
  "software/tinyclr/tutorials/file-system.html": {
    "href": "software/tinyclr/tutorials/file-system.html",
    "title": "File System",
    "keywords": "File System The file system library is a subset of the full .NET file system support. Most examples should work with only minor changes. The internal drivers fully support FAT16 or FAT32 file systems, with no limitations beyond the FAT file system itself! Note The USB drive must have an MBR record, not a GPT table. FAT16 and FAT32 file systems are supported. Fat File System USB Mass Storage This allows file access on USB devices with MSC class, such as USB memory sticks. See the USB page. SD Card SD and MMC cards are fully supported as detailed on the SD tutorial page. Additionally, SPI SD drivers are also supported through the ManagedFileSystem software utility drivers. The example below requires the GHIElectronics.TinyCLR.IO and GHIElectronics.TinyCLR.Devices.Storage libraries and a device with an SD card. var sd = StorageController.FromName(SC20100.StorageController.SdCard); var drive = FileSystem.Mount(sd.Hdc); //Show a list of files in the root directory var directory = new DirectoryInfo(drive.Name); var files = directory.GetFiles(); foreach (var f in files) { System.Diagnostics.Debug.WriteLine(f.Name); } //Create a text file and save it to the SD card. var file = new FileStream($@\"{drive.Name}Test.txt\", FileMode.OpenOrCreate); var bytes = Encoding.UTF8.GetBytes(DateTime.UtcNow.ToString() + Environment.NewLine); file.Write(bytes, 0, bytes.Length); file.Flush(); FileSystem.Flush(sd.Hdc); Low-level Access You can access the raw underlying data of the storage provider by using the Provider property of the controller. Be careful when using this interface, however, as it bypasses any file system present and writes directly to the device. This is useful for implementing your own or otherwise unsupported file systems. var controller = StorageController.FromName (SC20100.StorageController.SdCard); controller.Provider.Open(); // open controller.Provider.Read(address, buffer, 0, buffer.Length, TimeSpan.FromSeconds(5)); controller.Provider.Close(); // close Tiny File System (TFS) Tiny File System(TFS) can be used to access any memory storage as a file system. All that is needed is a basic driver to Read, Write, and Erase these storages. Below is an example that uses the external flash through TFS. Note This example requires the GHIElectronics.TinyCLR.IO.TinyFileSystem const int CLUSTER_SIZE = 1024; var tfs = new TinyFileSystem(new QspiMemory(), CLUSTER_SIZE); if (!tfs.CheckIfFormatted()) { //Do Format if necessary tfs.Format(); } else { // Mount tiny file system tfs.Mount(); } //Open to write using (var fsWrite = tfs.Create(\"settings.dat\")) { using (var wr = new StreamWriter(fsWrite)) { wr.WriteLine(\"This is TFS test\"); wr.Flush(); fsWrite.Flush(); } } //Open to read using (var fsRead = tfs.Open(\"settings.dat\", FileMode.Open)) { using (var rdr = new StreamReader(fsRead)) { System.String line; while ((line = rdr.ReadLine()) != null) { Debug.WriteLine(line); } } } Below is a basic driver implementation utilizing QSPI external flash. It automatically sets the size appropriately depending on whether the deployment is extended or not, as explained on the External Flash page. It however gives you the option to fix the size to 2MB, as the remaining 8MB can optionally be used by InField Update. public sealed class QspiMemory : IStorageControllerProvider { public StorageDescriptor Descriptor => this.descriptor; const int SectorSize = 4 * 1024; private StorageDescriptor descriptor = new StorageDescriptor() { CanReadDirect = false, CanWriteDirect = false, CanExecuteDirect = false, EraseBeforeWrite = true, Removable = true, RegionsContiguous = true, RegionsEqualSized = true, RegionAddresses = new long[] { 0 }, RegionSizes = new int[] { SectorSize }, RegionCount = (2 * 1024 * 1024) / (SectorSize) }; private IStorageControllerProvider qspiDrive; public QspiMemory() : this(2 * 1024 * 1024) { } public QspiMemory(uint size) { var maxSize = Flash.IsEnabledExtendDeployment ? (10 * 1024 * 1024) : (16 * 1024 * 1024); if (size > maxSize) throw new ArgumentOutOfRangeException(\"size too large.\"); if (size <= SectorSize) throw new ArgumentOutOfRangeException(\"size too small.\"); if (size != descriptor.RegionCount * SectorSize) { descriptor.RegionCount = (int)(size / SectorSize); } qspiDrive = StorageController.FromName(SC20260.StorageController.QuadSpi).Provider; this.Open(); } public void Open() { qspiDrive.Open(); } public void Close() { qspiDrive.Close(); } public void Dispose() { qspiDrive.Dispose(); } public int Erase(long address, int count, TimeSpan timeout) { return qspiDrive.Erase(address, count, timeout); } public bool IsErased(long address, int count) { return qspiDrive.IsErased(address, count); } public int Read(long address, int count, byte[] buffer, int offset, TimeSpan timeout) { return qspiDrive.Read(address, count, buffer, offset, timeout); } public int Write(long address, int count, byte[] buffer, int offset, TimeSpan timeout) { return qspiDrive.Write(address, count, buffer, offset, timeout); } public void EraseAll(TimeSpan timeout) { for (var sector = 0; sector < this.Descriptor.RegionCount; sector++) { qspiDrive.Erase(sector * this.Descriptor.RegionSizes[0], this.Descriptor.RegionSizes[0], timeout); } } }"
  },
  "software/tinyclr/tutorials/font-support.html": {
    "href": "software/tinyclr/tutorials/font-support.html",
    "title": "Font Support",
    "keywords": "Font Support Fonts can be included in your TinyCLR application by adding them as a resource. Any TrueType font can be used after being converted to the .tcfnt format with the FontConverter tool. The Font Converter tool (found under downloads is a command line utility which does just that. Make sure to use this tool for any fonts you need, using old fonts from NETMF will not work. var screen = Graphics.FromHdc(displayController.Hdc); var font = Resource.GetFont(Resource.FontResources.NinaB); var greenPen = new Pen(Color.Green); screen.DrawString(\"Hello World!\", font, greenPen.Brush, 10, 100); screen.Flush(); Font Conversion To convert a font you must first make a .fntdef file which is a text file describing the font to convert as well as a number of other parameters. This file contains one option on each line. A minimal .fntdef file may look like this to have the standard ASCII characters. SelectFont \"FN:Arial,WE:400,HE:12,IT:0\" ImportRange 32 126 Tip This third-party tool can be handy for generating compatible fonts. Font Definition The .fntdef file options are as follows: Note The order of statements in the .fntdef file matters. For example, properties such as AntiAlias must be specified before the InputRange property. AddFontToProcess path Path is the path to the TrueType font you want to convert. If the path contains spaces, you must enclose it in quotes and escape any backslashes. Example: AddFontToProcess C:\\Windows\\Fonts\\Arial.ttf SelectFont \"selection string\" \"Selection string\" is a quoted string containing comma delimited fields indicating the characteristics of the font to convert. ConvertFont searches the TrueType fonts installed on your computer, as well as any fonts in the AddFontToProcess argument, for a font matching the characteristics in the selection string argument. The first match is converted. Using spaces around the commas or colons in selection string will result in errors. Field types are as follows: HE: Height in logical units. Use zero for default height, a positive number for cell height and a negative number for character height. WI: Width. Average width of characters in logical units. Set to zero for closest match based on aspect ratio. ES: Escapement angle in tenths of a degree. Negative numbers rotate clockwise, positive numbers rotate counterclockwise. WE: Weight of font in range of 0 to 1000. 400 is normal, 700 is bold. Set to zero for default weight. IT: Italic if set to 1 (IT:1). FN: Face name. Name of the typeface. FullName: Full name. The unique name of the font. For example: \"Monotype:Arial Regular (Microsoft).\" For example, SelectFont \"HE:12,WE:400,FN:Arial\" will look for a regular-weight font of height 12 with a face name of \"Arial.\" AdjustAscent adjustment Adjustment is integer number of EM units to adjust ascent. Can be positive or negative. Can only be used once per .fntdef file. If it is used more than once, only the last occurrence will be used. AdjustDescent adjustment Adjustment is integer number of EM units to adjust descent. Can be positive or negative. Can only be used once per .fntdef file. If it is used more than once, only the last occurrence will be used. AdjustExternalLeading adjustment Adjustment is integer number of EM units to adjust the external leading. Can be positive or negative. Can only be used once per .fntdef file. If it is used more than once, only the last occurrence will be used. AdjustInternalLeading adjustment Adjustment is integer number of EM units to adjust the internal leading. Can be positive or negative. Can only be used once per .fntdef file. If it is used more than once, only the last occurrence will be used. AdjustLeftMargin adjustment Adjustment is integer number of device units to add to the left margin. Can be positive or negative. Applies to the characters specified by the ImportRange statement that most closely follows this option. AdjustRightMargin adjustment Adjustment is integer number of EM units to add to the right margin. Can be positive or negative. Applies to the characters specified by the ImportRange statement that most closely follows this statement. AntiAlias level Level can be 1, 2, 4, or 8. Font bitmaps will contain 2, 5, 17, or 65 levels of gray respectively. Must come after the SelectFont statement specifying the font to which this statement applies. May be applied to a range of characters defined by the ImportRange option. ImportRange start end Start and end are Unicode character codes indicating the beginning and end of the range of characters to convert (inclusive). Can be applied multiple times to convert a non-contiguous range of characters. Must come after the SelectFont statement specifying the font to which this statement applies. Both arguments are required. To specify a single character, make start and end the same number. ImportRangeAndMap start end offset Specifies range of characters to convert starting with Unicode character start + offset and ending with character end + offset, inclusive. Can be applied multiple times to convert a non-contiguous range of characters. Must come after the SelectFont statement specifying the font to which this statement applies. NoDefaultCharacter Specifies that no default character will be substituted for characters not converted. Must come after the SelectFont statement specifying the font to which this statement applies. OffsetX adjustment Adjustment is an integer describing the number of EM units to shift character position left or right. Positive numbers shift to the left, and negative numbers shift to the right. Applies to characters specified by any ImportRange, ImportRangeAndMap, or SetAsDefaultCharacter statements that follow it in the .fntdef file. Subsequent OffsetX statements supersede all previous OffxetX statements in the same .fntdef file. OffsetY adjustment Adjustment is an integer describing the number of EM units to shift character position up or down. Positive numbers shift down, and negative numbers shift up. Applies to characters specified by any ImportRange, ImportRangeAndMap, or SetAsDefaultCharacter statements that follow it in the .fntdef file. Subsequent OffsetX statements supersede all previous OffxetX statements in the same .fntdef file. SetAsDefaultcharacter charcode \"Charcode is the Unicode character code for the default character to substitute for characters that weren't converted. SetDefaultcharacter Indicates that the default character of the currently selected TrueType font will be substituted for characters that weren't converted. Verbosity level Note Not currently supported, set to 0. Level can be 0, 1, or 2. Level 0 displays no details, level 1 displays font properties, and level 2 displays font and character properties and a diagram of each character. # Comments You can add comments to your .fntdef file by starting the comment line with the \"#\" character. Syntax for running FontConverter is GHIElectronics.TinyCLR.FontConverter.exe input-font output-font. For example GHIElectronics.TinyCLR.FontConverter.exe Arial.fntdef Arial.tcfnt. Resources Fonts can be added to your application as a resource. Click here for more information."
  },
  "software/tinyclr/tutorials/google-cloud.html": {
    "href": "software/tinyclr/tutorials/google-cloud.html",
    "title": "Google Cloud",
    "keywords": "Google Cloud This example shows how to communicate with Google Cloud Platform using MQTT. You'll also need to set up a Network Interface connection on the device such as WiFi to Connect to Google Cloud in your program. Tip Needed NuGets: GHIElectronics.TinyCLR.Networking.Mqtt Add using statement: using System.Security.Cryptography.X509Certificates; string iotHubName = \"mqtt.googleapis.com\"; int iotPort = 8883; var projectId = \"Your ProjectID\"; var cloudRegion = \"Your Cloud Region\"; var registryId = \"Your Registry\"; var deviceId = \"Your DeviceID\"; var gatewayId = \"Your GatewayID\"; var clientId = $\"projects/{projectId}\" + $\"/locations/{cloudRegion}\" + $\"/registries/{registryId}\" + $\"/devices/{gatewayId}\"; var message = \"My message\"; var caCertSource = Resources.GetBytes(Resources.BinaryResources.\"GOOGLE Root CERT\"); X509Certificate CaCert = new X509Certificate(caCertSource); var clientSetting = new MqttClientSetting { BrokerName = iotHubName, BrokerPort = iotPort, CaCertificate = CaCert, ClientCertificate = null, SslProtocol = System.Security.Authentication.SslProtocols.Tls12 }; var iotClient = new Mqtt(clientSetting); var jwt = \"Your JSON Web Token\"; iotClient.PublishReceivedChanged += (p1, p2, p3, p4, p5, p6) => { Debug.WriteLine(\"Received message: \" + Encoding.UTF8.GetString(p3)); }; iotClient.PublishedChanged += (a, b, c) => { Debug.WriteLine(\"Published Changed.\"); }; iotClient.SubscribedChanged += (a, b) => { Debug.WriteLine(\"Subscribed Changed.\"); }; iotClient.ConnectedChanged += (a) => { Debug.WriteLine(\"Connected Changed.\"); }; iotClient.UnsubscribedChanged += (a, b) => { Debug.WriteLine(\"Unsubscribed Changed.\"); }; var connectSetting = new MqttConnectionSetting { ClientId = clientId, UserName = \"unused\", Password = jwt }; string topic = $\"/devices/{deviceId}/events\"; var returnCode = iotClient.Connect(connectSetting); if (returnCode == ConnectReturnCode.ConnectionAccepted) { Gcp_SetupMqttTopics(iotClient, gatewayId); Gcp_AttachDevice(iotClient, deviceId, \"{}\"); while (true) { iotClient.Publish(topic , UTF8Encoding.UTF8.GetBytes(\"\" + message + cnt) , QoSLevel.LeastOnce , false, 1); cnt++; Thread.Sleep(5000); } } Thread.Sleep(Timeout.Infinite); static void Gcp_SetupMqttTopics(Mqtt client, string deviceId) { // The configuration topic is used for acknowledged changes. string mqttConfigTopic = $\"/devices/{deviceId}/config\"; // The commands topic is used for frequent, transitory, updates. string mqttCommandTopic = $\"/devices/{deviceId}/commands/#\"; string mqttErrorTopic = $\"/devices/{deviceId}/errors\"; string[] topics = new string[] { mqttConfigTopic, mqttCommandTopic, mqttErrorTopic }; QoSLevel[] qosLevels = new QoSLevel[] { QoSLevel.LeastOnce, // config topic, Qos *1* QoSLevel.MostOnce, // command topic, Qos 0 QoSLevel.MostOnce // error topic, Qos 0 }; client.Subscribe(topics, qosLevels, 1); } static void Gcp_AttachDevice(Mqtt client, string deviceId, string auth) { var attachTopic = $\"/devices/{deviceId}/attach\"; var BinaryData = Encoding.UTF8.GetBytes(auth); client.Publish(attachTopic, BinaryData, QoSLevel.LeastOnce, true, 1); Debug.WriteLine(\"Waiting for device to attach about 5 seconds\"); Thread.Sleep(5); } This example requires projectId, cloudRegion, registryId, gatewayId, and deviceId, which will be available when you register a Google Cloud account. a client certificate and private key are also provided when you register your account. Let's create a new project. Click on 'Create Project' on the Manage resources dashboard. Next we'll need to create a meaningful name, for this project will call it SITCoreIoT. In the search box type 'IoT Core' and then select it. Next, we need to 'ENABLE' the Google Cloud IoT API. Next we'll need to create a Registry for our project. Click on 'CREATE REGISTRY' We need to create a 'Registry ID', select a cloud 'Region', and a create a 'Topic'. Finally, we need to click on the 'SHOW ADVANCED OPTIONS' Tab to finish the creation For this exercise we only need MQTT, and we've selected 'Debug' under Cloud Logging. This isn't necessary but will allow us to see device activity in the log and may be useful for more complex programs. Finally click the 'CREATE' button. Once created we're taken to the Registry details dashboard. We need to create our device by clicking on 'Devices' from the left menu. From the Device dashboard, click on 'CREATE A DEVICE' Before we continue, we'll need to generate both a Private and Public key that we can attach to our Device. This can be done with a program like OpenSSL (secure), or we can use a third-party site to generate one for us for testing (unsecure). For this exercise, we'll use a third-party site like: CryptoTool.net We need to select a Key Length of 2048, and then click 'Generate key pair'. Next, we need to copy the Public Key to the clipboard and use it in a moment. Keep the window open, we'll need to use the Private key later. Now let's go back to the 'Create a device' dashboard in Google. We need to create a name for our Device, this will be the 'Device ID'. Before we click 'CREATE' we need to click on the 'COMMUNICATION, CLOUD LOGGING, AUTENTICATION drop down. Here we'll paste the Public key we generated earlier. Make sure the Public key format is set to RS256. Then click on 'CREATE' button. Next we'll create a Gateway. From inside the Device details dashboard select 'Gateways' from the menu on the left. Click on the 'CREATE A GATEWAY' Next will name our Gateway, this will be the 'Gateway ID' that we will add to our code. Before we click 'CREATE', click on the 'COMMUNICATION, CLOUD LOGGING, AUTHENTICATION tab. We have to add the same Public key we pasted earlier here too. Make sure that the key format is also set to RS256. Then click on 'CREATE' button. Finally, lets bind our Device to the Gateway. Click on 'BOUND DEVICES' tab and then click on the 'BIND DEVICES' button. Select our Device from the list and click 'BIND' We have the data we need now let's plug in all the IDs we created into our code var projectId = \"sitcoreiot\"; var cloudRegion = \"us-central1\"; var registryId = \"SITCore-IoT-Registry\"; var deviceId = \"MySITCore\"; var gatewayId = \"SITCoreGatewayIoT\"; We need to add a Google Root CA Certificate to our resources and add it to this line of our code. var caCertSource = Resources.GetBytes(Resources.BinaryResources.\"GOOGLE Root CERT\"); Lastly when connect to google cloud, you also need a JWT (JSON Web Token) to be used as password if using MQTT. For an easy way to generate a JWT visit https://jwt.io/. However, if you are concerned about sharing your private key with a third party site, there are a multitude of other options. Warning By using https://jwt.io/, your private key is shared with a third-party. This should be used only for testing purpose.\" We must change the 'PAYLOAD DATA' to match the image above. There are two fields iat (issue at), and exp (expire), they contain time in Unix Timestamp format. You can convert them online at https://www.epochconverter.com/ { \"iat\": 1602616824, \"aud\": \"sitcoreiot\", \"exp\": 1602616858 } Finally copy your Endoded Token into this line of code in your program: var jwt = \"Paste your JWT here\"; Note The google cloud connection accepts a maximum expire time of 24 hours, meaning the timespan between iat and exp must be less than 24 hours. To receive a message from Google Cloud click on the 'SEND COMMAND' under the Gateway dashboard. Enter your message and click 'SEND' The device will receive your message and display it in the Output window of Visual Studio. To view the messages being sent from the device to the cloud we need to add a subscription to 'MyTopic'. To do this we need to go to the Registry dashboard and click on the topic we created called 'MyTopic' Once on the 'Pub/Sub' dashboard, select 'Subscriptions' from the side menu. Next, click on 'CREATE SUBSCRIPTION' Create a name for in the 'Subscription ID' box and select topic we created earlier. There may be additional setting on this dashboard you can use, but for this tutorial we only need to set these two items. Click the 'CREATE' button at the bottom. Deploy the program to your device. Once connected, inside the 'Subscription details' dashboard, click on 'VIEW MESSAGES', inside the 'Messages' Pop-up click on the 'PULL' button. This will display the latest messages being sent from the device. The tutorial program sends a new message every 5 seconds and then increments the count by one. We can also continue to send messages to the device from the 'Gateway' dashboard as we did earlier."
  },
  "software/tinyclr/tutorials/gpio.html": {
    "href": "software/tinyclr/tutorials/gpio.html",
    "title": "General Purpose Input Output (GPIO)",
    "keywords": "General Purpose Input Output (GPIO) Microcontrollers include pins that can be controlled through software. They can be logical inputs or outputs, hence the name \"general purpose input/output\". Tip GPIO is found in the GHIElectronics.TinyCLR.Devices.Gpio NuGet package and pin definitions are found in the GHIElectronics.TinyCLR.Pins package. Digital Outputs A digital output pin can be set to either high or low. High means that there is approx. 3.3V on the output pin. When the pin is set to low, it's voltage will be very close to zero. Warning Never connect two output pins together. If they are connected and one is high and the other is low, the entire processor can be damaged. Tip Digital pins on microcontrollers are weak. They can only be used to control small LEDs or drive transistors. Those transistors can, in turn, control devices with high power needs like a motor. var led = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PH6); led.SetDriveMode(GpioPinDriveMode.Output); while (true) { led.Write(GpioPinValue.High); Thread.Sleep(100); led.Write(GpioPinValue.Low); Thread.Sleep(100); } Digital Inputs Digital inputs sense the state of a pin based on its voltage. Minimum voltage on most pins is 0 volts; a negative voltage may damage the pin or the processor. Most processors run on 3.3V, the highest voltage a pin should see is 3.3V. However, some processors that are powered by 3.3V are 5V tolerant -- they can withstand up to 5V on their inputs. SITCore is 5V tolerant. Warning 5V tolerant doesn't mean the processor can be powered by 5V, only that the input pins can tolerate 5V. Unconnected input pins are called \"floating.\" A resistor can be added to pull the pin high or low. Modern processors include internal pull-up and pull-down resistors that are controlled by software. The code sample below uses an internal pull-up resistor to set the button high. When the button is pressed the GpioPinValue goes low. var gpio = GpioController.GetDefault(); var button = gpio.OpenPin(SC20260.GpioPin.PD7); button.SetDriveMode(GpioPinDriveMode.InputPullUp); while (true) { if (button.Read() == GpioPinValue.Low) { //Button is pressed. } Thread.Sleep(10); //Always give the system time to think! } Digital Input Events Using events to check an input instead of polling the input (using a loop) is often preferred. The following code demonstrates a GPIO pin event (interrupt) on the SCM20260D Dev board. You will see a reference to a \"falling edge\" in the following code. A falling edge occurs when the state of a pin goes from high to low. A rising edge is just the opposite -- it occurs when a pin goes from low to high. var gpio = GpioController.GetDefault(); var button = gpio.OpenPin(SC20260.GpioPin.PD7); button.SetDriveMode(GpioPinDriveMode.InputPullUp); button.ValueChangedEdge = GpioPinEdge.FallingEdge | GpioPinEdge.RisingEdge; button.ValueChanged += Button_ValueChanged; //Do other tasks here ... Thread.Sleep(Timeout.Infinite); void Button_ValueChanged(GpioPin sender, GpioPinValueChangedEventArgs e) { if (e.Edge == GpioPinEdge.FallingEdge) { // Pin went low } else { // Pin went high } } When a mechanical button is pressed it generates multiple edges that are caused by the contact physically bouncing. The built in debounce feature filters out any edges coming in faster than a specific time, which is set to 20ms be default. The debounce value can be changed using software. pin.DebounceTimeout = TimeSpan.FromMilliseconds(10); SITCore Interrupt limitation Digital input events rely on internal GPIO interrupts to work. On SITCore, these interrupts are only available on 16 pins at any given time, the pin number must be unique, over all of the available ports. For example: PA1 and PB1 cannot both be used as interrupts at the same time. However, PA1 and PB2, or even PA1 and PA2, can be used simultaneously. Consider other internal system functions that need interrupts, such as WiFi. Those also reserve one of the 16 available interrupts. LowLevel Access For advanced users only Warning This advanced feature does not check what alternate functions are valid. This advanced feature does not reserve the destination pin. This example will move MOSI2 pin from PB2 to PC7, assuming AF6 (AF6 mean Alternate Function 6) // start by creating SPI2 to initialize the feature on PB2 // now transfer... var settings = new Settings { mode = PortMode.AlternateFunction, speed = OutputSpeed.VeryHigh, driveDirection = PullDirection.None, alternate = AlternateFunction.AF6, type = OutputType.PushPull }; LowLevelController.TransferFeature(SC20100.GpioPin.PB2, SC20100.GpioPin.PC7, settings); // SC20100.GpioPin.PB2: Becomes default state (input) // SC20100.GpioPin.PC7: Becomes AF6 This advanced feature needs to be called right before Enable() (or Open() if Uart, Start() if PWM etc... - depends on peripherals) for working properly."
  },
  "software/tinyclr/tutorials/graphics.html": {
    "href": "software/tinyclr/tutorials/graphics.html",
    "title": "Graphics",
    "keywords": "Graphics The GHIElectronics.TinyCLR.Drawing NuGet package includes the backbone for all graphics needs. It has support for shapes, fonts and bitmaps. Shape examples are Graphics.FillEllipse, Graphics.DrawLine and Graphics.DrawRectangle. These methods need Pen and Brush that are also part of Graphics. Besides the basic methods above, there are some additional useful methods found inside the Graphics library. Method Description TileImage Used to tile the image over a any area on the screen. DrawTextInRect Confines text to a specific rectangle area of the screen. Parameters can be set to justify or word wrap the text inside the rectangle's area. SetClippingRectangle Creates a rectangle area on the screen where only the area within that rectangle is drawn. MakeTransparent Used to select a color within an image that appears transparent. Alpha needs to be set to 0 (0x00) Scale9Image Used to scale the size of an image. You can also stretch specific areas within the image itself, opacity can also be controlled. MeasureString Used to measure a string size in pixels, when using a specific font. RotateImage Used to rotate an image based on arguments passed. BasicGraphics BasicGraphics driver is a simpler alternative that runs on all devices, including small devices without native display support. Learn more about BasicGraphics here. Native Displays Native display support in TinyCLR OS is handled automatically using the microcontroller's DMA to transfer data in parallel to the display without slowing down your application. The following example runs on the SCM20260D Dev Board with either the 4.3\" or 7\" display. You will need to add a font and a small JPG image as resources to run the code as is. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Display, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.I2c, GHIElectronics.TinyCLR.Devices.Spi, GHIElectronics.TinyCLR.Drawing, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Pins. using System.Drawing; using System.Threading; using GHIElectronics.TinyCLR.Devices.Display; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Pins; GpioPin backlight = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PA15); backlight.SetDriveMode(GpioPinDriveMode.Output); backlight.Write(GpioPinValue.High); var displayController = DisplayController.GetDefault(); // Enter the proper display configurations displayController.SetConfiguration(new ParallelDisplayControllerSettings { Width = 480, Height = 272, DataFormat = DisplayDataFormat.Rgb565, Orientation = DisplayOrientation.Degrees0, //Rotate display. PixelClockRate = 10000000, PixelPolarity = false, DataEnablePolarity = false, DataEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, }); displayController.Enable(); //This line turns on the display I/O and starts // refreshing the display. Native displays are // continually refreshed automatically after this // command is executed. var screen = Graphics.FromHdc(displayController.Hdc); var image = Resources.GetBitmap(Resources.BitmapResources.smallJpegBackground); var font = Resources.GetFont(Resources.FontResources.small); screen.Clear(); screen.FillEllipse(new SolidBrush(System.Drawing.Color.FromArgb (255, 255, 0, 0)), 0, 0, 240, 136); screen.FillEllipse(new SolidBrush(System.Drawing.Color.FromArgb (255, 0, 0, 255)), 240, 0, 240, 136); screen.FillEllipse(new SolidBrush(System.Drawing.Color.FromArgb (128, 0, 255, 0)), 120, 0, 240, 136); screen.DrawImage(image, 216, 122); screen.DrawRectangle(new Pen(Color.Yellow), 10, 150, 140, 100); screen.DrawEllipse(new Pen(Color.Purple), 170, 150, 140, 100); screen.FillRectangle(new SolidBrush(Color.Teal), 330, 150, 140, 100); screen.DrawLine(new Pen(Color.White), 10, 271, 470, 271); screen.SetPixel(240, 200, Color.White); screen.DrawString(\"Hello world!\", font, new SolidBrush(Color.Blue), 210, 255); screen.Flush(); Same example but with 7 inch display, replace the display configuration code with the following code: displayController.SetConfiguration(new ParallelDisplayControllerSettings { Width = 800, Height = 480, DataFormat = DisplayDataFormat.Rgb565, Orientation = DisplayOrientation.Degrees0, //Rotate display. PixelClockRate = 24000000, PixelPolarity = false, DataEnablePolarity = false, DataEnableIsFixed = false, HorizontalFrontPorch = 16, HorizontalBackPorch = 46, HorizontalSyncPulseWidth = 1, HorizontalSyncPolarity = false, VerticalFrontPorch = 7, VerticalBackPorch = 23, VerticalSyncPulseWidth = 1, VerticalSyncPolarity = false, }); Virtual Displays Displays can be virtual, meaning the system handles the drawing in RAM and when Flush is called an event is fired with the graphics data that needs to be transferred to the display. This for example can be an SPI display or over-the-network display. The following sample code runs on our SC20100S Dev Board with its SPI-based display. You will need to add a font and a small JPG image as resources to run the code as is. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Display, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.I2c, GHIElectronics.TinyCLR.Devices.Spi, GHIElectronics.TinyCLR.Drawing, GHIElectronics.TinyCLR.Drivers.Sitronix.ST7735, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Pins. using System; using System.Drawing; using System.Threading; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Devices.Spi; using GHIElectronics.TinyCLR.Drivers.Sitronix.ST7735; using GHIElectronics.TinyCLR.Pins; namespace GraphicsSample { class Program { private static ST7735Controller st7735; private const int SCREEN_WIDTH = 160; private const int SCREEN_HEIGHT = 128; private static void Main() { var spi = SpiController.FromName(SC20100.SpiBus.Spi4); var gpio = GpioController.GetDefault(); st7735 = new ST7735Controller( spi.GetDevice(ST7735Controller.GetConnectionSettings (SpiChipSelectType.Gpio, gpio.OpenPin(SC20100.GpioPin.PD10))), //CS pin. gpio.OpenPin(SC20100.GpioPin.PC4), //RS pin. gpio.OpenPin(SC20100.GpioPin.PE15) //RESET pin. ); var backlight = gpio.OpenPin(SC20100.GpioPin.PA15); backlight.SetDriveMode(GpioPinDriveMode.Output); backlight.Write(GpioPinValue.High); st7735.SetDataAccessControl(true, true, false, false); //Rotate the screen. st7735.SetDrawWindow(0, 0, SCREEN_WIDTH-1, SCREEN_HEIGHT-1); st7735.Enable(); // Create flush event Graphics.OnFlushEvent += Graphics_OnFlushEvent; // Create bitmap buffer var screen = Graphics.FromImage(new Bitmap(SCREEN_WIDTH, SCREEN_HEIGHT)); var image = Resources.GetBitmap(Resources.BitmapResources. smallJpegBackground); var font = Resources.GetFont(Resources.FontResources.small); screen.Clear(); screen.FillEllipse(new SolidBrush(System.Drawing.Color.FromArgb (255, 255, 0, 0)), 0, 0, 80, 64); screen.FillEllipse(new SolidBrush(System.Drawing.Color.FromArgb (255, 0, 0, 255)), 80, 0, 80, 64); screen.FillEllipse(new SolidBrush(System.Drawing.Color.FromArgb (128, 0, 255, 0)), 40, 0, 80, 64); screen.DrawImage(image, 56, 50); screen.DrawRectangle(new Pen(Color.Yellow), 10, 80, 40, 25); screen.DrawEllipse(new Pen(Color.Purple), 60, 80, 40, 25); screen.FillRectangle(new SolidBrush(Color.Teal), 110, 80, 40, 25); screen.DrawLine(new Pen(Color.White), 10, 127, 150, 127); screen.SetPixel(80, 92, Color.White); screen.DrawString(\"Hello world!\", font, new SolidBrush(Color.Blue), 50, 110); screen.Flush(); Thread.Sleep(Timeout.Infinite); } private static void Graphics_OnFlushEvent(Graphics sender, byte[] data, int x, int y, int width, int height, int originalWidth) { st7735.DrawBuffer(data); } } } Helper Methods With parallel native displays the DisplayController.ActiveConfiguration can be used to read the configuration at any time. The Width and Height can be used to write code that automatically scales to the display's resolution. The following line of code draws a line from corner to corner, no matter the display resolution. screen.DrawLine(new Pen(Color.Red), 0, 0, displayController.ActiveConfiguration.Width - 1, displayController.ActiveConfiguration.Height - 1); Images TinyCLR OS supports BMP, GIF, and JPG file formats. See the Image Decoders page. Fonts Fonts are fully supported. They are covered here. Color Space Internally, TinyCLR uses 5:6:5 RGB 16BPP color space. There are helper methods to convert to other color spaces. See Encoding & Decoding for more details. 2D Matrix copy The built-in native 2D Matrix extract/copy is an simple, fast and efficient way to crop out an area of an image. GroupSize is the pixel size in bytes. TinyCLR OS is 16bpp graphics, that is GroupSize = 2. var groupSize = 2; var screenWidth = 160; var screenHeight = 128; var screen = new Bitmap(screenWidth, screenHeight); var imageNew = new byte[80 * 80 * 2]; var x = 5; var y = 5; var width = 80; var height = 80; Array.Copy2D(screen.GetBitmap(), imageNew, x, y, width, height, screenWidth, groupSize); VNC VNC (Virtual Network Computing) is a simple remote desktop that with available terminals supported by major operating systems. It is covered here."
  },
  "software/tinyclr/tutorials/hashing.html": {
    "href": "software/tinyclr/tutorials/hashing.html",
    "title": "Hashing",
    "keywords": "Hashing Tip Needed NuGets: GHIElectronics.TinyCLR.Core and GHIElectronics.TinyCLR.Cryptography MD5 TinyCLR OS supports MD5 hash function. The following commands will calculate the MD5 hash value of a byte array: var md5 = GHIElectronics.TinyCLR.Cryptography.MD5.Create(); var hashValue = md5.ComputeHash(data); //data is a byte array. CRC16 TinyCLR OS supports CRC16. ComputeHash(byte[] data, int offset, int count); Large amounts of data can be calculated in chunks and the hash is concatenated automatically. var crc16 = new Crc16(); var data = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 }; // Uses entire array to build the hash var crcVal1 = crc16.ComputeHash(data, 0, data.Length); // Uses chunks of the array to build the hash var crc1 = crc16.ComputeHash(data, 0, 3); var crc1_2 = crc16.ComputeHash(data, 3, 1, crc1); SHA1 SHA-1 is most often used to verify that a file has been unaltered. This is done by producing a checksum before the file has been transmitted, and then again once it reaches its destination. var data = new byte[] { 1, 2, 3, 4, 5 }; var sha1 = SHA1.Create(); var result = sha1.ComputeHash(data); HMAC-SHA1 HMACSHA1 is a type of keyed hash algorithm that is constructed from the SHA1 hash function and used as an HMAC, or hash-based message authentication code. var data = new byte[] { 1, 2, 3, 4, 5 }; var hmacSha1 = new HMACSHA1(); var result = hmacSha1.ComputeHash(data); HMAC-SHA256 HMAC-SHA256 offers better security than standard SHA256. It is also required for SAS(Shared Access Signature), needed for Microsoft Azure. var key = new byte[] { 1, 2, 3, 4, 5, 6 }; var hmacSha256 = new HMACSHA256(key); var message = \"this is for test\"; var result = hmacSha256.ComputeHash(System.Text.UTF8Encoding.UTF8.GetBytes(message));"
  },
  "software/tinyclr/tutorials/http-https.html": {
    "href": "software/tinyclr/tutorials/http-https.html",
    "title": "HTTP/HTTPS",
    "keywords": "HTTP/HTTPS Hyper Text Transport Protocol (HTTP) builds on top of the Core Networking Protocols to provide a standard way to work with web servers. HTTP Client The following code connects to bing.com and reads the robots.txt file. This code needs an active network connection to work properly. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Network and GHIElectronics.TinyCLR.Networking.Http. var url = \"http://www.bing.com/robots.txt\"; int read = 0, total = 0; byte[] result = new byte[512]; try { using (var req = HttpWebRequest.Create(url) as HttpWebRequest) { req.KeepAlive = false; req.ReadWriteTimeout = 2000; using (var res = req.GetResponse() as HttpWebResponse) { using (var stream = res.GetResponseStream()) { do { read = stream.Read(result, 0, result.Length); total += read; Debug.WriteLine(\"read : \" + read); Debug.WriteLine(\"total : \" + total); String page = \"\"; page = new String(System.Text.Encoding.UTF8.GetChars (result, 0, read)); Debug.WriteLine(\"Response : \" + page); } while (read != 0); } } } } catch { } HTTP Server TinyCLR OS provides an HttpListener class which can be used to make an HTTP Server. This code needs an active network connection on the same local network as your client application to work properly. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Network and GHIElectronics.TinyCLR.Networking.Http. Note To run this example the client and server devices must both connect to the same local network. //Create a listener. HttpListener listener = new HttpListener(\"http\", 80); listener.Start(); System.Diagnostics.Debug.WriteLine(\"Listening...\"); var clientRequestCount = 0; while (true) { //Note: The GetContext method blocks while waiting for a request. HttpListenerContext context = listener.GetContext(); //Obtain a response object. HttpListenerResponse response = context.Response; //Construct a response. var responseString = string.Format(\"<HTML><BODY> I am TinyCLR OS Server. \" + \"Client request count: {0}</BODY></HTML>\", ++clientRequestCount); byte[] buffer = System.Text.Encoding.UTF8.GetBytes(responseString); //Get a response stream and write the response to it. response.ContentLength64 = buffer.Length; var output = response.OutputStream; output.Write(buffer, 0, buffer.Length); //You must close the output stream. output.Close(); } listener.Stop(); From your client device (smartphone, PC...), enter the server ip address into your web browser. In our case it's 192.168.1.6. The response is shown as below: HTTPS Secure connections work in a similar way through built in TLS support. HTTPS can also be used to send data to cloud computing services such as Azure."
  },
  "software/tinyclr/tutorials/i2c.html": {
    "href": "software/tinyclr/tutorials/i2c.html",
    "title": "I2C",
    "keywords": "I2C I2C (pronounced eye-squared-sea, or eye-two-sea) was originally developed by Phillips as a protocol for synchronous serial communication between integrated circuits. It has a master and one or more slaves sharing the same data bus. Instead of selecting the slaves by using a dedicated chip select signal like SPI, I2C uses an addressing mechanism to communicate with the selected device. This addressing method saves one I/O pin per slave. Before data is transferred, the master transmits the 7-bit address of the slave device it wants to communicate with. It also sends one bit indicating whether it wants to send data to the slave or receive data from the slave. When a slave sees its address on the bus, it will acknowledge its presence. At this point, the master can send or receive data. The master will start data transfers with a \"start condition\" before sending an address or data. The master ends the data transfer with a \"stop condition.\" The two wires for I2C communication are called the SDA and SCL lines. SDA stands for Serial Data, and SCL is Serial Clock. Note I2C bus speed can be either 100,000 bits/second (standard mode) or 400,000 bits/second (fast mode). I2C Master This is a partial demo showing the use of I2C in master mode. var settings = new I2cConnectionSettings(0x1C, 100_000); //The slave's address and the bus speed. var controller = I2cController.FromName(SC20100.I2cBus.I2c1); var device = controller.GetDevice(settings); device.Write(new byte[] { 1, 2 }); //Write something device.WriteRead(...); //This is good for reading register I2C Slave This is a partial demo showing the use of I2C in slave mode. var i2cControllers = I2cController.FromName(SC20260.I2cBus.I2c1); i2cControllers.ReadBufferSize = 1024; // Default 256 i2cControllers.WriteBufferSize = 1024; // Default 256 i2cControllers.ClearReadBuffer(); // Clear i2cControllers.ClearWriteBuffer(); // Clear var i2cSetting = new I2cConnectionSettings(0x48, I2cMode.Slave); // Enable slave mode i2cSetting.EnableClockStretching = true; var i2cDevice = i2cControllers.GetDevice(i2cSetting); i2cDevice.ErrorReceived += (sender, args) => Debug.WriteLine(\"Error received \" + args.Error); i2cDevice.FrameReceived += (sender, args) => { switch (args.Event) { case I2cTransaction.MasterWrite: Debug.WriteLine(\"Mastester is writing\"); break; case I2cTransaction.MasterRead: Debug.WriteLine(\"Mastester is reading\"); // Send data sender.Write(data); break; case I2cTransaction.MasterStop: Debug.WriteLine(\"Done a frame!\"); break; } }; Software I2C Users have the option to drive (bit bang) I2C bus in software over any of the available GPIOs. var sda = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PB9); var scl = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PB8); var controllers = I2cController.FromName(SC20260.I2cBus.Software, sda, scl); The internal pull-ups on the GPIO pins used by software I2C can be enabled. This is sufficient in most cases but adding 2.2K external is better. var controllers = I2cController.FromName(SC20260.I2cBus.Software, sda, scl, true); Tip Software generated buses are slower and use more resources, but can be used on any pins."
  },
  "software/tinyclr/tutorials/ifttt.html": {
    "href": "software/tinyclr/tutorials/ifttt.html",
    "title": "IFTTT",
    "keywords": "IFTTT If This Then That IOT Example. If This Then That (IFTTT) is a service allowing users to automate tasks by using simple conditional statements to create scripts or Applets (previously called \"recipes\"). Some similar platforms you might want to check out include Twilio, ThingSpeak, Yonomi, and Home Assistant. IFTTT can be used to respond to both events on websites and events from devices. Some uses include: Turn on the lights when you come home. Send a text message if rain is forecast. Turn on your lights if your Ring doorbell senses motion. Turn off your WiFi when you aren't home. Send you an e-mail when the New York Times publishes a new article in its science section. Automatically back up your smart phone photos to the cloud. Automate GitHub tasks. Get a text message whenever a Craigslist post matches your search. Notify you when the International Space Station passes overhead. Track when your company is mentioned on Twitter or Reddit. The possibilities are almost endless. Here we will take you step by step through the process using IFTTT to send an email notification of a button being pressed on a SITCore Dev Board. First we will set up an IFTTT account, then create and test the needed applets, and finally program the SITCore to trigger the IFTTT applet. Create an IFTTT Account Signing up for IFTTT is easy and they offer a free limited account, but it only allows up to 3 applets. Their paid service offers unlimited applet creation, queries, conditional logic and multiple actions -- just go to IFTTT.com and click on the Sign up button in the upper right hand corner of the screen. You can sign up using your Google or Facebook account, or use an e-mail address and password to sign in. IFTTT will usually offer to set up a sample connection right after you sign up -- just hit the \"X\" in the upper right corner to skip this step. Click on the Get more button under the message Start connecting your world to get started. Create the IFTTT Applets Two IFTTT applets will be needed for this project. An Email Applet will be send an email when a button is pushed. A Webhooks Applet will be used to receive an HTTP GET request from the FEZ when the temperature goes below ten degrees. Finally, an If This Then That Applet will call the Email Applet when triggered by the Webhooks Applet. Create the Webhooks Applet After signing up click on Create button in the top menu. You will then be presented with a screen that may seem to provide no option forward. Click on If This Add to get to the next step. Search for webhooks and click on that option. On the next screen click on the Connect button, then click on the Receive a web request box on the following screen. You will be prompted for an event name. Enter button_press and press the Create trigger button. Now click on +That. This will take us to the next step of choosing an action service -- in this case we will send an email. Create the Email Applet You should now be on the Choose action service screen. Search for email and then click on the email icon. Click on the Connect button on the next screen. You will be prompted for an email address to send notifications to. Type in the email address you would like to use and press the Send PIN button. Once you receive the email with your PIN, enter the PIN and hit the Connect button. Now click on the Send me an email box. You should now be on the Complete action fields screen. Click on the Create action button without making any changes. This will tell IFTTT to use the default method of constructing the subject line and body of the notification email. This will then take you back to the main If Then page. Click on continue Finally we're at the Review and finish screen. Click on the Finish button. Get Your Key Now we just have to get the key that is sent from the SITCore to trigger the event. You should now be at a screen with the text \"If Maker Event \"button_press\", then Send me an email at. . . Click on the Webhooks icon as shown below: Then click on the Documentation button near the upper right of the next screen. This will bring up a page with your unique key. Including this key in an HTTP GET or POST request to the IFTTT website will trigger your event. To test the IFTTT event, you can enter the following line into the address bar of your web brower (replace Your_Key_Here with your key) : https://maker.ifttt.com/trigger/button_press/with/key/Your_Key_Here Setup the SITCore To setup the FEZ we will have to connect a temperature sensor and then program the FEZ to send the proper HTTP GET request when the temperature drops below 10 degrees. Connect the Temperature Sensor For this demo we programmed the FEZ to act as a temperature alarm, but the same principles can be applied to any sensor that can be connected to the FEZ. You can also test the program without any sensor at all - just call SendSmsAlert() to simulate an alarm condition. For our temperature sensor we used an NPN transistor (2N2222A) and an 8.2K resistor as they were sitting conveniently on my desk. They were wired as shown below. Power for the temperature sensor is controlled by GPIO pin A1. 3V3 could have been used, but by using a GPIO pin the sensor can be turned off between readings to reduce the effects of self heating. The transistor is wired with its base and collector connected together so it is acting as a diode. When a constant current passes through this diode the voltage drop is a linear function with a temperature coefficient of about two millivolts per degree celsius. While a series resistor does not provide a true constant current source, it will be plenty accurate for this demo. Programming the FEZ Start a new C# project. You will need to add the following NuGet packages: GHIElectronics.TinyCLR.Core GHIElectronics.TinyCLR.Devices.Adc GHIElectronics.TinyCLR.Devices.Gpio GHIElectronics.TinyCLR.Devices.Spi GHIElectronics.TinyCLR.Native GHIElectronics.TinyCLR.Networking GHIElectronics.TinyCLR.Networking.Http GHIElectronics.TinyCLR.Pins Cut and paste the following code into the Program.cs window. You will have to change the WiFi SSID and password (line 50) and cut and paste your IFTTT key into line 53 near the end of the program (replace Paste_IFTTT_Key_Here). To copy your key, click on My Applets on the IFTTT website, then click on Services, click on the Webhooks box, and click on the Documentation button. using GHIElectronics.TinyCLR.Devices.Adc; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Devices.Spi; using GHIElectronics.TinyCLR.Drivers.STMicroelectronics.SPWF04Sx; using GHIElectronics.TinyCLR.Pins; using System; using System.Threading; class Program { private static void Main() { var gpioCont = GpioController.GetDefault(); var reset = gpioCont.OpenPin(FEZ.GpioPin.WiFiReset); var irq = gpioCont.OpenPin(FEZ.GpioPin.WiFiInterrupt); var wifiGpio8 = gpioCont.OpenPin(FEZCLR.GpioPin.PA0); var tempSensePower = gpioCont.OpenPin(FEZ.GpioPin.A1); var spiCont = SpiController.FromName(FEZ.SpiBus.WiFi); var spi = spiCont.GetDevice(SPWF04SxInterface.GetConnectionSettings(SpiChipSelectType.Gpio, FEZ.GpioPin.WiFiChipSelect)); var adcController = AdcController.GetDefault(); var tempSense = adcController.OpenChannel(FEZ.AdcChannel.A0); tempSensePower.SetDriveMode(GpioPinDriveMode.Output); tempSensePower.Write(GpioPinValue.Low); wifiGpio8.SetDriveMode(GpioPinDriveMode.InputPullDown); while (true) { tempSensePower.Write(GpioPinValue.High); var tempSenseValue = tempSense.ReadRatio(); tempSensePower.Write(GpioPinValue.Low); // ADC value was 0.589 volts at 21 degrees celsius. // Temperature coefficient is approx. 2mv/deg C. var temperature = 21 - (tempSenseValue * 3.3 - 0.589) / 0.002; temperature = Math.Round(temperature * 10) / 10; if (temperature < 10) { SendSmsAlert(temperature); Thread.Sleep(2 * 60 * 60 * 1000); // Don't alert more than once every 2 hrs. } Thread.Sleep(1000); } void SendSmsAlert(double temperature) { var wifi = new SPWF04SxInterface(spi, irq, reset); wifi.TurnOn(); Thread.Sleep(10000); wifi.JoinNetwork(\"SSID\", \"password\"); Thread.Sleep(10000); var triggerString = \"/trigger/FEZ_Temp_Alert/with/key/Paste_IFTTT_Key_Here?value1=\" + temperature.ToString(); wifi.SendHttpGet(\"maker.ifttt.com\", triggerString, 80, SPWF04SxConnectionSecurityType.None); wifi.TurnOff(); wifi.Dispose(); } } }"
  },
  "software/tinyclr/tutorials/image-decoders.html": {
    "href": "software/tinyclr/tutorials/image-decoders.html",
    "title": "Image Decoders",
    "keywords": "Image Decoders TinyCLR OS provides methods for converting JPG, BMP, and GIF files into bitmaps that can be used in your application. The image can be added to your project as a resource, or the image can be loaded from a byte array, like from and SD card. Tip BMP supports 256 colors and 24bit. GIF does not support animated images. var screen = Graphics.FromImage(new Bitmap(displayController.ActiveConfiguration.Width, displayController.ActiveConfiguration.Height)); //Image is in a resource file named \"jpegImageFile\": var imageBitmap = Resources.GetBitmap(Resources.BitmapResources.jpegImageFile); var b1 = new Bitmap(dataArray, BitmapImageType.Jpeg); var b2 = new Bitmap(dataArray, BitmapImageType.Gif); var b3 = new Bitmap(dataArray, BitmapImageType.Bmp); var imageX = 0; var imageY = 0; screen.DrawImage(imageBitmap, imageX, imageY); Saving Bitmaps Image class supports saving Bitmaps in a file stream format using the following code sample: var bm = new Bitmap(data, width, height); bm.Save(yourFilestream, System.Drawing.Imaging.ImageFormat.Bmp); Video playback Video playback can be achieved through Motion JPEG."
  },
  "software/tinyclr/tutorials/in-field-update.html": {
    "href": "software/tinyclr/tutorials/in-field-update.html",
    "title": "In-Field Update",
    "keywords": "In-Field Update TinyCLR OS allows for secure, encrypted, In-Field Update (IFU). Simply, the IFU feature buffers the new 'to-be-updated' application (and/or firmware) into RAM or FLASH. Once the entire application (or firmware) is buffered, the IFU will do a full security check before it updates the system. Having enough flash or RAM (typically external) is needed to buffer up the application and the firmware. The IFU service is started with var updater = new InFieldUpdate(QuadSpiController) when using external flash, or simply with var updater = new InFieldUpdate() when using RAM. It is important to note that the firmware application is buffered temporarily externally in its encrypted format, keeping security intact. All decrypted data is handled internally inside the chip, away from intruders! The IFU system supports data coming from any source. An update, for example, can come from a file, network, or even CAN bus! Loading an application requires a key, which is loaded using updater.LoadApplicationKey(appKey) and then the application can then be loaded in chunks using updater.LoadApplicationChunk(data, 0, count). And similarly, the firmware can be loaded through updater.LoadFirmwareChunk(data, 0, count). Internally, IFU keeps track of chunk count and size. The passed argument is for the user's provided data and not the internal chunk/data counters. In case of an error, the user can reset the internal chunk counters updater.ResetChunks(), which resets both application and firmware counters. Once the entire firmware or application chunks are loaded, they can be verified and a version number is returned back, or an exception is raised if the loaded firmware/application did not pass authentication. var firmwareVersion = updater.VerifyFirmware(); var applicationVersion = updater.VerifyApplication(); The system is now ready for flash and reset updater.FlashAndReset(). It is critical that the system is not reset or power is lost during reset. Depending on the application size, this can take a few seconds. A power loss will result in a nonfunctional device that needs to be manually update. Note When update uses external flash (QSPI) as temporary buffer, the block size must be 1K, 2K, 4K, 8K...etc. We recommend using 1K as the firmware and tca files are always multiple of 1K. Memory Requirements Firmware update needs to have a temp buffer that is the size of the firmware itself. For applications, the temporary buffer needs to be the size of the internal deployment, plus the external deployment if implemented, by \"extending deployment\". Systems with large external RAM will usually select RAM update. For systems without external RAM, an external QSPI flash becomes necessary. When external flash is used for buffering, IFU will overwrite the entire flash, minus the first 2MB and the area reserved for extending the application deployment area, as explained under External Flash on the External Memory page. A Tiny File System usage of the first 2MB of external flash will survive IFU even when useExternalFlash is enabled. Activity Pin As update can take a while, an activity pin can be enabled to help in determining when the update is finished. Using an LED as an indicator is an excellent example. var indicatorLed = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PB0); updater.ActivityPin = indicatorLed; Example Code Tip The application and the firmware are buffered in external memories in encrypted fashion and has no security implication, keeping IFU done securely. Warning Power interruption during FlashAndReset will cause the update to fail, requiring a manual update. The example below show how to use IFU, firmware and application data are loaded from SDCard. var qspiController = StorageController.FromName(SC20260.StorageController.QuadSpi); var indicatorPin = GpioController.GetDefault().OpenPin(SC13048.GpioPin.PB5); var appKey = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; // your key, assumming they are all zero as example. var updater = new InFieldUpdate(qspiController) { ActivityPin = indicatorPin }; var dataChunk = new byte[1 * 1024]; // must be multiple of 1K var filestreamApp = new FileStream(@\"A:\\your_app.tca\", FileMode.Open); var filestreamFw = new FileStream(@\"A:\\ghi_firmware.ghi\", FileMode.Open); // Buffer application var idxApp = 0; while (idxApp < filestreamApp.Length) { var count = filestreamApp.Read(dataChunk, 0, dataChunk.Length); idxApp += updater.LoadApplicationChunk(dataChunk, 0, count); } // Buffer firmware var idxFirmware = 0; while (idxFirmware < filestreamFw.Length) { var count = filestreamFw.Read(dataChunk, 0, dataChunk.Length); idxFirmware += updater.LoadFirmwareChunk(dataChunk, 0, count); } //Load key updater.LoadApplicationKey(appKey); Debug.WriteLine(\"Verifying application.... \"); Debug.WriteLine(\"Application version: \" + updater.VerifyApplication()); Debug.WriteLine(\"Verify firmware.... \"); Debug.WriteLine(\"Firmware version: \" + updater.VerifyFirmware()); // Flashing updater.FlashAndReset(); Tip Once FlashAndReset is called the system is locked till done and reset automatically. ApplicationUpdate When no external memories are present (Flash nor RAM) and standard IFU is not an options, the application (not firmware) can still be updated from a file located on SD card or USB memory. // Open a file stream to an application file on an SD card or USB memory // ... var updater = new ApplicationUpdate(filestream, appKey) var applicationVersion = updater.Verify(); updater.ActivityPin = indicatorPin; // optional updater.FlashAndReset(); IFU 2.0 to 2.1 Starting release 2.1, IFU is reworked to support complete firmware and application update using external flash (when available) or external RAM (when available). Unfortunately, using IFU to update from 2.0 to 2.1 is only possible if the deployment region was not extended to use external flash. A work around to update 2.0 to 2.1 is by updating 2.0 to a new 2.1 temporary application that does not use external flash. Once this temp application is loaded then the final application with external flash can be deployed. Firmware and Application Matching It is important that the loaded firmware is the same version expected by the application. It is usually best to update both when possible."
  },
  "software/tinyclr/tutorials/intro.html": {
    "href": "software/tinyclr/tutorials/intro.html",
    "title": "TinyCLR Tutorials",
    "keywords": "TinyCLR Tutorials Here you will find programming tutorials and code examples for our TinyCLR OS. We try to keep the documents as hardware generic as possible, but changes may be required to get the sample code to run on your target device. Use the sub menu on the left to navigate the long list of available tutorials."
  },
  "software/tinyclr/tutorials/ip-protection.html": {
    "href": "software/tinyclr/tutorials/ip-protection.html",
    "title": "IP Protection",
    "keywords": "IP Protection Designed with security as a top priority, TinyCLR OS provides protection for both user's code and user's data. Securing Code By default, user's code is stored securely on the internal flash memory. It can only be reached by the USB or serial debug interfaces, which can be disabled using the TinyCLR Config utility program or using GHIElectronics.TinyCLR.Native.DeviceInformation.SetDebugInterface(DebugInterface.Disable). This DebugInterface.Disable can only be undone by a complete system Erase All, from TinyCLR Config. When the debug interface is set to DebugInterface.Disable APP and MOD become inactive. The current active debug interface can be read through GHIElectronics.TinyCLR.Native.DeviceInformation.DebugInterface. The system supports extending the deployment region, where user's code/assemblies are stored, into external unsecured flash memory. To keep important data secure, the system supports Secure Assemblies. Those assemblies are loaded into the internal secure flash. To tag an assembly as secure, users must edit the AssemblyInfo.cs file in the Properties folder within the project's folder. Change the line [assembly: AssemblyConfiguration(\"\")] to [assembly: AssemblyConfiguration(\"secure\")] (the word \"secure\" is not case sensitive). During deployment Visual Studio will display an allocation table showing both the secure and unsecure assemblies and their address, a quick way to verify secure assemblies. This is found in the TinyCLR Device Deployment Visual Studio output window. The In-Field Update page covers the details on updating a locked system. Securing Data The entire system, including user's keys, cryptography, and everything else are stored on the internal RAM, accessible only by the system itself and the user's application. When external RAM is utilized, it is only there for the graphics engine. Having images stored in unsecure memory has very little security concerns, unless for example, a key is shown on one of the images. There is also a special UnmanagedBuffer class that allocates memory from Unmanaged Heap, where the user is aware and is in control of what to do with this unsecure buffer. If desired, designs that require large heaps of RAM for the entire application have the option to extend the heap to fully encapsulate the external memory, making the system data unsecure. However, external RAM (SDRAM) isn't probed easily like external flash (QSPI) even if used for extended heap, not secure in this case but more challenging to probe. Refer to the External Memory page for more info."
  },
  "software/tinyclr/tutorials/marshal.html": {
    "href": "software/tinyclr/tutorials/marshal.html",
    "title": "Marshal",
    "keywords": "Marshal Marshal is a static class that provides two functions ReadInt32 to read, and WriteInt32 to write and modify some special peripheral's registers. Example below shows how to use Marshal to read gpio input data register, and modify on gpio output data register to set pin PB0 to high: Tip The example below requires System.Runtime.InteropServices. var pinPB0OutDataReg = (IntPtr)0x58020414; var portValue = Marshal.ReadInt32(pinPB0OutDataReg) | (1 << 0); // Pin 0 Marshal.WriteInt32(pinPB0OutDataReg, portValue); Warning Some peripherals, reading status registers also clear their status, which may affect their behavior at run time. Below is list of peripheral registers that TinyCLR OS allows access to. An exception will be thrown if an invalid register is used. - Analog-to-digital converters (ADC) - Controller area network (CANFD) - Digital-to-analog converter (DAC) - Digital camera interface (DCMI) - LCD-TFT Display Controller (LTDC) - Ethernet (ETH) - Flexible memory controller (FMC) - General-purpose I/Os (GPIO) - Inter-integrated circuit (I2C) interface - Power control (PWR) - Advanced-control timers (TIM1/TIM8) - General-purpose timers (TIM2/TIM3/TIM4/TIM5/TIM12/TIM13/TIM14/TIM15/TIM16/TIM17) - Basic timers (TIM6/TIM7) - Quad-SPI interface (QUADSPI) - Secure digital input/output MultiMediaCard interface (SDMMC1) - Real Time Clock (RTC) - Serial peripheral interface (SPI) - Universal synchronous/asynchronous receiver transmitter (USART/UART) - USB on-the-go (USB_OTG) - WatchDog (WDG) - Reset and Clock Control - Voltage reference buffer (VREFBUF)"
  },
  "software/tinyclr/tutorials/memory.html": {
    "href": "software/tinyclr/tutorials/memory.html",
    "title": "Memory Management",
    "keywords": "Memory Management RAM Memory This memory type loses its contents when the system is turned off. The system uses this memory at runtime to quickly store and retrieve data. TinyCLR OS is a managed operating system -- objects in RAM are automatically tracked and freed as needed. The Garbage Collector (GC) runs when the system is low on available RAM, where it will look for unused objects and free the memory they occupy. You may also invoke the GC at any time using System.GC.Collect(). RAM is the main workspace for your application -- running out of memory will cause your application to fail. It is important to understand the memory needs of your application and to plan accordingly. When creating a buffer for a UART for example, use a reasonable size buffer that's large enough to handle your communication needs without being so large as to waste memory. RAM Memory Size The amount of free and used memory can be shown at runtime, which can be helpful for debugging and optimizing your application. var freeRam = GHIElectronics.TinyCLR.Native.Memory.ManagedMemory.FreeBytes; var usedRam = GHIElectronics.TinyCLR.Native.Memory.ManagedMemory.UsedBytes; Allocating Memory The TinyCLR OS Garbage Collector allocates and frees objects automatically on the heap. When the memory gets fragmented, the system will compact the heap. This is desired behavior, but this also creates a problem when sharing resource between TinyCLR OS and native drivers. In a more advanced application, a user may have a buffer that gets written from an interrupt routine. Assuming this is implemented in native code, we would need a buffer that always sits at a fixed address. Using var buffer = new byte[12] will not work as the garbage collector may move the buffer to compact the heap. A fixed location buffer can be allocated using GHIElectronics.TinyCLR.Native.Memory.ManagedMemory.Allocate(). Keep in mind that this is not managed memory anymore, and you are responsible for freeing this memory using GHIElectronics.TinyCLR.Native.Memory.ManagedMemory.Free(). Memory Allocation Cost Creating and disposing of objects is costly, especially when done in inner loops. The following code sends 10,000 bytes from an array over a network one byte at a time. for (int i=0; i<10000; i++) { var byteArray = new byte[1]; byteArray[0] = arrayData[i]; Network.SendByteArray(byteArray); } The code will work just fine, but as byteArray[] is created within the loop, 10,000 single element byte arrays will be created and disposed of. It is much more efficient to create the array only once. byte[] byteArray = new byte[1]; for (int i=0; i<10000; i++) { byteArray[0] = arrayData[i]; Network.SendByteArray(byteArray); } Disposing of Objects As TinyCLR OS is a managed system that monitors and frees resources, memory leaks are less of a concern than they are for unmanaged systems. However, there is still chance that issues can arise, especially in embedded systems where objects can be a combination of memory and other hardware. Take a GPIO pin for example. What happens when we no longer have a reference to a GPIO pin? Will the GC free the object? Will the pin change in state when the GC frees the pin? And finally, why would a pin (or any physical object) be left for the GC to decide how it should be freed? The answer is that we need to understand and track these resources manually. This example code will declare and initialize a GPIO pin in a function, causing the main program to lose control of the pin. The BadExample method uses the LED's GPIO pin, but it doesn't free it. class Program { static void Main() { BadExample(); //The following line will raise an exception: var led = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PE11); led.SetDriveMode(GpioPinDriveMode.Output); led.Write(GpioPinValue.Low); } static void BadExample() { var led = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PE11); led.SetDriveMode(GpioPinDriveMode.Output); led.Write(GpioPinValue.High); } } The next example will Dispose of the pin and the code will work; however, disposing the pin may take the pin back to its default state. There is no exact definition on what a piece of hardware (the GPIO pin in this example) does when disposed. class Program { static void Main() { GoodExample(); //This code will now work var led = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PE11); led.SetDriveMode(GpioPinDriveMode.Output); led.Write(GpioPinValue.Low); //... } static void GoodExample() { var led = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PE11); led.SetDriveMode(GpioPinDriveMode.Output); led.Write(GpioPinValue.High); //Free the pin, but this may cause the pin to revert to its default state. led.Dispose(); } } The following example shows the best way to handle the situation by moving the LED object declaration, so it is available and accessible to the entire class. class Program { static GpioPin led; //You can now use 'led' anywhere within 'Program' static void Main() { // Init the hardware led = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PE11); led.SetDriveMode(GpioPinDriveMode.Output); Example(); led.Write(GpioPinValue.Low); } static void Example() { led.Write(GpioPinValue.High); } } Garbage Collection TinyCLR OS automatically disposes of objects that are no longer needed. Garbage collection eliminates the need to manage memory manually and reduces or eliminates some types of bugs. The act of garbage collection can temporarily reduce the responsiveness of your system, so it may be beneficial to actively manage garbage collection to improve real time response. Garbage collection will usually only run when there is a failed memory allocation, so by properly structuring your program you should be able to eliminate garbage collection or greatly reduce it. String operations are particularly troublesome in the creation of garbage as strings are immutable. To reduce garbage collection, minimize the use of dynamically allocated buffers and minimize allocations in routines that get called often by preallocating or using static objects. Minimize string manipulation. As strings are immutable, manipulating a string creates a new string and the old string becomes garbage. Using StringBuilder to manipulate strings may help reduce garbage generation. You can use System.GC.GetTotalMemory(true) to find out how much memory is being used. the \"true\" argument forces full garbage collection. Checking free memory often during program execution will let you know if the amount of free memory is decreasing and how quickly. System.Diagnostics.Debug.EnableGCMessages(true) can be used to make sure that garbage collection messages are sent out over the debug port. TinyCLR also supports unmanaged heap space. Unmanaged heap space can be used for large graphic buffers, for example. In unmanaged heap space, it is up to the programmer to make sure memory is correctly allocated and deallocated. Read more about unmanaged heap space here. Finalizers The Garbage Collector does a lot of work in the background. To keep the system running smoothly, some of this work is done when the system is idle, like running finalizers and compacting the heap. When the system running a tight loop with continuous allocations, there will be no idle time for the Garbage Collector to finish its tasks. In this case, it is possible to force the Garbage Collector to finish the tasks. System.GC.Collect(); System.GC.WaitForPendingFinalizers(); Battery Backed RAM SITCore devices support 4 KBytes of battery backed RAM. Details can be found in the Real Time Clock Tutorial. Flash Memory Flash memory does not lose its contents on power loss. There are special requirements to write to Flash, but you can read Flash just like RAM. When deploying a program, the TinyCLR Device Deployment window will show what is being loaded and how large it is. It will then show how much free Flash is still available. Assemblies deployed. There are 2,408,408 bytes left in the deployment area. Flash is not typically written to at runtime. The system will function even with no free available FLASH. Resources TinyCLR OS allows resources, like fonts and images, to be merged into the project as a resource and then deployed to the device's Flash. Those resources can then be fetched into RAM and used at runtime. The Resource tutorial has more details. Direct Access Writing to Flash (persistent storage) is supported securely through secure storage."
  },
  "software/tinyclr/tutorials/mjpeg-video.html": {
    "href": "software/tinyclr/tutorials/mjpeg-video.html",
    "title": "MJPEG Video",
    "keywords": "MJPEG Video The MJPEG video format is simply a chain of JPG images that are stored in a single file. A codec driver is provide here."
  },
  "software/tinyclr/tutorials/modbus.html": {
    "href": "software/tinyclr/tutorials/modbus.html",
    "title": "Modbus",
    "keywords": "Modbus Modbus RTU Modbus is an asynchronous serial communications protocol that uses RS485 as its physical layer. It was developed for communicating with programmable logic controllers and is widely used for industrial applications. Modbus uses the a server/client relationship. With one server and up to 32 connections for Modbus RTU. The following sample is written for the SC20100S Dev Board and uses UART5 for communication: Tip Needed NuGets: GHIElectronics.TinyCLR.Devices.Uart, GHIElectronics.TinyCLR.Pins, GHIElectronics.TinyCLR.Devices.Modbus var serial = UartController.FromName(SC20100.UartPort.Uart5); var uartSetting = new UartSetting(){ BaudRate = 19200, DataBits = 8, Parity = UartParity.None, StopBits = UartStopBitCount.One, Handshaking = UartHandshake.None, }; serial.SetActiveSettings(uartSetting); serial.Enable(); IModbusInterface mbInterface; mbInterface = ModbusRtuInterface( serial, 19200, 8, UartStopBitCount.One, UartParity.None); ModbusMaster mbMaster; mbMaster = new ModbusMaster(mbInterface); var mbTimeout = false; ushort[] reply = null; int count = 0; while (true) { try { mbTimeout = false; reply = mbMaster.ReadHoldingRegisters(10, 0, 1, 3333); count++; if (count == 5) break; } catch (System.Exception error) { Debug.WriteLine(\"Modbus Timeout\"); mbTimeout = true; } if (!mbTimeout) { Debug.WriteLine(\"Modbus : \" + (object)reply[0].ToString()); } Thread.Sleep(1000); } Modbus IP Modbus IP is Ethernet based Modbus that transfers data over standard Ethernet packets and devices. Modbus IP offers greater distances than Modbus RTU. In the example below setup the hardware as Modbus IP client. First create a ModbusClient class that is derived from ModbusDevice. `Modbus ID public class ModbusClient : ModbusDevice{ public ModbusSlave(byte deviceAddress, object syncObject = null) : base(deviceAddress, syncObject) { } protected override string OnGetDeviceIdentification(ModbusObjectId objectId) { switch (objectId) { case ModbusObjectId.VendorName: return \"GHI Electronics\"; case ModbusObjectId.ProductCode: return \"101\"; case ModbusObjectId.MajorMinorRevision: return \"1.0\"; case ModbusObjectId.VendorUrl: return \"ghielectronics.com\"; case ModbusObjectId.ProductName: return \"SitCore\"; case ModbusObjectId.ModelName: return \"SCM20260D\"; case ModbusObjectId.UserApplicationName: return \"Modbus Slave Test\"; } return null; } protected override ModbusConformityLevel GetConformityLevel() { return ModbusConformityLevel.Regular; } protected override ModbusErrorCode OnReadCoils(bool isBroadcast, ushort startAddress, ushort coilCount, byte[] coils) { try { for (int n = 0; n < coilCount; ++n) { coils[n] = 1; } Debug.WriteLine(\"Master read coils\"); return ModbusErrorCode.NoError; } catch { Debug.WriteLine(\"error in on read coils registers\"); return base.OnReadCoils(isBroadcast, startAddress, coilCount, coils); } } protected override ModbusErrorCode OnReadHoldingRegisters(bool isBroadcast, ushort startAddress, ushort[] registers) { for (int n = 0; n < registers.Length; ++n) { registers[n] = 65530; // set number in each register for testing } Debug.WriteLine(\"Master Read Holding Registers - \" + registers[0].ToString()); return ModbusErrorCode.NoError; } catch { Debug.WriteLine(\"error in on read holding registers\"); return base.OnReadHoldingRegisters(isBroadcast, startAddress, registers); } // override On<ModusFunction> methods here Now, we can set up the instantiate the Modbus client device inside our code. ModbusDevice ModbusTCP_Device; ModbusTCP_Device = new ModbusSlave(248); ModbusTcpListener mbListner; mbListner = new ModbusTcpListener(ModbusTCP_Device, 502, 5, 1000); Thread.Sleep(100); ModbusTCP_Device.Start();"
  },
  "software/tinyclr/tutorials/mqtt.html": {
    "href": "software/tinyclr/tutorials/mqtt.html",
    "title": "MQTT",
    "keywords": "MQTT MQTT is a light weight messaging protocol for sensors that is supported by all major cloud services. See the following cloud provider pages for further details: Azure, AWS and Google Cloud. The following is a simple example of MQTT: Tip Needed NuGets: GHIElectronics.TinyCLR.Networking.Mqtt var caCertificate = new X509Certificate(UTF8Encoding.UTF8.GetBytes(\"Your certificate\")); var mqttHost = \"your_host\"; var mqttPort = 8883; //default 8883 var deviceId = \"your_device_id\"; var username = \"your_username\"; var password = \"your_password\"; var topic = \"your_topic\"; try { var clientSetting = new MqttClientSetting { BrokerName = mqttHost, BrokerPort = mqttPort, ClientCertificate = null, CaCertificate = caCertificate, SslProtocol = System.Security.Authentication.SslProtocols.Tls12 }; var client = new Mqtt(clientSetting); var connectSetting = new MqttConnectionSetting { ClientId = deviceId, UserName = username, Password = password }; // Connect to host var returnCode = client.Connect(connectSetting); var packetId = 1; // Subscribe to a topic client.Subscribe(new string[] { topic }, new QoSLevel[] { QoSLevel.ExactlyOnce }, (ushort)packetId++); // Publish a topic client.Publish(topic, Encoding.UTF8.GetBytes(\"your message\"), QoSLevel.MostOnce, false, (ushort)packetId); // Publish recieved change from a specific topic client.PublishReceivedChanged += (object sender, string topic, byte[] data, bool duplicate, QoSLevel qosLevel, bool retain) => { Debug.WriteLine(\"Received message: \" + Encoding.UTF8.GetString(data)); }; } catch (Exception e) { } Note The MQTT driver in TinyCLR OS supports client mode only. The PublishedReceivedChanged Event allows you to select the topic that the device receives the change from. Event Handler The Mqtt driver provides five events: client.PublishReceivedChanged += (p1, p2, p3, p4, p5, p6) => { Debug.WriteLine(\"Received message\");}; client.PublishedChanged += (a, b, c) => { Debug.WriteLine(\"Published Changed.\"); }; ; client.SubscribedChanged += (a, b, c) => { Debug.WriteLine(\"Subscribed Changed.\"); }; client.ConnectedChanged += (a) => { Debug.WriteLine(\"Connected Changed.\"); }; client.UnsubscribedChanged += (a, b) => { Debug.WriteLine(\"Unsubscribed Changed.\"); };"
  },
  "software/tinyclr/tutorials/multithreading.html": {
    "href": "software/tinyclr/tutorials/multithreading.html",
    "title": "Multithreading",
    "keywords": "Multithreading TinyCLR OS is a single process system, only running your application. This is in fact a good security feature! However, TinyCLR OS supports threading similar to full .NET. void Blinker() { // LED on Thread.Sleep(100); // LED off Thread.Sleep(100); } var t = new Thread(Blinker); t.Start(); // do secondary task Thread.Sleep(Timeout.Infinite);"
  },
  "software/tinyclr/tutorials/networking-core.html": {
    "href": "software/tinyclr/tutorials/networking-core.html",
    "title": "Networking Core",
    "keywords": "Networking Core Networking support in TinyCLR OS is a subset of Microsoft's .NET Framework networking stack. More details will be added to this tutorial in the future. You might want to look at the Microsoft Sockets Class documentation to get started -- it should very closely resemble the TinyCLR sockets class. MAC Addresses Before using SITCore's built in PHY and ENC28 Ethernet networking, you have to set a MAC address or an exception will be raised. While you may not need a unique MAC address for internal testing, you will need to set a valid and unique MAC address before shipping your product. If you do not have access to an appropriate MAC address, you can either use an online MAC address generator, which is not ideal, or you can use a MAC address from an old computer or network card that is no longer used. Not having a unique MAC address can be a problem. If two devices with the same MAC address are present on the same local network subnet, neither device will be able to communicate properly. The WINC1500 WiFi module supported by SITCore devices ships with a manufacturer assigned unique MAC address. This address is used by default, although you can provide your own MAC address if desired. Secure Sockets TLS is natively supported. See the TLS page for details. .NET Sockets TinyCLR OS's support of sockets is very similar to .NET socket support. Most .NET socket code should run with little modification. Socket support is provided as part of the TinyCLR OS core. Tiny CLR sockets work similar to .NET sockets -- most .NET examples are applicable to TinyCLR. TCP/UDP TCP and UDP are the core of the Internet protocols and are supported through standard .NET Sockets. The web is full of examples on using TCP and UDP Sockets that should work as is or with minor changes. TCP example: var s = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp)){ try { var ip = IPAddress.Parse(\"192.168.1.87\"); s.Connect(new IPEndPoint(ip, 80)); s.Send(System.Text.UTF8Encoding.UTF8.GetBytes(\"I am SITCore\\n\\r\")); } catch { } } UDP example: var socket = new System.Net.Sockets.Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp); var ip = new IPAddress(new byte[] { 192, 168, 1, 87 }); var endPoint = new IPEndPoint(ip, 2000); socket.Connect(endPoint); byte[] bytesToSend = Encoding.UTF8.GetBytes(msg); while (true) { socket.SendTo(bytesToSend, bytesToSend.Length, SocketFlags.None, endPoint); while (socket.Poll(2000000, SelectMode.SelectRead)){ if (socket.Available > 0){ byte[] inBuf = new byte[socket.Available]; var recEndPoint = new IPEndPoint(IPAddress.Any, 0); socket.ReceiveFrom(inBuf, ref recEndPoint); if (!recEndPoint.Equals(endPoint))// Check if the received packet is from the 192.168.0.2 continue; Debug.WriteLine(new String(Encoding.UTF8.GetChars(inBuf))); } } Thread.Sleep(100); } IP Assignment TinyCLR OS supports both static and dynamic IP addressing. With either method, an event is fired providing the local IP settings. networkController.NetworkAddressChanged += NetworkController_NetworkAddressChanged; // ... private static void NetworkController_NetworkAddressChanged (NetworkController sender, NetworkAddressChangedEventArgs e) { var ipProperties = sender.GetIPProperties(); } Tip Static IP addressing does not work with PPP. Static IP With static IP addressing, the following settings must be provided. networkInterfaceSetting.DhcpEnabled = false; networkInterfaceSetting.Address = new IPAddress(new byte[] { 192, 168, 1, 122 }); networkInterfaceSetting.SubnetMask = new IPAddress(new byte[] { 255, 255, 255, 0 }); networkInterfaceSetting.GatewayAddress = new IPAddress(new byte[] { 192, 168, 1, 1 }); networkInterfaceSetting.DnsAddresses = new IPAddress[] { new IPAddress(new byte[] { 75, 75, 75, 75 }), new IPAddress(new byte[] { 75, 75, 75, 76 }) }; Dynamic IP The following line of code enables dynamic IP, which start by trying to lease an IP from a DHCP server. If that fails, the system will self-assign an IP address through AutoIP mechanism. This can take a while but an event is fired when an IP is available. networkInterfaceSetting.DhcpEnabled = true; Tip AutoIP addresses always fall within the 169.254.x.x range to determine if an IP was generated using AutoIP DNS The TinyCLR Dns class can be used to resolve a URL into its IP address by using the following code: var hostEntry = Dns.GetHostEntry(hostName); if ((hostEntry != null) && (hostEntry.AddressList.Length > 0)) { var i = 0; while (hostEntry.AddressList[i] == null) i++; remoteIpAddress = hostEntry.AddressList[i]; } else { throw new Exception(\"Server not found.\"); ; } mDNS Multicast DNS is a local name resolution service over local networks. Please note that not all operating systems support mDNS. networkInterfaceSetting.MulticastDnsEnable = true; networkController.Enable(); MulticastDns.Start(\"MyServer\", TimeSpan.FromSeconds(1*60*60)); // TTL set to 1 hour"
  },
  "software/tinyclr/tutorials/nuget.html": {
    "href": "software/tinyclr/tutorials/nuget.html",
    "title": "NuGet",
    "keywords": "NuGet All libraries are hosted in the cloud using the industry standard NuGet format on www.NuGet.org. Not only is it easy to install and upgrade libraries, it is also easy to create and publish custom libraries. The steps below explain how to add online-hosted NuGet libraries to your project. If you are using a pre-release, the libraries must be downloaded and installed as a local feed. Start Visual Studio and create a new TinyCLR Application under C# > TinyCLR. New to Visual Studio or C#? Take a look at the getting started guide from Microsoft. Right click on your Project in the Solution Explorer panel and select Manage NuGet Packages. If the Solution Explorer window is not visible, open it by selecting Solution Explorer in the View menu. You can also select Manage NuGet Packages... in the Project menu of Visual Studio. Make sure the package source is set to \"Package source\" or \"All.\" In the search box type \"tinyclr.\" You may have to check the \"Include prerelease\" box to find the libraries. Selecting the Browse tab will show all the TinyCLR NuGet packages. To install one of the packages click on the down arrow to the right of the package version. You can also select the package and click on the Install button in the center panel. Click OK to accept the proposed changes. Accept the licensing agreement to install the package. Note Pre-release libraries are not hosted on NuGet.org, use the local feed feature to fetch the needed libraries from your local machine, found on the Downloads page. For information on creating custom NuGet Packages, this page from Microsoft is a good place to start. Tip Developers can use the NuGet Package Manager Console to reinstall NuGets Update-Package -reinstall. More details are found on Visual Studio Docs website."
  },
  "software/tinyclr/tutorials/password.html": {
    "href": "software/tinyclr/tutorials/password.html",
    "title": "Password",
    "keywords": "Password One Time Password The library supports TOTP Time-based One-Time Password, which is a password that is only valid for a specific duration of time. And also HOPT Hash-based One-Time Password, which is made from a given token. Note As this is \"time based\", the server and client must have the proper time. Tip Needed NuGet: GHIElectronics.TinyCLR.Drivers.OneTimePassword var otp = new OneTimePassword(\"JBSWY3DPEHPK3PXP\"); //TimeBased Password that is good for 2 days (48 hours*60minutes*60seconds) var t = otp.Generate(DateTime.Now.Utc, TimeSpan.FromMilliseconds(172800*1000)); // Token Based password var token = 123; var t = otp.Generate(token);"
  },
  "software/tinyclr/tutorials/power-management.html": {
    "href": "software/tinyclr/tutorials/power-management.html",
    "title": "Power Management",
    "keywords": "Power Management TinyCLR OS supports multiple power-saving modes. Idle The system enters this state whenever it is idle, such as when waiting on events and there are no running threads. This is automatic and they user is not required to take any action. Slow Clock Speed The system can operate at half speed, saving about 40% power consumption. The system can switch speed (with a required soft reset) but it can optionally persist the slow clock. var PersistClock = false; if (Power.GetSystemClock() == SystemClock.High) { Power.SetSystemClock(SystemClock.Low, PersistClock); Power.Reset(); } Switch back to full speed (only if \"PersistClock\" was false): if (Power.GetSystemClock() == SystemClock.Low) { Power.SetSystemClock(SystemClock.High, false); Power.Reset(); } When not persisted, calling Power.Reset() will retain the set clock speed, but hardware reset (reset pin) or power cycle will revert to the default state. Sleep In this mode, most of the system features are disabled. A GPIO or RTC interrupt can be used to wake the system and resume operations. Note Don't forget to configure the interrupt and interrupt handler for the pin that will be used to wake up from Sleep. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Pins var ldrButton = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PE3); ldrButton.SetDriveMode(GpioPinDriveMode.InputPullUp); ldrButton.ValueChanged += ldrButton_ValueChanged; Debug.WriteLine(\"System is going to sleep...\"); Power.Sleep(); Debug.WriteLine(\"This will print after system wakeup\"); // An event is needed to activate the interrupts internally private static void ldrButton_ValueChanged(GpioPin sender, GpioPinValueChangedEventArgs e) { } To sleep for a specific time, using RTC: Power.Sleep(DateTime.Now.AddSeconds(90)); //Will wake up after 90 seconds. Shutdown In this mode the system completely shuts down. It can only be awakened by reset, power cycle, RTC, or by toggling the WKUP pin, which will also reset the system. When Shutdown is used the system is turned completely off, internal pull-up resistors are also disabled. Adding pull-up or pull-down resistor on WKUP pin is required. Note Waking from Shutdown mode always resets the system. Your application will start over, it will not resume where it left off. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Native, and GHIElectronics.TinyCLR.Pins The following code shuts down the system to only wake up using WKUP pin. Power.Shutdown(true, DateTime.MaxValue); By default, a rising edge on WKUP pin is needed to wake the system up. The system also allows for using a falling edge instead. Power.WakeupEdge = WakeupEdge.Falling; To shutdown for a specific time: Power.Shutdown(false, DateTime.Now.AddSeconds(90); //Will wake up after 90 seconds. //WKUP pin has no effect. To shutdown for a specific time or when the WKUP pin changes state (whichever comes first): Power.Shutdown(true, DateTime.Now.AddSeconds(90); //Will wake up after 90 seconds or //when WKUP is pressed. On-board Ethernet Some modules include an on-board Ethernet PHY. This can be disabled by setting a specific GPIO to low. Below are the pin numbers. Module Pin SCM20260E/D PG3 SCM20100E PD8 Software Reset TinyCLR OS provides two reset modes within your application: Reset Application This command allows to reset your application: GHIElectronics.TinyCLR.Native.Power.Reset(); Reset to Bootloader mode The command below will boot the device in GHI Bootloader mode: GHIElectronics.TinyCLR.Native.Power.Reset(false); Reset Source The cause of the previous reset can be found through GetResetSource. This is useful to determine if, for example, a watchdog or was the reason for the reset. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Native var resetSource = Power.GetResetSource();"
  },
  "software/tinyclr/tutorials/ppp.html": {
    "href": "software/tinyclr/tutorials/ppp.html",
    "title": "PPP",
    "keywords": "PPP Point to Point Protocol (PPP) started in the days of dial up Internet and is still used today in cellular modems. While using PPP can be optional for small IoT systems, having a secure connection requires PPP. A MAC address is not needed for PPP. This example uses the LTE IoT 2 click module on the SCM20260D Dev Boards to establish a connection and read a web page. We've also successfully tested the SIMCOM SIM900 and NimbeLink's Skywire cellular embedded modems. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.Network, GHIElectronics.TinyCLR.Devices.Spi, GHIElectronics.TinyCLR.Devices.Uart, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Networking, and GHIElectronics.TinyCLR.Pins. class Program { static bool linkReady = false; static void Main() { var reset = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PI8); reset.SetDriveMode(GpioPinDriveMode.Output); reset.Write(GpioPinValue.High); Thread.Sleep(200); reset.Write(GpioPinValue.Low); Thread.Sleep(7000); //Wait for modem to initialize. InitSimCard(); TestPPP(); } static void InitSimCard() { var serial = UartController.FromName (SC20260.UartPort.Uart8); serial.SetActiveSettings(115200, 8, UartParity.None, UartStopBitCount.One, UartHandshake.None); serial.Enable(); while (!SendAT(serial, \"AT\")) { } SendAT(serial, \"AT+CGDCONT=1,\\\"IP\\\",\\\"h2g2\\\"\"); //Google Fi. SendAT(serial, \"AT+CGDCONT=2,\\\"IP\\\",\\\"telargo.t-mobile.com\\\"\"); //T-Mobile. SendAT(serial, \"AT+CGDCONT=3,\\\"IP\\\",\\\"fast.t-mobile.com\\\"\"); //T-Mobile. SendAT(serial, \"AT+CGDCONT=4,\\\"IPV4V6\\\",\\\"NIMBLINK.GW12.VZWENTP\\\"\"); //NimbeLink. SendAT(serial, \"ATDT*99***1#\"); //Modem dial string. The '1' in this string points // to the Google Fi PDP context previously defined // by the SendAT() method. Debug.WriteLine(\"OK to start PPP....\"); } static void TestPPP() { var networkController = NetworkController. FromName(SC20260.NetworkController.Ppp); PppNetworkInterfaceSettings networkInterfaceSetting = new PppNetworkInterfaceSettings() { AuthenticationType = PppAuthenticationType.Pap, Username = \"\", Password = \"\", }; UartNetworkCommunicationInterfaceSettings networkCommunicationInterfaceSettings = new UartNetworkCommunicationInterfaceSettings() { ApiName = SC20260.UartPort.Uart8, BaudRate = 115200, DataBits = 8, Parity = UartParity.None, StopBits = UartStopBitCount.One, Handshaking = UartHandshake.None, }; networkController.SetInterfaceSettings(networkInterfaceSetting); networkController.SetCommunicationInterfaceSettings (networkCommunicationInterfaceSettings); networkController.SetAsDefaultController(); networkController.NetworkAddressChanged += NetworkController_NetworkAddressChanged; networkController.NetworkLinkConnectedChanged += NetworkController_NetworkLinkConnectedChanged; networkController.Enable(); while (linkReady == false) { } //Network is now ready to use. } private static void NetworkController_NetworkLinkConnectedChanged (NetworkController sender, NetworkLinkConnectedChangedEventArgs e) { //Raise event connect/disconnect } private static void NetworkController_NetworkAddressChanged (NetworkController sender,NetworkAddressChangedEventArgs e) { var ipProperties = sender.GetIPProperties(); var address = ipProperties.Address.GetAddressBytes(); Debug.WriteLine(\"IP Address: \" + address[0] + \".\" + address[1] + \".\" + address[2] + \".\" + address[3]); linkReady = address[0] != 0; } static bool SendAT(UartController port, string command) { command += \"\\r\"; var sendBuffer = Encoding.UTF8.GetBytes(command); var readBuffer = new byte[256]; var read = 0; var count = 10; port.Write(sendBuffer, 0, sendBuffer.Length); while (count-- > 0) { Thread.Sleep(100); read += port.Read(readBuffer, read, readBuffer.Length - read); var response = new string (Encoding.UTF8.GetChars(readBuffer, 0, read)); if (response.IndexOf(\"OK\") != -1 || response.IndexOf(\"CONNECT\") != -1) { Debug.WriteLine(\" \" + response); return true; } } return false; } } Switching to Command Mode When a PPP connection is set up successfully, you can switch the modem from data mode to command mode with the +++ escape sequence. To prevent the +++ escape sequence from being misinterpreted as data, the following guidelines should be followed: Do not send any other characters within one second (before or after) of sending +++. Send +++ quickly, sending all three characters within one second. When the +++ sequence is received, the modem will switch from data mode to command mode and reply with an \"OK\" response. Switching to Data Mode When the modem is in command mode, sending the ATO command will switch the modem to Data Mode. Wait for the \"CONNECT 150000000\" response after sending the ATO command to make sure the modem is in data mode. All data sent will now be treated as PPP frames. The following example switches from Data mode to Command Mode, sends a few AT commands, then switches back to Data mode. TinyCLR OS provides two functions, Suspend() and Resume() that are needed for this example. This code uses SC20260.UartPort.Uart8 for PPP configuration. //PPP is connected //.... networkController.Suspend(); { //Suspend PPP, release UART Port from TinyCLR OS. //Open UART. var serial = GHIElectronics.TinyCLR.Devices.Uart.UartController.FromName (SC20260.UartPort.Uart8); serial.SetActiveSettings( 115200, 8, GHIElectronics.TinyCLR.Devices.Uart.UartParity.None, GHIElectronics.TinyCLR.Devices.Uart.UartStopBitCount.One, GHIElectronics.TinyCLR.Devices.Uart.UartHandshake.None); serial.Enable(); Thread.Sleep(1000); SendAT(serial, \"+++\"); //Send \"+++\" to enter command mode. Thread.Sleep(1000); //Send any AT command here. //For example, AT+CSQ to check signal strength. SendAT(serial, \"AT+CSQ\"); SendAT(serial, \"ATO\"); //Enable \"PPP\" modem, wait for \"CONNECT 150000000\" response. serial.Dispose(); serial = null; //Release UART, resume PPP interface. } networkController.Resume(); // Continue network ... Note When sending \"+++\", do not send \"\\r\" or \"\\n\" at the end. While most AT commands need end of line characters, +++ does not. Security Clarification Most users of embedded systems that connect to mobile networks assume they are secure, but often they are not. Typically, a serial connection with AT commands is used to communicate with the modem. While the data over the air is secure, all data transmitted over the serial connection is raw unencrypted data that can be easily scoped. This is not the case with TinyCLR OS. With TinyCLR OS, serial data between the device and the modem is encrypted. All data handling is done internally inside the core processor, which is extremely difficult to hack into."
  },
  "software/tinyclr/tutorials/pwm.html": {
    "href": "software/tinyclr/tutorials/pwm.html",
    "title": "PWM",
    "keywords": "PWM Pulse Width Modulation (PWM) is a very useful feature found on most microcontrollers. PWM is a method of generating a square wave signal of uniform frequency with variable duty cycle. PWM is often used to generate analog voltages, but has many other uses such as generating digital pulses for driving servo motors or driving infrared LEDs for communication. The ratio of the pulse width to it's period is called the duty cycle. Through software, you can control both the PWM frequency and duty cycle. Tip We usually use GetDefault() for most peripherals. For example, there is only one GPIO controller on most systems. This is not the case with PWM. Never use the Default controller and always select the proper channel on the corresponding controller. Tip PWM2.3 is channel 3 on controller 2. Energy Level PWM is perfect for dimming an LED or controlling the speed of a motor. When the duty cycle is 50%, half the energy is transferred to the attached load. var controller = PwmController.FromName(SC20260.Timer.Pwm.Controller3.Id); var led = controller.OpenChannel(SC20260.Timer.Pwm.Controller3.PB0); controller.SetDesiredFrequency(10000); double duty = 0.5, speed = 0.01; led.Start(); while (true) { if (duty <= 0 || duty >= 1.0) { speed *= -1; //Reverse direction. duty += speed; } led.SetActiveDutyCyclePercentage(duty); duty += speed; Thread.Sleep(10); //Always give the system time to think! } Musical Tones Musical notes have specific frequencies; C for example is about 261Hz. Plugging these numbers into an array and knowing the length of each tone is all that is needed to play some simple music. When playing notes by changing the frequency, keep the duty cycle set to 0.5. The following example is written for the SC20100S Dev Board. using GHIElectronics.TinyCLR.Devices.Pwm; using GHIElectronics.TinyCLR.Pins; using System.Threading; class Program { const int NOTE_C = 261; const int NOTE_D = 294; const int NOTE_E = 330; const int NOTE_F = 349; const int NOTE_G = 392; const int WHOLE_DURATION = 2000; const int EIGHTH = WHOLE_DURATION / 8; const int QUARTER = WHOLE_DURATION / 4; const int QUARTERDOT = WHOLE_DURATION / 3; const int HALF = WHOLE_DURATION / 2; const int WHOLE = WHOLE_DURATION; //Make sure the two below arrays match in length. Each duration element corresponds to // one note element. private static int[] note = { NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_E, NOTE_D, NOTE_D, NOTE_E, NOTE_E, NOTE_F, NOTE_G, NOTE_G, NOTE_F, NOTE_E, NOTE_D, NOTE_C, NOTE_C, NOTE_D, NOTE_E, NOTE_D, NOTE_C, NOTE_C}; private static int[] duration = { QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, HALF, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTER, QUARTERDOT, EIGHTH, WHOLE}; private static void Main() { var controller = PwmController.FromName(SC20100.Timer.Pwm.Controller3.Id); var toneOut = controller.OpenChannel(SC20100.Timer.Pwm.Controller3.PB1); toneOut.SetActiveDutyCyclePercentage(0.5); while (true) { toneOut.Start(); for (int i = 0; i < note.Length; i++) { controller.SetDesiredFrequency(note[i]); Thread.Sleep(duration[i]); } toneOut.Stop(); Thread.Sleep(1000); } } } Software PWM The built-in support for PWM uses hardware to generate signals very accurately with zero processing. However, hardware-PWM only worked on specific pins. TinyCLR supports PWM on any pin, generated by software. While software PWM is not very accurate and requires constant processor time to generate the signal, it works well at lower frequencies. This is good for dimming lights or driving servos. var softwarePwmController = PwmController.FromName(SC20260.Timer.Pwm.Software.Id); var pwmPinPB3 = softwarePwmController.OpenChannel(SC20260.GpioPin.PB3); softwarePwmController.SetDesiredFrequency(1000); // set frequency 1KHz pwmPinPB3.SetActiveDutyCyclePercentage(0.5); pwmPinPB3.Start(); Thread.Sleep(10 * 1000); //Delay 10 second pwmPinPB3.Stop(); Tip On SITCore, the range the range of PWM frequency is 15.4Hz to 10KHz. Servo Motors Servo motors use PWM to generate the necessary signal. A NuGet package is provided to simplify the use of servos. The example below uses the software PWM feature, allowing any digital pin to be used. Hardware PWM can be used as well. Tip As a rule, servos have three wires. Be sure the central wire is connected to 5V. The lighter color wire on one side of the connector is a signal and should be connected to a PWM pin. The third one, which is usually a darker color, is ground. Tip Needed NuGets: System.Threading, GHIElectronics.TinyCLR.Pins, GHIElectronics.TinyCLR.Devices.Pwm, GHIElectronics.TinyCLR.Drivers.Motor.Servo var softwarePwmController = PwmController.FromName(SC20260.Timer.Pwm.Software.Id); var pwmPinPB3 = softwarePwmController.OpenChannel(SC20260.GpioPin.PB3); var servo = new ServoController(softwarePwmController, pwmPinPB3); servo.Set(0); // 0 degree Thread.Sleep(2000); servo.Set(45.0); // 45 degree Thread.Sleep(2000); servo.Set(90.0); // 90 degree Thread.Sleep(2000); servo.Set(180.0); // 180 degree Thread.Sleep(4000); Tip Typically, servos will have a 1ms - 2ms pulse width, but not always."
  },
  "software/tinyclr/tutorials/real-time-clock.html": {
    "href": "software/tinyclr/tutorials/real-time-clock.html",
    "title": "Real Time Clock",
    "keywords": "Real Time Clock The Real Time Clock (RTC) is a circuit that runs off a small battery or a super capacitor connected to VBAT. It needs its own crystal and keeps running even when the main system and its clocks are powered off. In the event the RTC battery was drained or the RTC was never initialized, the RTC will not have a correct value. Use the rtc.IsValid method to determine if the time was set correctly. Tip Needed NuGets: GHIElectronics.TinyCLR.Devices.Rtc, GHIElectronics.TinyCLR.Native using GHIElectronics.TinyCLR.Devices.Rtc; using GHIElectronics.TinyCLR.Native; using System; using System.Diagnostics; using System.Threading; var rtc = RtcController.GetDefault(); if (rtc.IsValid) { Debug.WriteLine(\"RTC is Valid\"); // RTC is good so let's use it SystemTime.SetTime(rtc.Now); } else { Debug.WriteLine(\"RTC is Invalid\"); // RTC is not valid. Get user input to set it // This example will simply set it to January 1st 2020 at 11:11:11 var MyTime = new DateTime(2020, 1, 1, 11, 11, 11); rtc.Now = MyTime; SystemTime.SetTime(MyTime); } while (true) { Debug.WriteLine(\"Current Time : \" + DateTime.Now); Debug.WriteLine(\"Current RTC Time: \" + rtc.Now); Thread.Sleep(1000); } The output will show both times and they should match. If the RTC time is invalid when you first run the program, the program will detect the invalid time and will set the RTC. RTC is Valid Current Time : 01/01/2019 11:15:35 Current RTC Time: 01/01/2019 11:15:35 Current Time : 01/01/2019 11:15:36 Current RTC Time: 01/01/2019 11:15:36 Clock Source When the RTC is initialized, it tries to use an external 32,768Khz crystal. This is usually what is recommended as it provides an accurate time. If crystal is not available, the RTC will fall back and run using an internal RC. The internal RC is not as accurate as an external crystal and temperature will skew the time. VBAT VBAT mode can be set in \"charger mode\" where it can charge an attached a supercap. Typically, VBAT requires 1.2 to 3.6 volts for correct operation. Important Make sure the RTC battery charge mode is correctly set. Charging a lithium coin cell may cause damage to the cell and could cause it to leak. Not charging a supercap will result in a discharged supercap and loss of correct time and battery backed ram data when your board is powered down. var rtc = GHIElectronics.TinyCLR.Devices.Rtc.RtcController.GetDefault(); //The following line turns off charging. Used for lithium coin cells. rtc.SetChargeMode(GHIElectronics.TinyCLR.Devices.Rtc.BatteryChargeMode.None); //The following line charges slowly through a 5 K resistor. Used for supercaps. rtc.SetChargeMode(GHIElectronics.TinyCLR.Devices.Rtc.BatteryChargeMode.Slow); //The following line charges quickly through a 1.5 K resistor. // This is the mode we use for the supercaps on SITCore Dev boards. rtc.SetChargeMode(GHIElectronics.TinyCLR.Devices.Rtc.BatteryChargeMode.Fast); System Clock You can get the current system time using DateTime.Now. The system clock starts running at power up, but until you set the clock, the time and date will be incorrect. The following command is used to set the time: GHIElectronics.TinyCLR.Native.SystemTime.SetTime(DateTime utcTime); To set the system clock to the RTC time, use the following command: GHIElectronics.TinyCLR.Native.SystemTime.SetTime(rtc.Now); SNTP You can use SNTP (Simple Network Time Protocol) to accurately set the time in your application. The following method will return the current date and time after retrieving it from an NTP server. Your device will need an active network connection for this code to work. public static DateTime GetNetworkTime(int CorrectLocalTime = 0) { const string ntpServer = \"pool.ntp.org\"; var ntpData = new byte[48]; ntpData[0] = 0x1B; //LeapIndicator = 0 (no warning), VersionNum = 3 (IPv4 only), // Mode = 3 (Client Mode) var addresses = System.Net.Dns.GetHostEntry(ntpServer).AddressList; var ipEndPoint = new System.Net.IPEndPoint(addresses[0], 123); var socket = new System.Net.Sockets.Socket( System.Net.Sockets.AddressFamily.InterNetwork, System.Net.Sockets.SocketType.Dgram, System.Net.Sockets.ProtocolType.Udp); socket.Connect(ipEndPoint); System.Threading.Thread.Sleep(1); //Added to support TinyCLR OS. socket.Send(ntpData); socket.Receive(ntpData); socket.Close(); ulong intPart = (ulong)ntpData[40] << 24 | (ulong)ntpData[41] << 16 | (ulong)ntpData[42] << 8 | (ulong)ntpData[43]; ulong fractPart = (ulong)ntpData[44] << 24 | (ulong)ntpData[45] << 16 | (ulong)ntpData[46] << 8 | (ulong)ntpData[47]; var milliseconds = (intPart * 1000) + ((fractPart * 1000) / 0x100000000L); var networkDateTime = (new System.DateTime(1900, 1, 1)). AddMilliseconds((long)milliseconds); return networkDateTime.AddHours(CorrectLocalTime); } The above method is used as follows, with the argument indicating how many hours to add to convert UTC time to your local time zone: DateTime dateTime = GetNetworkTime(-5); Battery Backed Memory SITCore devices include 4 KBytes of battery backed memory. This memory accepts and returns byte arrays of data. The commands and their overloads for accessing this memory are as follows: BackupMemorySize; //Returns 4096, total size in bytes of battery backed memory. ReadBackupMemory(byte[] destinationData); ReadBackupMemory(byte[] destinationData, uint sourceOffset); ReadBackupMemory(byte[] destinationData, uint destinationOffset, uint sourceOffset, int count); public void WriteBackupMemory(byte[] sourceData, uint destinationOffset); public void WriteBackupMemory(byte[] sourceData); public void WriteBackupMemory(byte[] sourceData, uint sourceOffset, uint destinationOffset, int count); Note that the battery backed memory is not managed at all. There is no allocate, dispose, or garbage collection. The commands used to access battery backed memory only copy the bytes from your array into memory, or from memory into your array. Until you overwrite it or lose RTC battery power, the data will always be in battery backed memory. Here is a simple example that displays the size of the battery backed memory, and then writes and reads five bytes of data. Tip Needed NuGet: GHIElectronics.TinyCLR.Devices.Rtc var rtc = RtcController.GetDefault(); Debug.WriteLine(rtc.BackupMemorySize.ToString()); //Displays \"4096\" var writeData = new byte[] { 1, 2, 3, 4, 5 }; rtc.WriteBackupMemory(writeData); var readData = new byte[5]; rtc.ReadBackupMemory(readData); for (int i=0; i < 5; i++) { Debug.WriteLine(readData[i].ToString()); //Displays 1, 2, 3, 4, 5 } RTC Calibration RTC also provides a calibration feature. rtc.Calibrate(int pulse); pulse is how many ticks to add (positive) or remove (negative) every 32 seconds. Use 0 to disable. Maximum pulse is +/-512, meaning RTC frequency can be adjust between -487.1ppm to 488.5ppm."
  },
  "software/tinyclr/tutorials/reflection.html": {
    "href": "software/tinyclr/tutorials/reflection.html",
    "title": "Reflection",
    "keywords": "Reflection Reflection objects are used for obtaining type information at runtime. This class is in the System.Reflection namespace. var i=20; Type type = i.GetType(); //type = System.Int32 Another example below shows how to access a private function from a different class. Let's say we have a class named ReflectionExample with private functions named FunctionA() and FunctionB(). public class ReflectionExample { private uint FunctionA() => 0x1234; private uint FunctionB(uint numPlus) => 0x1234 + numPlus; } Reflection provides a way to access these two functions even though they are declared as private. var r = new ReflectionExample(); var type = r.GetType(); var methodA = type.GetMethod(\"FunctionA\", BindingFlags.NonPublic | BindingFlags.Instance); var valueA = methodA.Invoke(r, null); var methodB= type.GetMethod(\"FunctionB\", BindingFlags.NonPublic | BindingFlags.Instance); var valueB = methodB.Invoke(r, new object[] { (uint)1 }); Debug.WriteLine(\"methodA : \" + valueA); Debug.WriteLine(\"methodB : \" + valueB); The output will be: methodA : 4660 methodB : 4661"
  },
  "software/tinyclr/tutorials/regex.html": {
    "href": "software/tinyclr/tutorials/regex.html",
    "title": "Regular Expression",
    "keywords": "Regular Expression The RegEx class can be used to quickly parse large amounts of text to find specific character patterns; to extract, edit, replace, or delete text substrings; and to add the extracted strings to a collection to generate a report. The Regex class is defined in the System.Text.Regular Expressions namespace. The RegEx class constructor takes a pattern string as a parameter with other optional parameters. The following code snippet creates a RegEx from a pattern. Here pattern is to match a word starting with char M. // Create a pattern for a word that starts with letter \"M\" string pattern = @\"\\b[M]\\w+\"; // Create a Regex Regex rg = new Regex(pattern); // Long string string authors = \"Mike, John, Meachel, Mickey, Jenifer\"; // Get all matches MatchCollection matchedAuthors = rg.Matches(authors); // Print all matched authors for (int count = 0; count < matchedAuthors.Count; count++) Debug.WriteLine(matchedAuthors[count].Value);"
  },
  "software/tinyclr/tutorials/resources.html": {
    "href": "software/tinyclr/tutorials/resources.html",
    "title": "Resources",
    "keywords": "Resources Resource files can be used to store strings, images, audio files, and other binary or text files that will be used by your application. Right-click on your project and Add-> New Item... Select TinyCLR and click on Resources File. Name the file Resources to match the code samples in Docs. You can now drag resources right into the file. In the background, a file is generated to reflect the added resources. Using the resource will look similar to var resourceData = Resources.GetBytes(Resources.BinaryResources.data); Tip If you are copying example code that uses resource files, some changes may be needed to match the resources' names in your project. Partial loading Large resources can be partially loaded in RAM as needed. var resourceId = (short)Resources.BinaryResources.YourResourceId; var data = (byte[])(Resources.ResourceManager.GetObject(resourceId, offset, readSize));"
  },
  "software/tinyclr/tutorials/sd-cards.html": {
    "href": "software/tinyclr/tutorials/sd-cards.html",
    "title": "SD/MMC Cards",
    "keywords": "SD/MMC Cards SD and MMC cards are fully supported through the File System libraries. This is a sample on how setup the SD driver. var sd = StorageController.FromName(SC20100.StorageController.SdCard); var drive = FileSystem.Mount(sd.Hdc); Additionally, SPI SD drivers are also supported through the ManagedFileSystem software utility drivers."
  },
  "software/tinyclr/tutorials/secure-boot.html": {
    "href": "software/tinyclr/tutorials/secure-boot.html",
    "title": "Secure Boot",
    "keywords": "Secure Boot TinyCLR OS is designed with security in mind. The system boots up from internal memories that are not accessible externally. The boot code only boots up an authenticated firmware that is provided by GHI Electronics. The user then controls the application and how it is updated though an encrypted In-Field Update and can also take advantage of the IP Protection feature."
  },
  "software/tinyclr/tutorials/secure-storage.html": {
    "href": "software/tinyclr/tutorials/secure-storage.html",
    "title": "Secure Storage",
    "keywords": "Secure Storage There are two secure storage areas you may find useful: the configuration storage area and the one-time programmable storage area. Configuration Storage On SC20260 (and SC20100), there is 128 KByte secure storage area is organized as 4096 blocks of 32 bytes each. On SC13048 there is 8KB secure storage, organized as 256 blocks of 32 bytes each. Configuration storage can be erased and modified. Performing an erase all in TinyCLR Config will wipe out this area. As this area is comprised of a single sector of flash memory, only the whole storage area can be erased. Partial erases are not possible. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.SecureStorage const uint STORAGE_SIZE = 32 * 1024; var configStorage = new SecureStorageController(SecureStorage.Configuration); var data = new byte[STORAGE_SIZE]; Debug.WriteLine(\"Configuration storage total size: \" + configStorage.TotalSize.ToString() + \" bytes.\"); Debug.WriteLine(\"Configuration storage block size: \" + configStorage.BlockSize.ToString() + \" bytes.\"); Debug.WriteLine(\"Checking if blank. . .\"); var isBlank = true; for (uint block = 0; block < configStorage.TotalSize / configStorage.BlockSize; block++) { if (!configStorage.IsBlank(block)) isBlank = false; } if (isBlank) { Debug.WriteLine(\"Configuration storage area is blank.\"); } else { Debug.WriteLine(\"Erasing entire configuration storage area...\"); configStorage.Erase(); } Debug.WriteLine(\"Filling buffer...\"); for (var i = 0; i < data.Length; i++) { data[i] = (byte)(i % 255); } Debug.WriteLine(\"Writing buffer...\"); var dataBlock = new byte[configStorage.BlockSize]; for (uint block = 0; block < data.Length / configStorage.BlockSize; block++) { Array.Copy(data, (int)(block * configStorage.BlockSize), dataBlock, 0, (int)(configStorage.BlockSize)); configStorage.Write(block, dataBlock); } Debug.WriteLine(\"Comparing buffer...\"); for (uint block = 0; block < data.Length / configStorage.BlockSize; block++) { for (var byteIndex = 0; byteIndex < configStorage.BlockSize; byteIndex++) { configStorage.Read(block, dataBlock); if (data[block * configStorage.BlockSize + byteIndex] != dataBlock[byteIndex]) { Debug.WriteLine(\"Configuration storage data is corrupted!\"); Thread.Sleep(Timeout.Infinite); } } } Debug.WriteLine(\"Configuration storage is good to go!!!\"); One Time Programmable Area Note If all 32 bytes of any OTP flash block contain 0xFF, the block is considered unused. If you write only 0xFF to the contents of a block, the block will be regarded as unused and you will be able to rewrite the block. The one time programmable (OTP) secure flash region is organized into 2048 blocks on SC20260 (or SC20100), and 64 blocks on SC13048 of 32 bytes each. Once you write to a block, that block can be read but never changed. There is no way to modify written data. Erasing the entire device Erase All in TinyCLR Config will not erase or modify this area. The API for OTP storage is the same as for the configuration storage area, except that instantiation takes a different argument and the Erase method is disabled. OTP secure storage is instantiated as follows: var otpStorage = new SecureStorageController(SecureStorage.Otp); Note SC13048 allows write one time on each block, even data all is 0xFF."
  },
  "software/tinyclr/tutorials/serialization.html": {
    "href": "software/tinyclr/tutorials/serialization.html",
    "title": "Serialization",
    "keywords": "Serialization Serialization is the process of converting the state of an object into a form that can be persisted or transported. The complement of serialization is deserialization, which converts a stream into an object. Together, these processes allow objects to be stored and transferred. Binary Serialization Binary Serialization is a native, fast and lean way to serialize objects. To keep serialization fast and efficient on embedded devices, TinyCLR's serialization is not compatible with binary serialization on desktop PCs. However, an implementation on the PC can be used to process the serialized binary data if necessary. Tip Needed NuGets: GHIElectronics.TinyCLR.Core and System.Reflection. public enum MyEnum : short { A, B, C }; private static void Main() { MySerializableClass original = new MySerializableClass(1, \"ABCD\", 3, MyEnum.B, 0.1f); Debug.WriteLine(\"original: \" + original.ToString()); byte[] buffer = Reflection.Serialize(original, typeof(MySerializableClass)); MySerializableClass restored = (MySerializableClass)Reflection. Deserialize(buffer, typeof(MySerializableClass)); Debug.WriteLine(\"restored: \" + restored.ToString()); Debug.WriteLine(\"Number of bytes: \" + buffer.Length.ToString()); } [System.Serializable] public class MySerializableClass { public int a; public string b; private byte c; private MyEnum d; private float e; private System.DateTime dt; public MySerializableClass(int a, string b, byte c, MyEnum d, float e) { this.a = a; this.b = b; this.c = c; this.d = d; this.e = e; this.dt = this.dt = new System.DateTime(2007, 1, 22); } public override string ToString() { return \"a=\" + a.ToString() + \", b=\" + b + \", c=\" + c.ToString() + \", d=\" + ((object)d).ToString() + \", e=\" + e.ToString(\"F2\"); } } Note Serialization in TinyCLR OS is not compatible with full .NET. That means you cannot deserialize an object with .NET on a PC from a byte stream that was created with TinyCLR OS and vice versa. There is a solution which allows Serialization in TinyCLR OS and the .NET Framework to be compatible. For details, look at the BinarySerializationDesktopSample here: https://github.com/Apress/exp-.net-micro-framework/tree/master/source/Chapter09/BinarySerializationDesktopSample Warning GHI Electronics does not own or have rights to the code in this repository: https://github.com/Apress/exp-.net-micro-framework. It is your responsibility to adhere to the license provided by the owner of this code. JSON TinyCLR OS includes a built in JSON library. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Data.Json. var intArray = new int[] { 1, 3, 5, 7, 9 }; var result = JsonConverter.Serialize(intArray); var bson = result.ToBson(); var compare = (System.Array).Json.JsonConverter. FromBson(bson, typeof(int[])); for (var i = 0; i < intArray.Length; i++) { if (intArray[i] != (int)compare.GetValue(i)) { Debug.WriteLine(\"Array test failed\"); break; } } Debug.WriteLine(\"Array test succeeded\"); XML TinyCLR OS supports both the writing and reading of XML (eXtensible Markup Language) files through its XmlReader and XmlWriter classes. Full documentation of XML is beyond the scope of this document, but for more information Microsoft's .NET XML documentation is a good place to start. Please note that the TinyCLR implementation of XML is not fully .NET compatible, for example the asynchronous API is not supported. Note XmlReader and XmlWriter both implement the IDisposable interface. The following example shows the creation and reading of an XML file to and from a memory stream: Tip Needed NuGets: GHIElectronics.TinyCLR.Core and GHIElectronics.TinyCLR.Data.Xml. MemoryStream stream = new MemoryStream(); XmlWriter writer = XmlWriter.Create(stream); writer.WriteProcessingInstruction(\"xml\", \"version=\\\"1.0\\\" encoding=\\\"utf-8\\\"\"); writer.WriteComment(\"This is just a comment\"); writer.WriteRaw(\"\\r\\n\"); writer.WriteStartElement(\"NETMF_DataLogger\"); //Root element writer.WriteString(\"\\r\\n\\t\"); writer.WriteStartElement(\"FileName\"); //Child element writer.WriteString(\"Data\"); writer.WriteEndElement(); writer.WriteRaw(\"\\r\\n\\t\"); writer.WriteStartElement(\"FileExt\"); writer.WriteString(\"txt\"); writer.WriteEndElement(); writer.WriteRaw(\"\\r\\n\\t\"); writer.WriteStartElement(\"SampleFeq\"); writer.WriteString(\"10\"); writer.WriteEndElement(); writer.WriteRaw(\"\\r\\n\"); writer.WriteEndElement(); //End of root element writer.Flush(); writer.Close(); //Display the XML data. byte[] byteArray = stream.ToArray(); char[] characterArray = UTF8Encoding.UTF8.GetChars(byteArray); Debug.WriteLine(new string(characterArray) + \"\\r\\n\\r\\n\"); stream.Dispose(); //Read the XML data. stream = new MemoryStream(byteArray); XmlReaderSettings settings = new XmlReaderSettings(); settings.IgnoreWhitespace = true; settings.IgnoreComments = false; XmlReader reader = XmlReader.Create(stream, settings); while (!reader.EOF) { reader.Read(); switch (reader.NodeType) { case XmlNodeType.Element: Debug.WriteLine(\"Element: \" + reader.Name); break; case XmlNodeType.Text: Debug.WriteLine(\"Text: \" + reader.Value); break; case XmlNodeType.XmlDeclaration: Debug.WriteLine(\"Declaration: \" + reader.Name + \", \" + reader.Value); break; case XmlNodeType.Comment: Debug.WriteLine(\"Comment: \" + reader.Value); break; case XmlNodeType.EndElement: Debug.WriteLine(\"End element\"); break; case XmlNodeType.Whitespace: Debug.WriteLine(\"White space\"); break; case XmlNodeType.None: Debug.WriteLine(\"None\"); break; default: Debug.WriteLine(reader.NodeType.ToString()); break; } }"
  },
  "software/tinyclr/tutorials/signal-control.html": {
    "href": "software/tinyclr/tutorials/signal-control.html",
    "title": "Signal Control",
    "keywords": "Signal Control DigitalSignal The DigitalSignal is used to handle digital signals! Unlike the other features on this page, DigitalSignal is accurate because it is hardware-backed and runs in a non-blocking manner. Being hardware backed, this feature only runs on specific pins. Those pins can be found under the pins library, under `SC20260.Timer.DigitalSignal.Controller?.xxx. Tip Timers are also used with other features, such as PWM. Once a Timer is reserved for DigitalSignal, it is no longer available for other features. There are two uses for DigitalSignal, reading a signal (capture) and sending a signal (generate). The capture feature also support capturing a stream of durations (signal analyzer) or a pulse counter. Generate Using the Generate function allows the user to create a very accurate signal generator. Generate(uint[]data, uint offset, uint count) data is the length of each pulse in ticks. By default, each tick is 100ns. There is a limitation to the data being used: The data array length is limited to 64K elements. Also, adding individual elements together in the array can also not exceed 0xFFFFFFFF in total. Generate(uint[]data, uint offset, uint count, unit multiplier) Depends on the devices, allowable multiplier values range are different: On SC20xxx, allowable multiplier values range from 25 to 250,000 (250us). There are also 2 rules to the allowed values: 1,000,000,000 % multiplier must result in zero and 240,000,000 (240MHz) % (1,000,000,000 / multiplier) must also be zero. There is no different between full speed and half speed because clock source is 240MHz always. On SC13xxx, allowable multiplier values range from 25 to 800,000 (800us). There are also 2 rules to the allowed values: 1,000,000,000 % multiplier must result in zero and 80,000,000 (80MHz) % (1,000,000,000 / multiplier) must also be zero. When device run at half speed, the clock source is 40MHz, and max ranges is 25 to 1,600,000 (1.6ms); The signal generator always start with a signal at low level. It then toggles the signal every x time. The time is fetched from the array given, one by one. Note that by sending an even count of pulses, teh signal will terminate with a high-level as shown below. Starting a second write will cause the signal to first go low, which may not be desired, as it causes an extra pulse on the next Generate. This pulse has a variable with. Making sure that the data Length is always an odd number will assure that the signal will terminate at a low-level. Tip Software-generated SignalGenerator below gives more flexibility but runs in system blocking mode. While SignalGenerator is all Hardware-driven making it very accurate, non-blocking and it does not use processor time. Calling Generate will return immediately (non-blocking) allowing the system to do other tasks while the signal is being generated in the background. When the signal is generated completely, an event is fired. To aid in signal handling, the event provides the final resting level of the signal. OnGenerateFinished => OnGenerateFinished; dsig.OnGenerateFinished += (a, b) => { if (b == GpioPinValue.High) Debug.WriteLine(\"Write done, end state high\"); else Debug.WriteLine(\"Write done, end state low\"); }; Capture The Capture feature returns an array of timestamps of individual durations. The returned values are in nanoseconds. Tip Digital Signal is limited to the timer max value, which comes to be about 17.89 seconds. The waitForEdge helps by only starting the timer when there is an active pulse. var digitalSignalPin = GpioController.GetDefault().OpenPin(SC20260.Timer.DigitalSignal.Controller2.PB3); var digitalSignal = new DigitalSignal(digitalSignalPin); bool waitForEdge = false;// Start capturing as soon as Capture is called // Subscribe event when done capturing digitalSignal.OnCaptureFinished += Digital_OnCaptureFinished; // start capture 100 samples, timeout is 15seconds digitalSignal.Capture(100, GpioPinEdge.RisingEdge | GpioPinEdge.FallingEdge, waitForEdge, TimeSpan.FromSeconds(15)); // Wait for finish capture // do other work Thread.Sleep(Timeout.Infinite); // The event private static void Digital_OnCaptureFinished(DigitalSignal sender, uint[] buffer, uint count, GpioPinValue pinValue) { if (count == 0) { Debug.WriteLine(\"no data was captured!\"); return; } for (int i = 0; i < count; i++) { Debug.WriteLine(\"Sample [\" + i +\"]: \"+ buffer[i]+\" ns\"); } } Note The first captured pulse will likely have an inaccurate (shorter) value due to system prep-time. ReadPulse ReadPulse can be used to measure frequency and other analyses that require measuring time duration for specific pulse count. var digitalSignalPin = GpioController.GetDefault().OpenPin(SC20260.Timer.DigitalSignal.Controller2.PB3); var digitalSignal = new DigitalSignal(digitalSignalPin); bool waitForEdge = true;// wait for first pulse before starting the measurement // Subscribe event when done reading digitalSignal.OnReadPulseFinished += Digital_OnReadPulseFinished; // Start reading 1000 pulses digitalSignal.ReadPulse(1000, GpioPinEdge.RisingEdge, waitForEdge); // do other work... Thread.Sleep(Timeout.Infinite); // the event void Digital_OnReadPulseFinished(DigitalSignal sender, TimeSpan duration, uint count, GpioPinValue pinValue) { var ticks = duration.Ticks; var microsecond = ((double)duration.Ticks) / 10; var millisecond = ((double)duration.Ticks) / 10000; var freq = (count / microsecond) * 1000000; Debug.WriteLine(\"GpioPinValue = \" + ((pinValue == GpioPinValue.High) ? \"High\" : \"Low\")); Debug.WriteLine(\"PulseCount = \" + count); Debug.WriteLine(\"Duration ticks = \" + ticks); Debug.WriteLine(\"Duration microsecond = \" + microsecond); Debug.WriteLine(\"Duration millisecond = \" + millisecond); Debug.WriteLine(\"freq = \" + freq / 1000.0 + \" KHz\"); } Abort An event is fired when any DigitalSignal operation is completed. In some cases, it may be desired to terminate the operation early, using Abort. When aborted, an event is still triggered, which will contain whatever data/pulses was collected from the trigger to the time Abort was called. var digitalSignalPin = GpioController.GetDefault().OpenPin(SC20260.Timer.DigitalSignal.Controller2.PB3); var digitalSignal = new DigitalSignal(digitalSignalPin); var waitForEdge = false; digitalSignal.OnReadPulseFinished += Digital_OnReadPulseFinished while (true) { if (digitalSignal.CanReadPulse) { digitalSignal.ReadPulse(1000, GpioPinEdge.RisingEdge, waitForEdge); Thread.Sleep(1000); digitalSignal.Abort(); Debug.WriteLine(\"Aborted\"); } } void Digital_OnReadPulseFinished(DigitalSignal sender, TimeSpan duration, uint count, GpioPinValue pinValue) { if (count > 0) { var microsecond = ((double)duration.Ticks) / 10; var freq = (count / microsecond) * 1000000; Debug.WriteLine(\"freq = \" + freq / 1000.0 + \" KHz\"); } else { Debug.WriteLine(\"No clock found.\"); } } Tip In the sample code above you can use PWM to provide the pulse needed to verify the code. Keep in mind that both PWM and DigitalSignal share resources, so a different Timer controller must be used. Pulse Feedback The PulseFeedback class can be used in three different modes. These modes are used to measure Echo Duration, Duration Until Echo, and Drain Duration. Echo Duration Echo Duration sends a trigger pulse of a given state over the provided pin. It then waits for an echo on the other specified pin and measures the length of that echo pulse. The trigger and echo pins cannot be the same pin. The following code will read the distance in centimeters from an HC-SR04 ultrasonic distance sensor. This sensor has a trigger pin that is pulsed high to start distance measurement. It has a separate echo pin that the sensor holds high until it receives an echo. Therefore, the time the echo pin is high represents the time it takes for the sound to hit the target and reflect back to the sensor. To test this code, I plugged the sensor directly into the SCM20260D Dev board and ran a couple short wires for power. It was convenient having 5V on the header. I was surprised how well this inexpensive sensor worked. Note The HC-SR04 ultrasonic distance sensor requires a 5 volt power supply. While the module accepts 3.3 volt logic on the Trig and Echo pins, it will not work with a 3.3 volt supply for power. var gpio = GpioController.GetDefault(); var distanceTriggerPin = gpio.OpenPin(SC20260.GpioPin.PA15); var distanceEchoPin = gpio.OpenPin(SC20260.GpioPin.PJ14); pulseFeedback = new PulseFeedback(distanceTriggerPin, distanceEchoPin, PulseFeedbackMode.EchoDuration) { DisableInterrupts = false, Timeout = System.TimeSpan.FromSeconds(1), PulseLength = System.TimeSpan.FromTicks(100), EchoValue = GpioPinValue.High, PulseValue = GpioPinValue.High, }; while (true) { var time = pulseFeedback.Trigger(); var microseconds = time.TotalMilliseconds * 1000.0; var distance = microseconds * 0.036 / 2.0; Debug.WriteLine(distance.ToString()); Thread.Sleep(Timeout.Infinite); } Duration Until Echo Duration Until Echo is very similar to Echo Duration, although instead of sending a pulse and measuring the length of the resulting echo, it measures how long it takes until that echo is received. Pulse and echo cannot use the same pins. The following code reads the distance in centimeters from a Polaroid 6500 Ranging Module. This module is similar to the HC-SR04 distance sensor, however the time it takes for the sensor to pulse the ECHO pin after your device pulses the INIT must be measured. Tip Needed Nuget: GHIElectronics.TinyCLR.Devices.Signals` var gpio = GpioController.GetDefault(); var distanceTriggerPin = gpio.OpenPin(SC20260.GpioPin.PA15); var distanceEchoPin = gpio.OpenPin(SC20260.GpioPin.PJ14); var pulseFeedback = new PulseFeedback(distanceTriggerPin, distanceEchoPin, PulseFeedbackMode.DurationUntilEcho) { DisableInterrupts = false, Timeout = System.TimeSpan.FromSeconds(1), PulseLength = System.TimeSpan.FromTicks(100), EchoValue = GHIElectronics.TinyCLR.Devices.Gpio.GpioPinValue.High, PulseValue = GHIElectronics.TinyCLR.Devices.Gpio.GpioPinValue.High, }; while (true) { var time = pulseFeedback.Trigger(); var microseconds = time.TotalMilliseconds * 1000.0; var distance = microseconds * 0.036 / 2.0; Debug.WriteLine(distance.ToString()); Thread.Sleep(1000); } Drain Duration In this DrainDuration mode is used to implement capacitive touch. When calling Trigger, the pulse line will be held in the specified state for the specified time and then set to an input. It then measures the time for the pin to change its state. Only the pulse line is used in this mode. Echo pin is ignored. The image below shows a sample circuit. Note that this mode can only be used with a single pin. The following example illustrates the reading of a capacitive touch sensor. It sends a pulse of 10us to charge a capacitor and then measures the length of time it takes the capacitor to discharge on the same pin. It prints out the total discharge duration in milliseconds. It repeats every second. var gpio = GpioController.GetDefault(); var capacitiveSensePin = gpio.OpenPin(SC20260.GpioPin.PJ14); var pulseFeedback = new PulseFeedback(capacitiveSensePin, PulseFeedbackMode.DrainDuration) { DisableInterrupts = false, Timeout = System.TimeSpan.FromSeconds(1), PulseLength = System.TimeSpan.FromMilliseconds(1), PulseValue = GHIElectronics.TinyCLR.Devices.Gpio.GpioPinValue.High, }; while (true) { Debug.WriteLine(pulseFeedback.Trigger().TotalMilliseconds.ToString()); Thread.Sleep(1000); } Signal Capture The SignalCapture class monitors a pin and records any changes (high-low or low-high transitions) of the pin to an array. It is a digital waveform recorder. Each array element is the number of microseconds between each signal change. When calling Read, it blocks other code from executing until it either fills the input buffer or it has captured the number of transitions specified by the count argument. If your signal is shorter than that, the call will never return. Make sure to request only what you plan to capture. The following sample code captures the signal generated by pressing LDR button on the SC20100S Dev board. It will attempt to capture 100 transitions, waiting no more than 10 seconds. It will also enable the pull-up resistor on the pin. It will return the initial state of the pin when it started capturing and how many transitions it captured. Note that the signal capture may record button bounces, resulting in a number of transitions in rapid succession. var gpio = GpioController.GetDefault(); var capturePin = gpio.OpenPin(SC20100.GpioPin.PE3); var capture = new SignalCapture(capturePin); var buffer = new TimeSpan[100]; capture.DisableInterrupts = false; capture.Timeout = TimeSpan.FromSeconds(10); capture.DriveMode = GpioPinDriveMode.InputPullUp; while (true) { var count = capture.Read(out var init, buffer); Thread.Sleep(100); } Signal Generator SignalGenerator is a digital waveform generator. SignalGenerator works by comparing an internal counter to an array of time values, one by one. When the value of the argument matches the counter, the output pin is changed. The time values are in microseconds. SignalGenerator can also be used to generate PWM. Unlike the PWM class, SignalGenerator can be used to generate PWM on any available output pin. It does use processor time -- the higher the frequency the more processor time it uses. At this time, SignalGenerator only operates in blocking mode. While SignalGenerator is running, it will not yield any processor time to other code. The following sample code will blink the user LED on the SC20100S Dev board four times (for one second each time) every five seconds. var gpio = GpioController.GetDefault(); var signalPin = gpio.OpenPin(SC20260.GpioPin.PE11); var signalGen = new SignalGenerator(signalPin); var buffer = new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1), }; signalGen.DisableInterrupts = false; signalGen.IdleValue = GpioPinValue.Low; while (true) { signalGen.Write(buffer); Thread.Sleep(5000); }"
  },
  "software/tinyclr/tutorials/specialized.html": {
    "href": "software/tinyclr/tutorials/specialized.html",
    "title": "Specialized",
    "keywords": "Specialized Some of the specialized low-level features in this section are used to directly access hardware control or change the normal behavior of the SITCore processor. Warning This section is for ADVANCED users. An understanding of how processors & registers work is recommended. Register Access The Marshal class allows us to directly access and modify some of the internal processor's registers. More on this can be found in the Marshal class section. SD Card Control A user may find it necessary to change the clock speed of the SD card. Using the Marshal class, we can directly access the processor and slow down the clock speed of the SD peripheral. Note This may be necessary depending on the design of the final product, or the use of low-cost SD cards. const int SD_CLOCK_ADDRESS_REG = 0x00000004; var clock_divider = 4; // 0,1,2,3 are 25MHz, 4: 12MHz, 5: 10MHz, 6: 8MHz... Marshal.WriteInt32((IntPtr)SD_CLOCK_ADDRESS_REG, clock_divider); Disable Interrupts Interrupts can be disabled and enabled. This is useful in timing critical tasks however interrupts shold only be disabled for a very short time. var isDisabled = Interrupt.IsDisabled(); if (isDisabled == false){ Interrupt.Disable(); } // code.... if (isDisabled == false){ Interrupt.Enable(); } Alternate Functions Some pins on a SITCore processor may offer alternate functions. There is an example in the GPIO section on moving a feature from one pin to another. Temperature The processor's internal temperature can be read as shown in the the Analog In tutorial."
  },
  "software/tinyclr/tutorials/spi.html": {
    "href": "software/tinyclr/tutorials/spi.html",
    "title": "SPI",
    "keywords": "SPI SPI uses three or four wires for transferring data. A SPI bus consists of a single master and one or more slaves. The master will send the clock signal to the slaves over the SCK (Serial Clock) pin. It will also send data over MOSI (Master Out Slave In) pin, while reading incoming data on the MISO (Master In Slave Out) pin. The SCK line is used to determine how fast the data is moved. If you know electronics, this is simply a shift register. The master selects which slave it will swap the data with using the SSEL (Slave SELect) pin, sometimes called CS (Chip Select). In its simplest terms, the master will swap data between itself and the slave. You cannot write data without reading data at the same time. However, often you want to write data and don't care about the incoming data. To do this you can use the Write method. Keep in mind that the Write method is discarding whatever data the slave is sending back. Tip Note that a board running TinyCLR OS is always the SPI master, not the slave. In TinyCLR OS, SPI transfers are dynamically sent in batches that are internally optimized to allow for maximum speed back-to-back transfers. This is helpful when sending large buffers, such as when refreshing displays. Tip Some SPI devices (slaves) can have more than one select pin, like the VS1053 MP3 decoder chip that uses one select pin for data and the other for commands. Both share the three data transfer pins (SCK, MOSI, MISO). var cs = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PE4); var settings = new SpiConnectionSettings() { ChipSelectType = SpiChipSelectType.Gpio, ChipSelectLine = cs, Mode = SpiMode.Mode1, ClockFrequency = 4_000_000, }; var controller = SpiController.FromName(SC20100.SpiBus.Spi4); var device = controller.GetDevice(settings); device.Write(new byte[] { 1, 2 }); //Write something. device.TransferSequential(...); //This is good for reading registers. device.TransferFullDuplex(...); //This is the only one that truly represents how SPI works. SPI Clock Speed SITCore SPI controllers support different clock ranges. SPI Controllers 1, 2 & 3 4 & 5 6 Minimum Speed 188 kHz 469 kHz 250K Maximum Speed 24 MHz 60 MHz 32MHz Note Supported clock speeds are derived/divisible from the Maximum clock frequency. If the requested clock is not divisible, the next lower frequency will be used. This is to keep the clock speed as high as possible, but still at or below the requested speed. For example, on 60Mhz clock, the available options are 60Mhz, 30Mhz, 20Mhz, 15Mhz...etc. If the desired frequency is set to 29Mhz then 20Mhz will be used. The MinClockFrequency and MaxClockFrequency fields can be used at runtime. var controller = SpiController.FromName(SC20100.SpiBus.Spi3); Debug.WriteLine(controller.MinClockFrequency.ToString()); Debug.WriteLine(controller.MaxClockFrequency.ToString()); Bit Ordering TinyCLR supports switching between sending the most significant bit first (MSb) or least significant bit first (LSb). var spiSettings = new SpiConnectionSettings() { DataFrameFormat = SpiDataFrame.MsbFirst // MSb }; var spiSettings = new SpiConnectionSettings() { DataFrameFormat = SpiDataFrame.LsbFirst // LSb }; Software SPI Users have the option to drive (bit bang) SPI bus in software over any of the available GPIOs. var provider = new GHIElectronics.TinyCLR.Devices. Spi.Provider.SpiControllerSoftwareProvider(mosi, miso, clk); Tip Software generated buses are slower and use more resources, but can be used on any pins. SPI Display Helper When partially updating a section of the SPI display, SPI includes a Write method to extract and send the needed data. Partial updates are faster than updating the full screen due to sending fewer bytes over SPI bus. var x = 10; var y = 20; var width = 100; var height = 100; var originalWidth = 160; spi.Write(graphicsBuffer, x, y, width, height, originalWidth, 1, 1); Tip Software SPI doesn't support this method. Pixel Multiplier This feature allows pixels to be multiplied across the screen, allowing larger displays to be used with lesser memory. For example, a 320x240 display can be used with 160x120 graphics buffer if both multipliers, the column and the row, are set to 2. The system will be able to drive the display with only 25% of the needed memory, trading off the resolution. Tip The column and row multipliers are independent from each other. A 320x240 display can be driven with a 320x120 graphics when column multiplier is set to 1 and the row multiplier is set to 2. spi.Write(buffer, x, y, width, height, originalWidth, columnMultiplier, rowMultiplier); Tip Software SPI doesn't support this feature."
  },
  "software/tinyclr/tutorials/sqlite-database.html": {
    "href": "software/tinyclr/tutorials/sqlite-database.html",
    "title": "SQLite Database",
    "keywords": "SQLite Database According to the SQLite homepage, \"SQLite is a software library that implements a self-contained, serverless, zero-configuration, transactional SQL database engine. SQLite is the most widely deployed SQL database engine in the world.\" SQLite lets you set up a database that resides entirely in a single file on a persistent storage device. Tip Needed NuGets: GHIElectronics.TinyCLR.Data.SQLite The code below is a simple example that creates a database file in RAM (SD cards and USB drives can be used as well). A table is created, a few rows are filled, and then this data is read from the database. This data is then iterated over and printed out. ColumnNames returns the name of each of the columns. using System.Collections; using System.Diagnostics; using GHIElectronics.TinyCLR.Data.SQLite; using (var db = new SQLiteDatabase()) { Debug.WriteLine(\"Executing 1...\"); db.ExecuteNonQuery(\"CREATE TABLE Test (Var1 TEXT, Var2 INTEGER, Var3 DOUBLE);\"); Debug.WriteLine(\"Executing 2...\"); db.ExecuteNonQuery(\"INSERT INTO Test(Var1, Var2, Var3) VALUES ('Hello, World!', 25, 3.14);\"); Debug.WriteLine(\"Executing 3...\"); db.ExecuteNonQuery(\"INSERT INTO Test(Var1, Var2, Var3) VALUES('Goodbye, World!', 15, 6.28); \"); Debug.WriteLine(\"Executing 4...\"); db.ExecuteNonQuery(\"INSERT INTO Test (Var1) VALUES('Red'),('Blue'),('Green'),('White');\"); Debug.WriteLine(\"Executing 5...\"); var result1 = db.ExecuteQuery(\"SELECT Var1 FROM Test;\"); Debug.WriteLine(\"Executing 6...\"); var result2 = db.ExecuteQuery(\"SELECT Var1, Var2, Var3 FROM Test WHERE Var2 > 10;\"); Debug.WriteLine(\"Executing 7...\"); var result3 = db.ExecuteQuery(\"SELECT Var1, Var2, Var3 FROM Test WHERE Var2 BETWEEN 24 AND 26\"); Debug.WriteLine(\"Executing 7...\"); Debug.WriteLine(result2.ColumnCount.ToString() + \" \" + result2.RowCount.ToString()); var str = \"\"; //foreach (var j in result1.ColumnNames) // str += j + \" \"; //Debug.WriteLine(str); foreach (ArrayList i in result1.Data) { str = \"\"; foreach (object j in i) str += j.ToString() + \" \"; Debug.WriteLine(str); } foreach (ArrayList i in result2.Data) { str = \"\"; foreach (object j in i) str += j.ToString() + \" \"; Debug.WriteLine(str); } foreach (ArrayList i in result3.Data) { str = \"\"; foreach (object j in i) str += j.ToString() + \" \"; Debug.WriteLine(str); } } Omitted commands & features In order to reduce the memory requirements, some commands and features of SQLite have been omitted. Below is a table of those omitted features. For more information regarding these omissions see the SQLite Website. Omitted Command or Feature ALTER TABLE Executing the statement causes a parse error ANALYZE Command omitted from the build ATTACH ATTACH and DETACH commands are omitted REINDEX Executing the statement causes a parse error AUTOMATIC INDEX Feature omitted from the build AUTHORIZATION Authorization callback feature omitted AUTOINCREMENT Feature omitted from the build AUTOVACCUM Feature omitted from the build BLOB LITERAL Not possible to specify a blob in an SQL statement using X'ABCD' syntax CTE Common Table Expressions omitted from the build DATETIME FUNCS SQL functions julianday(), date(), time(), datetime() and strftime() are not available DEPRECATED Omitted support for interfaces marked deprecated by SQLite EXPLAIN Executing the statement causes a parse error FLAG PRAGMAS PRAGMA commands that query and set boolean properties omitted FOREIGN KEY Foreign key constraint syntax is not recognized HEX INTEGER Support for Hexadecimal integer literals omitted INCRBLOB Support for incremental BLOB I/O omitted INTEGRITY CHECK Support for integrity check pragma omitted LIKE OPTIMIZATION Feature to help resolve LIKE and GLOB operators in a WHERE clause omitted LOAD EXTENSION Extension loading mechanism omitted LOCALTIME \"localtime\" modifier from the date and time functions omitted LOOKASIDE Lookaside memory allocator omitted OR OPTIMIZATION Index together with terms of a WHERE clause connected by the OR operator, disabled. PAGER PRAGMAS Pragmas related to the pager subsystem omitted from the build PRAGMA P ragma command has been omitted PROGRESS CALLBACK \"progress\" callbacks capability during long-running SQL statements omitted. QUICKBALANCE Omitted an alternative, faster B-Tree balancing routine. SCHEMA PRAGMAS Pragmas for querying the database schema from the build omitted SCHEMA VERSION PRAGMAS Pragmas for querying & modifying the database schema and user versions omitted SHARED CACHE Support for shared-cache mode has been omitted SUBQUERY Support for sub-selects and the IN() operator are omitted. TCL VARIABLE \"$\" syntax used to automatically bind SQL variables to TCL variables is omitted. TEMPDB Support for TEMP or TEMPORARY tables omitted TRACE Sqlite3_profile() and sqlite3_trace() interfaces and their associated logic omitted TRIGGER TRIGGER objects omitted. CREATE TRIGGER or DROP TRIGGER commands are unavailable TRUNCATE OPTIMIZATION Removing this feature only affects the speed of operation UTF16 Support for UTF16 text encoding has been omitted. VIRTUALTABLE Virtual Table mechanism in SQLite omitted. XFER OPT Removed optimization that help INSERT INTO...SELECT...run faster WAL Write-ahead log capability omitted. More Info Further details on SQLite can be found at the official SQLite website http://www.sqlite.org/"
  },
  "software/tinyclr/tutorials/stream.html": {
    "href": "software/tinyclr/tutorials/stream.html",
    "title": "Stream Class",
    "keywords": "Stream Class Provides a generic view of a sequence of bytes. This is an abstract class. Tip Need NuGets: GHIElectronics.TinyCLR.Core FileStream var fileStream = new FileStream(@\"A:\\filename.tca\", FileMode.Open); // Allocate a buffer with size fileStream.Length var buffer = new byte[fileStream.Length]; // Read data fileStream.Read(buffer, 0, buffer.Length); MemoryStream var bufferIn = new byte[3] { 1, 2, 3 }; var memoryStream = new System.IO.MemoryStream(); memoryStream.Seek(0, System.IO.SeekOrigin.Begin); memoryStream.Write(bufferIn, 0, bufferIn.Length); var bufferOut = memoryStream.ToArray(); // bufferIn and bufferOut match NetworkStream var myNetworkStream = new NetworkStream(networkSocket); UartStream public class UartStream : Stream { private UartController uart; public UartStream(UartController uart) => this.uart = uart; public override bool CanRead => true; public override bool CanSeek => false; public override bool CanWrite => true; public override long Length => throw new NotImplementedException(); public override long Position { get => throw new NotImplementedException(); set => throw new NotImplementedException(); } public override void Flush() => this.uart.Flush(); public override int Read(byte[] buffer, int offset, int count) { var read = 0; while (read < count){ while (this.uart.BytesToRead == 0) ; read += this.uart.Read(buffer, offset + read, count - read); } return read; } public override long Seek(long offset, SeekOrigin origin) => throw new NotImplementedException(); public override void SetLength(long value) => throw new NotImplementedException(); public override void Write(byte[] buffer, int offset, int count){ var write = 0; while (write < count){ write += this.uart.Write(buffer, offset + write, count - write); } } public override bool DataAvailable => this.uart.BytesToRead > 0; }"
  },
  "software/tinyclr/tutorials/timers.html": {
    "href": "software/tinyclr/tutorials/timers.html",
    "title": "Timers",
    "keywords": "Timers A timer is used to call a method at a specific time. This example will call or invoke the Ticker method after a three second delay, and then it will call Ticker once a second indefinitely. static void Ticker(object o) { Debug.WriteLine(\"Hello!\"); } static void Main() { Timer timer = new Timer(Ticker, null, 3000, 1000); Thread.Sleep(Timeout.Infinite); } A thread can also be created that loops once a second on its own, without being called by a timer. The difference is that a thread that contains a one second sleep will delay for that one second in addition to the time used by other code in the thread. So, if a thread needs 0.5 second to complete what it is doing, sleeping for one second will cause the thread to execute every 1.5 seconds. This also gets more complex as a thread's code can have different processing time in every loop. A timer set to invoke a method every second will do so every second regardless of how long the invoked method takes to execute. However, care must be taken, because if a timer calls a method every 100 milliseconds, but the method needs more than 100 milliseconds to execute, you will end up flooding the system. The best practice is for timers to invoke methods that execute in a very short time."
  },
  "software/tinyclr/tutorials/tls-client.html": {
    "href": "software/tinyclr/tutorials/tls-client.html",
    "title": "TLS Client",
    "keywords": "TLS Client TLS is how the Internet securely works, for banks, airports and security systems. We support TLS 1.3, a global security standard. All encryption, decryption and certification are done in secure internal memory to keep sensitive data safe. Below is simple example showing how to connect to https://www.google.com Tip Needed NuGets: GHIElectronics.TinyCLR.Devices.Network, GHIElectronics.TinyCLR.Networking.Http var url = \"https://www.google.com\"; var certificates = Resources.GetBytes(Resources.BinaryResources.GlobalSign); X509Certificate[] certx509 = new X509Certificate[] { new X509Certificate(certificates) }; int read = 0, total = 0; byte[] result = new byte[512]; try { using (var req = HttpWebRequest.Create(url) as HttpWebRequest){ req.KeepAlive = false; req.HttpsAuthentCerts = certx509; req.ReadWriteTimeout = 2000; using (var res = req.GetResponse() as HttpWebResponse){ using (var stream = res.GetResponseStream()){ do { read = stream.Read(result, 0, result.Length); total += read; System.Diagnostics.Debug.WriteLine(\"read : \" + read); System.Diagnostics.Debug.WriteLine(\"total : \" + total); var page = new String(System.Text.Encoding.UTF8. GetChars(result, 0, read)); System.Diagnostics.Debug.WriteLine(\"Response : \" + page); } while (read != 0); } } } } catch { } Entropy TinyCLR OS uses the internal True Random Number (TRNG) generator to seed the entropy needed. Users can optionally provide their own. networkInterfaceSetting.TlsEntropy = new byte[] { 0, 1, 2, 3 }; Root Certificate A root certificate is needed to access secure websites. TinyCLR OS accepts certificates in both text and binary formats. The following instructions show how to download certificates using Google as an example: First click on the lock icon inside the URL window. Select Certificate (Valid) option. Select the Certificate Path TAB and click on the top Root certificate, select the Root Certificate Next navigate to the Details TAB and click on the Copy to File button. The Certificate Export Wizard page will appear, click Next Select the Base-64 encoded X.509(.CER) file format and click Next Name the file and browse to the location to save. Then click Next An export confirmation message will appear, click OK and then click Finish"
  },
  "software/tinyclr/tutorials/tls-server.html": {
    "href": "software/tinyclr/tutorials/tls-server.html",
    "title": "TLS Server",
    "keywords": "TLS Server Creating a self-signed certificate Many ways exists to reach the same goal, this is example is based on Linux and OpenSSL and creates not only a Server Certificate, but also a CA Certificate. An existing CA Certificate makes it easier for the Client PC trusts the Certificates as he only need to trust the CA Certificate and all Certificates signed by this CA (your own CA) are automatically trusted. This not only makes it easier for testing purposes but also if you need to create more Certificates Create the following 3 files: ca.cnf - ca certificate configuration [req] prompt = no distinguished_name = req_distinguished_name [req_distinguished_name] C = AT ST = MYSTATE L = MYLOCALITY O = MYORGANIZATION server.cnf - server certificate configuration [req] default_bits = 2048 prompt = no default_md = sha256 distinguished_name = req_distinguished_name [req_distinguished_name] C = AT ST = MYSTATE L = MYLOCALITY O = MYORGANIZATION CN = SCM20260D server_v3.ext - server certificate extension authorityKeyIdentifier=keyid,issuer basicConstraints=CA:FALSE keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment subjectAltName = @alt_names [alt_names] DNS.1 = SCM20260D IP.1 = 192.168.0.109 The following steps produce a ca.crt(Certificate Authority) you can publish and import in your PC edit ca.cnf change the values for C, ST, L and O Generate a CA private key $ openssl genrsa -out ca_privatekey.pem 2048 Generate a 10 years valid CA certificate (from Linux Shell) $ openssl req -new -x509 -days 3650 -nodes -key ca_privatekey.pem -sha256 -out ca.crt -config ca.cnf The following steps produce 2 files named serverkey.key and servercert.crt you need to use in your device edit server.cnf change the values for C, ST, L and O change the value of CN, with DNS the FQDN (server.exampledomain.local), NetBIOS Name (SERVER) or IP Address edit server_v3.ext change the values in alt_names section, important to have an entry for the CN value from before important to include CN content from step before! Create a Certificate Signing Request $ openssl req -new -nodes -out server.csr -keyout serverkey.key -config server.cnf Generate a 1 year valid self signed Server Certificate $ openssl x509 -req -in server.csr -CA ca.crt -CAkey ca_privatekey.pem -CAcreateserial -out servercert.crt -days 365 -extfile server_v3.ext Importing the root certificate Install the CA Certificate in \"Current User\" Store Location and \"Trusted Root Certification Authorities\" Certificate store Double click on ca.crt and click Install Certificate.. Make sure Current User is selected. Select Place all certificates in the following store. Click Browse... and select Trusted Root Certification Authorities From this moment your PC will trust all Certificates signed from your CA Removing a root certificate from a PC Either run certmgr.msc or search for cert in Windows 10 Settings and select \"Manage user certificates\" to open Cert Manager for Current User, not for Local Computer Select \"Trusted Root Certification Authorities\" and \"Certificates\", on the right side find your certificate based on the values from ca.cnf This sample of code uses X509Certificate. Place the certificate inside the projects Resources Tip Add using statement: System.Security.Cryptography.X509Certificates; byte[] servercert = Resources.GetBytes(Resources.BinaryResources.servercert); X509Certificate certificate = new X509Certificate(servercert){ PrivateKey = Resources.GetBytes(Resources.BinaryResources.serverkey), }; This sample of code uses SslStream Tip Add using statements: using System.Net.Security & using System.Net.Sockets Socket socket; NetworkStream stream; try{ SslStream sslStream = new SslStream(socket); sslStream.AuthenticateAsServer(certificate, System.Security.Authentication.SslProtocols.Tls12); stream = sslStream; } catch (InvalidOperationException){ } stream.Write(byte[]buffer,int offset, int count); stream.Read(byte[]buffer, int offset, int count); For further information on OpenSSL can be found here."
  },
  "software/tinyclr/tutorials/tls.html": {
    "href": "software/tinyclr/tutorials/tls.html",
    "title": "TLS",
    "keywords": "TLS TLS (Transport Layer Security) is how the Internet securely works, for banks, airports and security systems. TinyCLR OS supports TLS 1.2, a global security standard. All encryption, decryption and certification are done in secure internal memory to keep sensitive data safe. TinyCLR OS can be set up using TLS as a Client or Server."
  },
  "software/tinyclr/tutorials/touch-screen.html": {
    "href": "software/tinyclr/tutorials/touch-screen.html",
    "title": "Touch Screen",
    "keywords": "Touch Screen Introduction Displays may optionally include a touch sensitive screen to detect user touch input. Touch Screens can be resistive or capacitive. Resistive Touch A resistive touch screen measures the resistance across the X and Y axes to determine the touch position. While it is possible to use GPIO and ADC, it is better to use dedicated chips. The only advantage of resistive touch over capacitive is that resistive touch works through a change in resistance induced by finger pressure, meaning you can use it while wearing gloves. However, resistive touch is not very accurate and requires calibration. Unless you have specific reason to use resistive touch, capacitive touch is preferred. The NuGet package GHIElectronics.TinyCLR.Drivers.Touch.ResistiveTouch simplifies the process of adding resistive touch to a project. The code example below details how it is used. var touch = new ResistiveTouchController( 320, // Screen width 240, // Screen height SC20260.GpioPin.PA0, // digital pin support analog SC20260.GpioPin.PA3, // digital pin support analog SC20260.GpioPin.PA5, // digital pin SC20260.GpioPin.PC3, // digital pin SC20260.Adc.Controller1.Id, // Analog controller id SC20260.Adc.Controller1.PA0, // analog channel id SC20260.Adc.Controller1.PA3 // analog channel id ); touch.ScaleX = new Scale(20, 280); // option to get more accurate point touch.ScaleY = new Scale(20, 200); // option to get more accurate point while (true) { Thread.Sleep(100); // poll interval every 100ms var x = touch.X; var y = touch.Y; if (x >= 0 && y >= 0) // detected touch Debug.WriteLine(\"X: \" + x +\", Y = \" + y); } Capacitive Touch Capacitive touch screens are used on most modern devices, including phones. They are very accurate and capable of detecting multiple simultaneous touches. A special capacitive controller chip must be used to read the touch panel. This chip is usually mounted right on the flat cable going to the touch panel. These chips are usually I2C or SPI, with I2C being more common. The capacitive displays used in our development options use a touch controller from FocalTech. We provide the GHIElectronics.TinyCLR.Drivers.FocalTech.FT5xx6 NuGet package to interact with capacitive touch screens. The constructor simply needs to know which I2C bus and reset pin are being used. The event fires giving the exact position using display pixels as units -- there is no need for scaling or calibration. The driver source code is found on the TinyCLR Drivers repo. This simple example will draw a dot on touch move: using GHIElectronics.TinyCLR.Drivers.FocalTech.FT5xx6; var touch = new FT5xx6Controller( i2cController.GetDevice(FT5xx6Controller.GetConnectionSettings()), gpioController.OpenPin(SC20260.GpioPin.PJ14)); touch.Orientation = FT5xx6Controller.TouchOrientation.Degrees0; //Rotate touch coordinates. touch.TouchMove += (_, e) => { screen.FillEllipse(brush, e.X, e.Y, 5, 5); screen.Flush(); };"
  },
  "software/tinyclr/tutorials/uart.html": {
    "href": "software/tinyclr/tutorials/uart.html",
    "title": "UART",
    "keywords": "UART Serial data ports, called UARTs, transfer data between devices using two pins: TXD (transmit data) and RXD (receive data). UART stands for Universal Asynchronous Receiver Transmitter. Asynchronous means there is no clock signal to synchronize the two devices. The devices agree on a data rate, called the baud rate, and send a start bit the beginning of each transmitted character to keep the devices synchronized. Some of the UARTs also have additional pins (RTS and CTS) to control data flow. These pins are only activated when Handshaking = UartHandshake.RequestToSend. Tip the TXD on one end (output) goes to the RXD on the other side (input) and vice versa. Tip UART ports are also referred to as COM ports, especially on PCs.. The easiest way to test a UART is by wiring a device's TXD to its RXD so any transmitted data is received by the same device. This is called a \"loopback\" test. The following code performs a simple loopback test. Tip UART requires the GHIElectronics.TinyCLR.Devices.Uart NuGet package. var txBuffer = new byte[] { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 }; //A, B, C, D, E, F var rxBuffer = new byte[txBuffer.Length]; var myUart = UartController.FromName(SC20100.UartPort.Uart7); var uartSetting = new UartSetting() { BaudRate = 115200, DataBits = 8, Parity = UartParity.None, StopBits = UartStopBitCount.One, Handshaking = UartHandshake.None, }; myUart.SetActiveSettings(uartSetting); myUart.Enable(); myUart.Write(txBuffer, 0, txBuffer.Length); while (true) { if (myUart.BytesToRead > 0) { var bytesReceived = myUart.Read(rxBuffer, 0, myUart.BytesToRead); Debug.WriteLine(Encoding.UTF8.GetString(rxBuffer, 0, bytesReceived)); } Thread.Sleep(20); } UART Settings The UART settings are expanded to better support serial protocols such as RS-485 and DMX. Here's a complete list of the available settings: BaudRate: Communication speed in bits per second. DataBits: Number of data bits in each byte. Usually set to eight. Parity: Parity bit setting. Disabled when set to UartParity.None. StopBits: Number of stop bits sent to mark the end of each byte. Handshaking: Can be set to none or UartHandshake.RequestToSend for hardware handshaking. EnableDePin: Used to enable and disable the Driver Enable pin, which is used for RS-485 communication. InvertTxPolarity: Used to invert high and low states of the transmit pin. Useful for hardware that inverts this signal. InvertRxPolarity: Used to invert high and low states of the receive pin. Useful for hardware that inverts this signal. InvertBinaryData: Used to invert the data polarity without inverting the start and stop bit polarity. SwapTxRxPin: Swaps the transmit and receive pins. Very useful for correcting board layout mistakes! InvertDePolarity: Inverts the polarity of the Driver Enable pin used for RS485. RS485 and Driver Enable Transceivers, such as RS485, may require a DE (Driver Enable) pin. On SITCore, DE pin is same pin as RTS. The UART settings can be used to enable this feature through EnableDePin and InvertDePolarity. RS232 UART uses the processor's voltage levels (logic levels) for transferring data. On the SITCore this is 0 to 3.3 volts. In the early days of computers, UARTs used -12 to +12 volts to communicate reliably over longer distances. This is known as the RS232 standard. Some PCs still include serial ports, but those are RS232 serial ports. A voltage level shifter is needed to properly connect a logic level UART to an RS232 device. Warning Connecting your device to an RS232 port without a proper voltage level shifter can damage your device. Break Generation It is sometimes necessary to generate a break signal before transmission to let the receiver(s) know that a new data frame is starting. Such is the case when using the DMX protocol, which is often used for stage lighting. Note The previous transmission must finish before starting a new transmission that incorporates a break signal. The following code sample shows how to transmit an array of bytes using the DMX protocol: GpioPin dmxEnablePin = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PA1); dmxEnablePin.SetDriveMode(GpioPinDriveMode.Output); dmxEnablePin.Write(GpioPinValue.High); var uart = UartController.FromName(SC20100.UartPort.Uart5); uart.SetActiveSettings(new UartSetting { DataBits = 8, StopBits = UartStopBitCount.Two, BaudRate = 250000 }); uart.Enable(); var txBuffer = new byte[] { 0, 127, 255, 255, 255 }; while (uart.BytesToWrite > 0) Thread.Sleep(0); //Make sure UART is done transmitting. //The following line sends a break of 100 uS before sending the data. uart.Write(txBuffer, 0, txBuffer.Length, TimeSpan.FromTicks(1000)); Event Handlers TinyCLR's UART API included the following event listeners: ClearToSendChanged DataReceived ErrorReceived txBuffer = new byte[] { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 }; //A, B, C, D, E, F rxBuffer = new byte[txBuffer.Length]; myUart = UartController.FromName(SC20100.UartPort.Uart7); var uartSetting = new UartSetting() { BaudRate = 115200, DataBits = 8, Parity = UartParity.None, StopBits = UartStopBitCount.One, Handshaking = UartHandshake.None, }; myUart.SetActiveSettings(uartSetting); myUart.Enable(); myUart.DataReceived += MyUart_DataReceived; myUart.Write(txBuffer, 0, txBuffer.Length); Thread.Sleep(-1); void MyUart_DataReceived(UartController sender, DataReceivedEventArgs e) { var bytesReceived = myUart.Read(rxBuffer, 0, e.Count); Debug.WriteLine(Encoding.UTF8.GetString(rxBuffer, 0, bytesReceived)); } Tip Once you type += after the event, hit the tab key and Visual Studio will automatically create the event for you."
  },
  "software/tinyclr/tutorials/unmanaged-heap.html": {
    "href": "software/tinyclr/tutorials/unmanaged-heap.html",
    "title": "Unmanaged Heap",
    "keywords": "Unmanaged Heap TinyCLR's memory management system takes care of everything in internal secure memory; however, TinyCLR OS also supports external unsecure memory through a special unmanaged heap. This memory is used in two different ways, for Large Buffers and for the Graphics system, and is only available on boards with that include external SDRAM memory. Most SITCore SoMs have 32 MBytes of external SDRAM. To ensure that unmanaged resources get disposed of properly, it is necessary to dispose of the buffer pointing to unmanaged heap manually, as shown in the sample code below. Unmanaged Buffers This is an easy way to create buffers that reside in external memory, which typically provides much more storage than internal memory. The following example creates an array uTable[] in unmanaged heap space on the SCM20260D Dev Board and then disposes of it. Tip Needed Nuget: GHIElectronics.TinyCLR.Native Needed Namespace: GHIElectronics.TinyCLR.Native //Allocate space for 100,000 byte array in unmanaged heap. UnmanagedBuffer uBuffer = new UnmanagedBuffer(100000); var uTable = uBuffer.Bytes; //uTable is now available as a byte array with 100,000 elements. // Properly release the objects. This is unmanaged so it is mandatory! uTable = null; uBuffer.Dispose(); Tip Optionally, users may utilize the built-in cryptography services to encrypt the data before it is loaded into the UnmanagedBuffer Graphical Memory When the graphics engine detects available external memory, it automatically uses it. Also, garbage collection will dispose of unmanaged graphics buffers automatically. You do not have to dispose of unmanaged graphics buffers like you do for unmanaged non-graphic buffers. Helper Methods //Print number of available bytes in unmanaged memory. System.Diagnostics.Debug.WriteLine(Memory.UnmanagedMemory.FreeBytes.ToString()); //Print the number of bytes being used in unmanaged memory. System.Diagnostics.Debug.WriteLine(Memory.UnmanagedMemory.UsedBytes.ToString());"
  },
  "software/tinyclr/tutorials/usb-client.html": {
    "href": "software/tinyclr/tutorials/usb-client.html",
    "title": "USB Client",
    "keywords": "USB Client By default, USB client support is used for deploying and debugging applications. However, deploying and debugging can be switched to a serial mode using MOD pin, freeing the USB Client port to serve other purposes. The USB port can also be freed by completely disabling the USB debug interface, which is a feature of ip protection. Tip Feature found in the GHIElectronics.TinyCLR.Devices.UsbClient NuGet and namespace USB Mouse In this mode, the hardware acts as a USB mouse. The driver supports absolute and relative modes. In relative mode, the MoveCursor method will move the cursor from current location, where ever it might be. Meaning, MoveCursor(10,0) followed by MoveCursor(-10,0) will move the cursor and immediately move it back where it started. In absolute mode, MoveCursor sets the cursor from (0,0), which is in the top left corner of the screen. var usbclientController = UsbClientController.GetDefault(); var absolutePosition = true; var mouse = new Mouse(usbclientController, absolutePosition); mouse.DeviceStateChanged += UsbClientDeviceStateChanged; mouse.Enable(); //... void UsbClientDeviceStateChanged(RawDevice sender, DeviceState state) { var i = 0.0; if (state == DeviceState.Configured) { new Thread(() => { while (true) { ((Mouse)sender).MoveCursor( Mouse.MaxRange /4 + (int)(Math.Cos(i) * Mouse.MaxRange / 10), Mouse.MaxRange /4 + (int)(Math.Sin(i) * Mouse.MaxRange / 10)); i+=0.03; Thread.Sleep(50); } }).Start(); } } USB Keyboard A USB Keyboard is simulated in this mode. The keys used can be Press, Release or Stroke (which is same as a Press followed by Release). var usbClientSetting = new UsbClientSetting() { ManufactureName = \"Manufacture_Name\", ProductName = \"Product_Name\", SerialNumber = \"serialnumber\", }; var usbclientController = UsbClientController.GetDefault(); var kb = new Keyboard(usbclientController, usbClientSetting); var key = new Key[] { Key.G, Key.H, Key.I, Key.Space, Key.E, Key.L, Key.E, Key.C, Key.T, Key.R, Key.O, Key.N, Key.I, Key.C, Key.S }; kb.Enable(); while (kb.DeviceState != DeviceState.Configured) Thread.Sleep(100);// wait or use events kb.Press(Key.LeftShift);// hold shift down for (var i = 0; i < key.Length; i++) { kb.Stroke(key[i]); Thread.Sleep(500);// type it twice a second } kb.Release(Key.LeftShift);// release shift USB Joystick Devices running TinyCLR OS can simulate a Joystick. var usbclientController = UsbClientController.GetDefault(); var usbClientSetting = new UsbClientSetting() { ManufactureName = \"Manufacture_Name\", ProductName = \"Product_Name\", SerialNumber = \"serialnumber\", }; var joystick = new Joystick(usbclientController, usbClientSetting); joystick.DeviceStateChanged += UsbClientDeviceStateChanged; joystick.Enable(); Thread.Sleep(Timeout.Infinite); //... void UsbClientDeviceStateChanged(RawDevice sender, DeviceState state) { if (state == DeviceState.Configured) { new Thread(() => { Joystick joystick = (Joystick)sender; while (true) { joystick.PressButton(0); Thread.Sleep(500); joystick.ReleaseButton(0); Thread.Sleep(1000); } }).Start(); } } USB Mass Storage Devices running TinyCLR OS can act as a Mass Storage Device, giving a connected PC access to files. For example, a datalogger can save parameters to an internal SD card but, when USB cable is connected, the datalogger can stop logging data and give the USB bus access to the SD card. This allows a PC to then read the files as if it is reading any USB storage device. SD card var sd = StorageController.FromName(SC20100.StorageController.SdCard); var usbclientController = UsbClientController.GetDefault(); var usbclient_masstorage = new MassStorage(usbclientController); var ready = false; usbclient_masstorage.DeviceStateChanged += (a, b) => { Debug.WriteLine(\"state : \" + b.ToString()); if (b == DeviceState.Configured) ready = true; }; usbclient_masstorage.AttachLogicalUnit(sd.Hdc); usbclient_masstorage.Enable(); while (!ready) ; // Wait few seconds for PC set up new drive QSPI Note When external flash is used for external deployment or any other purposes (Tiny FileSystem), do not enable QSPI for USB Mass Storage. USB Mass Storage uses entire 16MB of QSPI. Once formatted, all data will be lost! var qspi = StorageController.FromName(SC20100.StorageController.QuadSpi); var usbclientController = UsbClientController.GetDefault(); var usbclient_masstorage = new MassStorage(usbclientController); var ready = false; usbclient_masstorage.DeviceStateChanged += (a, b) => { Debug.WriteLine(\"state : \" + b.ToString()); if (b == DeviceState.Configured) ready = true; }; usbclient_masstorage.AttachLogicalUnit(qspi.Hdc); usbclient_masstorage.Enable(); while (!ready); // Wait few seconds for PC set up new drive USB thumb drive var usbHostController = UsbHostController.GetDefault(); StorageController strogareController = null; var usbHostReady = false; usbHostController.OnConnectionChangedEvent += (a, b) => { switch (b.DeviceStatus) { case DeviceConnectionStatus.Connected: switch (b.Type) { case BaseDevice.DeviceType.MassStorage: strogareController = StorageController.FromName(SC20260.StorageController.UsbHostMassStorage); usbHostReady = true; break; } break; } }; usbHostController.Enable(); while (!usbHostReady); var usbclientController = UsbClientController.GetDefault(); var usbclient_masstorage = new MassStorage(usbclientController); var ready = false; usbclient_masstorage.DeviceStateChanged += (a, b) => { Debug.WriteLine(\"state : \" + b.ToString()); if (b == DeviceState.Configured) ready = true; }; usbclient_masstorage.AttachLogicalUnit(strogareController.Hdc); usbclient_masstorage.Enable(); while (!ready); // Wait few seconds for PC set up new drive PC Data Transfer This feature is used to transfer data between the hardware and a PC. See PC Data Comm for details. USB Raw For advanced users, virtually any type of USB device can be created using USB Raw. The USB mouse driver inside GHIElectronics.TinyCLR.Devices.UsbClient is a good example of how this can be achieved."
  },
  "software/tinyclr/tutorials/usb-host.html": {
    "href": "software/tinyclr/tutorials/usb-host.html",
    "title": "USB Host",
    "keywords": "USB Host The USB Host API supports USB keyboards, mice, joysticks, raw devices, and USB MSC (Mass Storage Class), which allows file access on USB memory devices. The following code sample shows how to detect devices as they are connected to your SITCore device's USB host port. Note USB hubs are not currently supported. Special USB memory devices that have multiple interfaces or built in hubs will not work. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Storage, GHIElectronics.TinyCLR.Devices.UsbHost, GHIElectronics.TinyCLR.IO, GHIElectronics.TinyCLR.Native, and GHIElectronics.TinyCLR.Pins. using System.IO; using System.Diagnostics; using System.Threading; using GHIElectronics.TinyCLR.Devices.UsbHost; using GHIElectronics.TinyCLR.Devices.UsbHost.Descriptors; using GHIElectronics.TinyCLR.Devices.Storage; using GHIElectronics.TinyCLR.IO; using GHIElectronics.TinyCLR.Pins; class Program { static void Main() { var usbHostController = UsbHostController.GetDefault(); usbHostController.OnConnectionChangedEvent += UsbHostController_OnConnectionChangedEvent; usbHostController.Enable(); Thread.Sleep(Timeout.Infinite); } private static void UsbHostController_OnConnectionChangedEvent (UsbHostController sender, DeviceConnectionEventArgs e) { Debug.WriteLine(\"e.Id = \" + e.Id + \" \\n\"); Debug.WriteLine(\"e.InterfaceIndex = \" + e.InterfaceIndex + \" \\n\"); Debug.WriteLine(\"e.PortNumber = \" + e.PortNumber); Debug.WriteLine(\"e.Type = \" + ((object)(e.Type)). ToString() + \" \\n\"); Debug.WriteLine(\"e.VendorId = \" + e.VendorId + \" \\n\"); Debug.WriteLine(\"e.ProductId = \" + e.ProductId + \" \\n\"); switch (e.DeviceStatus) { case DeviceConnectionStatus.Connected: switch (e.Type) { case BaseDevice.DeviceType.Keyboard: var keyboard = new Keyboard(e.Id, e.InterfaceIndex); keyboard.KeyUp += Keyboard_KeyUp; keyboard.KeyDown += Keyboard_KeyDown; break; case BaseDevice.DeviceType.Mouse: var mouse = new Mouse(e.Id, e.InterfaceIndex); mouse.ButtonChanged += Mouse_ButtonChanged; mouse.CursorMoved += Mouse_CursorMoved; break; case BaseDevice.DeviceType.Joystick: var joystick = new Joystick(e.Id, e.InterfaceIndex); joystick.CursorMoved += Joystick_CursorMoved; joystick.HatSwitchPressed += Joystick_HatSwitchPressed; joystick.ButtonChanged += Joystick_ButtonChanged; break; case BaseDevice.DeviceType.MassStorage: var storageController = StorageController.FromName (SC20260.StorageController.UsbHostMassStorage); var driver = FileSystem.Mount(storageController.Hdc); var driveInfo = new DriveInfo(driver.Name); Debug.WriteLine(\"Free: \" + driveInfo.TotalFreeSpace); Debug.WriteLine(\"TotalSize: \" + driveInfo.TotalSize); Debug.WriteLine(\"VolumeLabel:\" + driveInfo.VolumeLabel); Debug.WriteLine(\"RootDirectory: \" + driveInfo.RootDirectory); Debug.WriteLine(\"DriveFormat: \" + driveInfo.DriveFormat); break; default: // This example is mount keyboard as RawDevice var rawDevice = new RawDevice(e.Id, e.InterfaceIndex, e.Type); var devDesc = rawDevice.GetDeviceDescriptor(); var cfgDesc = rawDevice.GetConfigurationDescriptor(0); rawDevice.SendSetupPacket(0, 9, 1, 0); var endpointData = new byte[7]; endpointData[0] = 7; //Length in bytes of this descriptor. endpointData[1] = 5; //Descriptor type (endpoint). endpointData[2] = 0x81; //Input endpoint address. endpointData[3] = 3; //Transfer type is interrupt endpoint. endpointData[4] = 8; //Max packet size LSB. endpointData[5] = 0; //Max packet size MSB. endpointData[6] = 10; //Polling interval. var endpoint = new Endpoint(endpointData, 0); var pipe = rawDevice.OpenPipe(endpoint); pipe.TransferTimeout = 10; var data = new byte[8]; var read = pipe.Transfer(data); if (read > 0) { Debug.WriteLine(\"Raw Device has new data \" + data[0] + \", \" + data[1] + \", \" + data[2] + \", \" + data[3]); } else if (read == 0) { Debug.WriteLine(\"No new data\"); } Thread.Sleep(500); break; } break; case DeviceConnectionStatus.Disconnected: Debug.WriteLine(\"Device Disconnected\"); //Unmount filesystem if it was mounted. break; case DeviceConnectionStatus.Bad: Debug.WriteLine(\"Bad Device\"); break; } } private static void Keyboard_KeyDown(Keyboard sender, Keyboard.KeyboardEventArgs args) { Debug.WriteLine(\"Key pressed: \" + ((object)args.Which).ToString()); Debug.WriteLine(\"Key pressed ASCII: \" + ((object)args.ASCII).ToString()); } private static void Keyboard_KeyUp(Keyboard sender, Keyboard.KeyboardEventArgs args) { Debug.WriteLine(\"Key released: \" + ((object)args.Which).ToString()); Debug.WriteLine(\"Key released ASCII: \" + ((object)args.ASCII).ToString()); } private static void Mouse_CursorMoved(Mouse sender, Mouse.CursorMovedEventArgs e) { Debug.WriteLine(\"Mouse moved to: \" + e.NewPosition.X + \", \" + e.NewPosition.Y); } private static void Mouse_ButtonChanged(Mouse sender, Mouse.ButtonChangedEventArgs args) { Debug.WriteLine(\"Mouse button changed: \" + ((object)args.Which).ToString()); } private static void Joystick_ButtonChanged(Joystick sender, Joystick.ButtonChangedEventArgs e) { Debug.WriteLine(\"Joystick button changed = \" + ((object)(e.Which)).ToString()); } private static void Joystick_HatSwitchPressed(Joystick sender, Joystick.HatSwitchPressedEventArgs e) { Debug.WriteLine(\"Joystick direction = \" + ((object)(e.Direction)).ToString()); } private static void Joystick_CursorMoved(Joystick sender, Joystick.CursorMovedEventArgs e) { Debug.WriteLine(\"Joystick.move = \" + e.NewPosition.X + \", \" + e.NewPosition.Y); } }"
  },
  "software/tinyclr/tutorials/usb-pc-comm.html": {
    "href": "software/tinyclr/tutorials/usb-pc-comm.html",
    "title": "USB PC Communication",
    "keywords": "USB PC Communication These protocols facilitate communication between the SITCore device and a PC. The USB page has more details and is a prerequisite to this tutorial. By default, USB client support is used for deploying and debugging applications. However, deploying and debugging can be switched to a serial mode using MOD pin, freeing the USB Client port to serve other purposes. The USB port can also be freed by completely disabling the USB debug interface, which is a feature of IP protection. USB CDC The USB Communications Device Class (CDC) is natively supported by Windows and Linux. It is a way for a PC to use a USB port as a virtual serial port. Once loaded, the PC will use this port like any other serial port (COM port). Windows 10 works without the need for any drivers, but earlier operating systems may need a driver. While it works with most operating systems, CDC is typically limited to 64 KBytes/second. Tip Needed NuGets: GHIElectronics.TinyCLR.Devices.UsbClient var usbclientController = UsbClientController.GetDefault(); var usbClientSetting = new UsbClientSetting(){ Mode = UsbClientMode.Cdc, ManufactureName = \"Manufacture_Name\", ProductName = \"Product_Name\", SerialNumber = \"12345678\", }; var cdc = new Cdc(usbclientController, usbClientSetting); cdc.DeviceStateChanged += (a,b) => Debug.WriteLine(\"Connection changed.\"); cdc.DataReceived += (a,count) => Debug.WriteLine(\"Data received:\" + count); cdc.Enable(); while (cdc.DeviceState != DeviceState.Configured); Debug.WriteLine(\"UsbClient Connected\"); // The example will read data from port to dataR array // Copy dataR to dataW array, plus 1 for each element // Write dataW array back to port while (true){ var len = cdc.Stream.BytesToRead; if (len > 0){ var dataR = new byte[len]; var dataW = new byte[len]; int read = cdc.Stream.Read(dataR); for (var i = 0; i < read; i++){ dataW[i] = (byte)(dataR[i] + 1); } cdc.Stream.Write(dataW); } Thread.Sleep(100); } WinUSB The WinUSB drivers are unique to Windows and take advantage of the power and speed of USB to provide faster communication than CDC. The speed is limited by the data processing on the IoT device. Windows 10 loads the drivers automatically, Windows 7 requires drivers. Note Unlike CDC mode, a disadvantage of WinUSB is that it requires a special code on the PC side to read and write to the device. var usbclientController = UsbClientController.GetDefault(); var usbClientSetting = new UsbClientSetting(){ Mode = UsbClientMode.WinUsb, ManufactureName = \"Manufacture_Name\", ProductName = \"Product_Name\", SerialNumber = \"12345678\", Guid = \"{your guid}\", }; var winUsb = new WinUsb(usbclientController, usbClientSetting); winUsb.DeviceStateChanged += (a,b) => Debug.WriteLine(\"Connection changed.\"); winUsb.DataReceived += (a,count) => Debug.WriteLine(\"Data received:\" + count); winUsb.Enable(); while (winUsb.DeviceState != DeviceState.Configured) ; Debug.WriteLine(\"UsbClient Connected\"); // The example will read data from port to dataR array // Copy dataR to dataW array, plus 1 for each element // Write dataW array back to port while (true){ var len = winUsb.Stream.BytesToRead; if (len > 0){ var dataR = new byte[len]; var dataW = new byte[len]; int read = winUsb.Stream.Read(dataR); for (var i = 0; i < read; i++){ dataW[i] = (byte)(dataR[i] + 1); } winUsb.Stream.Write(dataW); } Thread.Sleep(100); } WebUSB Some modern browsers, like Chrome and Edge, include a way to give access to the USB from the web content. TinyCLR CDC and WinUSB already include the necessary descriptors to enable WebUSB. This repo includes a full WebUSBApp and SerialWebUSBApp examples to load onto the device, that is any TinyCLR device. Once loaded, visit https://ghi-electronics.github.io/TinyCLR-WebUSB/ to connect to the device. Note For CDC (Serial Web USB), needs to load SerialWebUSBApp into the device and visit https://ghi-electronics.github.io/TinyCLR-WebUSB/serialwebusb.html User will see TinyCLR WebUsb device as an option to Connect On successful connection the input drop downs are enabled. After selecting Update State the device sends back a message indicating the outcome. In this case the PB0 is set HIGH and the LED turns on. The secret sauce is in using the correct endpoints, which are fixed in both CDC and WinUSB drivers. This line can be used to initiate the class let webusb = new WebUSB(2, 1); which is found inside webusb.js file"
  },
  "software/tinyclr/tutorials/usb.html": {
    "href": "software/tinyclr/tutorials/usb.html",
    "title": "USB",
    "keywords": "USB Being the go-to for modern communication, TinyCLR OS includes a wide range of USB (Universal Serial Bus) services, for both USB Client and USB Host. The USB Client is the default Visual Studio interface, allowing for easy deploying and troubleshooting."
  },
  "software/tinyclr/tutorials/user-interface.html": {
    "href": "software/tinyclr/tutorials/user-interface.html",
    "title": "User Interface",
    "keywords": "User Interface You can use the GHIElectronics.TinyCLR.UI library to create user interfaces for your application. The UI library is inspired by Windows Presentation Foundation on the desktop. Application Management The UI library requires internal management that is handled by the application class. The following code provides a good starting point. Tip Needed NuGets: GHIElectronics.TinyCLR.Devices.Display, GHIElectronics.TinyCLR.UI using GHIElectronics.TinyCLR.Devices.Display; using GHIElectronics.TinyCLR.UI; namespace UserInterfaceExample { class Program : Application { public Program(DisplayController d) : base(d) { } static void Main() { var display = DisplayController.GetDefault(); display.SetConfiguration(new ParallelDisplayControllerSettings { //Your display configuration }); display.Enable(); var app = new Program(display); app.Run(Program.CreateWindow(display)); } private static Window CreateWindow(DisplayController display) { var window = ... return window; } } } Windows While you can have multiple windows in your UI application, it is mandatory to have at least one window. Here is a complete example that shows a window with a gradient brush background. The code is for SCM20260D Dev board with the 4.3 inch display. Tip Needed NuGets: GHIElectronics.TinyCLR.Devices.Display, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.I2c, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Pins, GHIElectronics.TinyCLR.UI, GHIElectronics.TinyCLR.UI.Media using GHIElectronics.TinyCLR.Devices.Display; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Devices.I2c; using GHIElectronics.TinyCLR.Native; using GHIElectronics.TinyCLR.Pins; using GHIElectronics.TinyCLR.UI; using GHIElectronics.TinyCLR.UI.Media; using System.Drawing; namespace UserInterfaceExample { class Program : Application { public Program(DisplayController d) : base(d){ } static Program app; static void Main() { GpioPin backlight = GpioController.GetDefault().OpenPin(SC20260.GpioPin.PA15); backlight.SetDriveMode(GpioPinDriveMode.Output); backlight.Write(GpioPinValue.High); var display = DisplayController.GetDefault(); var controllerSetting = new GHIElectronics.TinyCLR.Devices.Display.ParallelDisplayControllerSettings { Width = 480, Height = 272, DataFormat = GHIElectronics.TinyCLR.Devices.Display.DisplayDataFormat.Rgb565, Orientation = DisplayOrientation.Degrees0, //Rotate display. PixelClockRate = 10000000, PixelPolarity = false, DataEnablePolarity = false, DataEnableIsFixed = false, HorizontalFrontPorch = 2, HorizontalBackPorch = 2, HorizontalSyncPulseWidth = 41, HorizontalSyncPolarity = false, VerticalFrontPorch = 2, VerticalBackPorch = 2, VerticalSyncPulseWidth = 10, VerticalSyncPolarity = false, }; display.SetConfiguration(controllerSetting); display.Enable(); var screen = Graphics.FromHdc(display.Hdc); var controller = I2cController.GetDefault(); app = new Program(display); app.Run(Program.CreateWindow(display)); } private static Window CreateWindow(DisplayController display){ var window = new Window { Height = (int)display.ActiveConfiguration.Height, Width = (int)display.ActiveConfiguration.Width }; window.Background = new LinearGradientBrush (Colors.Blue, Colors.Teal, 0, 0, window.Width, window.Height); window.Visibility = Visibility.Visible; return window; } } } When using the 7\" display with the above code sample, change the display configuration to the following: var controllerSetting = new GHIElectronics.TinyCLR.Devices.Display.ParallelDisplayControllerSettings { Width = 800, Height = 480, DataFormat = DisplayDataFormat.Rgb565, Orientation = DisplayOrientation.Degrees0, //Rotate Display. PixelClockRate = 24000000, PixelPolarity = false, DataEnablePolarity = false, DataEnableIsFixed = false, HorizontalFrontPorch = 16, HorizontalBackPorch = 46, HorizontalSyncPulseWidth = 1, HorizontalSyncPolarity = false, VerticalFrontPorch = 7, VerticalBackPorch = 23, VerticalSyncPulseWidth = 1, VerticalSyncPolarity = false, }; This code is for the SC20100S Dev Board with the N18 1.8 inch display. Tip Needed NuGets: GHIElectronics.TinyCLR.Devices.Display, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.Spi, GHIElectronics.TinyCLR.Drivers.Sitronix.ST7735, GHIElectronics.TinyCLR.Pins, GHIElectronics.TinyCLR.UI, GHIElectronics.TinyCLR.UI.Media using GHIElectronics.TinyCLR.Devices.Display; using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Devices.Spi; using GHIElectronics.TinyCLR.Drivers.Sitronix.ST7735; using GHIElectronics.TinyCLR.Pins; using GHIElectronics.TinyCLR.UI; using GHIElectronics.TinyCLR.UI.Media; using System; using System.Drawing; namespace SC20100_N18_WPF{ class Program : Application{ public Program(int width, int height) : base(width, height){ } private static ST7735Controller st7735; private const int SCREEN_WIDTH = 160; private const int SCREEN_HEIGHT = 128; private static void Main(){ var spi = SpiController.FromName(SC20100.SpiBus.Spi3); var gpio = GpioController.GetDefault(); st7735 = new ST7735Controller( spi.GetDevice(ST7735Controller.GetConnectionSettings (SpiChipSelectType.Gpio, SC20100.GpioPin.PD10)), //CS pin. gpio.OpenPin(SC20100.GpioPin.PC4), //RS pin. gpio.OpenPin(SC20100.GpioPin.PE15) //RESET pin. ); var backlight = gpio.OpenPin(SC20100.GpioPin.PE5); backlight.SetDriveMode(GpioPinDriveMode.Output); backlight.Write(GpioPinValue.High); st7735.SetDataAccessControl(true, true, false, false); //Rotate the screen. st7735.SetDrawWindow(0, 0, SCREEN_WIDTH-1, SCREEN_HEIGHT-1); st7735.Enable(); Graphics.OnFlushEvent += Graphics_OnFlushEvent; app = new Program(SCREEN_WIDTH, SCREEN_HEIGHT); app.Run(Program.CreateWindow(SCREEN_WIDTH, SCREEN_HEIGHT)); } private static void Graphics_OnFlushEvent(Graphics sender, byte[] data, int x, int y, int width, int height, int originalWidth){ st7735.DrawBuffer(data); } private static Window CreateWindow(int width, int height){ var window = new Window{ Height = height, Width = width }; window.Background = new LinearGradientBrush Colors.Blue, Colors.Red, 0, 0, window.Width, -20); window.Visibility = Visibility.Visible; return window; } } } Elements A window is not very useful without some elements (controls). There are many available standard elements, and you can make your own custom elements as well. All elements descend from the UIElement class. Explore the GHIElectronics.TinyCLR.UI.Controls namespace to see what's available. For the sake of simplifying the rest of this tutorial, we've added the private static UIElement Elements() method that creates and returns the elements. This is then assigned to the child of our window. You will need to add window.Child = Elements() right before returning from CreateWindow. Tip This example needs a font. private static UIElement Elements() { var txt = new TextBox { Font = font, Text = \"Hello World!\", HorizontalAlignment = HorizontalAlignment.Center, VerticalAlignment = VerticalAlignment.Center }; return txt; } TextBox The TextBox allows for both single line and multiple line text input. var textBox = new TextBox() { Text = \"This is TextBox\", Font = fontB, Width = 120, Height = 25, HorizontalAlignment = HorizontalAlignment.Center, VerticalAlignment = VerticalAlignment.Center, }; Panel A Window can carry only a single Child, that is a single element. This is not a concern because the single element can be a container, like a Panel, which holds multiple elements. You can even have panels within panels with each having its own elements. This example will introduce shapes found in the GHIElectronics.TinyCLR.UI.Shapes namespace. It also shows an example of the TextBox element. We will also set margins for a better look. private static UIElement Elements() { var panel = new Panel(); var txt1 = new TextBox() { HorizontalAlignment = HorizontalAlignment.Left, VerticalAlignment = VerticalAlignment.Top, }; txt1.Font = font; txt1.SetMargin(20); txt1.Text = \"Hello World!\"; var txt2 = new Text(font, \"TinyCLR is Great!\") { ForeColor = Colors.White, HorizontalAlignment = HorizontalAlignment.Right, }; txt2.SetMargin(20); var rect = new Rectangle(200, 10) { Fill = new SolidColorBrush(Colors.Green), HorizontalAlignment = HorizontalAlignment.Center, }; panel.Children.Add(txt1); panel.Children.Add(txt2); panel.Children.Add(rect); return panel; } StackPanel There are also two types of elements that descend from panels, Canvas and StackPanel. The Canvas control allows elements to be added anywhere. StackPanels, on the other hand, place elements in order. We will modify the previous example to use a vertical StackPanel. The elements will stack and be arranged to the right and the left. Note that setting vertical alignment will be ignored as the vertical StackPanel overrides how elements are stacked. private static UIElement Elements() { var panel = new StackPanel(Orientation.Vertical); var txt1 = new TextBox() { HorizontalAlignment = HorizontalAlignment.Left, VerticalAlignment = VerticalAlignment.Top, }; txt1.Font = font; txt1.SetMargin(20); txt1.Text = \"Hello World!\"; var txt2 = new Text(font, \"TinyCLR is Great!\") { ForeColor = Colors.White, HorizontalAlignment = HorizontalAlignment.Right, }; txt2.SetMargin(20); var rect = new Rectangle(200, 10) { Fill = new SolidColorBrush(Colors.Green), HorizontalAlignment = HorizontalAlignment.Center, }; panel.Children.Add(txt1); panel.Children.Add(txt2); panel.Children.Add(rect); return panel; } Canvas The Canvas element provides pixel level control over the placement of its child controls. The Width and Height properties of Canvas are requested dimensions, but the actual size depends on the size of the parent element. The ActualWidth and ActualHeight properties can be used to determine the actual size of the Canvas. Controls within a Canvas are positioned relative to the four edges of the Canvas. private static UIElement Elements() { var canvas = new Canvas(); var txt = new Text(font, \"TinyCLR is Great!\") { ForeColor = Colors.White, }; var rect = new Rectangle(150, 30) { Fill = new SolidColorBrush(Colors.Green), HorizontalAlignment = HorizontalAlignment.Center, }; Canvas.SetLeft(rect, 20); Canvas.SetBottom(rect, 20); canvas.Children.Add(rect); Canvas.SetLeft(txt, 30); Canvas.SetBottom(txt, 25); canvas.Children.Add(txt); return canvas; } Border This element defines a border inside another element. The position of child elements is constrained to the area inside the border. In this example the border thickness is set to 10, but if the children do not fill the area within the border, the border's thickness will automatically increase. Uncomment the two alignment lines to see an undesired effect of how borders work. private static UIElement Elements() { var border = new Border(); border.SetBorderThickness(10); border.BorderBrush = new SolidColorBrush(Colors.Red) var txt = new TextBox() { //HorizontalAlignment = HorizontalAlignment.Center, //VerticalAlignment= VerticalAlignment.Center, }; txt.Font = font; txt.Text = \"TinyCLR is Great!\"; border.Child = txt; return border; } The fix is to add a container and then the container will have a border. In this example, the parent of the border is the canvas instead of the window. private static UIElement Elements() { var canvas = new Canvas(); var border = new Border(); border.SetBorderThickness(10); border.BorderBrush = new SolidColorBrush(Colors.Red); Canvas.SetLeft(border, 20); Canvas.SetTop(border, 20); var txt = new TextBox(); txt.Font = font; txt.Text = \"TinyCLR is Great!\"; border.Child = txt; canvas.Children.Add(border); return canvas; } Button Buttons are simple controls that accept user input in the form of a click, which in embedded devices is usually a finger tap on a touch screen. The button needs a child, typically text, which describes the button's function. Buttons have a Click event to respond to user input. private static UIElement Elements() { var txt = new Text(font, \"Push me!\") { VerticalAlignment = VerticalAlignment.Center, HorizontalAlignment = HorizontalAlignment.Center, }; var button = new Button() { Child = txt, Width = 100, Height = 40, }; button.Click += Button_Click; return button; } private static void Button_Click(object sender, RoutedEventArgs e) { // Add button click event code here... } TextFlow TextFlow is a more powerful version of TextBlock that supports more advanced text formatting, and works well with large blocks of text. private static UIElement Elements() { var textFlow = new TextFlow(); textFlow.TextRuns.Add(\"Hello \", font, Colors.Red); textFlow.TextRuns.Add(\"World!\", font, Colors.Purple); textFlow.TextRuns.Add(TextRun.EndOfLine); textFlow.TextRuns.Add(\"TinyCLR is Great!\", font, Colors.Yellow); return textFlow; } ListBox This element provides a list of options for users to select from. private static UIElement Elements() { var listBox = new ListBox(); listBox.Items.Add(new Text(font, \"Item 1\")); listBox.Items.Add(new Text(font, \"Item 2\")); listBox.Items.Add(new Text(font, \"Item 3\")); listBox.Items.Add(new Text(font, \"Item 4\")); return listBox; } It is also possible to add a separator between items, simply by using a rectangle. This item will be set to be not selectable. private static UIElement Elements() { var rect = new Rectangle() { Height = 1, Width=30, Stroke = new Pen(Colors.Black), }; var separator = new ListBoxItem() { Child = rect, IsSelectable = false, }; separator.SetMargin(2); var listBox = new ListBox(); listBox.Items.Add(new Text(font, \"Item 1\")); listBox.Items.Add(new Text(font, \"Item 2\")); listBox.Items.Add(separator); listBox.Items.Add(new Text(font, \"Item 3\")); listBox.Items.Add(new Text(font, \"Item 4\")); return listBox; } ScrollViewer The scroll viewer allows for viewing content that is larger than the viewing area. User input is used to shift the content within the viewing area. // Create a scrollviewer var scrollViewer = new ScrollViewer { Background = new SolidColorBrush(Colors.Gray), // scroll line by line with 10 pixels per line ScrollingStyle = ScrollingStyle.LineByLine, LineWidth = 10, LineHeight = 10 }; Register Touch event, items in scrollViewer will go up or down every time touched. scrollViewer.TouchUp += ScrollViewer_TouchUp; private void ScrollViewer_TouchUp(object sender, GHIElectronics.TinyCLR.UI.Input.TouchEventArgs e) { var s = (ScrollViewer)sender; s.LineDown(); } MessageBox var font = \"user font\"; var messageBox = new MessageBox(font); messageBox.Show(\"Is this messageBox?\", \"MessageBox caption\", MessageBox.MessageBoxButtons.YesNo); messageBox.ButtonClick += (a, b) => { Debug.WriteLine(b.DialogResult.ToString()); }; Slider var slider = new Slider(30, 150); slider.Direction = Orientation.Vertical; slider.OnValueChanged += (a, b) => Debug.WriteLine(\"new value = \" + b.Value); DataGrid var gridWidth = 400; var rowCount = 5; var columnWidth = 60; var rowHeight = 60; var font = \"user font\"; var dataGrid = new DataGrid(gridWidth, rowHeight, rowCount, font); var colum1 = new DataGridColumn(\"Column 1\", columnWidth); var colum2 = new DataGridColumn(\"Column 2\", columnWidth); var colum3 = new DataGridColumn(\"Column 3\", columnWidth); var item123 = new DataGridItem(new string[] { \"item 1\", \"item 2\", \"item 3\" }); var item456 = new DataGridItem(new string[] { \"item 4\", \"item 5\", \"item 6\" }); // Add column dataGrid.AddColumn(colum1); dataGrid.AddColumn(colum2); dataGrid.AddColumn(colum3); // Add Item dataGrid.AddItem(item123); dataGrid.AddItem(item456); // Touch Event dataGrid.TapCellEvent += (a, b) => { Debug.WriteLine(b.ToString()); }; Chart var chartData = new ArrayList(); var random = new Random(); for (var i = 0; i < 10; i++) { chartData.Add(new DataItem() { Value = random.Next(100), Name = $\"N{i}\" }); } var chart = new Chart(400, 200) { Font = 'your font', // need font DivisionAxisX = 1, DivisionAxisY = 10, RadiusPoint = 10, ChartTitle = \"TinyCLR Chart\", Items = chartData, Mode = ChartMode.RectangleMode }; The Dispatcher The User Interface libraries rely on a dispatcher to handle system events and update invalidated elements. All elements are changed and updated from within the dispatcher. In this example, we will show the time on the screen. The time will be in a text box that is updated every second using a Timer. Since timers run in their own thread, a dispatcher invoke is needed. static void Counter(object o) { Application.Current.Dispatcher.Invoke(TimeSpan.FromMilliseconds(1), _ => { Text txt = (Text)o; txt.TextContent = DateTime.Now.ToString(); txt.Invalidate(); return null; }, null); } private static UIElement Elements() { var txt = new Text(font, \"Hello World!\") { ForeColor = Colors.White, VerticalAlignment = VerticalAlignment.Center, HorizontalAlignment = HorizontalAlignment.Center, }; Timer timer = new Timer(Counter, txt, 2000, 1000); return txt; } You can also use the dispatcher timer directly: private static UIElement Elements() { var txt = new Text(font, \"Hello World!\") { ForeColor = Colors.White, VerticalAlignment = VerticalAlignment.Center, HorizontalAlignment = HorizontalAlignment.Center, }; var timer = new DispatcherTimer(); timer.Tag = txt; timer.Tick += Counter; timer.Interval = new TimeSpan(0, 0, 1); timer.Start(); return txt; } private static void Counter(object sender, EventArgs e) { var txt = (Text)((DispatcherTimer)sender).Tag; txt.TextContent = DateTime.Now.ToString(); txt.Invalidate(); } User Input A user can feed input to the graphical interface through touch or button input. Touch input app.InputProvider.RaiseTouch(x, y, touchState, DateTime.UtcNow); app.InputProvider.RaiseButton(btn, btnState, DateTime.UtcNow); The touch tutorial has further details. Button input User can map gpio pin to button left, right, back, home or select. Below is how to use left, right on MessageBox, assuming that Left is Yes, Right is No. //Declare gpio pin cs var buttonLeft = gpioController.OpenPin(SC20100.GpioPin.PE3); var buttonRight = gpioController.OpenPin(SC20100.GpioPin.PB7); buttonLeft.SetDriveMode(GpioPinDriveMode.InputPullUp); buttonRight.SetDriveMode(GpioPinDriveMode.InputPullUp); buttonLeft.DebounceTimeout = TimeSpan.FromMilliseconds(50); buttonRight.DebounceTimeout = TimeSpan.FromMilliseconds(50); buttonLeft.ValueChangedEdge = GpioPinEdge.RisingEdge; buttonRight.ValueChangedEdge = GpioPinEdge.RisingEdge; // Map to Input event buttonLeft.ValueChanged += (a, b) => { Program.MainApp.InputProvider.RaiseButton(GHIElectronics.TinyCLR.UI.Input.HardwareButton.Left, true, DateTime.UtcNow); }; buttonRight.ValueChanged += (a, b) => { Program.MainApp.InputProvider.RaiseButton(GHIElectronics.TinyCLR.UI.Input.HardwareButton.Right, true, DateTime.UtcNow); }; // Usage: void TestMessageBox(int counter) { var messageBox = new MessageBox(this.font12); // assuming font12 load from resource. Example: font12 = Resources.GetFont(Resources.FontResources.droid_reg12); this.mainStackPanel.Children.Add(messageBox); // messagebox to parent Element, here is this.mainStackPanel: example mainStackPanel = new StackPanel(Orientation.Vertical); messageBox.AddHandler(Buttons.ButtonUpEvent, new RoutedEventHandler(ProcessMessageboxButtons), true); messageBox.Show(\"Counter \" + counter.ToString() + \". Are you sure?\", \"Confirm\", MessageBox.MessageBoxButtons.YesNo); Buttons.Focus(messageBox); // focus event to messagebox // Use touch if touch is available. messageBox.ButtonClick += (a, b) => { if (b.DialogResult == MessageBox.DialogResult.Yes) { Debug.WriteLine(\"Press yes\"); } }; // Process gpio button events void ProcessMessageboxButtons(object sender, RoutedEventArgs e) { var buttonSource = (GHIElectronics.TinyCLR.UI.Input.ButtonEventArgs)e; switch (buttonSource.Button) { case GHIElectronics.TinyCLR.UI.Input.HardwareButton.Left: Debug.WriteLine(\"Button left - \"Yes\" pressed\"); break; case GHIElectronics.TinyCLR.UI.Input.HardwareButton.Right: Debug.WriteLine(\"Button Right - \"No\" pressed\"); break; case GHIElectronics.TinyCLR.UI.Input.HardwareButton.Select: Debug.WriteLine(\"Button Select pressed\"); break; } messageBox.Close(); // close messagebox } this.mainStackPanel.Invalidate(); // parent Invalidate }"
  },
  "software/tinyclr/tutorials/vnc.html": {
    "href": "software/tinyclr/tutorials/vnc.html",
    "title": "VNC (Virtual Network Computing)",
    "keywords": "VNC (Virtual Network Computing) Users can use a VNC viewer to remotely view and control SITCore hardware from a PC, Phone or Tablet. Tested and compatible with the following VNC viewers: TightVNC Viewer 2.8.27 TightVNC Java Viewer 2.8.3 UltraVNC 1.2.4.0 bVNC: Secure VNC Viewer APP Tip RealVNC is not supported. The only requirement to connect is the IP address of the Remote Host (SITCore device). The Preferred encoding format should be set to Raw. From here, the TinyCLR Graphics will appear in the VNC client window. Additionally, the VncServer receives Mouse coordinates & click status from the VNC client and are returned in the PointerChangedEvent. Tip Needed NuGets: GHIElectronics.TinyCLR.Vnc; static VncServer vncServer; // To do: Setup the preferred network connection here // ... // Start VNC vncServer = new VncServer(\"VNC Viewer\", 5900, 320, 240); vncServer.PointerChangedEvent += S_PointerChangedEvent; vncServer.Start(); Debug.WriteLine(\"VNC started\"); // Start Drawing! Graphics vncDisplay = Graphics.FromImage(new Bitmap(320, 240)); var font = Resources.GetFont(Resources.FontResources.Arial); var cnt = 0; Graphics.OnFlushEvent += Graphics_OnFlushEvent; while (true) { vncDisplay.Clear(); vncDisplay.DrawString(cnt + \" SITCore VNC ! \", font, new SolidBrush(Color.Yellow), 15, 20); vncDisplay.DrawEllipse(new Pen(Color.Red), cnt, 160, 40, 40); vncDisplay.Flush(); if ((cnt += 5) > 320) { cnt = 0; vncDisplay.Clear(); } Thread.Sleep(10); } } void S_PointerChangedEvent(int x, int y, bool pressed) { Debug.WriteLine(\"x = \" + x + \", y = \" + y + \", press: \" + pressed); } void Graphics_OnFlushEvent(Graphics sender, byte[] data, int x, int y, int width, int height, int originalWidth) { vncServer.Send(data, x, y, width, height); }"
  },
  "software/tinyclr/tutorials/watchdog-timer.html": {
    "href": "software/tinyclr/tutorials/watchdog-timer.html",
    "title": "Watchdog",
    "keywords": "Watchdog A watchdog timer is used to reset the system if the system fails or locks up. During normal operation, the application will regularly reset the watchdog timer so it never reaches zero and doesn't reset the system. Note Once Watchdog is enabled it can't be disabled without resetting the system or a power cycle. Tip Needed NuGets: GHIElectronics.TinyCLR.Devices.Watchdog It's recommend to run Watchdog inside a thread in the application. new Thread(RunWatchDog).Start(); static void RunWatchDog() { // Set watchdog to 5 seconds and reset it every 4 seconds var WatchDog = WatchdogController.GetDefault(); WatchDog.Enable(5000); while (true) { //reset the timer WatchDog.Reset(); Thread.Sleep(4000); } } Tip Set your Watchdog timer to a reasonable amount of time, setting it too low will cause the application to constantly reset. Note Enabling the watchdog timer when debugging is a bad idea since the system will probably reset while stepping through code."
  },
  "software/tinyclr/tutorials/wifi.html": {
    "href": "software/tinyclr/tutorials/wifi.html",
    "title": "WiFi",
    "keywords": "WiFi SITCore line of products includes native support for the Microchip ATWINC1500 series of WiFi modules. These modules are available pre-certified from FCC, CE, and other regulatory agencies. For added security, WiFi module communication is handled through SPI, not through AT commands. Important To take security to the next level, all network cryptography and security are done internally inside SITCore and not inside the WiFi module, meaning the data going over SPI is all encrypted and secure. Supported Modules ATWINC1500 & 1510 both work identically with SITCore, except the 1510 has more memory that SITCore doesn't need. The part number with the correct firmware that has been tested with TinyCLR is ATWINC1500-MR210PB. A module with a different firmware version can still be used, but a firmware update becomes necessary. Using the exact version eliminates the need for this step. Sample Code The sample code is meant for the FEZ Portal with it's built in WiFi module. If you want to use a bare ATWINC1500 module instead, you'll need to connect interrupt, reset, and chip select lines in addition to the SPI lines (MOSI, MISO, SCK). The user can overide the WiFi built-in MAC address, but not recommended. Important If using WiFi 7 click module, there is an enable pin which needs to be pulled high. Tip Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices.Gpio, GHIElectronics.TinyCLR.Devices.Network, GHIElectronics.TinyCLR.Devices.Spi, GHIElectronics.TinyCLR.Devices.Uart, GHIElectronics.TinyCLR.Native, GHIElectronics.TinyCLR.Networking, and GHIElectronics.TinyCLR.Pins. using GHIElectronics.TinyCLR.Devices.Gpio; using GHIElectronics.TinyCLR.Devices.Network; using GHIElectronics.TinyCLR.Devices.Spi; using GHIElectronics.TinyCLR.Pins; using System; using System.Diagnostics; using System.Net; using System.Threading; var enablePinNumber = SC20260.GpioPin.PA8; var chipSelectPinNumber = SC20260.GpioPin.PA6; var irqPinNumber = SC20260.GpioPin.PF10; var resetPinNumber = SC20260.GpioPin.PC3; var spiControllerName = SC20260.SpiBus.Spi3; var gpioControllerName = SC20260.GpioPin.Id; var enablePin = GpioController.GetDefault().OpenPin(enablePinNumber); enablePin.SetDriveMode(GpioPinDriveMode.Output); enablePin.Write(GpioPinValue.High); SpiNetworkCommunicationInterfaceSettings netInterfaceSettings = new SpiNetworkCommunicationInterfaceSettings(); var chipselect = GpioController.GetDefault().OpenPin(chipSelectPinNumber); var settings = new SpiConnectionSettings() { ChipSelectLine = chipselect, ClockFrequency = 4000000, Mode = SpiMode.Mode0, ChipSelectType = SpiChipSelectType.Gpio, ChipSelectHoldTime = TimeSpan.FromTicks(10), ChipSelectSetupTime = TimeSpan.FromTicks(10) }; // netInterfaceSettings netInterfaceSettings.SpiApiName = spiControllerName; netInterfaceSettings.SpiSettings = settings; netInterfaceSettings.GpioApiName = gpioControllerName; netInterfaceSettings.InterruptPin = GpioController.GetDefault().OpenPin(irqPinNumber); netInterfaceSettings.InterruptEdge = GpioPinEdge.FallingEdge; netInterfaceSettings.InterruptDriveMode = GpioPinDriveMode.InputPullUp; netInterfaceSettings.ResetPin = GpioController.GetDefault().OpenPin(resetPinNumber); netInterfaceSettings.ResetActiveState = GpioPinValue.Low; // Wifi setting var wifiSettings = new WiFiNetworkInterfaceSettings() { Ssid = \"Your SSID\", Password = \"Your Password\", }; wifiSettings.DhcpEnable = true; wifiSettings.DynamicDnsEnable = true; var networkController = NetworkController.FromName(SC20260.NetworkController.ATWinc15x0); networkController.SetInterfaceSettings(wifiSettings); networkController.SetCommunicationInterfaceSettings(netInterfaceSettings); networkController.SetAsDefaultController(); networkController.NetworkAddressChanged += NetworkController_NetworkAddressChanged; networkController.NetworkLinkConnectedChanged += NetworkController_NetworkLinkConnectedChanged; networkController.Enable(); // Network is ready to use Thread.Sleep(Timeout.Infinite); void NetworkController_NetworkLinkConnectedChanged (NetworkController sender, NetworkLinkConnectedChangedEventArgs e) { // Raise event connect/disconnect } void NetworkController_NetworkAddressChanged (NetworkController sender, NetworkAddressChangedEventArgs e) { var ipProperties = sender.GetIPProperties(); var address = ipProperties.Address.GetAddressBytes(); Debug.WriteLine(\"IP: \" + address[0] + \".\" + address[1] + \".\" + address[2] + \".\" + address[3]); } WINC1500 Utilities The Winc15x0Interface class provides to access some of the native functions of the WINC1500 WiFi module. Such as getting the WiFi module's MAC address, getting RSSI (Relative Signal Strength Indicator), scanning for access points, checking the firmware version, and over-the-air (OTA) firmware update. Tip Needed NuGets: GHIElectronics.TinyCLR.Drivers.Microchip.Winc15x0 SetCommunicationInterfaceSettings function needs to be called before using this driver. //Initialize the WiFi interface first before using any of the below functions... SetCommunicationInterfaceSettings // ... //Scan for WiFi access points: string[] ssidList = Winc15x0Interface.Scan(); //Get Relative Signal Strength Indicator for the connected access point: int signalStrength = Winc15x0Interface.GetRssi(); //Get the WiFi module's MAC address: byte[] macAddress = Winc15x0Interface.GetMacAddress(); //Get the version of the installed WiFi firmware: string fwVersion = Winc15x0Interface.GetFirmwareVersion(); //Print a list of WiFi firmware versions that have been tested with TinyCLR OS. // Note: Untested WiFi firmware versions may also work. for (int i = 0; i < Winc15x0Interface.FirmwareSupports.Length; i++) { System.Diagnostics.Debug.WriteLine(\"Supported firmware version #\" + (i + 1).ToString() + \": \" + Winc15x0Interface.FirmwareSupports[i].ToString()); } //Download and install firmware from an OTA download (web) server: // Must upload firmware file to root folder in server // (e.g. http://192.168.0.100/m2m_ota_3a0.bin). bool otaUpdate = Winc15x0Interface.FirmwareUpdate(\"http://192.168.0.100/m2m_ota_3a0.bin\", TimeSpan.FromMilliseconds(5000)); Multicast IP Multicast works as expected on all other network interfaces; however, in order to achieve this on WiFi, we need to convert a Multicast IP to a multicast MAC Address. Any online tool like this can be used. This capture shows Multicast IP address 239.255.255.254 for example. This Multicast MAC address is then used as below. Winc15x0Interface.AddMulticastMacAddress(new byte[] { 0x01, 0x00, 0x5e, 0x7f, 0xff, 0xfe }); If more than one Multicast MAC address is needed, just call AddMulticastMacAddress multiple time. There is also an API allows remove multicast mac address from the list as well. Winc15x0Interface.RemoveMulticastMacAddress(new byte[] { 0x01, 0x00, 0x5e, 0x7f, 0xff, 0xfe }); Tip Needed NuGets: GHIElectronics.TinyCLR.Drivers.Microchip.Winc15x0"
  }
}