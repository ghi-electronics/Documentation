<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>CAN </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="CAN ">
    <meta name="generator" content="docfx ">
  
    <link rel="shortcut icon" href="../../../images/favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
  
  <meta property="docfx:rel" content="../../../">
  <meta property="docfx:newtab" content="true">
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../images/logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="can">CAN</h1>

<hr>
<p>Controller Area Network (CAN) bus is a serial communication protocol with built-in error checking and retransmission. It is generally a two wire bus, but other transceivers with one wire or LSFT (Low Speed Fault Tolerant) are used.</p>
<p>The common high-speed two-wire CAN requires termination resistors at the end of the wires, typically 120 ohm.</p>
<p><img src="../images/can-bus.png" alt="CAN linear bus"></p>
<div class="TIP">
<h5>Tip</h5>
<p>Some CAN devices, including our own development boards, have built in termination resistors.</p>
</div>
<p>CAN bit timing is a complex topic that requires considerable knowledge of the CAN protocol. All nodes on a CAN network must use the same baud rate. Sample bit timing settings are provided further down on this page to help you get started.</p>
<p><code>SetNominalBitTiming()</code> and <code>SetDataBitTiming()</code> define the CAN bus timing using the arguments listed below. Note that <code>SetDataBitTiming()</code> is only used for CAN-FD to specify the faster data rate. <code>SetNominalBitTiming()</code> is used both for standard CAN and to define the slower data bit rate for CAN-FD.</p>
<div class="TIP">
<h5>Tip</h5>
<p>The <code>propagationPhase1</code> argument combines the propagation and phase1 CAN timing parameters.</p>
</div>
<table>
<thead>
<tr>
<th>Baud</th>
<th>Propagation+Phase1</th>
<th>Phase2</th>
<th>Baudrate Prescaler</th>
<th>Synchronization Jump Width</th>
<th>Use Multi Bit Sampling</th>
<th>Sample Point</th>
<th>Max Osc. Tolerance</th>
<th>Max Cable Length</th>
</tr>
</thead>
<tbody>
<tr>
<td>33.333K</td>
<td>13</td>
<td>2</td>
<td>90</td>
<td>1</td>
<td>False</td>
<td>87.5%</td>
<td>0.31%</td>
<td>2200M</td>
</tr>
<tr>
<td>83.333K</td>
<td>13</td>
<td>2</td>
<td>36</td>
<td>1</td>
<td>False</td>
<td>87.5%</td>
<td>0.31%</td>
<td>850M</td>
</tr>
<tr>
<td>125K</td>
<td>13</td>
<td>2</td>
<td>24</td>
<td>1</td>
<td>False</td>
<td>87.5%</td>
<td>0.31%</td>
<td>550M</td>
</tr>
<tr>
<td>250K</td>
<td>13</td>
<td>2</td>
<td>12</td>
<td>1</td>
<td>False</td>
<td>87.5%</td>
<td>0.31%</td>
<td>250M</td>
</tr>
<tr>
<td>500K</td>
<td>13</td>
<td>2</td>
<td>6</td>
<td>1</td>
<td>False</td>
<td>87.5%</td>
<td>0.31%</td>
<td>100M</td>
</tr>
<tr>
<td>1M</td>
<td>13</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>False</td>
<td>87.5%</td>
<td>0.31%</td>
<td>40M</td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
</div>
<p>The table above is calculated base on 40MHz clock source.</p>
<p>There are many online CAN calculators that can be used to help you with CAN timing, for <a href="http://www.bittiming.can-wiki.info/">example</a>.</p>
<p><img src="images/can-bit-segments.png" alt="CAN bit segments"></p>
<p>The CAN calculator needs the microcontroller's CAN clock speed. For the SITCore series SC20xxx, this is 48 MHz. For the SC13xxx the speed is 40MHz. These can easily be found with <code>SourceClock</code> property.</p>
<h2 id="filtering">Filtering</h2>
<p>Filters can be set to automatically accept or ignore messages based on their arbitration ID.</p>
<div class="TIP">
<h5>Tip</h5>
<p>On SC20xxx, each CAN channel supports up to 64 standard IDs and 32 Extended IDs. SC13xxx supports up to 14 filters.</p>
</div>
<h3 id="range-filter">Range Filter</h3>
<p><code>AddRangeFilter()</code> allows you to set a range of arbitration IDs that will be accepted as valid messages. Messages with arbitration IDs outside of this range will be ignored. You can add more than one range filter. In the sample code below, the range filters will accept messages with arbitration IDs ranging from <code>0x12</code> to <code>0x20</code> and also between <code>0x500</code> and <code>0x1000</code> inclusive.</p>
<div class="NOTE">
<h5>Note</h5>
</div>
<p>Only SC20xxx supports Range Filter, SC13xxx doesn't.</p>
<h3 id="mask-filter">Mask Filter</h3>
<p><code>AddMaskFilter()</code> can be used to specify an individual arbitration ID or a range of arbitration IDs that will be accepted regardless of the group filter settings. If the arbitration ID of the message is bitwise anded with the given mask argument, and the result is equal to the compare argument you provide, the message will be accepted.</p>
<p>In the sample code below, CAN messages with arbitration IDs of <code>0x11</code>, <code>0x13</code>, and <code>0x5678</code> will be accepted in addition to the arbitration IDs specified by the group filters.</p>
<hr>
<h2 id="sample-code">Sample Code</h2>
<div class="TIP">
<h5>Tip</h5>
<p>Needed NuGets: GHIElectronics.TinyCLR.Core, GHIElectronics.TinyCLR.Devices and GHIElectronics.TinyCLR.Pins</p>
</div>
<pre><code class="lang-cs">using GHIElectronics.TinyCLR.Devices.Can;
using GHIElectronics.TinyCLR.Devices.Gpio;
using GHIElectronics.TinyCLR.Pins;
using System;
using System.Diagnostics;
using System.Threading;

var LdrButton = GpioController.GetDefault().OpenPin(SC20100.GpioPin.PE3);
LdrButton.SetDriveMode(GpioPinDriveMode.InputPullUp);

var can = CanController.FromName(SC20100.CanBus.Can1);

var propagationPhase1 = 13;
var phase2 = 2;
var baudratePrescaler = 3;
var synchronizationJumpWidth = 1;
var useMultiBitSampling = false;

can.SetNominalBitTiming(new CanBitTiming(propagationPhase1, phase2, baudratePrescaler,
    synchronizationJumpWidth, useMultiBitSampling));        

var message = new CanMessage() {
    Data = new byte[] { 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x2E, 0x20, 0x20 },
    ArbitrationId = 0x11,
    Length = 6,
    RemoteTransmissionRequest = false,
    ExtendedId = false,
    FdCan = false,
    BitRateSwitch = false
};

//The following filter will accept arbitration IDs from 0x12 to 0x20 inclusive.
can.Filter.AddRangeFilter(Filter.IdType.Standard, 0x12, 0x20);

//The following filter will accept arbitration IDs from 0x500 to 0x1000 inclusive.
can.Filter.AddRangeFilter(Filter.IdType.Standard, 0x500, 0x1000);

//The following filter will accept arbitration IDs of 0x11 and 0x13.
can.Filter.AddMaskFilter(Filter.IdType.Standard, 0x11, 0xFD);

//The following filter will accept arbitration IDs of 5678 only.
can.Filter.AddMaskFilter(Filter.IdType.Standard, 0x5678, 0xFFFF);

can.MessageReceived += Can_MessageReceived;
can.ErrorReceived += Can_ErrorReceived;
        
can.Enable();

while (true) {
    if (LdrButton.Read() == GpioPinValue.Low)
        can.WriteMessage(message);

    Thread.Sleep(100);
}


void Can_MessageReceived(CanController sender,
    MessageReceivedEventArgs e) {

    sender.ReadMessage(out var message);

    Debug.WriteLine(&quot;Arbitration ID: 0x&quot; + message.ArbitrationId.ToString(&quot;X8&quot;));
    Debug.WriteLine(&quot;Is extended ID: &quot; + message.ExtendedId.ToString());
    Debug.WriteLine(&quot;Is remote transmission request: &quot;
        + message.RemoteTransmissionRequest.ToString());

    Debug.WriteLine(&quot;Time stamp: &quot; + message.Timestamp.ToString());

    var data = &quot;&quot;;
    for (var i = 0; i &lt; message.Length; i++) data += Convert.ToChar(message.Data[i]);

    Debug.WriteLine(&quot;Data: &quot; + data);
}

void Can_ErrorReceived(CanController sender, ErrorReceivedEventArgs e)
    =&gt; Debug.WriteLine(&quot;Error &quot; + e.ToString());

</code></pre>
<hr>
<h2 id="can-fd">CAN-FD</h2>
<p>CAN-FD allows for faster data transmission and larger data packet size to increase throughput. At the same time, CAN-FD is compatible with traditional CAN -- CAN-FD and standard CAN nodes can even coexist on the same CAN bus!</p>
<p>CAN-FD can be used by setting the <code>FdCan</code> property of your CAN message to <code>true</code>. This setting will allow you to send up to 64 bytes of data per CAN message.</p>
<p>To send the data at higher speed you will also need to set two bit timings, one for the normal, slower speed (<code>SetNominalBitTiming()</code>), and one for the faster speed (<code>SetDataBitTiming()</code>). You will also have to set the <code>BitRateSwitch</code> property of the CAN message to <code>true.</code></p>
<p>The following code shows the changes needed to make the above code sample use CAN-FD with speeds of 250 kilobaud and 1 megabaud.</p>
<div class="NOTE">
<h5>Note</h5>
</div>
<p>Only SC20xxx supports CAN-FD, SC13xxx doesn't support this feature.</p>
<pre><code class="lang-cs">var propagationPhase1 = 13; //250 kilobaud settings
var phase2 = 2;
var baudratePrescaler = 12;
var synchronizationJumpWidth = 1;
var useMultiBitSampling = false;

//Set the lower CAN speed to 250 kilobaud.
can.SetNominalBitTiming(new CanBitTiming(propagationPhase1, phase2, baudratePrescaler,
    synchronizationJumpWidth, useMultiBitSampling));

baudratePrescaler = 3;  //Change bit timing to 1 megabaud.
        
//Set faster CAN speed to 1 megabaud.
can.SetDataBitTiming(new CanBitTiming(propagationPhase1, phase2, baudratePrescaler,
    synchronizationJumpWidth, useMultiBitSampling));

can.Enable();

var message = new CanMessage() {
    Data = new byte[] { 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x2E, 0x20, 0x20 },
    ArbitrationId = 0x11,
    Length = 6,
    RemoteTransmissionRequest = false,
    ExtendedId = false,
    FdCan = true,
    BitRateSwitch = true
};

</code></pre>
</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/ghi-electronics/Documentation/blob/RemoveDUE/software/tinyclr/tutorials/can.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <div class="toggle-mode">
                <div class="icon">
                  <i aria-hidden="true">☀</i>
                </div>
                <label class="switch">
                  <input type="checkbox" id="switch-style">
                  <span class="slider round"></span>
                </label>
                <div class="icon">
                  <i aria-hidden="true">☾</i>
                </div>
                <script type="text/javascript" src="../../../styles/toggle-theme.js"></script>
              </div>

              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <h5>In This Article</h5>
              <div></div>
              <p><a class="back-to-top" href="#top">Back to top</a><p>
              </p></nav>
            </div>
          </div>

        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      <span>Copyright © 2022 GHI Electronics, LLC<br>Generated by DocFX</span>
      
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
